[
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 1,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate potential for improvement (inverse of objective values)\n    potentials = [1 / (obj[0] * obj[1]) for _, obj in archive]\n    total_potential = sum(potentials)\n    probabilities = [p / total_potential for p in potentials]\n\n    # Select a solution based on calculated probabilities\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge insertion heuristic\n    n = len(new_solution)\n    if n >= 6:  # Ensure enough nodes for 3-opt\n        # Perform 3-opt on a random segment\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment\n        new_solution[j:k] = new_solution[j:k][::-1]  # Reverse another segment\n    else:\n        # For small instances, use a novel edge insertion heuristic\n        # Select a random node and insert it in the best position for both objectives\n        node = random.choice(new_solution)\n        temp_solution = new_solution[new_solution != node]\n        best_insert_pos = 0\n        best_cost = float('inf')\n\n        for pos in range(len(temp_solution)):\n            candidate = np.insert(temp_solution, pos, node)\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(len(candidate)-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(len(candidate)-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            total_cost = cost1 + cost2  # Combined cost for selection\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_insert_pos = pos\n\n        new_solution = np.insert(temp_solution, best_insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8330287496318151,
            0.8514487147331238
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate potential for improvement (inverse of objective values)\n    potentials = [1 / (obj[0] * obj[1]) for _, obj in archive]\n    total_potential = sum(potentials)\n    probabilities = [p / total_potential for p in potentials]\n\n    # Select a solution based on calculated probabilities\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge insertion heuristic\n    n = len(new_solution)\n    if n >= 6:  # Ensure enough nodes for 3-opt\n        # Perform 3-opt on a random segment\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment\n        new_solution[j:k] = new_solution[j:k][::-1]  # Reverse another segment\n    else:\n        # For small instances, use a novel edge insertion heuristic\n        # Select a random node and insert it in the best position for both objectives\n        node = random.choice(new_solution)\n        temp_solution = new_solution[new_solution != node]\n        best_insert_pos = 0\n        best_cost = float('inf')\n\n        for pos in range(len(temp_solution)):\n            candidate = np.insert(temp_solution, pos, node)\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(len(candidate)-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(len(candidate)-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            total_cost = cost1 + cost2  # Combined cost for selection\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_insert_pos = pos\n\n        new_solution = np.insert(temp_solution, best_insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 1,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate potential for improvement (inverse of objective values)\n    potentials = [1 / (obj[0] * obj[1]) for _, obj in archive]\n    total_potential = sum(potentials)\n    probabilities = [p / total_potential for p in potentials]\n\n    # Select a solution based on calculated probabilities\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge insertion heuristic\n    n = len(new_solution)\n    if n >= 6:  # Ensure enough nodes for 3-opt\n        # Perform 3-opt on a random segment\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment\n        new_solution[j:k] = new_solution[j:k][::-1]  # Reverse another segment\n    else:\n        # For small instances, use a novel edge insertion heuristic\n        # Select a random node and insert it in the best position for both objectives\n        node = random.choice(new_solution)\n        temp_solution = new_solution[new_solution != node]\n        best_insert_pos = 0\n        best_cost = float('inf')\n\n        for pos in range(len(temp_solution)):\n            candidate = np.insert(temp_solution, pos, node)\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(len(candidate)-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(len(candidate)-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            total_cost = cost1 + cost2  # Combined cost for selection\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_insert_pos = pos\n\n        new_solution = np.insert(temp_solution, best_insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8330287496318151,
            0.8514487147331238
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate potential for improvement (inverse of objective values)\n    potentials = [1 / (obj[0] * obj[1]) for _, obj in archive]\n    total_potential = sum(potentials)\n    probabilities = [p / total_potential for p in potentials]\n\n    # Select a solution based on calculated probabilities\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge insertion heuristic\n    n = len(new_solution)\n    if n >= 6:  # Ensure enough nodes for 3-opt\n        # Perform 3-opt on a random segment\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment\n        new_solution[j:k] = new_solution[j:k][::-1]  # Reverse another segment\n    else:\n        # For small instances, use a novel edge insertion heuristic\n        # Select a random node and insert it in the best position for both objectives\n        node = random.choice(new_solution)\n        temp_solution = new_solution[new_solution != node]\n        best_insert_pos = 0\n        best_cost = float('inf')\n\n        for pos in range(len(temp_solution)):\n            candidate = np.insert(temp_solution, pos, node)\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(len(candidate)-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(len(candidate)-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            total_cost = cost1 + cost2  # Combined cost for selection\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_insert_pos = pos\n\n        new_solution = np.insert(temp_solution, best_insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 1,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate potential for improvement (inverse of objective values)\n    potentials = [1 / (obj[0] * obj[1]) for _, obj in archive]\n    total_potential = sum(potentials)\n    probabilities = [p / total_potential for p in potentials]\n\n    # Select a solution based on calculated probabilities\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge insertion heuristic\n    n = len(new_solution)\n    if n >= 6:  # Ensure enough nodes for 3-opt\n        # Perform 3-opt on a random segment\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment\n        new_solution[j:k] = new_solution[j:k][::-1]  # Reverse another segment\n    else:\n        # For small instances, use a novel edge insertion heuristic\n        # Select a random node and insert it in the best position for both objectives\n        node = random.choice(new_solution)\n        temp_solution = new_solution[new_solution != node]\n        best_insert_pos = 0\n        best_cost = float('inf')\n\n        for pos in range(len(temp_solution)):\n            candidate = np.insert(temp_solution, pos, node)\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(len(candidate)-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(len(candidate)-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            total_cost = cost1 + cost2  # Combined cost for selection\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_insert_pos = pos\n\n        new_solution = np.insert(temp_solution, best_insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8330287496318151,
            0.8514487147331238
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate potential for improvement (inverse of objective values)\n    potentials = [1 / (obj[0] * obj[1]) for _, obj in archive]\n    total_potential = sum(potentials)\n    probabilities = [p / total_potential for p in potentials]\n\n    # Select a solution based on calculated probabilities\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge insertion heuristic\n    n = len(new_solution)\n    if n >= 6:  # Ensure enough nodes for 3-opt\n        # Perform 3-opt on a random segment\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment\n        new_solution[j:k] = new_solution[j:k][::-1]  # Reverse another segment\n    else:\n        # For small instances, use a novel edge insertion heuristic\n        # Select a random node and insert it in the best position for both objectives\n        node = random.choice(new_solution)\n        temp_solution = new_solution[new_solution != node]\n        best_insert_pos = 0\n        best_cost = float('inf')\n\n        for pos in range(len(temp_solution)):\n            candidate = np.insert(temp_solution, pos, node)\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(len(candidate)-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(len(candidate)-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            total_cost = cost1 + cost2  # Combined cost for selection\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_insert_pos = pos\n\n        new_solution = np.insert(temp_solution, best_insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 2,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    if len(archive_solutions) == 1:\n        base_solution = archive_solutions[0].copy()\n    else:\n        # Select solutions with the highest combined objective values (potential for improvement)\n        objectives = np.array([obj for _, obj in archive])\n        normalized_objectives = objectives / np.max(objectives, axis=0)\n        combined_scores = np.sum(normalized_objectives, axis=1)\n        selected_idx = np.argmax(combined_scores)\n        base_solution = archive_solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combination of edge insertion and segment reversal\n    for _ in range(5):  # Perform multiple iterations\n        # Randomly select two distinct segments\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        c, d = sorted(random.sample(range(1, n-1), 2))\n\n        # Ensure segments don't overlap\n        if b < c or d < a:\n            # Extract segments\n            segment1 = new_solution[a:b]\n            segment2 = new_solution[c:d]\n\n            # Reverse segments with probability 0.5\n            if random.random() > 0.5:\n                segment1 = segment1[::-1]\n            if random.random() > 0.5:\n                segment2 = segment2[::-1]\n\n            # Insert segments at new positions\n            new_solution = np.concatenate([\n                new_solution[:a],\n                segment2,\n                new_solution[b:c],\n                segment1,\n                new_solution[d:]\n            ])\n\n            # Ensure the solution remains a valid tour\n            if len(np.unique(new_solution)) == n:\n                # Evaluate the new solution's quality\n                cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n                # If the new solution is better in at least one objective, keep it\n                old_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n                old_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n\n                if (cost1 < old_cost1) or (cost2 < old_cost2):\n                    base_solution = new_solution.copy()\n\n    return base_solution\n\n",
        "score": [
            -0.8508703231166641,
            1.0637440085411072
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    if len(archive_solutions) == 1:\n        base_solution = archive_solutions[0].copy()\n    else:\n        # Select solutions with the highest combined objective values (potential for improvement)\n        objectives = np.array([obj for _, obj in archive])\n        normalized_objectives = objectives / np.max(objectives, axis=0)\n        combined_scores = np.sum(normalized_objectives, axis=1)\n        selected_idx = np.argmax(combined_scores)\n        base_solution = archive_solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combination of edge insertion and segment reversal\n    for _ in range(5):  # Perform multiple iterations\n        # Randomly select two distinct segments\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        c, d = sorted(random.sample(range(1, n-1), 2))\n\n        # Ensure segments don't overlap\n        if b < c or d < a:\n            # Extract segments\n            segment1 = new_solution[a:b]\n            segment2 = new_solution[c:d]\n\n            # Reverse segments with probability 0.5\n            if random.random() > 0.5:\n                segment1 = segment1[::-1]\n            if random.random() > 0.5:\n                segment2 = segment2[::-1]\n\n            # Insert segments at new positions\n            new_solution = np.concatenate([\n                new_solution[:a],\n                segment2,\n                new_solution[b:c],\n                segment1,\n                new_solution[d:]\n            ])\n\n            # Ensure the solution remains a valid tour\n            if len(np.unique(new_solution)) == n:\n                # Evaluate the new solution's quality\n                cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n                # If the new solution is better in at least one objective, keep it\n                old_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n                old_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n\n                if (cost1 < old_cost1) or (cost2 < old_cost2):\n                    base_solution = new_solution.copy()\n\n    return base_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 2,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    if len(archive_solutions) == 1:\n        base_solution = archive_solutions[0].copy()\n    else:\n        # Select solutions with the highest combined objective values (potential for improvement)\n        objectives = np.array([obj for _, obj in archive])\n        normalized_objectives = objectives / np.max(objectives, axis=0)\n        combined_scores = np.sum(normalized_objectives, axis=1)\n        selected_idx = np.argmax(combined_scores)\n        base_solution = archive_solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combination of edge insertion and segment reversal\n    for _ in range(5):  # Perform multiple iterations\n        # Randomly select two distinct segments\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        c, d = sorted(random.sample(range(1, n-1), 2))\n\n        # Ensure segments don't overlap\n        if b < c or d < a:\n            # Extract segments\n            segment1 = new_solution[a:b]\n            segment2 = new_solution[c:d]\n\n            # Reverse segments with probability 0.5\n            if random.random() > 0.5:\n                segment1 = segment1[::-1]\n            if random.random() > 0.5:\n                segment2 = segment2[::-1]\n\n            # Insert segments at new positions\n            new_solution = np.concatenate([\n                new_solution[:a],\n                segment2,\n                new_solution[b:c],\n                segment1,\n                new_solution[d:]\n            ])\n\n            # Ensure the solution remains a valid tour\n            if len(np.unique(new_solution)) == n:\n                # Evaluate the new solution's quality\n                cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n                # If the new solution is better in at least one objective, keep it\n                old_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n                old_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n\n                if (cost1 < old_cost1) or (cost2 < old_cost2):\n                    base_solution = new_solution.copy()\n\n    return base_solution\n\n",
        "score": [
            -0.8508703231166641,
            1.0637440085411072
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    if len(archive_solutions) == 1:\n        base_solution = archive_solutions[0].copy()\n    else:\n        # Select solutions with the highest combined objective values (potential for improvement)\n        objectives = np.array([obj for _, obj in archive])\n        normalized_objectives = objectives / np.max(objectives, axis=0)\n        combined_scores = np.sum(normalized_objectives, axis=1)\n        selected_idx = np.argmax(combined_scores)\n        base_solution = archive_solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combination of edge insertion and segment reversal\n    for _ in range(5):  # Perform multiple iterations\n        # Randomly select two distinct segments\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        c, d = sorted(random.sample(range(1, n-1), 2))\n\n        # Ensure segments don't overlap\n        if b < c or d < a:\n            # Extract segments\n            segment1 = new_solution[a:b]\n            segment2 = new_solution[c:d]\n\n            # Reverse segments with probability 0.5\n            if random.random() > 0.5:\n                segment1 = segment1[::-1]\n            if random.random() > 0.5:\n                segment2 = segment2[::-1]\n\n            # Insert segments at new positions\n            new_solution = np.concatenate([\n                new_solution[:a],\n                segment2,\n                new_solution[b:c],\n                segment1,\n                new_solution[d:]\n            ])\n\n            # Ensure the solution remains a valid tour\n            if len(np.unique(new_solution)) == n:\n                # Evaluate the new solution's quality\n                cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n                # If the new solution is better in at least one objective, keep it\n                old_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n                old_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n\n                if (cost1 < old_cost1) or (cost2 < old_cost2):\n                    base_solution = new_solution.copy()\n\n    return base_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 3,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best but not the worst)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(len(archive_sorted) // 2, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: edge insertion + node swap\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply the operator\n\n    # Step 1: Edge insertion (remove a segment and reinsert it elsewhere)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n    remaining = np.concatenate([new_solution[:a], new_solution[b+1:]])\n    insert_pos = np.random.randint(0, len(remaining) + 1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Node swap (swap nodes based on distance improvement)\n    for _ in range(2):  # Perform a few swaps\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate current and new distances for both objectives\n        current_dist_1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_1[new_solution[j-1], new_solution[j]])\n        current_dist_2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n        new_dist_1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_1[new_solution[j-1], new_solution[i]])\n        new_dist_2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[j-1], new_solution[i]])\n\n        # Accept swap if it improves at least one objective\n        if (new_dist_1 < current_dist_1) or (new_dist_2 < current_dist_2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8858511536040018,
            1.562852919101715
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best but not the worst)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(len(archive_sorted) // 2, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: edge insertion + node swap\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply the operator\n\n    # Step 1: Edge insertion (remove a segment and reinsert it elsewhere)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n    remaining = np.concatenate([new_solution[:a], new_solution[b+1:]])\n    insert_pos = np.random.randint(0, len(remaining) + 1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Node swap (swap nodes based on distance improvement)\n    for _ in range(2):  # Perform a few swaps\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate current and new distances for both objectives\n        current_dist_1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_1[new_solution[j-1], new_solution[j]])\n        current_dist_2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n        new_dist_1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_1[new_solution[j-1], new_solution[i]])\n        new_dist_2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[j-1], new_solution[i]])\n\n        # Accept swap if it improves at least one objective\n        if (new_dist_1 < current_dist_1) or (new_dist_2 < current_dist_2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 3,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best but not the worst)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(len(archive_sorted) // 2, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: edge insertion + node swap\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply the operator\n\n    # Step 1: Edge insertion (remove a segment and reinsert it elsewhere)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n    remaining = np.concatenate([new_solution[:a], new_solution[b+1:]])\n    insert_pos = np.random.randint(0, len(remaining) + 1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Node swap (swap nodes based on distance improvement)\n    for _ in range(2):  # Perform a few swaps\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate current and new distances for both objectives\n        current_dist_1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_1[new_solution[j-1], new_solution[j]])\n        current_dist_2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n        new_dist_1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_1[new_solution[j-1], new_solution[i]])\n        new_dist_2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[j-1], new_solution[i]])\n\n        # Accept swap if it improves at least one objective\n        if (new_dist_1 < current_dist_1) or (new_dist_2 < current_dist_2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8858511536040018,
            1.562852919101715
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best but not the worst)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(len(archive_sorted) // 2, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: edge insertion + node swap\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply the operator\n\n    # Step 1: Edge insertion (remove a segment and reinsert it elsewhere)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n    remaining = np.concatenate([new_solution[:a], new_solution[b+1:]])\n    insert_pos = np.random.randint(0, len(remaining) + 1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Node swap (swap nodes based on distance improvement)\n    for _ in range(2):  # Perform a few swaps\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate current and new distances for both objectives\n        current_dist_1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_1[new_solution[j-1], new_solution[j]])\n        current_dist_2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n        new_dist_1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_1[new_solution[j-1], new_solution[i]])\n        new_dist_2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[j-1], new_solution[i]])\n\n        # Accept swap if it improves at least one objective\n        if (new_dist_1 < current_dist_1) or (new_dist_2 < current_dist_2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 4,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0] + x[1][1], reverse=True)\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three segments to perturb\n    i, j, k = sorted(np.random.choice(np.arange(1, n-1), size=3, replace=False))\n\n    # Perform 3-opt move\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Recombine segments in a different order\n    new_segments = [segment1, segment3, segment2, segment4]\n    new_solution = np.concatenate(new_segments)\n\n    # Novel edge swap: swap edges between non-adjacent nodes\n    if np.random.rand() < 0.5:  # 50% chance to apply edge swap\n        a, b = np.random.choice(np.arange(1, n-1), size=2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7906332789868071,
            1.1880155205726624
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0] + x[1][1], reverse=True)\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three segments to perturb\n    i, j, k = sorted(np.random.choice(np.arange(1, n-1), size=3, replace=False))\n\n    # Perform 3-opt move\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Recombine segments in a different order\n    new_segments = [segment1, segment3, segment2, segment4]\n    new_solution = np.concatenate(new_segments)\n\n    # Novel edge swap: swap edges between non-adjacent nodes\n    if np.random.rand() < 0.5:  # 50% chance to apply edge swap\n        a, b = np.random.choice(np.arange(1, n-1), size=2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 5,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    import numpy as np\n\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a higher probability if its objectives are not dominated by others\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        # If no non-dominated solutions, select randomly\n        selected = random.choice(archive)[0]\n    else:\n        # Select from non-dominated solutions with probability proportional to their \"promise\"\n        # \"Promise\" is inversely proportional to the product of objectives (simplified)\n        promises = [1.0 / (obj[0] * obj[1]) for _, obj in non_dominated]\n        total_promise = sum(promises)\n        probs = [p / total_promise for p in promises]\n        selected_idx = np.random.choice(len(non_dominated), p=probs)\n        selected = non_dominated[selected_idx][0]\n\n    # Generate neighbor using hybrid local search\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Randomly choose between edge exchange and insertion\n    if random.random() < 0.5:\n        # Edge exchange (similar to 2-opt but more flexible)\n        i, j = sorted(random.sample(range(n), 2))\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Insertion move: remove a node and reinsert it elsewhere\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        # Remove the node\n        new_solution = np.delete(new_solution, i)\n        # Reinsert at a random position\n        j = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9199067199875444,
            1.7490455508232117
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    import numpy as np\n\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a higher probability if its objectives are not dominated by others\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        # If no non-dominated solutions, select randomly\n        selected = random.choice(archive)[0]\n    else:\n        # Select from non-dominated solutions with probability proportional to their \"promise\"\n        # \"Promise\" is inversely proportional to the product of objectives (simplified)\n        promises = [1.0 / (obj[0] * obj[1]) for _, obj in non_dominated]\n        total_promise = sum(promises)\n        probs = [p / total_promise for p in promises]\n        selected_idx = np.random.choice(len(non_dominated), p=probs)\n        selected = non_dominated[selected_idx][0]\n\n    # Generate neighbor using hybrid local search\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Randomly choose between edge exchange and insertion\n    if random.random() < 0.5:\n        # Edge exchange (similar to 2-opt but more flexible)\n        i, j = sorted(random.sample(range(n), 2))\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Insertion move: remove a node and reinsert it elsewhere\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        # Remove the node\n        new_solution = np.delete(new_solution, i)\n        # Reinsert at a random position\n        j = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 5,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    import numpy as np\n\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a higher probability if its objectives are not dominated by others\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        # If no non-dominated solutions, select randomly\n        selected = random.choice(archive)[0]\n    else:\n        # Select from non-dominated solutions with probability proportional to their \"promise\"\n        # \"Promise\" is inversely proportional to the product of objectives (simplified)\n        promises = [1.0 / (obj[0] * obj[1]) for _, obj in non_dominated]\n        total_promise = sum(promises)\n        probs = [p / total_promise for p in promises]\n        selected_idx = np.random.choice(len(non_dominated), p=probs)\n        selected = non_dominated[selected_idx][0]\n\n    # Generate neighbor using hybrid local search\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Randomly choose between edge exchange and insertion\n    if random.random() < 0.5:\n        # Edge exchange (similar to 2-opt but more flexible)\n        i, j = sorted(random.sample(range(n), 2))\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Insertion move: remove a node and reinsert it elsewhere\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        # Remove the node\n        new_solution = np.delete(new_solution, i)\n        # Reinsert at a random position\n        j = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9199067199875444,
            1.7490455508232117
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    import numpy as np\n\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a higher probability if its objectives are not dominated by others\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        # If no non-dominated solutions, select randomly\n        selected = random.choice(archive)[0]\n    else:\n        # Select from non-dominated solutions with probability proportional to their \"promise\"\n        # \"Promise\" is inversely proportional to the product of objectives (simplified)\n        promises = [1.0 / (obj[0] * obj[1]) for _, obj in non_dominated]\n        total_promise = sum(promises)\n        probs = [p / total_promise for p in promises]\n        selected_idx = np.random.choice(len(non_dominated), p=probs)\n        selected = non_dominated[selected_idx][0]\n\n    # Generate neighbor using hybrid local search\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Randomly choose between edge exchange and insertion\n    if random.random() < 0.5:\n        # Edge exchange (similar to 2-opt but more flexible)\n        i, j = sorted(random.sample(range(n), 2))\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Insertion move: remove a node and reinsert it elsewhere\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        # Remove the node\n        new_solution = np.delete(new_solution, i)\n        # Reinsert at a random position\n        j = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 6,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by sum of objectives to prioritize solutions with higher potential\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select top 30% of solutions\n        top_solutions = archive_sorted[:max(1, len(archive) // 3)]\n        selected_solution, _ = random.choice(top_solutions)\n    else:\n        selected_solution = archive[0][0]\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: combine edge insertion and node relocation\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Step 1: Randomly select segments to modify\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Step 2: Extract and reverse segments (like 2-opt but more flexible)\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    # Step 3: Reinsert segments in different positions\n    new_solution = np.concatenate([\n        new_solution[:a],\n        segment2[::-1],  # Reverse segment2\n        new_solution[b+1:c],\n        segment1[::-1],  # Reverse segment1\n        new_solution[d+1:]\n    ])\n\n    # Ensure the solution remains a valid tour\n    # If the solution is too short, we might need to adjust\n    if len(new_solution) != n:\n        # Fallback to simple swap if the above operation failed\n        new_solution = selected_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9022991118062041,
            1.2090597748756409
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by sum of objectives to prioritize solutions with higher potential\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select top 30% of solutions\n        top_solutions = archive_sorted[:max(1, len(archive) // 3)]\n        selected_solution, _ = random.choice(top_solutions)\n    else:\n        selected_solution = archive[0][0]\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: combine edge insertion and node relocation\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Step 1: Randomly select segments to modify\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Step 2: Extract and reverse segments (like 2-opt but more flexible)\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    # Step 3: Reinsert segments in different positions\n    new_solution = np.concatenate([\n        new_solution[:a],\n        segment2[::-1],  # Reverse segment2\n        new_solution[b+1:c],\n        segment1[::-1],  # Reverse segment1\n        new_solution[d+1:]\n    ])\n\n    # Ensure the solution remains a valid tour\n    # If the solution is too short, we might need to adjust\n    if len(new_solution) != n:\n        # Fallback to simple swap if the above operation failed\n        new_solution = selected_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 7,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their combined objective (sum of both objectives)\n        sorted_solutions = sorted(archive, key=lambda x: sum(x[1]))\n        # Create a probability distribution where better solutions have higher probability\n        probabilities = np.linspace(1, 0.1, len(sorted_solutions))\n        probabilities = probabilities / probabilities.sum()\n        # Randomly select a solution based on the distribution\n        selected_idx = np.random.choice(len(sorted_solutions), p=probabilities)\n        base_solution = sorted_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: Edge exchange + Segment inversion\n    if n > 3:\n        # With 70% probability, apply edge exchange\n        if random.random() < 0.7:\n            # Select two random edges to exchange\n            i, j = sorted(random.sample(range(1, n), 2))\n            # Perform edge exchange\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Apply segment inversion\n            # Select a random segment to invert\n            segment_start = random.randint(1, n - 3)\n            segment_end = random.randint(segment_start + 1, n - 1)\n            # Invert the segment\n            new_solution[segment_start:segment_end] = new_solution[segment_start:segment_end][::-1]\n\n    # Ensure the solution is valid (visits all nodes exactly once)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.7769056352430268,
            1.264788806438446
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their combined objective (sum of both objectives)\n        sorted_solutions = sorted(archive, key=lambda x: sum(x[1]))\n        # Create a probability distribution where better solutions have higher probability\n        probabilities = np.linspace(1, 0.1, len(sorted_solutions))\n        probabilities = probabilities / probabilities.sum()\n        # Randomly select a solution based on the distribution\n        selected_idx = np.random.choice(len(sorted_solutions), p=probabilities)\n        base_solution = sorted_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: Edge exchange + Segment inversion\n    if n > 3:\n        # With 70% probability, apply edge exchange\n        if random.random() < 0.7:\n            # Select two random edges to exchange\n            i, j = sorted(random.sample(range(1, n), 2))\n            # Perform edge exchange\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Apply segment inversion\n            # Select a random segment to invert\n            segment_start = random.randint(1, n - 3)\n            segment_end = random.randint(segment_start + 1, n - 1)\n            # Invert the segment\n            new_solution[segment_start:segment_end] = new_solution[segment_start:segment_end][::-1]\n\n    # Ensure the solution is valid (visits all nodes exactly once)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 8,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    total_cost = sum(obj[0] + obj[1] for _, obj in archive)\n    if total_cost == 0:\n        selected = random.choice(archive)\n    else:\n        weights = [(obj[0] + obj[1]) / total_cost for _, obj in archive]\n        selected = random.choices(archive, weights=weights, k=1)[0]\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal strategy\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Determine the type of local search to apply\n    if random.random() < 0.7:  # 70% chance for 3-opt\n        # Select three distinct edges to modify\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Create new segments by reconnecting the edges\n        new_segments = [\n            new_solution[:i+1],\n            new_solution[i+1:j+1][::-1],\n            new_solution[j+1:k+1][::-1],\n            new_solution[k+1:]\n        ]\n        new_solution = np.concatenate(new_segments)\n    else:  # 30% chance for novel segment reversal\n        # Select two distinct segments and reverse one of them\n        i, j = sorted(random.sample(range(1, n), 2))\n        if random.random() < 0.5:\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Reverse a longer segment with a higher probability\n            segment_length = min(n//2, j - i + n//3)\n            new_solution[i:i+segment_length] = new_solution[i:i+segment_length][::-1]\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution with a small perturbation\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8619973847472628,
            1.411961019039154
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    total_cost = sum(obj[0] + obj[1] for _, obj in archive)\n    if total_cost == 0:\n        selected = random.choice(archive)\n    else:\n        weights = [(obj[0] + obj[1]) / total_cost for _, obj in archive]\n        selected = random.choices(archive, weights=weights, k=1)[0]\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal strategy\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Determine the type of local search to apply\n    if random.random() < 0.7:  # 70% chance for 3-opt\n        # Select three distinct edges to modify\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Create new segments by reconnecting the edges\n        new_segments = [\n            new_solution[:i+1],\n            new_solution[i+1:j+1][::-1],\n            new_solution[j+1:k+1][::-1],\n            new_solution[k+1:]\n        ]\n        new_solution = np.concatenate(new_segments)\n    else:  # 30% chance for novel segment reversal\n        # Select two distinct segments and reverse one of them\n        i, j = sorted(random.sample(range(1, n), 2))\n        if random.random() < 0.5:\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Reverse a longer segment with a higher probability\n            segment_length = min(n//2, j - i + n//3)\n            new_solution[i:i+segment_length] = new_solution[i:i+segment_length][::-1]\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution with a small perturbation\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 9,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (sum of both objectives)\n    best_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-swapping strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct positions to perform 3-opt\n    a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Perform 3-opt: reverse the segment between a and b, then between b and c\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    # Novel edge-swapping: swap edges between segments to improve both objectives\n    if np.random.rand() < 0.5:  # 50% chance to apply edge-swapping\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b:c+1]\n\n        # Swap edges between segments if it improves both objectives\n        if len(segment1) > 1 and len(segment2) > 1:\n            # Calculate cost before swap\n            cost1_before = distance_matrix_1[segment1[-1], segment2[0]] + distance_matrix_2[segment1[-1], segment2[0]]\n            cost2_before = distance_matrix_1[segment2[-1], segment1[0]] + distance_matrix_2[segment2[-1], segment1[0]]\n\n            # Calculate cost after swap\n            cost1_after = distance_matrix_1[segment1[-1], segment2[-1]] + distance_matrix_2[segment1[-1], segment2[-1]]\n            cost2_after = distance_matrix_1[segment2[0], segment1[0]] + distance_matrix_2[segment2[0], segment1[0]]\n\n            # Swap if both objectives improve\n            if (cost1_after + cost2_after) < (cost1_before + cost2_before):\n                new_solution[a:b+1] = segment2[::-1]\n                new_solution[b:c+1] = segment1[::-1]\n\n    # Ensure the solution remains valid (no duplicates and all nodes visited)\n    assert len(np.unique(new_solution)) == len(base_solution), \"Invalid solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.8469160260362592,
            1.2350215315818787
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (sum of both objectives)\n    best_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-swapping strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct positions to perform 3-opt\n    a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Perform 3-opt: reverse the segment between a and b, then between b and c\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    # Novel edge-swapping: swap edges between segments to improve both objectives\n    if np.random.rand() < 0.5:  # 50% chance to apply edge-swapping\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b:c+1]\n\n        # Swap edges between segments if it improves both objectives\n        if len(segment1) > 1 and len(segment2) > 1:\n            # Calculate cost before swap\n            cost1_before = distance_matrix_1[segment1[-1], segment2[0]] + distance_matrix_2[segment1[-1], segment2[0]]\n            cost2_before = distance_matrix_1[segment2[-1], segment1[0]] + distance_matrix_2[segment2[-1], segment1[0]]\n\n            # Calculate cost after swap\n            cost1_after = distance_matrix_1[segment1[-1], segment2[-1]] + distance_matrix_2[segment1[-1], segment2[-1]]\n            cost2_after = distance_matrix_1[segment2[0], segment1[0]] + distance_matrix_2[segment2[0], segment1[0]]\n\n            # Swap if both objectives improve\n            if (cost1_after + cost2_after) < (cost1_before + cost2_before):\n                new_solution[a:b+1] = segment2[::-1]\n                new_solution[b:c+1] = segment1[::-1]\n\n    # Ensure the solution remains valid (no duplicates and all nodes visited)\n    assert len(np.unique(new_solution)) == len(base_solution), \"Invalid solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 10,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(int(len(archive) * 0.2), len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: 3-opt move (select 3 random edges and reconnect)\n    if n >= 4:\n        a, b, c = sorted(random.sample(range(n), 3))\n        # Create all possible 3-opt neighbors and select the best one\n        candidates = []\n        for i in range(3):\n            # Try all 8 possible 3-opt configurations\n            for j in range(2):\n                for k in range(2):\n                    temp = new_solution.copy()\n                    # Reverse segments based on configuration\n                    if i == 0:\n                        temp[a:b+1] = temp[a:b+1][::-1] if j else temp[a:b+1]\n                        temp[b:c+1] = temp[b:c+1][::-1] if k else temp[b:c+1]\n                    elif i == 1:\n                        temp[a:b+1] = temp[a:b+1][::-1] if j else temp[a:b+1]\n                        temp[a:c+1] = temp[a:c+1][::-1] if k else temp[a:c+1]\n                    else:\n                        temp[b:c+1] = temp[b:c+1][::-1] if j else temp[b:c+1]\n                        temp[b:c+1] = temp[b:c+1][::-1] if k else temp[b:c+1]\n                    candidates.append(temp)\n\n        # Evaluate all candidates based on both objectives\n        best_candidate = None\n        best_score = float('inf')\n        for candidate in candidates:\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n            score = cost1 + cost2  # Simple weighted sum for selection\n            if score < best_score:\n                best_score = score\n                best_candidate = candidate\n\n        if best_candidate is not None:\n            new_solution = best_candidate.copy()\n\n    # Step 2: Edge swap based on Pareto dominance\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Try both possible edge swaps\n        temp1 = new_solution.copy()\n        temp1[i], temp1[j] = temp1[j], temp1[i]\n\n        temp2 = new_solution.copy()\n        temp2[i:j+1] = temp2[i:j+1][::-1]\n\n        # Evaluate both options\n        cost1_1 = sum(distance_matrix_1[temp1[k], temp1[(k+1)%n]] for k in range(n))\n        cost2_1 = sum(distance_matrix_2[temp1[k], temp1[(k+1)%n]] for k in range(n))\n\n        cost1_2 = sum(distance_matrix_1[temp2[k], temp2[(k+1)%n]] for k in range(n))\n        cost2_2 = sum(distance_matrix_2[temp2[k], temp2[(k+1)%n]] for k in range(n))\n\n        # Select the one that dominates in both objectives\n        if (cost1_1 <= cost1_2 and cost2_1 <= cost2_2) and (cost1_1 < cost1_2 or cost2_1 < cost2_2):\n            new_solution = temp1.copy()\n        elif (cost1_2 <= cost1_1 and cost2_2 <= cost2_1) and (cost1_2 < cost1_1 or cost2_2 < cost2_1):\n            new_solution = temp2.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8358483127963895,
            3.678896427154541
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(int(len(archive) * 0.2), len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: 3-opt move (select 3 random edges and reconnect)\n    if n >= 4:\n        a, b, c = sorted(random.sample(range(n), 3))\n        # Create all possible 3-opt neighbors and select the best one\n        candidates = []\n        for i in range(3):\n            # Try all 8 possible 3-opt configurations\n            for j in range(2):\n                for k in range(2):\n                    temp = new_solution.copy()\n                    # Reverse segments based on configuration\n                    if i == 0:\n                        temp[a:b+1] = temp[a:b+1][::-1] if j else temp[a:b+1]\n                        temp[b:c+1] = temp[b:c+1][::-1] if k else temp[b:c+1]\n                    elif i == 1:\n                        temp[a:b+1] = temp[a:b+1][::-1] if j else temp[a:b+1]\n                        temp[a:c+1] = temp[a:c+1][::-1] if k else temp[a:c+1]\n                    else:\n                        temp[b:c+1] = temp[b:c+1][::-1] if j else temp[b:c+1]\n                        temp[b:c+1] = temp[b:c+1][::-1] if k else temp[b:c+1]\n                    candidates.append(temp)\n\n        # Evaluate all candidates based on both objectives\n        best_candidate = None\n        best_score = float('inf')\n        for candidate in candidates:\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n            score = cost1 + cost2  # Simple weighted sum for selection\n            if score < best_score:\n                best_score = score\n                best_candidate = candidate\n\n        if best_candidate is not None:\n            new_solution = best_candidate.copy()\n\n    # Step 2: Edge swap based on Pareto dominance\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Try both possible edge swaps\n        temp1 = new_solution.copy()\n        temp1[i], temp1[j] = temp1[j], temp1[i]\n\n        temp2 = new_solution.copy()\n        temp2[i:j+1] = temp2[i:j+1][::-1]\n\n        # Evaluate both options\n        cost1_1 = sum(distance_matrix_1[temp1[k], temp1[(k+1)%n]] for k in range(n))\n        cost2_1 = sum(distance_matrix_2[temp1[k], temp1[(k+1)%n]] for k in range(n))\n\n        cost1_2 = sum(distance_matrix_1[temp2[k], temp2[(k+1)%n]] for k in range(n))\n        cost2_2 = sum(distance_matrix_2[temp2[k], temp2[(k+1)%n]] for k in range(n))\n\n        # Select the one that dominates in both objectives\n        if (cost1_1 <= cost1_2 and cost2_1 <= cost2_2) and (cost1_1 < cost1_2 or cost2_1 < cost2_2):\n            new_solution = temp1.copy()\n        elif (cost1_2 <= cost1_1 and cost2_2 <= cost2_1) and (cost1_2 < cost1_1 or cost2_2 < cost2_1):\n            new_solution = temp2.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 11,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Intelligently select a solution with potential for improvement\n    # Prefer solutions with lower costs but higher diversity\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    selected_idx = min(int(len(archive_sorted) * 0.3), len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    # 1. Edge insertion: Move a random segment to a different position\n    if n > 3:\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n        remaining = np.concatenate([new_solution[:a], new_solution[b:]])\n        insert_pos = random.randint(0, len(remaining))\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # 2. Segment reversal: Reverse a random segment\n    if n > 2:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # 3. Novel edge swap: Swap edges that improve both objectives\n    for _ in range(min(3, n // 2)):\n        i = random.randint(0, n-1)\n        j = (i + random.randint(2, min(5, n-1))) % n\n\n        # Calculate original and new costs\n        orig_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        orig_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        # Accept if both objectives improve\n        if new_cost1 < orig_cost1 and new_cost2 < orig_cost2:\n            new_solution[i+1:j+1] = new_solution[j:i:-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6902742621612693,
            1.1305584907531738
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Intelligently select a solution with potential for improvement\n    # Prefer solutions with lower costs but higher diversity\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    selected_idx = min(int(len(archive_sorted) * 0.3), len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    # 1. Edge insertion: Move a random segment to a different position\n    if n > 3:\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n        remaining = np.concatenate([new_solution[:a], new_solution[b:]])\n        insert_pos = random.randint(0, len(remaining))\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # 2. Segment reversal: Reverse a random segment\n    if n > 2:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # 3. Novel edge swap: Swap edges that improve both objectives\n    for _ in range(min(3, n // 2)):\n        i = random.randint(0, n-1)\n        j = (i + random.randint(2, min(5, n-1))) % n\n\n        # Calculate original and new costs\n        orig_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        orig_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        # Accept if both objectives improve\n        if new_cost1 < orig_cost1 and new_cost2 < orig_cost2:\n            new_solution[i+1:j+1] = new_solution[j:i:-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 12,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high probability if it has good potential (low cost in either objective)\n    # or randomly select if all have similar costs\n    objectives = [obj for _, obj in archive]\n    costs1 = [c1 for c1, _ in objectives]\n    costs2 = [c2 for _, c2 in objectives]\n\n    min_cost1, max_cost1 = min(costs1), max(costs1)\n    min_cost2, max_cost2 = min(costs2), max(costs2)\n\n    # Normalize costs to [0, 1] range\n    normalized_costs1 = [(c - min_cost1) / (max_cost1 - min_cost1 + 1e-10) if max_cost1 > min_cost1 else 0.5 for c in costs1]\n    normalized_costs2 = [(c - min_cost2) / (max_cost2 - min_cost2 + 1e-10) if max_cost2 > min_cost2 else 0.5 for c in costs2]\n\n    # Combine normalized costs and select with probability inversely proportional to cost\n    combined_costs = [0.5 * (n1 + n2) for n1, n2 in zip(normalized_costs1, normalized_costs2)]\n    selection_probs = [1 - c for c in combined_costs]  # Higher probability for lower combined cost\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply hybrid local search operator\n    if random.random() < 0.7:  # 70% chance for edge exchange\n        # Randomly select two distinct edges to exchange\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]  # Reverse the segment\n    else:  # 30% chance for segment inversion\n        # Select a random segment and invert it\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution (though this should theoretically not happen)\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.874655244823204,
            1.2446888089179993
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high probability if it has good potential (low cost in either objective)\n    # or randomly select if all have similar costs\n    objectives = [obj for _, obj in archive]\n    costs1 = [c1 for c1, _ in objectives]\n    costs2 = [c2 for _, c2 in objectives]\n\n    min_cost1, max_cost1 = min(costs1), max(costs1)\n    min_cost2, max_cost2 = min(costs2), max(costs2)\n\n    # Normalize costs to [0, 1] range\n    normalized_costs1 = [(c - min_cost1) / (max_cost1 - min_cost1 + 1e-10) if max_cost1 > min_cost1 else 0.5 for c in costs1]\n    normalized_costs2 = [(c - min_cost2) / (max_cost2 - min_cost2 + 1e-10) if max_cost2 > min_cost2 else 0.5 for c in costs2]\n\n    # Combine normalized costs and select with probability inversely proportional to cost\n    combined_costs = [0.5 * (n1 + n2) for n1, n2 in zip(normalized_costs1, normalized_costs2)]\n    selection_probs = [1 - c for c in combined_costs]  # Higher probability for lower combined cost\n    total_prob = sum(selection_probs)\n    selection_probs = [p / total_prob for p in selection_probs]\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply hybrid local search operator\n    if random.random() < 0.7:  # 70% chance for edge exchange\n        # Randomly select two distinct edges to exchange\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]  # Reverse the segment\n    else:  # 30% chance for segment inversion\n        # Select a random segment and invert it\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution (though this should theoretically not happen)\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 13,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in either objective)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    top_k = max(1, len(archive_sorted) // 5)\n    candidates = archive_sorted[:top_k]\n    selected_idx = random.randint(0, len(candidates)-1)\n    base_solution = candidates[selected_idx][0].copy()\n\n    # Hybrid local search operator: combination of edge insertion and edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments to modify\n    i, j = sorted(random.sample(range(1, n-1), 2))\n\n    # Edge insertion: move segment [i..j] to a different position\n    segment = new_solution[i:j+1]\n    remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Edge swap: swap two edges with high potential for improvement\n    # Find the worst edges in both objective spaces\n    worst_edge1 = max(range(n), key=lambda k: distance_matrix_1[new_solution[k-1], new_solution[k]])\n    worst_edge2 = max(range(n), key=lambda k: distance_matrix_2[new_solution[k-1], new_solution[k]])\n    worst_edge = worst_edge1 if distance_matrix_1[new_solution[worst_edge1-1], new_solution[worst_edge1]] + \\\n                           distance_matrix_2[new_solution[worst_edge1-1], new_solution[worst_edge1]] > \\\n                           distance_matrix_1[new_solution[worst_edge2-1], new_solution[worst_edge2]] + \\\n                           distance_matrix_2[new_solution[worst_edge2-1], new_solution[worst_edge2]] else worst_edge2\n\n    # Swap the worst edge with a random other edge\n    if worst_edge > 0 and worst_edge < n-1:\n        swap_pos = random.randint(1, n-2)\n        new_solution[worst_edge], new_solution[swap_pos] = new_solution[swap_pos], new_solution[worst_edge]\n\n    return new_solution\n\n",
        "score": [
            -0.8377787871957245,
            0.8571922779083252
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in either objective)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    top_k = max(1, len(archive_sorted) // 5)\n    candidates = archive_sorted[:top_k]\n    selected_idx = random.randint(0, len(candidates)-1)\n    base_solution = candidates[selected_idx][0].copy()\n\n    # Hybrid local search operator: combination of edge insertion and edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments to modify\n    i, j = sorted(random.sample(range(1, n-1), 2))\n\n    # Edge insertion: move segment [i..j] to a different position\n    segment = new_solution[i:j+1]\n    remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n    insert_pos = random.randint(0, len(remaining)-1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Edge swap: swap two edges with high potential for improvement\n    # Find the worst edges in both objective spaces\n    worst_edge1 = max(range(n), key=lambda k: distance_matrix_1[new_solution[k-1], new_solution[k]])\n    worst_edge2 = max(range(n), key=lambda k: distance_matrix_2[new_solution[k-1], new_solution[k]])\n    worst_edge = worst_edge1 if distance_matrix_1[new_solution[worst_edge1-1], new_solution[worst_edge1]] + \\\n                           distance_matrix_2[new_solution[worst_edge1-1], new_solution[worst_edge1]] > \\\n                           distance_matrix_1[new_solution[worst_edge2-1], new_solution[worst_edge2]] + \\\n                           distance_matrix_2[new_solution[worst_edge2-1], new_solution[worst_edge2]] else worst_edge2\n\n    # Swap the worst edge with a random other edge\n    if worst_edge > 0 and worst_edge < n-1:\n        swap_pos = random.randint(1, n-2)\n        new_solution[worst_edge], new_solution[swap_pos] = new_solution[swap_pos], new_solution[worst_edge]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 14,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search: combine edge insertion with biased random walk\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge insertion (for diversification)\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while abs(i - j) < 2:  # Ensure sufficient distance\n        j = random.randint(0, n - 1)\n\n    # Insert node at j after node at i\n    new_solution = np.concatenate([new_solution[:i+1], [new_solution[j]], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Step 2: Biased random walk (for intensification)\n    for _ in range(2):  # Perform a few steps of random walk\n        k = random.randint(0, n - 3)\n        # Reorder a small segment to improve local structure\n        new_solution[k:k+3] = new_solution[[k+1, k+2, k]]\n\n    # Ensure the solution is valid (no duplicates or missing nodes)\n    assert len(np.unique(new_solution)) == len(selected_solution), \"Invalid solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.7466597758100921,
            0.5790765881538391
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search: combine edge insertion with biased random walk\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge insertion (for diversification)\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while abs(i - j) < 2:  # Ensure sufficient distance\n        j = random.randint(0, n - 1)\n\n    # Insert node at j after node at i\n    new_solution = np.concatenate([new_solution[:i+1], [new_solution[j]], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Step 2: Biased random walk (for intensification)\n    for _ in range(2):  # Perform a few steps of random walk\n        k = random.randint(0, n - 3)\n        # Reorder a small segment to improve local structure\n        new_solution[k:k+3] = new_solution[[k+1, k+2, k]]\n\n    # Ensure the solution is valid (no duplicates or missing nodes)\n    assert len(np.unique(new_solution)) == len(selected_solution), \"Invalid solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 14,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search: combine edge insertion with biased random walk\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge insertion (for diversification)\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while abs(i - j) < 2:  # Ensure sufficient distance\n        j = random.randint(0, n - 1)\n\n    # Insert node at j after node at i\n    new_solution = np.concatenate([new_solution[:i+1], [new_solution[j]], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Step 2: Biased random walk (for intensification)\n    for _ in range(2):  # Perform a few steps of random walk\n        k = random.randint(0, n - 3)\n        # Reorder a small segment to improve local structure\n        new_solution[k:k+3] = new_solution[[k+1, k+2, k]]\n\n    # Ensure the solution is valid (no duplicates or missing nodes)\n    assert len(np.unique(new_solution)) == len(selected_solution), \"Invalid solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.7466597758100921,
            0.5790765881538391
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search: combine edge insertion with biased random walk\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge insertion (for diversification)\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while abs(i - j) < 2:  # Ensure sufficient distance\n        j = random.randint(0, n - 1)\n\n    # Insert node at j after node at i\n    new_solution = np.concatenate([new_solution[:i+1], [new_solution[j]], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Step 2: Biased random walk (for intensification)\n    for _ in range(2):  # Perform a few steps of random walk\n        k = random.randint(0, n - 3)\n        # Reorder a small segment to improve local structure\n        new_solution[k:k+3] = new_solution[[k+1, k+2, k]]\n\n    # Ensure the solution is valid (no duplicates or missing nodes)\n    assert len(np.unique(new_solution)) == len(selected_solution), \"Invalid solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 15,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    solutions = [s for s, _ in archive]\n    objectives = [o for _, o in archive]\n\n    # Calculate potential for improvement (e.g., based on dominance or diversity)\n    potentials = []\n    for i, (s, o) in enumerate(zip(solutions, objectives)):\n        # Simple heuristic: solutions with worse objectives have higher potential\n        # (assuming minimization problem)\n        potential = (o[0] + o[1]) / len(solutions)\n        potentials.append(potential)\n\n    # Normalize potentials to form a probability distribution\n    total_potential = sum(potentials)\n    if total_potential == 0:\n        probabilities = [1.0 / len(potentials) for _ in potentials]\n    else:\n        probabilities = [p / total_potential for p in potentials]\n\n    # Select a base solution based on the probability distribution\n    base_solution = random.choices(solutions, weights=probabilities, k=1)[0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: combine 2-opt with a novel segment relocation\n    if n > 3:\n        # Step 1: Perform a 2-opt swap on a random segment\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Step 2: Relocate a random segment to a new position\n        k, l = sorted(random.sample(range(n), 2))\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], new_solution[l:], segment])\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if the above operation causes duplicates\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9175099654541558,
            1.682327926158905
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    solutions = [s for s, _ in archive]\n    objectives = [o for _, o in archive]\n\n    # Calculate potential for improvement (e.g., based on dominance or diversity)\n    potentials = []\n    for i, (s, o) in enumerate(zip(solutions, objectives)):\n        # Simple heuristic: solutions with worse objectives have higher potential\n        # (assuming minimization problem)\n        potential = (o[0] + o[1]) / len(solutions)\n        potentials.append(potential)\n\n    # Normalize potentials to form a probability distribution\n    total_potential = sum(potentials)\n    if total_potential == 0:\n        probabilities = [1.0 / len(potentials) for _ in potentials]\n    else:\n        probabilities = [p / total_potential for p in potentials]\n\n    # Select a base solution based on the probability distribution\n    base_solution = random.choices(solutions, weights=probabilities, k=1)[0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: combine 2-opt with a novel segment relocation\n    if n > 3:\n        # Step 1: Perform a 2-opt swap on a random segment\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Step 2: Relocate a random segment to a new position\n        k, l = sorted(random.sample(range(n), 2))\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], new_solution[l:], segment])\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if the above operation causes duplicates\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 16,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its rank in the Pareto front\n    ranks = np.argsort([sum(obj) for _, obj in archive])  # Simple rank based on combined objective\n    selected_idx = random.choices(range(len(archive)), weights=[1/(r+1) for r in ranks], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combination of 3-opt and edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 3-opt move\n    i, j, k = sorted(random.sample(range(1, n-1), 3))\n    new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment\n    new_solution[j:k] = new_solution[j:k][::-1]  # Reverse segment\n\n    # Perform edge insertion move\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    node = new_solution[b]\n    new_solution = np.concatenate([new_solution[:a], [node], new_solution[a:b], new_solution[b+1:]])\n\n    # Ensure solution remains feasible (no duplicates and all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by inserting missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            insert_pos = random.randint(1, n-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8546677563878989,
            1.540088176727295
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its rank in the Pareto front\n    ranks = np.argsort([sum(obj) for _, obj in archive])  # Simple rank based on combined objective\n    selected_idx = random.choices(range(len(archive)), weights=[1/(r+1) for r in ranks], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combination of 3-opt and edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 3-opt move\n    i, j, k = sorted(random.sample(range(1, n-1), 3))\n    new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment\n    new_solution[j:k] = new_solution[j:k][::-1]  # Reverse segment\n\n    # Perform edge insertion move\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    node = new_solution[b]\n    new_solution = np.concatenate([new_solution[:a], [node], new_solution[a:b], new_solution[b+1:]])\n\n    # Ensure solution remains feasible (no duplicates and all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by inserting missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            insert_pos = random.randint(1, n-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 17,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    # If no non-dominated solutions, use all archive\n    if not non_dominated:\n        non_dominated = archive\n\n    # Step 2: Select a base solution (biased toward better solutions)\n    weights = np.array([1/(i+1) for i in range(len(non_dominated))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(non_dominated), p=weights)\n    base_solution = non_dominated[selected_idx][0].copy()\n\n    # Step 3: Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive perturbation strength based on solution quality\n    quality = non_dominated[selected_idx][1][0] + non_dominated[selected_idx][1][1]\n    perturbation_strength = max(1, int(0.1 * n * (1 - min(1, quality/1000))))\n\n    for _ in range(perturbation_strength):\n        # Select three distinct segments\n        a, b, c = sorted(random.sample(range(n), 3))\n\n        # 3-opt-inspired move with adaptive segment selection\n        if random.random() < 0.7:  # Higher probability for better moves\n            # Try to improve both objectives\n            current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + \\\n                           distance_matrix_1[new_solution[b-1], new_solution[b]] + \\\n                           distance_matrix_1[new_solution[c-1], new_solution[c]]\n            current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + \\\n                           distance_matrix_2[new_solution[b-1], new_solution[b]] + \\\n                           distance_matrix_2[new_solution[c-1], new_solution[c]]\n\n            # Try different configurations\n            for config in [(a, b, c), (a, c, b), (b, a, c), (b, c, a), (c, a, b), (c, b, a)]:\n                x, y, z = config\n                new_cost1 = distance_matrix_1[new_solution[x-1], new_solution[y]] + \\\n                           distance_matrix_1[new_solution[y-1], new_solution[z]] + \\\n                           distance_matrix_1[new_solution[z-1], new_solution[x]]\n                new_cost2 = distance_matrix_2[new_solution[x-1], new_solution[y]] + \\\n                           distance_matrix_2[new_solution[y-1], new_solution[z]] + \\\n                           distance_matrix_2[new_solution[z-1], new_solution[x]]\n\n                if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n                   (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n                    # Apply the best configuration\n                    new_solution[x:y] = new_solution[x:y][::-1]\n                    new_solution[y:z] = new_solution[y:z][::-1]\n                    new_solution[z:] = new_solution[z:][::-1]\n                    break\n        else:\n            # Random perturbation\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7960258777773619,
            1.6330609917640686
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    # If no non-dominated solutions, use all archive\n    if not non_dominated:\n        non_dominated = archive\n\n    # Step 2: Select a base solution (biased toward better solutions)\n    weights = np.array([1/(i+1) for i in range(len(non_dominated))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(non_dominated), p=weights)\n    base_solution = non_dominated[selected_idx][0].copy()\n\n    # Step 3: Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive perturbation strength based on solution quality\n    quality = non_dominated[selected_idx][1][0] + non_dominated[selected_idx][1][1]\n    perturbation_strength = max(1, int(0.1 * n * (1 - min(1, quality/1000))))\n\n    for _ in range(perturbation_strength):\n        # Select three distinct segments\n        a, b, c = sorted(random.sample(range(n), 3))\n\n        # 3-opt-inspired move with adaptive segment selection\n        if random.random() < 0.7:  # Higher probability for better moves\n            # Try to improve both objectives\n            current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + \\\n                           distance_matrix_1[new_solution[b-1], new_solution[b]] + \\\n                           distance_matrix_1[new_solution[c-1], new_solution[c]]\n            current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + \\\n                           distance_matrix_2[new_solution[b-1], new_solution[b]] + \\\n                           distance_matrix_2[new_solution[c-1], new_solution[c]]\n\n            # Try different configurations\n            for config in [(a, b, c), (a, c, b), (b, a, c), (b, c, a), (c, a, b), (c, b, a)]:\n                x, y, z = config\n                new_cost1 = distance_matrix_1[new_solution[x-1], new_solution[y]] + \\\n                           distance_matrix_1[new_solution[y-1], new_solution[z]] + \\\n                           distance_matrix_1[new_solution[z-1], new_solution[x]]\n                new_cost2 = distance_matrix_2[new_solution[x-1], new_solution[y]] + \\\n                           distance_matrix_2[new_solution[y-1], new_solution[z]] + \\\n                           distance_matrix_2[new_solution[z-1], new_solution[x]]\n\n                if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n                   (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n                    # Apply the best configuration\n                    new_solution[x:y] = new_solution[x:y][::-1]\n                    new_solution[y:z] = new_solution[y:z][::-1]\n                    new_solution[z:] = new_solution[z:][::-1]\n                    break\n        else:\n            # Random perturbation\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 18,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution with high potential for improvement\n    # We prioritize solutions with high variance in objectives (indicating room for improvement)\n    # and those with lower total cost (better starting point)\n    scores = []\n    for sol, (cost1, cost2) in archive:\n        variance = abs(cost1 - cost2)\n        total_cost = cost1 + cost2\n        score = variance / (total_cost + 1e-6)  # Avoid division by zero\n        scores.append(score)\n\n    # Select top 3 solutions with highest scores\n    top_indices = np.argsort(scores)[-3:][::-1]\n    selected_idx = np.random.choice(top_indices) if len(top_indices) > 1 else top_indices[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid strategy: Combine edge insertion with a novel segment reversal\n    # 1. Randomly select a segment of the tour\n    seg_start = np.random.randint(0, n-3)\n    seg_end = np.random.randint(seg_start+2, min(seg_start+5, n))\n    segment = new_solution[seg_start:seg_end]\n\n    # 2. Apply segment reversal with probability\n    if np.random.rand() > 0.5:\n        segment = segment[::-1]\n\n    # 3. Insert the segment at a new random position\n    insert_pos = np.random.randint(0, n)\n    if insert_pos < seg_start:\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:seg_start],\n            new_solution[seg_end:]\n        ])\n    else:\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n    # Ensure validity by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.4030031699022848,
            1.4366612434387207
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution with high potential for improvement\n    # We prioritize solutions with high variance in objectives (indicating room for improvement)\n    # and those with lower total cost (better starting point)\n    scores = []\n    for sol, (cost1, cost2) in archive:\n        variance = abs(cost1 - cost2)\n        total_cost = cost1 + cost2\n        score = variance / (total_cost + 1e-6)  # Avoid division by zero\n        scores.append(score)\n\n    # Select top 3 solutions with highest scores\n    top_indices = np.argsort(scores)[-3:][::-1]\n    selected_idx = np.random.choice(top_indices) if len(top_indices) > 1 else top_indices[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid strategy: Combine edge insertion with a novel segment reversal\n    # 1. Randomly select a segment of the tour\n    seg_start = np.random.randint(0, n-3)\n    seg_end = np.random.randint(seg_start+2, min(seg_start+5, n))\n    segment = new_solution[seg_start:seg_end]\n\n    # 2. Apply segment reversal with probability\n    if np.random.rand() > 0.5:\n        segment = segment[::-1]\n\n    # 3. Insert the segment at a new random position\n    insert_pos = np.random.randint(0, n)\n    if insert_pos < seg_start:\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:seg_start],\n            new_solution[seg_end:]\n        ])\n    else:\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n    # Ensure validity by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 19,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n\n    # Normalize objectives and compute a score (higher is better for improvement)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    scores = 1 - normalized  # Inverse of normalized objectives (lower original objective is better)\n    weights = np.mean(scores, axis=1)  # Average score across objectives\n    weights = weights / np.sum(weights)  # Normalize to probabilities\n\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform 3-opt with a probability of 0.7, otherwise use edge-swap\n        if random.random() < 0.7:\n            # 3-opt: select three random edges and reconnect them\n            i, j, k = sorted(random.sample(range(1, n), 3))\n            # Reconnect the edges in a different configuration\n            new_solution[i:j] = new_solution[i:j][::-1]\n            new_solution[j:k] = new_solution[j:k][::-1]\n        else:\n            # Edge-swap heuristic: swap two edges that are far apart in the solution\n            # Find two edges that are far apart in the tour\n            max_dist = -1\n            best_i, best_j = 0, 0\n            for i in range(n):\n                for j in range(i+2, n):\n                    # Calculate the \"distance\" between edges in the tour\n                    dist = (j - i) * (n - (j - i))\n                    if dist > max_dist:\n                        max_dist = dist\n                        best_i, best_j = i, j\n            # Swap the edges\n            new_solution[best_i:best_j] = new_solution[best_i:best_j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8215519714229006,
            1.5740340948104858
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n\n    # Normalize objectives and compute a score (higher is better for improvement)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    scores = 1 - normalized  # Inverse of normalized objectives (lower original objective is better)\n    weights = np.mean(scores, axis=1)  # Average score across objectives\n    weights = weights / np.sum(weights)  # Normalize to probabilities\n\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform 3-opt with a probability of 0.7, otherwise use edge-swap\n        if random.random() < 0.7:\n            # 3-opt: select three random edges and reconnect them\n            i, j, k = sorted(random.sample(range(1, n), 3))\n            # Reconnect the edges in a different configuration\n            new_solution[i:j] = new_solution[i:j][::-1]\n            new_solution[j:k] = new_solution[j:k][::-1]\n        else:\n            # Edge-swap heuristic: swap two edges that are far apart in the solution\n            # Find two edges that are far apart in the tour\n            max_dist = -1\n            best_i, best_j = 0, 0\n            for i in range(n):\n                for j in range(i+2, n):\n                    # Calculate the \"distance\" between edges in the tour\n                    dist = (j - i) * (n - (j - i))\n                    if dist > max_dist:\n                        max_dist = dist\n                        best_i, best_j = i, j\n            # Swap the edges\n            new_solution[best_i:best_j] = new_solution[best_i:best_j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 20,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    archive_sorted = sorted(archive, key=lambda x: min(x[1]))\n    selected_idx = min(3, len(archive_sorted) - 1)  # Select from top 3 or all available\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: combination of edge insertion and segment reversal\n    for _ in range(2):  # Apply operator multiple times\n        # Randomly select two distinct segments\n        a, b = sorted(random.sample(range(1, n-2), 2))\n        c, d = sorted(random.sample(range(a+1, n-1), 2))\n\n        # Extract segments\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n\n        # Reinsert segments in reverse order with some probability\n        if random.random() < 0.5:\n            segment1 = segment1[::-1]\n            segment2 = segment2[::-1]\n\n        # Create new solution with segments swapped and reversed\n        new_solution = np.concatenate([\n            new_solution[:a],\n            segment2,\n            new_solution[b+1:c],\n            segment1,\n            new_solution[d+1:]\n        ])\n\n        # Ensure validity by checking for duplicates and missing nodes\n        if len(np.unique(new_solution)) != n:\n            # If invalid, revert to original segments\n            new_solution = np.concatenate([\n                new_solution[:a],\n                segment1,\n                new_solution[b+1:c],\n                segment2,\n                new_solution[d+1:]\n            ])\n\n    return new_solution\n\n",
        "score": [
            -0.6808252378695504,
            0.35478705167770386
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    archive_sorted = sorted(archive, key=lambda x: min(x[1]))\n    selected_idx = min(3, len(archive_sorted) - 1)  # Select from top 3 or all available\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: combination of edge insertion and segment reversal\n    for _ in range(2):  # Apply operator multiple times\n        # Randomly select two distinct segments\n        a, b = sorted(random.sample(range(1, n-2), 2))\n        c, d = sorted(random.sample(range(a+1, n-1), 2))\n\n        # Extract segments\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n\n        # Reinsert segments in reverse order with some probability\n        if random.random() < 0.5:\n            segment1 = segment1[::-1]\n            segment2 = segment2[::-1]\n\n        # Create new solution with segments swapped and reversed\n        new_solution = np.concatenate([\n            new_solution[:a],\n            segment2,\n            new_solution[b+1:c],\n            segment1,\n            new_solution[d+1:]\n        ])\n\n        # Ensure validity by checking for duplicates and missing nodes\n        if len(np.unique(new_solution)) != n:\n            # If invalid, revert to original segments\n            new_solution = np.concatenate([\n                new_solution[:a],\n                segment1,\n                new_solution[b+1:c],\n                segment2,\n                new_solution[d+1:]\n            ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 20,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    archive_sorted = sorted(archive, key=lambda x: min(x[1]))\n    selected_idx = min(3, len(archive_sorted) - 1)  # Select from top 3 or all available\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: combination of edge insertion and segment reversal\n    for _ in range(2):  # Apply operator multiple times\n        # Randomly select two distinct segments\n        a, b = sorted(random.sample(range(1, n-2), 2))\n        c, d = sorted(random.sample(range(a+1, n-1), 2))\n\n        # Extract segments\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n\n        # Reinsert segments in reverse order with some probability\n        if random.random() < 0.5:\n            segment1 = segment1[::-1]\n            segment2 = segment2[::-1]\n\n        # Create new solution with segments swapped and reversed\n        new_solution = np.concatenate([\n            new_solution[:a],\n            segment2,\n            new_solution[b+1:c],\n            segment1,\n            new_solution[d+1:]\n        ])\n\n        # Ensure validity by checking for duplicates and missing nodes\n        if len(np.unique(new_solution)) != n:\n            # If invalid, revert to original segments\n            new_solution = np.concatenate([\n                new_solution[:a],\n                segment1,\n                new_solution[b+1:c],\n                segment2,\n                new_solution[d+1:]\n            ])\n\n    return new_solution\n\n",
        "score": [
            -0.6808252378695504,
            0.35478705167770386
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    archive_sorted = sorted(archive, key=lambda x: min(x[1]))\n    selected_idx = min(3, len(archive_sorted) - 1)  # Select from top 3 or all available\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: combination of edge insertion and segment reversal\n    for _ in range(2):  # Apply operator multiple times\n        # Randomly select two distinct segments\n        a, b = sorted(random.sample(range(1, n-2), 2))\n        c, d = sorted(random.sample(range(a+1, n-1), 2))\n\n        # Extract segments\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n\n        # Reinsert segments in reverse order with some probability\n        if random.random() < 0.5:\n            segment1 = segment1[::-1]\n            segment2 = segment2[::-1]\n\n        # Create new solution with segments swapped and reversed\n        new_solution = np.concatenate([\n            new_solution[:a],\n            segment2,\n            new_solution[b+1:c],\n            segment1,\n            new_solution[d+1:]\n        ])\n\n        # Ensure validity by checking for duplicates and missing nodes\n        if len(np.unique(new_solution)) != n:\n            # If invalid, revert to original segments\n            new_solution = np.concatenate([\n                new_solution[:a],\n                segment1,\n                new_solution[b+1:c],\n                segment2,\n                new_solution[d+1:]\n            ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 21,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel move\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful local search\n\n    # Step 1: Randomly select two non-adjacent edges to break\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while abs(i - j) <= 1 or (i == 0 and j == n - 1) or (j == 0 and i == n - 1):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n\n    # Step 2: Perform a novel move that combines reversal and insertion\n    if random.random() < 0.5:\n        # Reverse a segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Insert a random segment elsewhere\n        k = random.randint(0, n - 1)\n        l = random.randint(0, n - 1)\n        while abs(k - l) <= 1 or (k == 0 and l == n - 1) or (l == 0 and k == n - 1):\n            k = random.randint(0, n - 1)\n            l = random.randint(0, n - 1)\n        segment = new_solution[k:l+1]\n        new_solution = np.concatenate([new_solution[:k], new_solution[l+1:], segment])\n\n    # Ensure the solution remains a valid tour\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        # Fallback to simple swap if invalid\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.803788590071948,
            0.6642659902572632
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel move\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful local search\n\n    # Step 1: Randomly select two non-adjacent edges to break\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while abs(i - j) <= 1 or (i == 0 and j == n - 1) or (j == 0 and i == n - 1):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n\n    # Step 2: Perform a novel move that combines reversal and insertion\n    if random.random() < 0.5:\n        # Reverse a segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Insert a random segment elsewhere\n        k = random.randint(0, n - 1)\n        l = random.randint(0, n - 1)\n        while abs(k - l) <= 1 or (k == 0 and l == n - 1) or (l == 0 and k == n - 1):\n            k = random.randint(0, n - 1)\n            l = random.randint(0, n - 1)\n        segment = new_solution[k:l+1]\n        new_solution = np.concatenate([new_solution[:k], new_solution[l+1:], segment])\n\n    # Ensure the solution remains a valid tour\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        # Fallback to simple swap if invalid\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 22,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    combined_objectives = objectives[:, 0] + objectives[:, 1]\n    selected_idx = np.argmax(combined_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel segment relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on a random segment\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Perform segment relocation: move a random segment to a different position\n    if n > 3:\n        seg_start, seg_end = sorted(np.random.choice(n, 2, replace=False))\n        insert_pos = np.random.randint(0, n)\n        segment = new_solution[seg_start:seg_end+1]\n\n        # Remove the segment\n        remaining = np.concatenate([new_solution[:seg_start], new_solution[seg_end+1:]])\n\n        # Insert the segment at the new position\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9837046024707672,
            1.4717006087303162
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    combined_objectives = objectives[:, 0] + objectives[:, 1]\n    selected_idx = np.argmax(combined_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel segment relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on a random segment\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Perform segment relocation: move a random segment to a different position\n    if n > 3:\n        seg_start, seg_end = sorted(np.random.choice(n, 2, replace=False))\n        insert_pos = np.random.randint(0, n)\n        segment = new_solution[seg_start:seg_end+1]\n\n        # Remove the segment\n        remaining = np.concatenate([new_solution[:seg_start], new_solution[seg_end+1:]])\n\n        # Insert the segment at the new position\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 22,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    combined_objectives = objectives[:, 0] + objectives[:, 1]\n    selected_idx = np.argmax(combined_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel segment relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on a random segment\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Perform segment relocation: move a random segment to a different position\n    if n > 3:\n        seg_start, seg_end = sorted(np.random.choice(n, 2, replace=False))\n        insert_pos = np.random.randint(0, n)\n        segment = new_solution[seg_start:seg_end+1]\n\n        # Remove the segment\n        remaining = np.concatenate([new_solution[:seg_start], new_solution[seg_end+1:]])\n\n        # Insert the segment at the new position\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9837046024707672,
            1.4717006087303162
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    combined_objectives = objectives[:, 0] + objectives[:, 1]\n    selected_idx = np.argmax(combined_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel segment relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on a random segment\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Perform segment relocation: move a random segment to a different position\n    if n > 3:\n        seg_start, seg_end = sorted(np.random.choice(n, 2, replace=False))\n        insert_pos = np.random.randint(0, n)\n        segment = new_solution[seg_start:seg_end+1]\n\n        # Remove the segment\n        remaining = np.concatenate([new_solution[:seg_start], new_solution[seg_end+1:]])\n\n        # Insert the segment at the new position\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 23,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (prioritize solutions with higher cost)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select a solution that is not the best in both objectives\n        selected = None\n        for sol, _ in archive_sorted:\n            if not any(np.array_equal(sol, best_sol) for best_sol, _ in archive[:10]):  # Avoid best solutions\n                selected = sol.copy()\n                break\n        if selected is not None:\n            base_solution = selected\n        else:\n            base_solution = archive[0][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: combine 3-opt with a novel segment reversal\n    if n >= 4:\n        # Select three random non-adjacent indices\n        i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n        while j == i + 1 or k == j + 1:  # Ensure non-adjacent\n            i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n        # Apply 3-opt: reverse segments between i-j and j-k\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Novel segment reversal: reverse a segment between i and k\n        new_solution[i:k] = new_solution[i:k][::-1]\n\n    # Ensure feasibility: check for duplicates and fix if any\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple 2-opt move\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.923465504664323,
            1.2874978184700012
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (prioritize solutions with higher cost)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select a solution that is not the best in both objectives\n        selected = None\n        for sol, _ in archive_sorted:\n            if not any(np.array_equal(sol, best_sol) for best_sol, _ in archive[:10]):  # Avoid best solutions\n                selected = sol.copy()\n                break\n        if selected is not None:\n            base_solution = selected\n        else:\n            base_solution = archive[0][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: combine 3-opt with a novel segment reversal\n    if n >= 4:\n        # Select three random non-adjacent indices\n        i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n        while j == i + 1 or k == j + 1:  # Ensure non-adjacent\n            i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n        # Apply 3-opt: reverse segments between i-j and j-k\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Novel segment reversal: reverse a segment between i and k\n        new_solution[i:k] = new_solution[i:k][::-1]\n\n    # Ensure feasibility: check for duplicates and fix if any\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple 2-opt move\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 24,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    # Higher probability for solutions with higher combined cost or more diverse edges\n    costs = [obj[0] + obj[1] for _, obj in archive]\n    max_cost = max(costs)\n    if max_cost == 0:\n        weights = [1.0 / len(archive)] * len(archive)\n    else:\n        weights = [cost / max_cost for cost in costs]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy combining edge insertion and path relocation\n    if n > 3:\n        # Step 1: Randomly select two non-adjacent edges to break\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while abs(i - j) <= 1 or abs(i - j) >= n - 1:\n            j = random.randint(0, n-1)\n\n        # Step 2: Break the tour into two paths\n        path1 = new_solution[:i+1]\n        path2 = new_solution[i+1:j+1]\n        path3 = new_solution[j+1:]\n\n        # Step 3: Reconnect the paths with a different combination\n        # Try different combinations to find the best improvement\n        candidates = [\n            np.concatenate([path1, path3, path2]),\n            np.concatenate([path2, path1, path3]),\n            np.concatenate([path3, path2, path1])\n        ]\n\n        # Evaluate each candidate and select the best one\n        best_candidate = candidates[0]\n        best_cost = float('inf')\n\n        for candidate in candidates:\n            cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_candidate = candidate\n\n        new_solution = best_candidate\n\n        # Step 4: Additional improvement with path relocation\n        if n > 4:\n            k = random.randint(0, n-1)\n            l = random.randint(0, n-1)\n            while abs(k - l) <= 1 or abs(k - l) >= n - 1:\n                l = random.randint(0, n-1)\n\n            # Relocate a segment between two random points\n            segment = new_solution[k:l+1]\n            remaining = np.concatenate([new_solution[:k], new_solution[l+1:]])\n            insert_pos = random.randint(0, len(remaining))\n            new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.7583281510403581,
            0.8512575626373291
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    # Higher probability for solutions with higher combined cost or more diverse edges\n    costs = [obj[0] + obj[1] for _, obj in archive]\n    max_cost = max(costs)\n    if max_cost == 0:\n        weights = [1.0 / len(archive)] * len(archive)\n    else:\n        weights = [cost / max_cost for cost in costs]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy combining edge insertion and path relocation\n    if n > 3:\n        # Step 1: Randomly select two non-adjacent edges to break\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while abs(i - j) <= 1 or abs(i - j) >= n - 1:\n            j = random.randint(0, n-1)\n\n        # Step 2: Break the tour into two paths\n        path1 = new_solution[:i+1]\n        path2 = new_solution[i+1:j+1]\n        path3 = new_solution[j+1:]\n\n        # Step 3: Reconnect the paths with a different combination\n        # Try different combinations to find the best improvement\n        candidates = [\n            np.concatenate([path1, path3, path2]),\n            np.concatenate([path2, path1, path3]),\n            np.concatenate([path3, path2, path1])\n        ]\n\n        # Evaluate each candidate and select the best one\n        best_candidate = candidates[0]\n        best_cost = float('inf')\n\n        for candidate in candidates:\n            cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_candidate = candidate\n\n        new_solution = best_candidate\n\n        # Step 4: Additional improvement with path relocation\n        if n > 4:\n            k = random.randint(0, n-1)\n            l = random.randint(0, n-1)\n            while abs(k - l) <= 1 or abs(k - l) >= n - 1:\n                l = random.randint(0, n-1)\n\n            # Relocate a segment between two random points\n            segment = new_solution[k:l+1]\n            remaining = np.concatenate([new_solution[:k], new_solution[l+1:]])\n            insert_pos = random.randint(0, len(remaining))\n            new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 25,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its dominance (better solutions are less likely to be selected)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct nodes to perform 3-opt\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Perform 3-opt: reverse the segment between i and k, then reverse the segment between j and k\n    new_solution[i:k] = np.flip(new_solution[i:k])\n    new_solution[j:k] = np.flip(new_solution[j:k])\n\n    # Custom edge swap: swap edges between i and j with edges between i and k\n    if random.random() < 0.5:  # 50% chance to apply the custom swap\n        temp = new_solution[i]\n        new_solution[i] = new_solution[j]\n        new_solution[j] = temp\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9117780059665468,
            1.307102084159851
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its dominance (better solutions are less likely to be selected)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct nodes to perform 3-opt\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Perform 3-opt: reverse the segment between i and k, then reverse the segment between j and k\n    new_solution[i:k] = np.flip(new_solution[i:k])\n    new_solution[j:k] = np.flip(new_solution[j:k])\n\n    # Custom edge swap: swap edges between i and j with edges between i and k\n    if random.random() < 0.5:  # 50% chance to apply the custom swap\n        temp = new_solution[i]\n        new_solution[i] = new_solution[j]\n        new_solution[j] = temp\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 26,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a novel move that considers both objectives\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations to explore different neighborhoods\n        # Randomly select 4 distinct indices to define the move\n        a, b, c, d = sorted(np.random.choice(np.arange(n), size=4, replace=False))\n\n        # Apply a novel 4-opt move that considers both objectives\n        # The move is designed to balance the two objectives by swapping segments\n        # and considering the distance reduction in both spaces\n        delta_1 = (distance_matrix_1[new_solution[a], new_solution[b]] +\n                   distance_matrix_1[new_solution[c], new_solution[d]] -\n                   distance_matrix_1[new_solution[a], new_solution[a+1]] -\n                   distance_matrix_1[new_solution[c], new_solution[c+1]])\n\n        delta_2 = (distance_matrix_2[new_solution[a], new_solution[b]] +\n                   distance_matrix_2[new_solution[c], new_solution[d]] -\n                   distance_matrix_2[new_solution[a], new_solution[a+1]] -\n                   distance_matrix_2[new_solution[c], new_solution[c+1]])\n\n        # Accept the move if it improves at least one objective\n        if delta_1 < 0 or delta_2 < 0:\n            # Reverse the segments between a and b, and between c and d\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n            new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6177325473927419,
            1.6458236575126648
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a novel move that considers both objectives\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations to explore different neighborhoods\n        # Randomly select 4 distinct indices to define the move\n        a, b, c, d = sorted(np.random.choice(np.arange(n), size=4, replace=False))\n\n        # Apply a novel 4-opt move that considers both objectives\n        # The move is designed to balance the two objectives by swapping segments\n        # and considering the distance reduction in both spaces\n        delta_1 = (distance_matrix_1[new_solution[a], new_solution[b]] +\n                   distance_matrix_1[new_solution[c], new_solution[d]] -\n                   distance_matrix_1[new_solution[a], new_solution[a+1]] -\n                   distance_matrix_1[new_solution[c], new_solution[c+1]])\n\n        delta_2 = (distance_matrix_2[new_solution[a], new_solution[b]] +\n                   distance_matrix_2[new_solution[c], new_solution[d]] -\n                   distance_matrix_2[new_solution[a], new_solution[a+1]] -\n                   distance_matrix_2[new_solution[c], new_solution[c+1]])\n\n        # Accept the move if it improves at least one objective\n        if delta_1 < 0 or delta_2 < 0:\n            # Reverse the segments between a and b, and between c and d\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n            new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 27,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-dominated solutions)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Hybrid local search strategy\n    # Step 1: Edge insertion for diversification\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution = np.concatenate([new_solution[:i+1], new_solution[j:], new_solution[i+1:j]])\n\n    # Step 2: Novel segment relocation for intensification\n    segment_size = min(3, n // 4)  # Relocate a small segment\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    # Find insertion point that minimizes both objectives\n    min_cost = float('inf')\n    best_insert_pos = 0\n\n    for pos in range(n - segment_size + 1):\n        if pos >= start and pos <= end:\n            continue  # Skip current position\n\n        # Create candidate solution\n        candidate = np.concatenate([\n            new_solution[:pos],\n            new_solution[start:end],\n            new_solution[pos:start],\n            new_solution[end:]\n        ])\n\n        # Calculate both objectives\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        total_cost = cost1 + cost2\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_insert_pos = pos\n\n    # Apply the best relocation\n    if best_insert_pos != start:\n        new_solution = np.concatenate([\n            new_solution[:best_insert_pos],\n            new_solution[start:end],\n            new_solution[best_insert_pos:start],\n            new_solution[end:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -0.8438926556601931,
            5.895217061042786
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-dominated solutions)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Hybrid local search strategy\n    # Step 1: Edge insertion for diversification\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution = np.concatenate([new_solution[:i+1], new_solution[j:], new_solution[i+1:j]])\n\n    # Step 2: Novel segment relocation for intensification\n    segment_size = min(3, n // 4)  # Relocate a small segment\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    # Find insertion point that minimizes both objectives\n    min_cost = float('inf')\n    best_insert_pos = 0\n\n    for pos in range(n - segment_size + 1):\n        if pos >= start and pos <= end:\n            continue  # Skip current position\n\n        # Create candidate solution\n        candidate = np.concatenate([\n            new_solution[:pos],\n            new_solution[start:end],\n            new_solution[pos:start],\n            new_solution[end:]\n        ])\n\n        # Calculate both objectives\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        total_cost = cost1 + cost2\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_insert_pos = pos\n\n    # Apply the best relocation\n    if best_insert_pos != start:\n        new_solution = np.concatenate([\n            new_solution[:best_insert_pos],\n            new_solution[start:end],\n            new_solution[best_insert_pos:start],\n            new_solution[end:]\n        ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 28,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligently select a solution with potential for improvement\n    # Here, we select a solution with the worst objective in either space, as it likely has room for improvement\n    def objective_score(obj):\n        return max(obj[0], obj[1])\n\n    archive_sorted = sorted(archive, key=lambda x: -objective_score(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Apply hybrid local search operator: a combination of node insertion and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    if n > 3:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply node insertion: move a random node to a new position\n    if n > 2:\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n        new_solution = np.delete(new_solution, node_pos)\n        new_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    assert len(new_solution) == len(selected_solution), \"Solution length changed\"\n    assert len(np.unique(new_solution)) == n, \"Duplicate nodes in solution\"\n\n    return new_solution\n\n",
        "score": [
            -0.931652312900138,
            1.3510748744010925
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligently select a solution with potential for improvement\n    # Here, we select a solution with the worst objective in either space, as it likely has room for improvement\n    def objective_score(obj):\n        return max(obj[0], obj[1])\n\n    archive_sorted = sorted(archive, key=lambda x: -objective_score(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Apply hybrid local search operator: a combination of node insertion and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    if n > 3:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply node insertion: move a random node to a new position\n    if n > 2:\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n        new_solution = np.delete(new_solution, node_pos)\n        new_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    assert len(new_solution) == len(selected_solution), \"Solution length changed\"\n    assert len(np.unique(new_solution)) == n, \"Duplicate nodes in solution\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 29,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by a combination of objective values and diversity\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n        # Select the middle solution to balance exploration and exploitation\n        base_solution = archive_sorted[len(archive) // 2][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    # Step 1: Perform 2-opt on a random segment\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Apply edge insertion for further improvement\n    # Select a random edge and try to insert it in a better position\n    k = random.randint(0, n-1)\n    current_node = new_solution[k]\n    next_node = new_solution[(k+1) % n]\n\n    # Find the best insertion point for the edge (current_node, next_node)\n    best_insert_pos = -1\n    min_increase = float('inf')\n\n    for pos in range(n):\n        if pos == k or pos == (k+1) % n:\n            continue\n\n        # Calculate the increase in total cost if we insert the edge at this position\n        prev_node = new_solution[pos]\n        next_next_node = new_solution[(pos+1) % n]\n\n        # Original cost without the edge\n        original_cost = distance_matrix_1[prev_node, next_next_node] + distance_matrix_2[prev_node, next_next_node]\n\n        # New cost with the edge inserted\n        new_cost = (distance_matrix_1[prev_node, current_node] + distance_matrix_1[current_node, next_next_node] +\n                    distance_matrix_2[prev_node, current_node] + distance_matrix_2[current_node, next_next_node])\n\n        increase = new_cost - original_cost\n\n        if increase < min_increase:\n            min_increase = increase\n            best_insert_pos = pos\n\n    # Perform the insertion if it improves the solution\n    if best_insert_pos != -1 and min_increase < 0:\n        # Remove the original edge\n        new_solution = np.delete(new_solution, (k+1) % n)\n\n        # Insert the edge at the best position\n        new_solution = np.insert(new_solution, (best_insert_pos+1) % n, current_node)\n\n    return new_solution\n\n",
        "score": [
            -0.8775473623860908,
            1.4465968012809753
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by a combination of objective values and diversity\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n        # Select the middle solution to balance exploration and exploitation\n        base_solution = archive_sorted[len(archive) // 2][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    # Step 1: Perform 2-opt on a random segment\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Apply edge insertion for further improvement\n    # Select a random edge and try to insert it in a better position\n    k = random.randint(0, n-1)\n    current_node = new_solution[k]\n    next_node = new_solution[(k+1) % n]\n\n    # Find the best insertion point for the edge (current_node, next_node)\n    best_insert_pos = -1\n    min_increase = float('inf')\n\n    for pos in range(n):\n        if pos == k or pos == (k+1) % n:\n            continue\n\n        # Calculate the increase in total cost if we insert the edge at this position\n        prev_node = new_solution[pos]\n        next_next_node = new_solution[(pos+1) % n]\n\n        # Original cost without the edge\n        original_cost = distance_matrix_1[prev_node, next_next_node] + distance_matrix_2[prev_node, next_next_node]\n\n        # New cost with the edge inserted\n        new_cost = (distance_matrix_1[prev_node, current_node] + distance_matrix_1[current_node, next_next_node] +\n                    distance_matrix_2[prev_node, current_node] + distance_matrix_2[current_node, next_next_node])\n\n        increase = new_cost - original_cost\n\n        if increase < min_increase:\n            min_increase = increase\n            best_insert_pos = pos\n\n    # Perform the insertion if it improves the solution\n    if best_insert_pos != -1 and min_increase < 0:\n        # Remove the original edge\n        new_solution = np.delete(new_solution, (k+1) % n)\n\n        # Insert the edge at the best position\n        new_solution = np.insert(new_solution, (best_insert_pos+1) % n, current_node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 30,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high variance in objectives)\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: Edge insertion + Segment relocation\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply the operator\n\n    # Step 1: Edge insertion (for diversification)\n    i, j = sorted(random.sample(range(n), 2))\n    node = new_solution[j]\n    new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    # Step 2: Segment relocation (novel operator for intensification)\n    segment_length = random.randint(2, min(5, n // 2))\n    k = random.randint(0, n - segment_length - 1)\n    segment = new_solution[k:k+segment_length]\n    remaining = np.concatenate([new_solution[:k], new_solution[k+segment_length:]])\n    pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:pos], segment, remaining[pos:]])\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if feasibility is violated\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8399428183593038,
            0.8436598777770996
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high variance in objectives)\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: Edge insertion + Segment relocation\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply the operator\n\n    # Step 1: Edge insertion (for diversification)\n    i, j = sorted(random.sample(range(n), 2))\n    node = new_solution[j]\n    new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    # Step 2: Segment relocation (novel operator for intensification)\n    segment_length = random.randint(2, min(5, n // 2))\n    k = random.randint(0, n - segment_length - 1)\n    segment = new_solution[k:k+segment_length]\n    remaining = np.concatenate([new_solution[:k], new_solution[k+segment_length:]])\n    pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:pos], segment, remaining[pos:]])\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if feasibility is violated\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 31,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    total_cost = sum(obj[0] + obj[1] for _, obj in archive)\n    probabilities = [(obj[0] + obj[1]) / total_cost for _, obj in archive]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a novel move\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Perform a 3-opt move (select three random edges and reconnect them)\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Create all possible 3-opt neighbors and select the best one\n    neighbors = []\n    # Case 1: Reverse segment between a and b\n    neighbor1 = new_solution.copy()\n    neighbor1[a:b+1] = neighbor1[a:b+1][::-1]\n    # Case 2: Reverse segment between b and c\n    neighbor2 = new_solution.copy()\n    neighbor2[b:c+1] = neighbor2[b:c+1][::-1]\n    # Case 3: Reverse all three segments\n    neighbor3 = new_solution.copy()\n    neighbor3[a:b+1] = neighbor3[a:b+1][::-1]\n    neighbor3[b:c+1] = neighbor3[b:c+1][::-1]\n    # Case 4: Novel move - shift segment between a and b to position c\n    neighbor4 = new_solution.copy()\n    segment = neighbor4[a:b+1]\n    neighbor4 = np.concatenate([neighbor4[:a], neighbor4[b+1:c+1], segment, neighbor4[c+1:]])\n\n    neighbors = [neighbor1, neighbor2, neighbor3, neighbor4]\n\n    # Evaluate all neighbors based on both objectives\n    best_neighbor = None\n    best_score = float('inf')\n\n    for neighbor in neighbors:\n        cost1 = sum(distance_matrix_1[neighbor[i], neighbor[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[neighbor[i], neighbor[(i+1)%n]] for i in range(n))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_score:\n            best_score = total_cost\n            best_neighbor = neighbor.copy()\n\n    # If no improvement, perform a random swap\n    if best_neighbor is None or np.array_equal(best_neighbor, new_solution):\n        i, j = random.sample(range(n), 2)\n        best_neighbor = new_solution.copy()\n        best_neighbor[i], best_neighbor[j] = best_neighbor[j], best_neighbor[i]\n\n    return best_neighbor\n\n",
        "score": [
            -0.7550802951593554,
            1.6962032318115234
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    total_cost = sum(obj[0] + obj[1] for _, obj in archive)\n    probabilities = [(obj[0] + obj[1]) / total_cost for _, obj in archive]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a novel move\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Perform a 3-opt move (select three random edges and reconnect them)\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Create all possible 3-opt neighbors and select the best one\n    neighbors = []\n    # Case 1: Reverse segment between a and b\n    neighbor1 = new_solution.copy()\n    neighbor1[a:b+1] = neighbor1[a:b+1][::-1]\n    # Case 2: Reverse segment between b and c\n    neighbor2 = new_solution.copy()\n    neighbor2[b:c+1] = neighbor2[b:c+1][::-1]\n    # Case 3: Reverse all three segments\n    neighbor3 = new_solution.copy()\n    neighbor3[a:b+1] = neighbor3[a:b+1][::-1]\n    neighbor3[b:c+1] = neighbor3[b:c+1][::-1]\n    # Case 4: Novel move - shift segment between a and b to position c\n    neighbor4 = new_solution.copy()\n    segment = neighbor4[a:b+1]\n    neighbor4 = np.concatenate([neighbor4[:a], neighbor4[b+1:c+1], segment, neighbor4[c+1:]])\n\n    neighbors = [neighbor1, neighbor2, neighbor3, neighbor4]\n\n    # Evaluate all neighbors based on both objectives\n    best_neighbor = None\n    best_score = float('inf')\n\n    for neighbor in neighbors:\n        cost1 = sum(distance_matrix_1[neighbor[i], neighbor[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[neighbor[i], neighbor[(i+1)%n]] for i in range(n))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_score:\n            best_score = total_cost\n            best_neighbor = neighbor.copy()\n\n    # If no improvement, perform a random swap\n    if best_neighbor is None or np.array_equal(best_neighbor, new_solution):\n        i, j = random.sample(range(n), 2)\n        best_neighbor = new_solution.copy()\n        best_neighbor[i], best_neighbor[j] = best_neighbor[j], best_neighbor[i]\n\n    return best_neighbor\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 32,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with probability proportional to its dominance (lower cost is better)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = objectives / objectives.max(axis=0)  # Normalize to avoid bias towards one objective\n    total_costs = normalized_costs.sum(axis=1)\n    probabilities = (1 / total_costs) / (1 / total_costs).sum()  # Inverse proportional selection\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Edge insertion + Segment relocation\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Step 1: Edge insertion (remove a random edge and reinsert it between two random nodes)\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = random.randint(0, n - 1)\n\n    # Remove edge (i, i+1) and insert it between j and j+1\n    removed_segment = new_solution[i:(i + 2) % n]\n    remaining_solution = np.concatenate([new_solution[:i], new_solution[(i + 2) % n:]])\n    new_solution = np.concatenate([remaining_solution[:j], removed_segment, remaining_solution[j:]])\n\n    # Step 2: Segment relocation (move a random segment to a new position)\n    seg_start = random.randint(0, n - 3)\n    seg_end = random.randint(seg_start + 1, min(seg_start + 3, n - 1))  # Small segment for stability\n    segment = new_solution[seg_start:seg_end + 1]\n    remaining_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end + 1:]])\n    insert_pos = random.randint(0, len(remaining_solution) - 1)\n    new_solution = np.concatenate([remaining_solution[:insert_pos], segment, remaining_solution[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8666005953496156,
            0.9950369596481323
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with probability proportional to its dominance (lower cost is better)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = objectives / objectives.max(axis=0)  # Normalize to avoid bias towards one objective\n    total_costs = normalized_costs.sum(axis=1)\n    probabilities = (1 / total_costs) / (1 / total_costs).sum()  # Inverse proportional selection\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Edge insertion + Segment relocation\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Step 1: Edge insertion (remove a random edge and reinsert it between two random nodes)\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = random.randint(0, n - 1)\n\n    # Remove edge (i, i+1) and insert it between j and j+1\n    removed_segment = new_solution[i:(i + 2) % n]\n    remaining_solution = np.concatenate([new_solution[:i], new_solution[(i + 2) % n:]])\n    new_solution = np.concatenate([remaining_solution[:j], removed_segment, remaining_solution[j:]])\n\n    # Step 2: Segment relocation (move a random segment to a new position)\n    seg_start = random.randint(0, n - 3)\n    seg_end = random.randint(seg_start + 1, min(seg_start + 3, n - 1))  # Small segment for stability\n    segment = new_solution[seg_start:seg_end + 1]\n    remaining_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end + 1:]])\n    insert_pos = random.randint(0, len(remaining_solution) - 1)\n    new_solution = np.concatenate([remaining_solution[:insert_pos], segment, remaining_solution[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 33,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for (sol, obj) in archive]\n    min_cost1 = min(obj[0] for obj in objectives)\n    max_cost1 = max(obj[0] for obj in objectives)\n    min_cost2 = min(obj[1] for obj in objectives)\n    max_cost2 = max(obj[1] for obj in objectives)\n\n    # Normalize and combine costs\n    normalized_costs = []\n    for obj in objectives:\n        norm_cost1 = (obj[0] - min_cost1) / (max_cost1 - min_cost1 + 1e-10)\n        norm_cost2 = (obj[1] - min_cost2) / (max_cost2 - min_cost2 + 1e-10)\n        combined_cost = norm_cost1 + norm_cost2\n        normalized_costs.append(combined_cost)\n\n    # Inverse selection probability\n    inv_prob = [1 / (cost + 1e-10) for cost in normalized_costs]\n    total = sum(inv_prob)\n    probs = [p / total for p in inv_prob]\n\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 4 distinct positions (for 3-opt-like operation)\n    i, j, k, l = sorted(random.sample(range(n), 4))\n\n    # Apply a novel edge exchange (inspired by Lin-Kernighan but simplified)\n    # We'll try to reconnect the edges in a way that potentially improves both objectives\n    # This is a simplified version of a more complex operation\n\n    # Store current edges\n    edges = [(new_solution[i-1], new_solution[i]),\n             (new_solution[j-1], new_solution[j]),\n             (new_solution[k-1], new_solution[k]),\n             (new_solution[l-1], new_solution[l])]\n\n    # Try to reconnect the edges in a way that might improve both objectives\n    # This is a placeholder for a more sophisticated operation\n    # In practice, you would implement a more intelligent edge reconnection strategy\n\n    # For demonstration, we'll just perform a simple 3-opt move\n    # Reverse the segment between j and k\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.790820645118402,
            1.6274457573890686
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for (sol, obj) in archive]\n    min_cost1 = min(obj[0] for obj in objectives)\n    max_cost1 = max(obj[0] for obj in objectives)\n    min_cost2 = min(obj[1] for obj in objectives)\n    max_cost2 = max(obj[1] for obj in objectives)\n\n    # Normalize and combine costs\n    normalized_costs = []\n    for obj in objectives:\n        norm_cost1 = (obj[0] - min_cost1) / (max_cost1 - min_cost1 + 1e-10)\n        norm_cost2 = (obj[1] - min_cost2) / (max_cost2 - min_cost2 + 1e-10)\n        combined_cost = norm_cost1 + norm_cost2\n        normalized_costs.append(combined_cost)\n\n    # Inverse selection probability\n    inv_prob = [1 / (cost + 1e-10) for cost in normalized_costs]\n    total = sum(inv_prob)\n    probs = [p / total for p in inv_prob]\n\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 4 distinct positions (for 3-opt-like operation)\n    i, j, k, l = sorted(random.sample(range(n), 4))\n\n    # Apply a novel edge exchange (inspired by Lin-Kernighan but simplified)\n    # We'll try to reconnect the edges in a way that potentially improves both objectives\n    # This is a simplified version of a more complex operation\n\n    # Store current edges\n    edges = [(new_solution[i-1], new_solution[i]),\n             (new_solution[j-1], new_solution[j]),\n             (new_solution[k-1], new_solution[k]),\n             (new_solution[l-1], new_solution[l])]\n\n    # Try to reconnect the edges in a way that might improve both objectives\n    # This is a placeholder for a more sophisticated operation\n    # In practice, you would implement a more intelligent edge reconnection strategy\n\n    # For demonstration, we'll just perform a simple 3-opt move\n    # Reverse the segment between j and k\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 34,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high crowding distance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swap + segment reversal\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Perform segment reversal with a higher probability\n        if random.random() < 0.7:\n            k, l = sorted(random.sample(range(n), 2))\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8613615204345302,
            1.3430821895599365
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high crowding distance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swap + segment reversal\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Perform segment reversal with a higher probability\n        if random.random() < 0.7:\n            k, l = sorted(random.sample(range(n), 2))\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 35,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution = archive[selected_idx][0].copy()\n    current_obj1, current_obj2 = archive[selected_idx][1]\n\n    # Hybrid local search: segment relocation with edge insertion\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to relocate\n    seg_start = random.randint(0, n - 3)\n    seg_length = random.randint(2, min(5, n - seg_start - 1))\n    seg_end = seg_start + seg_length\n\n    segment = new_solution[seg_start:seg_end]\n    remaining = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n\n    # Find the best insertion point for the segment\n    best_pos = 0\n    min_cost = float('inf')\n\n    for i in range(len(remaining)):\n        # Try inserting segment at position i\n        candidate = np.concatenate([remaining[:i], segment, remaining[i:]])\n        cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(len(candidate)))\n        cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(len(candidate)))\n\n        # Combine costs using a weighted sum (simple approach)\n        total_cost = 0.5 * cost1 + 0.5 * cost2\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_pos = i\n\n    # Perform the best insertion\n    new_solution = np.concatenate([remaining[:best_pos], segment, remaining[best_pos:]])\n\n    # Additional edge insertion for further improvement\n    for _ in range(2):  # Limit the number of edge insertions for efficiency\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:  # Ensure we're not just swapping adjacent nodes\n            # Create a new solution by removing edge (i-1, i) and (j, j+1) and adding (i-1, j) and (i, j+1)\n            temp = new_solution.copy()\n            temp[i], temp[j] = temp[j], temp[i]\n            cost1 = sum(distance_matrix_1[temp[k-1], temp[k]] for k in range(len(temp)))\n            cost2 = sum(distance_matrix_2[temp[k-1], temp[k]] for k in range(len(temp)))\n\n            # Accept if both objectives are improved\n            if cost1 < current_obj1 and cost2 < current_obj2:\n                new_solution = temp\n                current_obj1, current_obj2 = cost1, cost2\n\n    return new_solution\n\n",
        "score": [
            -0.7092756154540236,
            6.362031102180481
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution = archive[selected_idx][0].copy()\n    current_obj1, current_obj2 = archive[selected_idx][1]\n\n    # Hybrid local search: segment relocation with edge insertion\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to relocate\n    seg_start = random.randint(0, n - 3)\n    seg_length = random.randint(2, min(5, n - seg_start - 1))\n    seg_end = seg_start + seg_length\n\n    segment = new_solution[seg_start:seg_end]\n    remaining = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n\n    # Find the best insertion point for the segment\n    best_pos = 0\n    min_cost = float('inf')\n\n    for i in range(len(remaining)):\n        # Try inserting segment at position i\n        candidate = np.concatenate([remaining[:i], segment, remaining[i:]])\n        cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(len(candidate)))\n        cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(len(candidate)))\n\n        # Combine costs using a weighted sum (simple approach)\n        total_cost = 0.5 * cost1 + 0.5 * cost2\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_pos = i\n\n    # Perform the best insertion\n    new_solution = np.concatenate([remaining[:best_pos], segment, remaining[best_pos:]])\n\n    # Additional edge insertion for further improvement\n    for _ in range(2):  # Limit the number of edge insertions for efficiency\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:  # Ensure we're not just swapping adjacent nodes\n            # Create a new solution by removing edge (i-1, i) and (j, j+1) and adding (i-1, j) and (i, j+1)\n            temp = new_solution.copy()\n            temp[i], temp[j] = temp[j], temp[i]\n            cost1 = sum(distance_matrix_1[temp[k-1], temp[k]] for k in range(len(temp)))\n            cost2 = sum(distance_matrix_2[temp[k-1], temp[k]] for k in range(len(temp)))\n\n            # Accept if both objectives are improved\n            if cost1 < current_obj1 and cost2 < current_obj2:\n                new_solution = temp\n                current_obj1, current_obj2 = cost1, cost2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 36,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high variance in objectives)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment of nodes to relocate\n    start = np.random.randint(0, n)\n    length = np.random.randint(3, min(8, n - 1))  # Segment length between 3 and 7 nodes\n    end = (start + length) % n\n\n    if start < end:\n        segment = new_solution[start:end]\n        remaining = np.concatenate([new_solution[:start], new_solution[end:]])\n    else:\n        segment = np.concatenate([new_solution[start:], new_solution[:end]])\n        remaining = new_solution[end:start]\n\n    # Step 2: Find the best insertion point for the segment in both objective spaces\n    best_pos = 0\n    best_improvement = 0\n\n    for pos in range(len(remaining)):\n        # Insert segment at position pos\n        candidate = np.insert(remaining, pos, segment)\n\n        # Calculate the cost of the new solution\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(len(candidate)))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(len(candidate)))\n\n        # Calculate improvement (sum of normalized improvements in both objectives)\n        original_cost1 = sum(distance_matrix_1[base_solution[i-1], base_solution[i]] for i in range(n))\n        original_cost2 = sum(distance_matrix_2[base_solution[i-1], base_solution[i]] for i in range(n))\n\n        improvement = (original_cost1 - cost1) / original_cost1 + (original_cost2 - cost2) / original_cost2\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_pos = pos\n\n    # Apply the best insertion\n    if start < end:\n        new_solution = np.insert(remaining, best_pos, segment)\n    else:\n        new_solution = np.concatenate([np.insert(remaining, best_pos, segment), segment])\n\n    # Step 3: Optional: Apply a small 2-opt to fine-tune the solution\n    if np.random.random() < 0.3:  # 30% chance to apply 2-opt\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7826297297249165,
            10.623830437660217
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high variance in objectives)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment of nodes to relocate\n    start = np.random.randint(0, n)\n    length = np.random.randint(3, min(8, n - 1))  # Segment length between 3 and 7 nodes\n    end = (start + length) % n\n\n    if start < end:\n        segment = new_solution[start:end]\n        remaining = np.concatenate([new_solution[:start], new_solution[end:]])\n    else:\n        segment = np.concatenate([new_solution[start:], new_solution[:end]])\n        remaining = new_solution[end:start]\n\n    # Step 2: Find the best insertion point for the segment in both objective spaces\n    best_pos = 0\n    best_improvement = 0\n\n    for pos in range(len(remaining)):\n        # Insert segment at position pos\n        candidate = np.insert(remaining, pos, segment)\n\n        # Calculate the cost of the new solution\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(len(candidate)))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(len(candidate)))\n\n        # Calculate improvement (sum of normalized improvements in both objectives)\n        original_cost1 = sum(distance_matrix_1[base_solution[i-1], base_solution[i]] for i in range(n))\n        original_cost2 = sum(distance_matrix_2[base_solution[i-1], base_solution[i]] for i in range(n))\n\n        improvement = (original_cost1 - cost1) / original_cost1 + (original_cost2 - cost2) / original_cost2\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_pos = pos\n\n    # Apply the best insertion\n    if start < end:\n        new_solution = np.insert(remaining, best_pos, segment)\n    else:\n        new_solution = np.concatenate([np.insert(remaining, best_pos, segment), segment])\n\n    # Step 3: Optional: Apply a small 2-opt to fine-tune the solution\n    if np.random.random() < 0.3:  # 30% chance to apply 2-opt\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 37,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    sorted_archive = sorted(archive, key=lambda x: max(x[1]))\n    selected_idx = min(len(sorted_archive) // 3, len(sorted_archive) - 1)\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge insertion strategy\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # 3-opt move (select 3 random edges and reconnect them)\n    i, j, k = sorted(random.sample(range(1, n), 3))\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Reconnect segments in a new order\n    new_order = [segment1, segment2[::-1], segment3, segment4[::-1]]\n    new_solution = np.concatenate(new_order)\n\n    # Novel edge insertion: insert a random node in a different position\n    if n > 3:\n        insert_pos = random.randint(1, n-1)\n        node_to_insert = random.choice([x for x in range(n) if x not in new_solution[:insert_pos]])\n        new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution and apply a simpler 2-opt\n        new_solution = base_solution.copy()\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8261165134596379,
            0.9396119713783264
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    sorted_archive = sorted(archive, key=lambda x: max(x[1]))\n    selected_idx = min(len(sorted_archive) // 3, len(sorted_archive) - 1)\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge insertion strategy\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # 3-opt move (select 3 random edges and reconnect them)\n    i, j, k = sorted(random.sample(range(1, n), 3))\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Reconnect segments in a new order\n    new_order = [segment1, segment2[::-1], segment3, segment4[::-1]]\n    new_solution = np.concatenate(new_order)\n\n    # Novel edge insertion: insert a random node in a different position\n    if n > 3:\n        insert_pos = random.randint(1, n-1)\n        node_to_insert = random.choice([x for x in range(n) if x not in new_solution[:insert_pos]])\n        new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution and apply a simpler 2-opt\n        new_solution = base_solution.copy()\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 38,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-dominated or high diversity)\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom segment swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform a 3-opt move (select three random edges and reconnect them)\n    a, b, c = sorted(random.sample(range(1, n), 3))\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Reconnect segments in a new order\n    new_order = [segment1, segment2, segment3, segment4]\n    random.shuffle(new_order)\n    new_solution = np.concatenate(new_order)\n\n    # Ensure the solution remains a valid tour (no duplicates, all nodes included)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8136837609542712,
            1.2747774720191956
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-dominated or high diversity)\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom segment swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform a 3-opt move (select three random edges and reconnect them)\n    a, b, c = sorted(random.sample(range(1, n), 3))\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Reconnect segments in a new order\n    new_order = [segment1, segment2, segment3, segment4]\n    random.shuffle(new_order)\n    new_solution = np.concatenate(new_order)\n\n    # Ensure the solution remains a valid tour (no duplicates, all nodes included)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 39,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate dominance counts (simplified for this example)\n        dominance_counts = [0] * len(archive)\n        for i in range(len(archive)):\n            for j in range(len(archive)):\n                if i != j:\n                    if (archive[i][1][0] <= archive[j][1][0] and archive[i][1][1] < archive[j][1][1]) or \\\n                       (archive[i][1][0] < archive[j][1][0] and archive[i][1][1] <= archive[j][1][1]):\n                        dominance_counts[i] += 1\n\n        # Select solution with lowest dominance count (more potential for improvement)\n        min_dominance = min(dominance_counts)\n        candidates = [i for i, count in enumerate(dominance_counts) if count == min_dominance]\n        selected_idx = random.choice(candidates)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of edge insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Select a random segment to reverse\n    start = random.randint(0, n-4)\n    end = random.randint(start+2, min(start+5, n-1))\n\n    # Reverse the selected segment\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Apply edge insertion for further improvement\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    if i != j:\n        # Move node at position i to position j\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7988746864450275,
            5.531206846237183
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate dominance counts (simplified for this example)\n        dominance_counts = [0] * len(archive)\n        for i in range(len(archive)):\n            for j in range(len(archive)):\n                if i != j:\n                    if (archive[i][1][0] <= archive[j][1][0] and archive[i][1][1] < archive[j][1][1]) or \\\n                       (archive[i][1][0] < archive[j][1][0] and archive[i][1][1] <= archive[j][1][1]):\n                        dominance_counts[i] += 1\n\n        # Select solution with lowest dominance count (more potential for improvement)\n        min_dominance = min(dominance_counts)\n        candidates = [i for i, count in enumerate(dominance_counts) if count == min_dominance]\n        selected_idx = random.choice(candidates)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of edge insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Select a random segment to reverse\n    start = random.randint(0, n-4)\n    end = random.randint(start+2, min(start+5, n-1))\n\n    # Reverse the selected segment\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Apply edge insertion for further improvement\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    if i != j:\n        # Move node at position i to position j\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 40,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weights = np.array([0.5, 0.5])  # Equal weights for both objectives\n    objectives = np.array([obj for _, obj in archive])\n    scores = np.dot(objectives, weights)\n    best_idx = np.argmin(scores)\n    base_solution = archive[best_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: 3-opt with biased randomness\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Select three random segments with bias towards promising regions\n    segment_length = max(3, n // 5)\n    i = np.random.randint(0, n - segment_length)\n    j = np.random.randint(i + 1, min(i + segment_length, n - 1))\n    k = np.random.randint(j + 1, min(j + segment_length, n))\n\n    # Apply 3-opt move\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Ensure feasibility (no duplicates)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        # If duplicates exist, repair by inserting missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for idx in range(n):\n            if new_solution[idx] not in new_solution[:idx]:\n                continue\n            # Replace duplicate with missing node\n            if len(missing_nodes) > 0:\n                new_solution[idx] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.8272337341878226,
            1.229716956615448
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weights = np.array([0.5, 0.5])  # Equal weights for both objectives\n    objectives = np.array([obj for _, obj in archive])\n    scores = np.dot(objectives, weights)\n    best_idx = np.argmin(scores)\n    base_solution = archive[best_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: 3-opt with biased randomness\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Select three random segments with bias towards promising regions\n    segment_length = max(3, n // 5)\n    i = np.random.randint(0, n - segment_length)\n    j = np.random.randint(i + 1, min(i + segment_length, n - 1))\n    k = np.random.randint(j + 1, min(j + segment_length, n))\n\n    # Apply 3-opt move\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Ensure feasibility (no duplicates)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        # If duplicates exist, repair by inserting missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for idx in range(n):\n            if new_solution[idx] not in new_solution[:idx]:\n                continue\n            # Replace duplicate with missing node\n            if len(missing_nodes) > 0:\n                new_solution[idx] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 41,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in Pareto front)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(int(0.2 * len(sorted_archive)), len(sorted_archive) - 1)\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    for _ in range(2):  # Perform multiple iterations for better exploration\n        # Segment relocation: move a random segment of the tour\n        segment_length = random.randint(2, max(2, n // 5))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start + segment_length]\n\n        # Remove the segment\n        remaining = np.concatenate([new_solution[:start], new_solution[start + segment_length:]])\n\n        # Insert the segment at a new position\n        insert_pos = random.randint(0, len(remaining) - segment_length)\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n        # Edge insertion: try to improve by moving a single edge\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        if i != j:\n            # Swap nodes to create a new edge\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.75187400893867,
            1.6087085604667664
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in Pareto front)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(int(0.2 * len(sorted_archive)), len(sorted_archive) - 1)\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    for _ in range(2):  # Perform multiple iterations for better exploration\n        # Segment relocation: move a random segment of the tour\n        segment_length = random.randint(2, max(2, n // 5))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start + segment_length]\n\n        # Remove the segment\n        remaining = np.concatenate([new_solution[:start], new_solution[start + segment_length:]])\n\n        # Insert the segment at a new position\n        insert_pos = random.randint(0, len(remaining) - segment_length)\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n        # Edge insertion: try to improve by moving a single edge\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        if i != j:\n            # Swap nodes to create a new edge\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 42,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weights = np.random.uniform(0.3, 0.7)  # Random weights for balancing objectives\n    best_solution = min(archive, key=lambda x: weights * x[1][0] + (1 - weights) * x[1][1])[0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge-swap\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select segments for 3-opt\n    i, j, k = sorted(np.random.choice(range(1, n), 3, replace=False))\n\n    # Apply 3-opt: reverse the middle segment\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Novel edge-swap: swap two edges with potential improvement\n    if n > 4:\n        a, b = np.random.choice(range(1, n-1), 2, replace=False)\n        if a > b:\n            a, b = b, a\n        # Ensure the swap maintains feasibility\n        if a + 1 < b and b + 1 < n:\n            # Swap edges (a,a+1) and (b,b+1) with (a,b) and (a+1,b+1)\n            new_solution[a+1], new_solution[b] = new_solution[b], new_solution[a+1]\n\n    return new_solution\n\n",
        "score": [
            -0.6049700665119484,
            1.6782750487327576
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weights = np.random.uniform(0.3, 0.7)  # Random weights for balancing objectives\n    best_solution = min(archive, key=lambda x: weights * x[1][0] + (1 - weights) * x[1][1])[0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge-swap\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select segments for 3-opt\n    i, j, k = sorted(np.random.choice(range(1, n), 3, replace=False))\n\n    # Apply 3-opt: reverse the middle segment\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Novel edge-swap: swap two edges with potential improvement\n    if n > 4:\n        a, b = np.random.choice(range(1, n-1), 2, replace=False)\n        if a > b:\n            a, b = b, a\n        # Ensure the swap maintains feasibility\n        if a + 1 < b and b + 1 < n:\n            # Swap edges (a,a+1) and (b,b+1) with (a,b) and (a+1,b+1)\n            new_solution[a+1], new_solution[b] = new_solution[b], new_solution[a+1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 43,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on a combination of objectives\n    def selection_criteria(solution_obj):\n        # Normalize objectives to avoid bias towards one objective\n        obj1, obj2 = solution_obj\n        norm_obj1 = obj1 / (distance_matrix_1.sum() / len(instance)) if distance_matrix_1.sum() > 0 else 0\n        norm_obj2 = obj2 / (distance_matrix_2.sum() / len(instance)) if distance_matrix_2.sum() > 0 else 0\n        return norm_obj1 + norm_obj2\n\n    # Sort solutions by the selection criteria and pick the best one\n    archive_sorted = sorted(archive, key=lambda x: selection_criteria(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge-swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct positions to perform 3-opt\n    indices = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted(indices)\n\n    # Apply 3-opt move\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Custom edge-swap: swap edges between two random nodes if it improves both objectives\n    a, b = np.random.choice(n, size=2, replace=False)\n    if a > b:\n        a, b = b, a\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n    potential_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b-1]] + distance_matrix_1[new_solution[a], new_solution[b]]\n\n    current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n    potential_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b-1]] + distance_matrix_2[new_solution[a], new_solution[b]]\n\n    # Accept the swap if it improves both objectives\n    if (potential_cost1 < current_cost1) and (potential_cost2 < current_cost2):\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6875903461076047,
            1.5717365741729736
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on a combination of objectives\n    def selection_criteria(solution_obj):\n        # Normalize objectives to avoid bias towards one objective\n        obj1, obj2 = solution_obj\n        norm_obj1 = obj1 / (distance_matrix_1.sum() / len(instance)) if distance_matrix_1.sum() > 0 else 0\n        norm_obj2 = obj2 / (distance_matrix_2.sum() / len(instance)) if distance_matrix_2.sum() > 0 else 0\n        return norm_obj1 + norm_obj2\n\n    # Sort solutions by the selection criteria and pick the best one\n    archive_sorted = sorted(archive, key=lambda x: selection_criteria(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge-swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct positions to perform 3-opt\n    indices = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted(indices)\n\n    # Apply 3-opt move\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Custom edge-swap: swap edges between two random nodes if it improves both objectives\n    a, b = np.random.choice(n, size=2, replace=False)\n    if a > b:\n        a, b = b, a\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n    potential_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b-1]] + distance_matrix_1[new_solution[a], new_solution[b]]\n\n    current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n    potential_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b-1]] + distance_matrix_2[new_solution[a], new_solution[b]]\n\n    # Accept the swap if it improves both objectives\n    if (potential_cost1 < current_cost1) and (potential_cost2 < current_cost2):\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 44,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest cost but not dominated)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_costs = [cost for _, cost in archive]\n\n    # Identify non-dominated solutions and select one with the lowest cost\n    non_dominated = []\n    for i, cost in enumerate(archive_costs):\n        is_dominated = False\n        for j, other_cost in enumerate(archive_costs):\n            if i != j and (other_cost[0] <= cost[0] and other_cost[1] <= cost[1]) and (other_cost[0] < cost[0] or other_cost[1] < cost[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = np.random.choice(non_dominated)\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: segment relocation and edge insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Segment relocation\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Ensure segments are not overlapping and valid\n    if a > c:\n        a, b, c, d = c, d, a, b\n\n    if b < c:\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[c:d], new_solution[b:c], segment, new_solution[d:]])\n\n    # Step 2: Edge insertion (swap two random edges)\n    e, f = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[e], new_solution[f] = new_solution[f], new_solution[e]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        return base_solution  # Fallback to original if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.9530159155897173,
            0.9580427408218384
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest cost but not dominated)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_costs = [cost for _, cost in archive]\n\n    # Identify non-dominated solutions and select one with the lowest cost\n    non_dominated = []\n    for i, cost in enumerate(archive_costs):\n        is_dominated = False\n        for j, other_cost in enumerate(archive_costs):\n            if i != j and (other_cost[0] <= cost[0] and other_cost[1] <= cost[1]) and (other_cost[0] < cost[0] or other_cost[1] < cost[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = np.random.choice(non_dominated)\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: segment relocation and edge insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Segment relocation\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Ensure segments are not overlapping and valid\n    if a > c:\n        a, b, c, d = c, d, a, b\n\n    if b < c:\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[c:d], new_solution[b:c], segment, new_solution[d:]])\n\n    # Step 2: Edge insertion (swap two random edges)\n    e, f = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[e], new_solution[f] = new_solution[f], new_solution[e]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        return base_solution  # Fallback to original if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 45,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt + segment-based perturbation\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Randomly select three non-consecutive edges to perform 3-opt\n    a, b, c = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n    segment1 = base_solution[:a]\n    segment2 = base_solution[a:b]\n    segment3 = base_solution[b:c]\n    segment4 = base_solution[c:]\n\n    # Reconnect segments in a new order to explore different configurations\n    new_order = [segment1, segment3, segment2, segment4]\n    new_solution = np.concatenate(new_order)\n\n    # Additional perturbation: reverse a random segment to increase diversity\n    if np.random.rand() < 0.5:\n        start, end = sorted(np.random.choice(range(n), size=2, replace=False))\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n    assert np.array_equal(np.sort(new_solution), np.arange(n)), \"Missing or duplicate nodes\"\n\n    return new_solution\n\n",
        "score": [
            -0.8439039702555537,
            1.7470321655273438
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt + segment-based perturbation\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Randomly select three non-consecutive edges to perform 3-opt\n    a, b, c = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n    segment1 = base_solution[:a]\n    segment2 = base_solution[a:b]\n    segment3 = base_solution[b:c]\n    segment4 = base_solution[c:]\n\n    # Reconnect segments in a new order to explore different configurations\n    new_order = [segment1, segment3, segment2, segment4]\n    new_solution = np.concatenate(new_order)\n\n    # Additional perturbation: reverse a random segment to increase diversity\n    if np.random.rand() < 0.5:\n        start, end = sorted(np.random.choice(range(n), size=2, replace=False))\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n    assert np.array_equal(np.sort(new_solution), np.arange(n)), \"Missing or duplicate nodes\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 46,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives to find those with room for improvement\n        archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n        # Select a middle solution (not the best or worst) to encourage diversity\n        base_solution = archive_sorted[min(1, len(archive_sorted) // 2)][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge-swap\n    n = len(new_solution)\n    if n >= 3:\n        # Randomly select three edges to modify\n        i, j, k = np.random.choice(range(n), size=3, replace=False)\n        i, j, k = sorted([i, j, k])\n\n        # Perform a 3-opt move (reversing a segment)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Custom edge-swap: swap nodes at positions j+1 and k if it improves both objectives\n        if j+1 < n and k < n and k != j+1:\n            # Calculate current and potential costs\n            current_cost1 = distance_matrix_1[new_solution[j], new_solution[j+1]] + distance_matrix_1[new_solution[k-1], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[j], new_solution[j+1]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n\n            new_cost1 = distance_matrix_1[new_solution[j], new_solution[k]] + distance_matrix_1[new_solution[k-1], new_solution[j+1]]\n            new_cost2 = distance_matrix_2[new_solution[j], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[j+1]]\n\n            # Apply swap if it improves both objectives\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2):\n                new_solution[j+1], new_solution[k] = new_solution[k], new_solution[j+1]\n\n    return new_solution\n\n",
        "score": [
            -0.8205975204007891,
            1.5854572057724
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives to find those with room for improvement\n        archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n        # Select a middle solution (not the best or worst) to encourage diversity\n        base_solution = archive_sorted[min(1, len(archive_sorted) // 2)][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge-swap\n    n = len(new_solution)\n    if n >= 3:\n        # Randomly select three edges to modify\n        i, j, k = np.random.choice(range(n), size=3, replace=False)\n        i, j, k = sorted([i, j, k])\n\n        # Perform a 3-opt move (reversing a segment)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Custom edge-swap: swap nodes at positions j+1 and k if it improves both objectives\n        if j+1 < n and k < n and k != j+1:\n            # Calculate current and potential costs\n            current_cost1 = distance_matrix_1[new_solution[j], new_solution[j+1]] + distance_matrix_1[new_solution[k-1], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[j], new_solution[j+1]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n\n            new_cost1 = distance_matrix_1[new_solution[j], new_solution[k]] + distance_matrix_1[new_solution[k-1], new_solution[j+1]]\n            new_cost2 = distance_matrix_2[new_solution[j], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[j+1]]\n\n            # Apply swap if it improves both objectives\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2):\n                new_solution[j+1], new_solution[k] = new_solution[k], new_solution[j+1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 47,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = random.choices(range(len(archive)), k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a novel segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small instances\n\n    # Randomly select three distinct indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse segments between i-j, j-k, and k-i\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n    new_solution[k:] = new_solution[k:][::-1]\n\n    # Novel segment reversal: reverse a random segment of length 2-4\n    seg_length = random.randint(2, min(4, n - 1))\n    start = random.randint(0, n - seg_length)\n    new_solution[start:start+seg_length] = new_solution[start:start+seg_length][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8876029120907281,
            1.4549046754837036
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = random.choices(range(len(archive)), k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a novel segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small instances\n\n    # Randomly select three distinct indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse segments between i-j, j-k, and k-i\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n    new_solution[k:] = new_solution[k:][::-1]\n\n    # Novel segment reversal: reverse a random segment of length 2-4\n    seg_length = random.randint(2, min(4, n - 1))\n    start = random.randint(0, n - seg_length)\n    new_solution[start:start+seg_length] = new_solution[start:start+seg_length][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 48,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already in the archive)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-swap strategy\n    n = len(new_solution)\n    if n < 4:\n        # Fallback to simple swap if the tour is too small\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Select 3 random segments to modify\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Reorder the selected segments in a way that improves both objectives\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Novel hybrid reordering strategy\n    # Try different permutations of the segments to find the best improvement\n    candidates = [\n        np.concatenate([segment1, segment3, segment2, segment4]),\n        np.concatenate([segment1, segment2[::-1], segment3, segment4]),\n        np.concatenate([segment1, segment3[::-1], segment2, segment4])\n    ]\n\n    best_candidate = new_solution\n    best_cost = np.inf\n\n    for candidate in candidates:\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n        total_cost = cost1 + cost2  # Simple weighted sum for selection\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_candidate = candidate\n\n    return best_candidate\n\n",
        "score": [
            -0.8710502022891972,
            1.4603262543678284
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already in the archive)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-swap strategy\n    n = len(new_solution)\n    if n < 4:\n        # Fallback to simple swap if the tour is too small\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Select 3 random segments to modify\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Reorder the selected segments in a way that improves both objectives\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Novel hybrid reordering strategy\n    # Try different permutations of the segments to find the best improvement\n    candidates = [\n        np.concatenate([segment1, segment3, segment2, segment4]),\n        np.concatenate([segment1, segment2[::-1], segment3, segment4]),\n        np.concatenate([segment1, segment3[::-1], segment2, segment4])\n    ]\n\n    best_candidate = new_solution\n    best_cost = np.inf\n\n    for candidate in candidates:\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n        total_cost = cost1 + cost2  # Simple weighted sum for selection\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_candidate = candidate\n\n    return best_candidate\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 49,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., one with high variance in objectives)\n    selected_idx = np.argmax([(obj[0] + obj[1]) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Combine 2-opt with a novel segment reversal\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k = np.random.randint(i, j)\n\n    # Segment reversal (novel operator)\n    new_solution[i:k+1] = new_solution[i:k+1][::-1]\n    new_solution[k+1:j+1] = new_solution[k+1:j+1][::-1]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to standard 2-opt if segment reversal causes issues\n        new_solution = base_solution.copy()\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8538273767438573,
            1.4598205089569092
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., one with high variance in objectives)\n    selected_idx = np.argmax([(obj[0] + obj[1]) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Combine 2-opt with a novel segment reversal\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k = np.random.randint(i, j)\n\n    # Segment reversal (novel operator)\n    new_solution[i:k+1] = new_solution[i:k+1][::-1]\n    new_solution[k+1:j+1] = new_solution[k+1:j+1][::-1]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to standard 2-opt if segment reversal causes issues\n        new_solution = base_solution.copy()\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 50,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with lower combined cost\n    costs = np.array([sum(obj) for _, obj in archive])\n    probs = 1 / (costs + 1e-10)  # Avoid division by zero\n    probs /= probs.sum()\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: 3-opt with biased random walk\n    for _ in range(5):  # Perform multiple iterations\n        # Select three random edges to modify (3-opt)\n        a, b, c = sorted(random.sample(range(1, n), 3))\n\n        # Apply 3-opt move\n        new_solution[a:b] = np.flip(new_solution[a:b])\n        new_solution[b:c] = np.flip(new_solution[b:c])\n\n        # With some probability, perform a biased random walk\n        if random.random() < 0.3:\n            # Select a segment to reverse based on the distance matrices\n            segment_length = min(5, n // 2)\n            start = random.randint(0, n - segment_length)\n            end = start + segment_length\n            segment = new_solution[start:end]\n\n            # Evaluate segment reversal in both objective spaces\n            original_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n            original_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n\n            reversed_segment = np.flip(segment)\n            reversed_cost1 = sum(distance_matrix_1[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n            reversed_cost2 = sum(distance_matrix_2[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n\n            # Accept if at least one objective improves\n            if (reversed_cost1 < original_cost1) or (reversed_cost2 < original_cost2):\n                new_solution[start:end] = reversed_segment\n\n    # Ensure the solution is valid (visits each node exactly once)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.8393823881220744,
            1.4274389147758484
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with lower combined cost\n    costs = np.array([sum(obj) for _, obj in archive])\n    probs = 1 / (costs + 1e-10)  # Avoid division by zero\n    probs /= probs.sum()\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: 3-opt with biased random walk\n    for _ in range(5):  # Perform multiple iterations\n        # Select three random edges to modify (3-opt)\n        a, b, c = sorted(random.sample(range(1, n), 3))\n\n        # Apply 3-opt move\n        new_solution[a:b] = np.flip(new_solution[a:b])\n        new_solution[b:c] = np.flip(new_solution[b:c])\n\n        # With some probability, perform a biased random walk\n        if random.random() < 0.3:\n            # Select a segment to reverse based on the distance matrices\n            segment_length = min(5, n // 2)\n            start = random.randint(0, n - segment_length)\n            end = start + segment_length\n            segment = new_solution[start:end]\n\n            # Evaluate segment reversal in both objective spaces\n            original_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n            original_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n\n            reversed_segment = np.flip(segment)\n            reversed_cost1 = sum(distance_matrix_1[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n            reversed_cost2 = sum(distance_matrix_2[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n\n            # Accept if at least one objective improves\n            if (reversed_cost1 < original_cost1) or (reversed_cost2 < original_cost2):\n                new_solution[start:end] = reversed_segment\n\n    # Ensure the solution is valid (visits each node exactly once)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 51,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with the best combined objective (sum of normalized costs)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    combined = normalized.sum(axis=1)\n    selected_idx = np.argmin(combined)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge swapping and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Apply segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Apply edge swapping between segments\n    if i < k <= j < l:\n        # Swap edges between segments\n        temp = new_solution[i]\n        new_solution[i] = new_solution[k]\n        new_solution[k] = temp\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if infeasible\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7227382395398445,
            1.6860681176185608
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with the best combined objective (sum of normalized costs)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    combined = normalized.sum(axis=1)\n    selected_idx = np.argmin(combined)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge swapping and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Apply segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Apply edge swapping between segments\n    if i < k <= j < l:\n        # Swap edges between segments\n        temp = new_solution[i]\n        new_solution[i] = new_solution[k]\n        new_solution[k] = temp\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if infeasible\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 52,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a bias towards those with lower combined cost\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selection_pool = archive_sorted[:max(1, len(archive) // 3)]  # Top 1/3 of solutions\n    selected = random.choice(selection_pool)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with edge-swap\n    n = len(new_solution)\n    for _ in range(3):  # Perform 3 iterations of the hybrid operator\n        # Randomly select 4 distinct edges to modify\n        a, b, c, d = sorted(random.sample(range(1, n), 4))\n\n        # 3-opt move: Reconnect edges in a non-crossing manner\n        new_order = np.concatenate([\n            new_solution[:a],\n            new_solution[b:c],\n            new_solution[a:b],\n            new_solution[c:d],\n            new_solution[d:]\n        ])\n\n        # Edge-swap: Swap two edges if it improves both objectives\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        if (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_1[new_solution[i], new_solution[j+1]]) < (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j], new_solution[j+1]]) and (\n            distance_matrix_2[new_solution[i-1], new_solution[j]] +\n            distance_matrix_2[new_solution[i], new_solution[j+1]]) < (\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j], new_solution[j+1]]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Apply the 3-opt move if it improves at least one objective\n        if (sum(distance_matrix_1[new_order[i-1], new_order[i]] for i in range(n)) <\n            sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))) or (\n            sum(distance_matrix_2[new_order[i-1], new_order[i]] for i in range(n)) <\n            sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))):\n            new_solution = new_order\n\n    return new_solution\n\n",
        "score": [
            -0.8609701620554662,
            2.926252841949463
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a bias towards those with lower combined cost\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selection_pool = archive_sorted[:max(1, len(archive) // 3)]  # Top 1/3 of solutions\n    selected = random.choice(selection_pool)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with edge-swap\n    n = len(new_solution)\n    for _ in range(3):  # Perform 3 iterations of the hybrid operator\n        # Randomly select 4 distinct edges to modify\n        a, b, c, d = sorted(random.sample(range(1, n), 4))\n\n        # 3-opt move: Reconnect edges in a non-crossing manner\n        new_order = np.concatenate([\n            new_solution[:a],\n            new_solution[b:c],\n            new_solution[a:b],\n            new_solution[c:d],\n            new_solution[d:]\n        ])\n\n        # Edge-swap: Swap two edges if it improves both objectives\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        if (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_1[new_solution[i], new_solution[j+1]]) < (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j], new_solution[j+1]]) and (\n            distance_matrix_2[new_solution[i-1], new_solution[j]] +\n            distance_matrix_2[new_solution[i], new_solution[j+1]]) < (\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j], new_solution[j+1]]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Apply the 3-opt move if it improves at least one objective\n        if (sum(distance_matrix_1[new_order[i-1], new_order[i]] for i in range(n)) <\n            sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))) or (\n            sum(distance_matrix_2[new_order[i-1], new_order[i]] for i in range(n)) <\n            sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))):\n            new_solution = new_order\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 53,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_solution = None\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            selected_solution = sol.copy()\n            break\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: segment reversal + edge insertion\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to reverse\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly insert an edge from another part of the tour\n    if n > 3:\n        k = random.randint(0, n-1)\n        if k != i and k != j:\n            # Remove edge (k, k+1) and insert it between i and j\n            edge_node = new_solution[k]\n            new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n            insert_pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, insert_pos, edge_node)\n\n    return new_solution\n\n",
        "score": [
            -0.7937489103665268,
            1.3619799613952637
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_solution = None\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            selected_solution = sol.copy()\n            break\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: segment reversal + edge insertion\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to reverse\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly insert an edge from another part of the tour\n    if n > 3:\n        k = random.randint(0, n-1)\n        if k != i and k != j:\n            # Remove edge (k, k+1) and insert it between i and j\n            edge_node = new_solution[k]\n            new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n            insert_pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, insert_pos, edge_node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 54,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its cost\n    costs = [sum(obj) for _, obj in archive]\n    min_cost = min(costs)\n    max_cost = max(costs)\n\n    # Avoid division by zero if all costs are equal\n    if min_cost == max_cost:\n        probabilities = [1.0 / len(archive) for _ in archive]\n    else:\n        normalized_costs = [(c - min_cost) / (max_cost - min_cost) for c in costs]\n        probabilities = [1.0 - (nc / sum(normalized_costs)) for nc in normalized_costs]\n        probabilities = [p / sum(probabilities) for p in probabilities]\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search\n    n = len(base_solution)\n    if n < 4:\n        # If too small, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Choose between 2-opt, segment inversion, or segment relocation\n        operator = random.choice(['2-opt', 'segment-inversion', 'segment-relocation'])\n\n        if operator == '2-opt':\n            # Standard 2-opt\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        elif operator == 'segment-inversion':\n            # Invert a segment and insert it elsewhere\n            i, j = sorted(random.sample(range(n), 2))\n            segment = new_solution[i:j]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.concatenate([new_solution[:insert_pos], segment[::-1], new_solution[insert_pos:]])\n\n        elif operator == 'segment-relocation':\n            # Relocate a segment to another position\n            i, j = sorted(random.sample(range(n), 2))\n            segment = new_solution[i:j]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure the solution remains a valid tour (no duplicates, all nodes present)\n    if len(set(new_solution)) != n or len(new_solution) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.859998007870719,
            1.4174662232398987
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its cost\n    costs = [sum(obj) for _, obj in archive]\n    min_cost = min(costs)\n    max_cost = max(costs)\n\n    # Avoid division by zero if all costs are equal\n    if min_cost == max_cost:\n        probabilities = [1.0 / len(archive) for _ in archive]\n    else:\n        normalized_costs = [(c - min_cost) / (max_cost - min_cost) for c in costs]\n        probabilities = [1.0 - (nc / sum(normalized_costs)) for nc in normalized_costs]\n        probabilities = [p / sum(probabilities) for p in probabilities]\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search\n    n = len(base_solution)\n    if n < 4:\n        # If too small, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Choose between 2-opt, segment inversion, or segment relocation\n        operator = random.choice(['2-opt', 'segment-inversion', 'segment-relocation'])\n\n        if operator == '2-opt':\n            # Standard 2-opt\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        elif operator == 'segment-inversion':\n            # Invert a segment and insert it elsewhere\n            i, j = sorted(random.sample(range(n), 2))\n            segment = new_solution[i:j]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.concatenate([new_solution[:insert_pos], segment[::-1], new_solution[insert_pos:]])\n\n        elif operator == 'segment-relocation':\n            # Relocate a segment to another position\n            i, j = sorted(random.sample(range(n), 2))\n            segment = new_solution[i:j]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure the solution remains a valid tour (no duplicates, all nodes present)\n    if len(set(new_solution)) != n or len(new_solution) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 55,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, _ in archive:\n        dominated = False\n        for _, obj in archive:\n            if obj[0] < sol[0] and obj[1] < sol[1]:\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if not non_dominated:\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        base_solution = random.choice(non_dominated).copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: 3-opt with edge-swap\n    if n >= 4:\n        # 3-opt: Select three non-consecutive edges and reconnect them\n        i, j, k = sorted(random.sample(range(1, n-1), 3))\n        segment1 = new_solution[:i]\n        segment2 = new_solution[i:j]\n        segment3 = new_solution[j:k]\n        segment4 = new_solution[k:]\n\n        # Reconnect segments in a different order\n        new_order = [segment1, segment3, segment2, segment4]\n        new_solution = np.concatenate(new_order)\n\n        # Edge-swap: Swap two edges if it improves both objectives\n        for _ in range(3):  # Limit the number of swaps to avoid excessive computation\n            a, b = sorted(random.sample(range(1, n-1), 2))\n            if a + 1 != b and b + 1 != a:\n                # Swap edges (a,a+1) and (b,b+1) with (a,b) and (a+1,b+1)\n                new_solution[a], new_solution[a+1], new_solution[b], new_solution[b+1] = (\n                    new_solution[a], new_solution[b], new_solution[a+1], new_solution[b+1]\n                )\n\n                # Check if the swap improves both objectives\n                old_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[a], new_solution[a+1]] + \\\n                            distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[b+1]]\n                new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[a+1]] + \\\n                            distance_matrix_1[new_solution[b-1], new_solution[a]] + distance_matrix_1[new_solution[a], new_solution[b+1]]\n\n                old_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a], new_solution[a+1]] + \\\n                            distance_matrix_2[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[b+1]]\n                new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[a+1]] + \\\n                            distance_matrix_2[new_solution[b-1], new_solution[a]] + distance_matrix_2[new_solution[a], new_solution[b+1]]\n\n                if not (new_cost1 < old_cost1 and new_cost2 < old_cost2):\n                    # Revert if no improvement\n                    new_solution[a], new_solution[a+1], new_solution[b], new_solution[b+1] = (\n                        new_solution[a], new_solution[b], new_solution[a+1], new_solution[b+1]\n                    )\n\n    return new_solution\n\n",
        "score": [
            -0.8335592711341713,
            1.3063510060310364
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, _ in archive:\n        dominated = False\n        for _, obj in archive:\n            if obj[0] < sol[0] and obj[1] < sol[1]:\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if not non_dominated:\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        base_solution = random.choice(non_dominated).copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: 3-opt with edge-swap\n    if n >= 4:\n        # 3-opt: Select three non-consecutive edges and reconnect them\n        i, j, k = sorted(random.sample(range(1, n-1), 3))\n        segment1 = new_solution[:i]\n        segment2 = new_solution[i:j]\n        segment3 = new_solution[j:k]\n        segment4 = new_solution[k:]\n\n        # Reconnect segments in a different order\n        new_order = [segment1, segment3, segment2, segment4]\n        new_solution = np.concatenate(new_order)\n\n        # Edge-swap: Swap two edges if it improves both objectives\n        for _ in range(3):  # Limit the number of swaps to avoid excessive computation\n            a, b = sorted(random.sample(range(1, n-1), 2))\n            if a + 1 != b and b + 1 != a:\n                # Swap edges (a,a+1) and (b,b+1) with (a,b) and (a+1,b+1)\n                new_solution[a], new_solution[a+1], new_solution[b], new_solution[b+1] = (\n                    new_solution[a], new_solution[b], new_solution[a+1], new_solution[b+1]\n                )\n\n                # Check if the swap improves both objectives\n                old_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[a], new_solution[a+1]] + \\\n                            distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[b+1]]\n                new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[a+1]] + \\\n                            distance_matrix_1[new_solution[b-1], new_solution[a]] + distance_matrix_1[new_solution[a], new_solution[b+1]]\n\n                old_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a], new_solution[a+1]] + \\\n                            distance_matrix_2[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[b+1]]\n                new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[a+1]] + \\\n                            distance_matrix_2[new_solution[b-1], new_solution[a]] + distance_matrix_2[new_solution[a], new_solution[b+1]]\n\n                if not (new_cost1 < old_cost1 and new_cost2 < old_cost2):\n                    # Revert if no improvement\n                    new_solution[a], new_solution[a+1], new_solution[b], new_solution[b+1] = (\n                        new_solution[a], new_solution[b], new_solution[a+1], new_solution[b+1]\n                    )\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 56,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: choose solution with lowest total cost in either objective\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        # For small instances, perform a simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # For larger instances, perform a more complex operation\n        # Step 1: Select a random segment to reorder\n        start = np.random.randint(0, n-3)\n        end = np.random.randint(start+2, n-1)\n        segment = new_solution[start:end]\n\n        # Step 2: Apply a combination of operations\n        if np.random.rand() < 0.5:\n            # Option 1: Reverse the segment\n            segment = segment[::-1]\n        else:\n            # Option 2: Rotate the segment\n            shift = np.random.randint(1, len(segment))\n            segment = np.roll(segment, shift)\n\n        # Step 3: Insert the modified segment back\n        new_solution[start:end] = segment\n\n        # Step 4: Optional: Perform a 2-opt like swap with a random pair\n        if np.random.rand() < 0.3:\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    assert len(np.unique(new_solution)) == len(base_solution), \"Invalid tour: duplicate nodes\"\n    assert len(new_solution) == len(base_solution), \"Invalid tour: length mismatch\"\n\n    return new_solution\n\n",
        "score": [
            -0.761990434247094,
            1.5905306935310364
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: choose solution with lowest total cost in either objective\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        # For small instances, perform a simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # For larger instances, perform a more complex operation\n        # Step 1: Select a random segment to reorder\n        start = np.random.randint(0, n-3)\n        end = np.random.randint(start+2, n-1)\n        segment = new_solution[start:end]\n\n        # Step 2: Apply a combination of operations\n        if np.random.rand() < 0.5:\n            # Option 1: Reverse the segment\n            segment = segment[::-1]\n        else:\n            # Option 2: Rotate the segment\n            shift = np.random.randint(1, len(segment))\n            segment = np.roll(segment, shift)\n\n        # Step 3: Insert the modified segment back\n        new_solution[start:end] = segment\n\n        # Step 4: Optional: Perform a 2-opt like swap with a random pair\n        if np.random.rand() < 0.3:\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    assert len(np.unique(new_solution)) == len(base_solution), \"Invalid tour: duplicate nodes\"\n    assert len(new_solution) == len(base_solution), \"Invalid tour: length mismatch\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 57,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its dominance count\n    # (simulating a preference for non-dominated or less explored solutions)\n    dominance_counts = np.zeros(len(archive))\n    for i, (sol_i, _) in enumerate(archive):\n        for j, (sol_j, _) in enumerate(archive):\n            if i != j:\n                cost_i1, cost_i2 = archive[i][1]\n                cost_j1, cost_j2 = archive[j][1]\n                if (cost_i1 <= cost_j1 and cost_i2 < cost_j2) or (cost_i1 < cost_j1 and cost_i2 <= cost_j2):\n                    dominance_counts[i] += 1\n\n    # Normalize dominance counts to get selection probabilities\n    if np.sum(dominance_counts) == 0:\n        selection_probs = np.ones(len(archive)) / len(archive)\n    else:\n        selection_probs = 1 / (1 + dominance_counts)\n        selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combination of edge insertion and 3-opt\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge insertion: randomly select a segment and insert it elsewhere\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    # 3-opt: select three edges and try to improve the tour\n    if n >= 4:\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Try different configurations of the three edges\n        candidates = [\n            np.concatenate([new_solution[:i+1], new_solution[j:k+1][::-1], new_solution[i+1:j], new_solution[k+1:]]),\n            np.concatenate([new_solution[:j+1], new_solution[i:k+1][::-1], new_solution[j+1:i], new_solution[k+1:]]),\n            np.concatenate([new_solution[:i+1], new_solution[j:k+1], new_solution[i+1:j], new_solution[k+1:]]),\n            np.concatenate([new_solution[:j+1], new_solution[i:k+1], new_solution[j+1:i], new_solution[k+1:]])\n        ]\n\n        # Evaluate all candidates based on both objectives\n        current_cost1, current_cost2 = archive[selected_idx][1]\n        best_candidate = new_solution\n        best_cost1, best_cost2 = current_cost1, current_cost2\n\n        for candidate in candidates:\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n            # Pareto dominance check\n            if (cost1 <= best_cost1 and cost2 < best_cost2) or (cost1 < best_cost1 and cost2 <= best_cost2):\n                best_candidate = candidate\n                best_cost1, best_cost2 = cost1, cost2\n\n        new_solution = best_candidate\n\n    return new_solution\n\n",
        "score": [
            -0.725429878312252,
            2.391373097896576
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its dominance count\n    # (simulating a preference for non-dominated or less explored solutions)\n    dominance_counts = np.zeros(len(archive))\n    for i, (sol_i, _) in enumerate(archive):\n        for j, (sol_j, _) in enumerate(archive):\n            if i != j:\n                cost_i1, cost_i2 = archive[i][1]\n                cost_j1, cost_j2 = archive[j][1]\n                if (cost_i1 <= cost_j1 and cost_i2 < cost_j2) or (cost_i1 < cost_j1 and cost_i2 <= cost_j2):\n                    dominance_counts[i] += 1\n\n    # Normalize dominance counts to get selection probabilities\n    if np.sum(dominance_counts) == 0:\n        selection_probs = np.ones(len(archive)) / len(archive)\n    else:\n        selection_probs = 1 / (1 + dominance_counts)\n        selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combination of edge insertion and 3-opt\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge insertion: randomly select a segment and insert it elsewhere\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    # 3-opt: select three edges and try to improve the tour\n    if n >= 4:\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Try different configurations of the three edges\n        candidates = [\n            np.concatenate([new_solution[:i+1], new_solution[j:k+1][::-1], new_solution[i+1:j], new_solution[k+1:]]),\n            np.concatenate([new_solution[:j+1], new_solution[i:k+1][::-1], new_solution[j+1:i], new_solution[k+1:]]),\n            np.concatenate([new_solution[:i+1], new_solution[j:k+1], new_solution[i+1:j], new_solution[k+1:]]),\n            np.concatenate([new_solution[:j+1], new_solution[i:k+1], new_solution[j+1:i], new_solution[k+1:]])\n        ]\n\n        # Evaluate all candidates based on both objectives\n        current_cost1, current_cost2 = archive[selected_idx][1]\n        best_candidate = new_solution\n        best_cost1, best_cost2 = current_cost1, current_cost2\n\n        for candidate in candidates:\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n            # Pareto dominance check\n            if (cost1 <= best_cost1 and cost2 < best_cost2) or (cost1 < best_cost1 and cost2 <= best_cost2):\n                best_candidate = candidate\n                best_cost1, best_cost2 = cost1, cost2\n\n        new_solution = best_candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 58,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values\n    # Here, we prioritize solutions with lower combined objective values\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(int(len(archive_sorted) * 0.2), len(archive_sorted) - 1)  # Select from top 20% of solutions\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of edge insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:  # Too small to perform meaningful operations\n        return new_solution\n\n    # Step 1: Edge insertion (move a random edge to a new position)\n    i, j = sorted(random.sample(range(n), 2))\n    if j - i > 1:  # Ensure there's a segment to insert\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    # Step 2: Segment reversal (reverse a random segment)\n    if n > 3:\n        k, l = sorted(random.sample(range(n), 2))\n        if l - k > 1:  # Ensure there's a segment to reverse\n            new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure the solution remains a valid tour\n    # Verify all nodes are present exactly once\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8759445682556046,
            1.4234177470207214
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values\n    # Here, we prioritize solutions with lower combined objective values\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(int(len(archive_sorted) * 0.2), len(archive_sorted) - 1)  # Select from top 20% of solutions\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of edge insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:  # Too small to perform meaningful operations\n        return new_solution\n\n    # Step 1: Edge insertion (move a random edge to a new position)\n    i, j = sorted(random.sample(range(n), 2))\n    if j - i > 1:  # Ensure there's a segment to insert\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    # Step 2: Segment reversal (reverse a random segment)\n    if n > 3:\n        k, l = sorted(random.sample(range(n), 2))\n        if l - k > 1:  # Ensure there's a segment to reverse\n            new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure the solution remains a valid tour\n    # Verify all nodes are present exactly once\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 59,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with a weighted random choice based on objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = objectives / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    weights = 1 / (1 + normalized_costs.sum(axis=1))\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: edge insertion + segment inversion\n    if n > 4:\n        # Edge insertion: randomly select two edges and reconnect them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Insert segment between i and j\n            segment = new_solution[i+1:j]\n            new_solution = np.concatenate([new_solution[:i+1], segment[::-1], new_solution[j:]])\n\n        # Segment inversion: flip a random segment\n        if n > 3:\n            a, b = sorted(random.sample(range(n), 2))\n            if b - a > 1:\n                new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if the solution becomes invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8865255196654163,
            1.3126107454299927
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with a weighted random choice based on objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = objectives / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    weights = 1 / (1 + normalized_costs.sum(axis=1))\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: edge insertion + segment inversion\n    if n > 4:\n        # Edge insertion: randomly select two edges and reconnect them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Insert segment between i and j\n            segment = new_solution[i+1:j]\n            new_solution = np.concatenate([new_solution[:i+1], segment[::-1], new_solution[j:]])\n\n        # Segment inversion: flip a random segment\n        if n > 3:\n            a, b = sorted(random.sample(range(n), 2))\n            if b - a > 1:\n                new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if the solution becomes invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 60,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    archive_sorted = sorted(archive, key=lambda x: min(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: 3-opt with edge insertion\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = sorted(random.sample(range(1, n-1), 3))\n\n    # 3-opt move: reverse segments between selected edges\n    temp_solution = new_solution.copy()\n    temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n    temp_solution[j:k+1] = temp_solution[j:k+1][::-1]\n\n    # Check if the move improves both objectives\n    original_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n    original_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n    temp_cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n))\n    temp_cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n))\n\n    if (temp_cost1 < original_cost1) or (temp_cost2 < original_cost2):\n        new_solution = temp_solution\n\n    # Edge insertion: try to insert a random node in a different position\n    node_to_move = random.choice(new_solution[1:-1])\n    current_pos = np.where(new_solution == node_to_move)[0][0]\n    new_pos = random.randint(1, n-1)\n\n    if current_pos != new_pos:\n        temp_solution = new_solution.copy()\n        temp_solution = np.delete(temp_solution, current_pos)\n        temp_solution = np.insert(temp_solution, new_pos, node_to_move)\n\n        # Check if the move improves both objectives\n        temp_cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n))\n        temp_cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n))\n\n        if (temp_cost1 < original_cost1) or (temp_cost2 < original_cost2):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.4270614893130533,
            1.9915268421173096
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    archive_sorted = sorted(archive, key=lambda x: min(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: 3-opt with edge insertion\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three edges to modify\n    i, j, k = sorted(random.sample(range(1, n-1), 3))\n\n    # 3-opt move: reverse segments between selected edges\n    temp_solution = new_solution.copy()\n    temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n    temp_solution[j:k+1] = temp_solution[j:k+1][::-1]\n\n    # Check if the move improves both objectives\n    original_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n    original_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n    temp_cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n))\n    temp_cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n))\n\n    if (temp_cost1 < original_cost1) or (temp_cost2 < original_cost2):\n        new_solution = temp_solution\n\n    # Edge insertion: try to insert a random node in a different position\n    node_to_move = random.choice(new_solution[1:-1])\n    current_pos = np.where(new_solution == node_to_move)[0][0]\n    new_pos = random.randint(1, n-1)\n\n    if current_pos != new_pos:\n        temp_solution = new_solution.copy()\n        temp_solution = np.delete(temp_solution, current_pos)\n        temp_solution = np.insert(temp_solution, new_pos, node_to_move)\n\n        # Check if the move improves both objectives\n        temp_cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n))\n        temp_cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n))\n\n        if (temp_cost1 < original_cost1) or (temp_cost2 < original_cost2):\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 61,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a high probability for better solutions\n    solution_weights = [1.0 / (1 + np.sum(obj)) for _, obj in archive]\n    total_weight = sum(solution_weights)\n    solution_weights = [w / total_weight for w in solution_weights]\n    selected_idx = np.random.choice(len(archive), p=solution_weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge exchange + segment relocation\n    if n > 3:\n        # Edge exchange: swap two adjacent edges\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, min(i + 2, n - 1))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment relocation: move a random segment to a different position\n        seg_start = random.randint(0, n - 2)\n        seg_end = random.randint(seg_start + 1, min(seg_start + 2, n - 1))\n        segment = new_solution[seg_start:seg_end]\n        remaining = np.delete(new_solution, np.s_[seg_start:seg_end])\n        insert_pos = random.randint(0, len(remaining) - 1)\n        new_solution = np.insert(remaining, insert_pos, segment)\n\n    return new_solution\n\n",
        "score": [
            -0.9244644015960483,
            1.9475890398025513
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a high probability for better solutions\n    solution_weights = [1.0 / (1 + np.sum(obj)) for _, obj in archive]\n    total_weight = sum(solution_weights)\n    solution_weights = [w / total_weight for w in solution_weights]\n    selected_idx = np.random.choice(len(archive), p=solution_weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge exchange + segment relocation\n    if n > 3:\n        # Edge exchange: swap two adjacent edges\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, min(i + 2, n - 1))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment relocation: move a random segment to a different position\n        seg_start = random.randint(0, n - 2)\n        seg_end = random.randint(seg_start + 1, min(seg_start + 2, n - 1))\n        segment = new_solution[seg_start:seg_end]\n        remaining = np.delete(new_solution, np.s_[seg_start:seg_end])\n        insert_pos = random.randint(0, len(remaining) - 1)\n        new_solution = np.insert(remaining, insert_pos, segment)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 62,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal)\n    # Here, we select a solution with the highest sum of objectives (non-dominated)\n    _, objectives = zip(*archive)\n    objectives = np.array(objectives)\n    sums = objectives.sum(axis=1)\n    selected_idx = np.argmax(sums)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Novel local search operator: \"Bi-directional Segment Reversal\"\n    # Select two random segments in the tour and reverse each segment independently\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Generate two random segments\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Reverse segments [a, b] and [c, d]\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.892044696819097,
            1.2738493084907532
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal)\n    # Here, we select a solution with the highest sum of objectives (non-dominated)\n    _, objectives = zip(*archive)\n    objectives = np.array(objectives)\n    sums = objectives.sum(axis=1)\n    selected_idx = np.argmax(sums)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Novel local search operator: \"Bi-directional Segment Reversal\"\n    # Select two random segments in the tour and reverse each segment independently\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Generate two random segments\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Reverse segments [a, b] and [c, d]\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 63,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential for improvement (lower is better)\n    improvement_potential = np.array([obj[0] + obj[1] for obj in objectives])\n    min_potential = np.min(improvement_potential)\n    max_potential = np.max(improvement_potential)\n\n    # Normalize and invert to make better solutions more likely\n    if min_potential == max_potential:\n        probabilities = np.ones(len(archive)) / len(archive)\n    else:\n        normalized = (max_potential - improvement_potential) / (max_potential - min_potential)\n        probabilities = normalized / np.sum(normalized)\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful changes\n\n    # Step 1: 3-opt move (select 3 random segments and try to improve)\n    a, b, c = sorted(random.sample(range(1, n-1), 3))\n    segment1 = base_solution[:a]\n    segment2 = base_solution[a:b]\n    segment3 = base_solution[b:c]\n    segment4 = base_solution[c:]\n\n    # Try all possible combinations of these segments\n    candidates = [\n        np.concatenate([segment1, segment2, segment3, segment4]),\n        np.concatenate([segment1, segment2[::-1], segment3, segment4]),\n        np.concatenate([segment1, segment3, segment2, segment4]),\n        np.concatenate([segment1, segment3[::-1], segment2, segment4]),\n        np.concatenate([segment1, segment2, segment3[::-1], segment4]),\n        np.concatenate([segment1, segment3, segment2[::-1], segment4]),\n        np.concatenate([segment1, segment2[::-1], segment3[::-1], segment4]),\n    ]\n\n    # Evaluate all candidates\n    def evaluate(sol):\n        cost1 = sum(distance_matrix_1[sol[i-1], sol[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[sol[i-1], sol[i]] for i in range(n))\n        return (cost1, cost2)\n\n    current_cost = evaluate(base_solution)\n    best_solution = base_solution\n    best_cost = current_cost\n\n    for candidate in candidates:\n        candidate_cost = evaluate(candidate)\n        if (candidate_cost[0] + candidate_cost[1]) < (best_cost[0] + best_cost[1]):\n            best_solution = candidate\n            best_cost = candidate_cost\n\n    new_solution = best_solution.copy()\n\n    # Step 2: Objective-aware segment inversion\n    # Identify segments that are non-dominated in both objectives\n    # This is a simplified version - in practice you'd need a more sophisticated dominance check\n    for i in range(n):\n        for j in range(i+2, n):\n            segment = new_solution[i:j]\n            inverted = segment[::-1]\n\n            # Create candidate solution\n            candidate = new_solution.copy()\n            candidate[i:j] = inverted\n\n            # Evaluate candidate\n            candidate_cost = evaluate(candidate)\n\n            # Accept if at least one objective improves\n            if (candidate_cost[0] < current_cost[0] or candidate_cost[1] < current_cost[1]):\n                new_solution = candidate\n                current_cost = candidate_cost\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.7356779925993826,
            12.981050670146942
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential for improvement (lower is better)\n    improvement_potential = np.array([obj[0] + obj[1] for obj in objectives])\n    min_potential = np.min(improvement_potential)\n    max_potential = np.max(improvement_potential)\n\n    # Normalize and invert to make better solutions more likely\n    if min_potential == max_potential:\n        probabilities = np.ones(len(archive)) / len(archive)\n    else:\n        normalized = (max_potential - improvement_potential) / (max_potential - min_potential)\n        probabilities = normalized / np.sum(normalized)\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful changes\n\n    # Step 1: 3-opt move (select 3 random segments and try to improve)\n    a, b, c = sorted(random.sample(range(1, n-1), 3))\n    segment1 = base_solution[:a]\n    segment2 = base_solution[a:b]\n    segment3 = base_solution[b:c]\n    segment4 = base_solution[c:]\n\n    # Try all possible combinations of these segments\n    candidates = [\n        np.concatenate([segment1, segment2, segment3, segment4]),\n        np.concatenate([segment1, segment2[::-1], segment3, segment4]),\n        np.concatenate([segment1, segment3, segment2, segment4]),\n        np.concatenate([segment1, segment3[::-1], segment2, segment4]),\n        np.concatenate([segment1, segment2, segment3[::-1], segment4]),\n        np.concatenate([segment1, segment3, segment2[::-1], segment4]),\n        np.concatenate([segment1, segment2[::-1], segment3[::-1], segment4]),\n    ]\n\n    # Evaluate all candidates\n    def evaluate(sol):\n        cost1 = sum(distance_matrix_1[sol[i-1], sol[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[sol[i-1], sol[i]] for i in range(n))\n        return (cost1, cost2)\n\n    current_cost = evaluate(base_solution)\n    best_solution = base_solution\n    best_cost = current_cost\n\n    for candidate in candidates:\n        candidate_cost = evaluate(candidate)\n        if (candidate_cost[0] + candidate_cost[1]) < (best_cost[0] + best_cost[1]):\n            best_solution = candidate\n            best_cost = candidate_cost\n\n    new_solution = best_solution.copy()\n\n    # Step 2: Objective-aware segment inversion\n    # Identify segments that are non-dominated in both objectives\n    # This is a simplified version - in practice you'd need a more sophisticated dominance check\n    for i in range(n):\n        for j in range(i+2, n):\n            segment = new_solution[i:j]\n            inverted = segment[::-1]\n\n            # Create candidate solution\n            candidate = new_solution.copy()\n            candidate[i:j] = inverted\n\n            # Evaluate candidate\n            candidate_cost = evaluate(candidate)\n\n            # Accept if at least one objective improves\n            if (candidate_cost[0] < current_cost[0] or candidate_cost[1] < current_cost[1]):\n                new_solution = candidate\n                current_cost = candidate_cost\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 64,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a bias towards those with lower objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = 1 / (1 + normalized_objectives.sum(axis=1))\n    probabilities = scores / scores.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Novel local search: Edge insertion with biased random walk\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select a segment to remove\n        segment_start = np.random.randint(0, n - 2)\n        segment_length = np.random.randint(2, min(4, n - segment_start))\n        segment = new_solution[segment_start:segment_start + segment_length]\n\n        # Remove the segment\n        new_solution = np.concatenate([\n            new_solution[:segment_start],\n            new_solution[segment_start + segment_length:]\n        ])\n\n        # Find insertion point with bias towards nodes that reduce total distance\n        insertion_candidates = []\n        for i in range(len(new_solution)):\n            # Try inserting after position i\n            candidate = np.insert(new_solution, i, segment)\n            cost1 = sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(len(candidate)-1))\n            cost2 = sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(len(candidate)-1))\n            insertion_candidates.append((i, candidate, cost1 + cost2))\n\n        # Select insertion point with probability inversely proportional to cost\n        insertion_costs = np.array([cost for _, _, cost in insertion_candidates])\n        insertion_probs = 1 / (insertion_costs + 1e-10)\n        insertion_probs /= insertion_probs.sum()\n        selected_insert = np.random.choice(len(insertion_candidates), p=insertion_probs)\n        _, new_solution, _ = insertion_candidates[selected_insert]\n\n    return new_solution\n\n",
        "score": [
            -0.9115896101338313,
            8.269198775291443
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a bias towards those with lower objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = 1 / (1 + normalized_objectives.sum(axis=1))\n    probabilities = scores / scores.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Novel local search: Edge insertion with biased random walk\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select a segment to remove\n        segment_start = np.random.randint(0, n - 2)\n        segment_length = np.random.randint(2, min(4, n - segment_start))\n        segment = new_solution[segment_start:segment_start + segment_length]\n\n        # Remove the segment\n        new_solution = np.concatenate([\n            new_solution[:segment_start],\n            new_solution[segment_start + segment_length:]\n        ])\n\n        # Find insertion point with bias towards nodes that reduce total distance\n        insertion_candidates = []\n        for i in range(len(new_solution)):\n            # Try inserting after position i\n            candidate = np.insert(new_solution, i, segment)\n            cost1 = sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(len(candidate)-1))\n            cost2 = sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(len(candidate)-1))\n            insertion_candidates.append((i, candidate, cost1 + cost2))\n\n        # Select insertion point with probability inversely proportional to cost\n        insertion_costs = np.array([cost for _, _, cost in insertion_candidates])\n        insertion_probs = 1 / (insertion_costs + 1e-10)\n        insertion_probs /= insertion_probs.sum()\n        selected_insert = np.random.choice(len(insertion_candidates), p=insertion_probs)\n        _, new_solution, _ = insertion_candidates[selected_insert]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 65,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with lower costs in both objectives\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine edge exchange with segment inversion\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Edge exchange (similar to 2-opt but more flexible)\n    i, j = sorted(random.sample(range(1, n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]  # Reverse a segment\n\n    # Segment inversion with objective-aware selection\n    if random.random() < 0.5:  # 50% chance to apply segment inversion\n        a, b = sorted(random.sample(range(1, n), 2))\n        segment = new_solution[a:b]\n\n        # Evaluate segment inversion in both objectives\n        original_cost1 = distance_matrix_1[new_solution[a-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[b]]\n        inverted_cost1 = distance_matrix_1[new_solution[a-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[b]]\n\n        original_cost2 = distance_matrix_2[new_solution[a-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[b]]\n        inverted_cost2 = distance_matrix_2[new_solution[a-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[b]]\n\n        # Apply if it improves at least one objective\n        if (inverted_cost1 < original_cost1) or (inverted_cost2 < original_cost2):\n            new_solution[a:b] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8109224848739752,
            1.396273672580719
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with lower costs in both objectives\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine edge exchange with segment inversion\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Edge exchange (similar to 2-opt but more flexible)\n    i, j = sorted(random.sample(range(1, n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]  # Reverse a segment\n\n    # Segment inversion with objective-aware selection\n    if random.random() < 0.5:  # 50% chance to apply segment inversion\n        a, b = sorted(random.sample(range(1, n), 2))\n        segment = new_solution[a:b]\n\n        # Evaluate segment inversion in both objectives\n        original_cost1 = distance_matrix_1[new_solution[a-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[b]]\n        inverted_cost1 = distance_matrix_1[new_solution[a-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[b]]\n\n        original_cost2 = distance_matrix_2[new_solution[a-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[b]]\n        inverted_cost2 = distance_matrix_2[new_solution[a-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[b]]\n\n        # Apply if it improves at least one objective\n        if (inverted_cost1 < original_cost1) or (inverted_cost2 < original_cost2):\n            new_solution[a:b] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 66,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its rank (better solutions more likely)\n    ranks = np.argsort(np.argsort([obj[0] + obj[1] for _, obj in archive]))\n    selected_idx = np.random.choice(len(archive), p=np.exp(-ranks) / np.sum(np.exp(-ranks)))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of edge exchange and segment reordering\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # No improvement possible\n\n    # Step 1: Random edge exchange (similar to 2-opt but with a twist)\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Segment reordering (move a random segment to a different position)\n    if n > 3:\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(4, n-seg_start-1))\n        seg = new_solution[seg_start:seg_start+seg_length]\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_start+seg_length:],\n            seg\n        ])\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7662146873189952,
            1.7010921835899353
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its rank (better solutions more likely)\n    ranks = np.argsort(np.argsort([obj[0] + obj[1] for _, obj in archive]))\n    selected_idx = np.random.choice(len(archive), p=np.exp(-ranks) / np.sum(np.exp(-ranks)))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of edge exchange and segment reordering\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # No improvement possible\n\n    # Step 1: Random edge exchange (similar to 2-opt but with a twist)\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Segment reordering (move a random segment to a different position)\n    if n > 3:\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(4, n-seg_start-1))\n        seg = new_solution[seg_start:seg_start+seg_length]\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_start+seg_length:],\n            seg\n        ])\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 67,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with higher potential for improvement\n    # Here, we use a simple selection strategy based on the average of the two objectives\n    objectives = [obj for _, obj in archive]\n    avg_costs = [sum(obj) / len(obj) for obj in objectives]\n    probabilities = np.array(avg_costs) / np.sum(avg_costs)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: Combine edge insertion with a biased random walk\n    for _ in range(10):  # Number of local search iterations\n        # Step 1: Edge insertion (like in Lin-Kernighan, but simpler)\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        if len(segment) > 1:\n            new_segment = np.roll(segment, 1)  # Rotate the segment\n            new_solution[i:j+1] = new_segment\n\n        # Step 2: Biased random walk to escape local optima\n        if random.random() < 0.3:  # 30% chance to perform a biased random walk\n            k = random.randint(0, n-1)\n            l = random.randint(0, n-1)\n            if k != l:\n                new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n        # Ensure the solution remains valid (no duplicates, all nodes visited)\n        if len(np.unique(new_solution)) != n:\n            new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.7894573617978962,
            1.628701090812683
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with higher potential for improvement\n    # Here, we use a simple selection strategy based on the average of the two objectives\n    objectives = [obj for _, obj in archive]\n    avg_costs = [sum(obj) / len(obj) for obj in objectives]\n    probabilities = np.array(avg_costs) / np.sum(avg_costs)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: Combine edge insertion with a biased random walk\n    for _ in range(10):  # Number of local search iterations\n        # Step 1: Edge insertion (like in Lin-Kernighan, but simpler)\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        if len(segment) > 1:\n            new_segment = np.roll(segment, 1)  # Rotate the segment\n            new_solution[i:j+1] = new_segment\n\n        # Step 2: Biased random walk to escape local optima\n        if random.random() < 0.3:  # 30% chance to perform a biased random walk\n            k = random.randint(0, n-1)\n            l = random.randint(0, n-1)\n            if k != l:\n                new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n        # Ensure the solution remains valid (no duplicates, all nodes visited)\n        if len(np.unique(new_solution)) != n:\n            new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 68,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or non-dominated potential\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of edge exchange and segment reversal\n    n = len(new_solution)\n    a, b, c, d = sorted(random.sample(range(n), 4))\n\n    # Edge exchange (similar to 3-opt but more flexible)\n    new_solution[a], new_solution[b], new_solution[c], new_solution[d] = (\n        new_solution[b], new_solution[d], new_solution[a], new_solution[c]\n    )\n\n    # Segment reversal for additional diversification\n    if random.random() < 0.5:\n        segment_start, segment_end = sorted(random.sample(range(n), 2))\n        new_solution[segment_start:segment_end+1] = new_solution[segment_start:segment_end+1][::-1]\n\n    # Ensure feasibility by checking for duplicates and repairing if needed\n    if len(np.unique(new_solution)) != n:\n        # If duplicates exist, use a simple 2-opt repair\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8628544375885365,
            1.0380231738090515
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or non-dominated potential\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of edge exchange and segment reversal\n    n = len(new_solution)\n    a, b, c, d = sorted(random.sample(range(n), 4))\n\n    # Edge exchange (similar to 3-opt but more flexible)\n    new_solution[a], new_solution[b], new_solution[c], new_solution[d] = (\n        new_solution[b], new_solution[d], new_solution[a], new_solution[c]\n    )\n\n    # Segment reversal for additional diversification\n    if random.random() < 0.5:\n        segment_start, segment_end = sorted(random.sample(range(n), 2))\n        new_solution[segment_start:segment_end+1] = new_solution[segment_start:segment_end+1][::-1]\n\n    # Ensure feasibility by checking for duplicates and repairing if needed\n    if len(np.unique(new_solution)) != n:\n        # If duplicates exist, use a simple 2-opt repair\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 69,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Select a solution with high potential for improvement (e.g., not dominated by others)\n        candidates = []\n        for sol, _ in archive:\n            dominated = False\n            for _, obj in archive:\n                if obj[0] < archive[0][1][0] and obj[1] < archive[0][1][1]:\n                    dominated = True\n                    break\n            if not dominated:\n                candidates.append(sol)\n        if candidates:\n            base_solution = random.choice(candidates).copy()\n        else:\n            base_solution = archive[0][0].copy()\n\n    # Hybrid local search strategy: combine edge exchange and segment relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose a segment of the tour to relocate\n    segment_size = random.randint(2, min(4, n//2))\n    start = random.randint(0, n - segment_size)\n    segment = new_solution[start:start+segment_size]\n\n    # Find a new position to insert the segment\n    possible_positions = [i for i in range(n) if i not in range(start, start+segment_size)]\n    if not possible_positions:\n        return new_solution\n\n    new_pos = random.choice(possible_positions)\n    new_solution = np.concatenate([\n        new_solution[:new_pos],\n        segment,\n        new_solution[new_pos:start],\n        new_solution[start+segment_size:]\n    ])\n\n    # Further refine with edge exchange if the segment relocation didn't help\n    if random.random() < 0.3:  # 30% chance to apply edge exchange\n        i, j = sorted(random.sample(range(n), 2))\n        if i + 1 != j:  # Ensure they are not adjacent\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8799767431457417,
            0.8324751257896423
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Select a solution with high potential for improvement (e.g., not dominated by others)\n        candidates = []\n        for sol, _ in archive:\n            dominated = False\n            for _, obj in archive:\n                if obj[0] < archive[0][1][0] and obj[1] < archive[0][1][1]:\n                    dominated = True\n                    break\n            if not dominated:\n                candidates.append(sol)\n        if candidates:\n            base_solution = random.choice(candidates).copy()\n        else:\n            base_solution = archive[0][0].copy()\n\n    # Hybrid local search strategy: combine edge exchange and segment relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose a segment of the tour to relocate\n    segment_size = random.randint(2, min(4, n//2))\n    start = random.randint(0, n - segment_size)\n    segment = new_solution[start:start+segment_size]\n\n    # Find a new position to insert the segment\n    possible_positions = [i for i in range(n) if i not in range(start, start+segment_size)]\n    if not possible_positions:\n        return new_solution\n\n    new_pos = random.choice(possible_positions)\n    new_solution = np.concatenate([\n        new_solution[:new_pos],\n        segment,\n        new_solution[new_pos:start],\n        new_solution[start+segment_size:]\n    ])\n\n    # Further refine with edge exchange if the segment relocation didn't help\n    if random.random() < 0.3:  # 30% chance to apply edge exchange\n        i, j = sorted(random.sample(range(n), 2))\n        if i + 1 != j:  # Ensure they are not adjacent\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 70,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-front solutions or those with high diversity)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1, len(archive)) / np.sum(np.linspace(0.1, 1, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combination of edge exchange and node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two non-adjacent edges to exchange (similar to 2-opt but with additional checks)\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    if abs(i - j) > 1:  # Ensure edges are not adjacent\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select a node and insert it in a different position (node insertion)\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility by verifying no node is skipped or revisited\n    if len(np.unique(new_solution)) != n:\n        # If infeasible, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8123149489932955,
            1.9471808671951294
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-front solutions or those with high diversity)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1, len(archive)) / np.sum(np.linspace(0.1, 1, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combination of edge exchange and node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two non-adjacent edges to exchange (similar to 2-opt but with additional checks)\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    if abs(i - j) > 1:  # Ensure edges are not adjacent\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select a node and insert it in a different position (node insertion)\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility by verifying no node is skipped or revisited\n    if len(np.unique(new_solution)) != n:\n        # If infeasible, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 71,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution with high diversity in objectives\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.sum((objectives - np.mean(objectives, axis=0)) ** 2, axis=1)\n    probabilities = diversity_scores / np.sum(diversity_scores)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search (edge insertion + segment reversal)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge insertion: randomly select a segment and insert it in a new position\n    if n > 3:\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n        remaining = np.concatenate([new_solution[:a], new_solution[b:]])\n        insert_pos = random.randint(0, len(remaining) - 1)\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Segment reversal: reverse a random segment to explore new configurations\n    if n > 2:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8381050575850901,
            1.5824748277664185
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution with high diversity in objectives\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.sum((objectives - np.mean(objectives, axis=0)) ** 2, axis=1)\n    probabilities = diversity_scores / np.sum(diversity_scores)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search (edge insertion + segment reversal)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge insertion: randomly select a segment and insert it in a new position\n    if n > 3:\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n        remaining = np.concatenate([new_solution[:a], new_solution[b:]])\n        insert_pos = random.randint(0, len(remaining) - 1)\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Segment reversal: reverse a random segment to explore new configurations\n    if n > 2:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 72,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a base solution with intelligent randomness\n    # Prioritize solutions with high diversity and potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    base_solution = random.choice(archive_solutions)\n\n    # Create a copy to modify\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    n = len(new_solution)\n\n    # Randomly choose one of three local search operators\n    operator = random.choice(['edge_insertion', 'segment_reversal', 'node_swap'])\n\n    if operator == 'edge_insertion':\n        # Randomly select a node and insert it in a different position\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        # Remove the node\n        new_solution = np.delete(new_solution, i)\n        # Insert at a random position\n        j = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, j, node)\n\n    elif operator == 'segment_reversal':\n        # Randomly select a segment and reverse it\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == 'node_swap':\n        # Randomly select two nodes and swap them\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8034191594996988,
            1.4423962831497192
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a base solution with intelligent randomness\n    # Prioritize solutions with high diversity and potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    base_solution = random.choice(archive_solutions)\n\n    # Create a copy to modify\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    n = len(new_solution)\n\n    # Randomly choose one of three local search operators\n    operator = random.choice(['edge_insertion', 'segment_reversal', 'node_swap'])\n\n    if operator == 'edge_insertion':\n        # Randomly select a node and insert it in a different position\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        # Remove the node\n        new_solution = np.delete(new_solution, i)\n        # Insert at a random position\n        j = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, j, node)\n\n    elif operator == 'segment_reversal':\n        # Randomly select a segment and reverse it\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == 'node_swap':\n        # Randomly select two nodes and swap them\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 73,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # Here, we select a solution with the highest total cost (sum of both objectives)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: Combination of 3-opt and edge insertion\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # No improvement possible for small instances\n\n    # Randomly select three distinct positions\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move\n    new_segment = new_solution[a:b+1]\n    if random.random() < 0.5:\n        new_segment = new_segment[::-1]  # Reverse segment\n\n    # Insert the modified segment at a different position\n    new_solution = np.concatenate([new_solution[:a], new_segment, new_solution[b+1:]])\n\n    # Apply edge insertion for further improvement\n    if n > 3:\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            # Remove node at i and insert it after j\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            insert_pos = (j + 1) % len(new_solution)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8715126780678725,
            1.430979073047638
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # Here, we select a solution with the highest total cost (sum of both objectives)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: Combination of 3-opt and edge insertion\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # No improvement possible for small instances\n\n    # Randomly select three distinct positions\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move\n    new_segment = new_solution[a:b+1]\n    if random.random() < 0.5:\n        new_segment = new_segment[::-1]  # Reverse segment\n\n    # Insert the modified segment at a different position\n    new_solution = np.concatenate([new_solution[:a], new_segment, new_solution[b+1:]])\n\n    # Apply edge insertion for further improvement\n    if n > 3:\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            # Remove node at i and insert it after j\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            insert_pos = (j + 1) % len(new_solution)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 74,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solutions with the best combined objective values\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    top_k = min(5, len(sorted_archive))\n    candidates = [sol[0] for sol in sorted_archive[:top_k]]\n\n    # Randomly select a base solution from the top candidates\n    base_solution = random.choice(candidates).copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt to a randomly selected segment\n    i, j, k = sorted(random.sample(range(1, n-1), 3))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:]\n\n    # Try all possible 3-opt configurations\n    configurations = [\n        np.concatenate([new_solution[:i], segment1, segment2, segment3]),\n        np.concatenate([new_solution[:i], segment1, segment3, segment2]),\n        np.concatenate([new_solution[:i], segment2, segment1, segment3]),\n        np.concatenate([new_solution[:i], segment2, segment3, segment1]),\n        np.concatenate([new_solution[:i], segment3, segment1, segment2]),\n        np.concatenate([new_solution[:i], segment3, segment2, segment1])\n    ]\n\n    # Evaluate all configurations based on both objectives\n    best_config = new_solution.copy()\n    best_cost = (float('inf'), float('inf'))\n\n    for config in configurations:\n        cost1 = sum(distance_matrix_1[config[i-1], config[i]] for i in range(len(config)))\n        cost2 = sum(distance_matrix_2[config[i-1], config[i]] for i in range(len(config)))\n        if (cost1 + cost2) < (best_cost[0] + best_cost[1]):\n            best_config = config.copy()\n            best_cost = (cost1, cost2)\n\n    new_solution = best_config\n\n    # Apply a custom edge insertion operation\n    if n > 4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        edge_to_insert = new_solution[b]\n        new_solution = np.concatenate([new_solution[:a], [edge_to_insert], new_solution[a:b], new_solution[b+1:]])\n\n    # Ensure the solution remains a valid TSP tour\n    if len(np.unique(new_solution)) != len(new_solution):\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0202927785077076,
            1.2919760942459106
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solutions with the best combined objective values\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    top_k = min(5, len(sorted_archive))\n    candidates = [sol[0] for sol in sorted_archive[:top_k]]\n\n    # Randomly select a base solution from the top candidates\n    base_solution = random.choice(candidates).copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt to a randomly selected segment\n    i, j, k = sorted(random.sample(range(1, n-1), 3))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:]\n\n    # Try all possible 3-opt configurations\n    configurations = [\n        np.concatenate([new_solution[:i], segment1, segment2, segment3]),\n        np.concatenate([new_solution[:i], segment1, segment3, segment2]),\n        np.concatenate([new_solution[:i], segment2, segment1, segment3]),\n        np.concatenate([new_solution[:i], segment2, segment3, segment1]),\n        np.concatenate([new_solution[:i], segment3, segment1, segment2]),\n        np.concatenate([new_solution[:i], segment3, segment2, segment1])\n    ]\n\n    # Evaluate all configurations based on both objectives\n    best_config = new_solution.copy()\n    best_cost = (float('inf'), float('inf'))\n\n    for config in configurations:\n        cost1 = sum(distance_matrix_1[config[i-1], config[i]] for i in range(len(config)))\n        cost2 = sum(distance_matrix_2[config[i-1], config[i]] for i in range(len(config)))\n        if (cost1 + cost2) < (best_cost[0] + best_cost[1]):\n            best_config = config.copy()\n            best_cost = (cost1, cost2)\n\n    new_solution = best_config\n\n    # Apply a custom edge insertion operation\n    if n > 4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        edge_to_insert = new_solution[b]\n        new_solution = np.concatenate([new_solution[:a], [edge_to_insert], new_solution[a:b], new_solution[b+1:]])\n\n    # Ensure the solution remains a valid TSP tour\n    if len(np.unique(new_solution)) != len(new_solution):\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 74,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solutions with the best combined objective values\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    top_k = min(5, len(sorted_archive))\n    candidates = [sol[0] for sol in sorted_archive[:top_k]]\n\n    # Randomly select a base solution from the top candidates\n    base_solution = random.choice(candidates).copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt to a randomly selected segment\n    i, j, k = sorted(random.sample(range(1, n-1), 3))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:]\n\n    # Try all possible 3-opt configurations\n    configurations = [\n        np.concatenate([new_solution[:i], segment1, segment2, segment3]),\n        np.concatenate([new_solution[:i], segment1, segment3, segment2]),\n        np.concatenate([new_solution[:i], segment2, segment1, segment3]),\n        np.concatenate([new_solution[:i], segment2, segment3, segment1]),\n        np.concatenate([new_solution[:i], segment3, segment1, segment2]),\n        np.concatenate([new_solution[:i], segment3, segment2, segment1])\n    ]\n\n    # Evaluate all configurations based on both objectives\n    best_config = new_solution.copy()\n    best_cost = (float('inf'), float('inf'))\n\n    for config in configurations:\n        cost1 = sum(distance_matrix_1[config[i-1], config[i]] for i in range(len(config)))\n        cost2 = sum(distance_matrix_2[config[i-1], config[i]] for i in range(len(config)))\n        if (cost1 + cost2) < (best_cost[0] + best_cost[1]):\n            best_config = config.copy()\n            best_cost = (cost1, cost2)\n\n    new_solution = best_config\n\n    # Apply a custom edge insertion operation\n    if n > 4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        edge_to_insert = new_solution[b]\n        new_solution = np.concatenate([new_solution[:a], [edge_to_insert], new_solution[a:b], new_solution[b+1:]])\n\n    # Ensure the solution remains a valid TSP tour\n    if len(np.unique(new_solution)) != len(new_solution):\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0202927785077076,
            1.2919760942459106
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solutions with the best combined objective values\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    top_k = min(5, len(sorted_archive))\n    candidates = [sol[0] for sol in sorted_archive[:top_k]]\n\n    # Randomly select a base solution from the top candidates\n    base_solution = random.choice(candidates).copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt to a randomly selected segment\n    i, j, k = sorted(random.sample(range(1, n-1), 3))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:]\n\n    # Try all possible 3-opt configurations\n    configurations = [\n        np.concatenate([new_solution[:i], segment1, segment2, segment3]),\n        np.concatenate([new_solution[:i], segment1, segment3, segment2]),\n        np.concatenate([new_solution[:i], segment2, segment1, segment3]),\n        np.concatenate([new_solution[:i], segment2, segment3, segment1]),\n        np.concatenate([new_solution[:i], segment3, segment1, segment2]),\n        np.concatenate([new_solution[:i], segment3, segment2, segment1])\n    ]\n\n    # Evaluate all configurations based on both objectives\n    best_config = new_solution.copy()\n    best_cost = (float('inf'), float('inf'))\n\n    for config in configurations:\n        cost1 = sum(distance_matrix_1[config[i-1], config[i]] for i in range(len(config)))\n        cost2 = sum(distance_matrix_2[config[i-1], config[i]] for i in range(len(config)))\n        if (cost1 + cost2) < (best_cost[0] + best_cost[1]):\n            best_config = config.copy()\n            best_cost = (cost1, cost2)\n\n    new_solution = best_config\n\n    # Apply a custom edge insertion operation\n    if n > 4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        edge_to_insert = new_solution[b]\n        new_solution = np.concatenate([new_solution[:a], [edge_to_insert], new_solution[a:b], new_solution[b+1:]])\n\n    # Ensure the solution remains a valid TSP tour\n    if len(np.unique(new_solution)) != len(new_solution):\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 75,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability of being non-dominated or with high potential for improvement\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1 / (1 + obj[0] + obj[1]) for _, obj in archive],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combination of edge insertion and node swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b]\n\n    # Edge insertion: try to reinsert the segment in a different position\n    new_pos = random.randint(0, n - len(segment))\n    if new_pos >= a and new_pos < b:\n        # Avoid invalid positions\n        new_pos = (new_pos + len(segment)) % n\n\n    # Create new solution by removing the segment and inserting it at new position\n    new_solution = np.concatenate([\n        new_solution[:a],\n        new_solution[b:],\n        segment\n    ])\n\n    # Perform a random swap between two nodes to further diversify\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure validity by checking all nodes are present exactly once\n    if len(set(new_solution)) != n:\n        # Fallback to a simple 2-opt if the solution becomes invalid\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution = np.concatenate([\n            new_solution[:i],\n            new_solution[i:j][::-1],\n            new_solution[j:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -0.941075314472591,
            1.4018394947052002
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability of being non-dominated or with high potential for improvement\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1 / (1 + obj[0] + obj[1]) for _, obj in archive],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combination of edge insertion and node swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b]\n\n    # Edge insertion: try to reinsert the segment in a different position\n    new_pos = random.randint(0, n - len(segment))\n    if new_pos >= a and new_pos < b:\n        # Avoid invalid positions\n        new_pos = (new_pos + len(segment)) % n\n\n    # Create new solution by removing the segment and inserting it at new position\n    new_solution = np.concatenate([\n        new_solution[:a],\n        new_solution[b:],\n        segment\n    ])\n\n    # Perform a random swap between two nodes to further diversify\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure validity by checking all nodes are present exactly once\n    if len(set(new_solution)) != n:\n        # Fallback to a simple 2-opt if the solution becomes invalid\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution = np.concatenate([\n            new_solution[:i],\n            new_solution[i:j][::-1],\n            new_solution[j:]\n        ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 76,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability weighted by its Pareto dominance\n    weights = np.array([1.0 / (i + 1) for i in range(len(archive))])  # Prefer earlier solutions\n    selected_idx = np.random.choice(len(archive), p=weights / weights.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: 3-opt combined with edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move\n    if random.random() < 0.5:\n        # Option 1: Reverse the middle segment\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    else:\n        # Option 2: Shift the middle segment to another position\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n    # Apply edge exchange (swap two edges if it improves both objectives)\n    i, j = sorted(random.sample(range(n), 2))\n    if i != j and j != (i + 1) % n:\n        # Calculate current and potential costs\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        # Swap nodes i and j\n        temp = new_solution[i]\n        new_solution[i] = new_solution[j]\n        new_solution[j] = temp\n\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        # Revert if not beneficial to both objectives\n        if (new_cost1 > current_cost1) or (new_cost2 > current_cost2):\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    # Ensure the solution remains valid (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8426272396880132,
            1.0857320427894592
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability weighted by its Pareto dominance\n    weights = np.array([1.0 / (i + 1) for i in range(len(archive))])  # Prefer earlier solutions\n    selected_idx = np.random.choice(len(archive), p=weights / weights.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: 3-opt combined with edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move\n    if random.random() < 0.5:\n        # Option 1: Reverse the middle segment\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    else:\n        # Option 2: Shift the middle segment to another position\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n    # Apply edge exchange (swap two edges if it improves both objectives)\n    i, j = sorted(random.sample(range(n), 2))\n    if i != j and j != (i + 1) % n:\n        # Calculate current and potential costs\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        # Swap nodes i and j\n        temp = new_solution[i]\n        new_solution[i] = new_solution[j]\n        new_solution[j] = temp\n\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        # Revert if not beneficial to both objectives\n        if (new_cost1 > current_cost1) or (new_cost2 > current_cost2):\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    # Ensure the solution remains valid (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 77,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal)\n    archive_solutions = [sol for sol, _ in archive]\n    if len(archive_solutions) == 1:\n        base_solution = archive_solutions[0].copy()\n    else:\n        # Select a solution with the highest sum of objectives (indicating potential for improvement)\n        objectives = [obj for _, obj in archive]\n        objective_sums = [sum(obj) for obj in objectives]\n        max_sum_idx = np.argmax(objective_sums)\n        base_solution = archive_solutions[max_sum_idx].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge insertion\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # 3-opt move\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n        # Novel edge insertion: try to insert a random edge from another solution\n        if len(archive) > 1:\n            other_solution = random.choice(archive_solutions)\n            if not np.array_equal(other_solution, base_solution):\n                # Find a random edge in the other solution\n                idx = random.randint(0, n-2)\n                edge = (other_solution[idx], other_solution[idx+1])\n\n                # Try to insert this edge into our solution\n                # Find positions where this edge can be inserted without violating feasibility\n                possible_positions = []\n                for pos in range(n):\n                    if pos == 0:\n                        continue  # Don't insert at start (would create duplicate)\n                    # Check if inserting edge between pos-1 and pos is valid\n                    if (new_solution[pos-1] != edge[0] and new_solution[pos] != edge[1] and\n                        edge[0] not in new_solution[pos:] and edge[1] not in new_solution[pos:]):\n                        possible_positions.append(pos)\n\n                if possible_positions:\n                    insert_pos = random.choice(possible_positions)\n                    # Insert the edge\n                    new_solution = np.insert(new_solution, insert_pos, edge[1])\n                    # Remove duplicates\n                    unique_nodes, indices = np.unique(new_solution, return_index=True)\n                    new_solution = new_solution[np.sort(indices)]\n\n    # Ensure the solution is a valid tour (visits each node exactly once)\n    assert len(new_solution) == len(base_solution), \"Solution length changed\"\n    assert len(np.unique(new_solution)) == len(new_solution), \"Solution contains duplicates\"\n\n    return new_solution\n\n",
        "score": [
            -0.8668638993833152,
            3.7858282923698425
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal)\n    archive_solutions = [sol for sol, _ in archive]\n    if len(archive_solutions) == 1:\n        base_solution = archive_solutions[0].copy()\n    else:\n        # Select a solution with the highest sum of objectives (indicating potential for improvement)\n        objectives = [obj for _, obj in archive]\n        objective_sums = [sum(obj) for obj in objectives]\n        max_sum_idx = np.argmax(objective_sums)\n        base_solution = archive_solutions[max_sum_idx].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge insertion\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # 3-opt move\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n        # Novel edge insertion: try to insert a random edge from another solution\n        if len(archive) > 1:\n            other_solution = random.choice(archive_solutions)\n            if not np.array_equal(other_solution, base_solution):\n                # Find a random edge in the other solution\n                idx = random.randint(0, n-2)\n                edge = (other_solution[idx], other_solution[idx+1])\n\n                # Try to insert this edge into our solution\n                # Find positions where this edge can be inserted without violating feasibility\n                possible_positions = []\n                for pos in range(n):\n                    if pos == 0:\n                        continue  # Don't insert at start (would create duplicate)\n                    # Check if inserting edge between pos-1 and pos is valid\n                    if (new_solution[pos-1] != edge[0] and new_solution[pos] != edge[1] and\n                        edge[0] not in new_solution[pos:] and edge[1] not in new_solution[pos:]):\n                        possible_positions.append(pos)\n\n                if possible_positions:\n                    insert_pos = random.choice(possible_positions)\n                    # Insert the edge\n                    new_solution = np.insert(new_solution, insert_pos, edge[1])\n                    # Remove duplicates\n                    unique_nodes, indices = np.unique(new_solution, return_index=True)\n                    new_solution = new_solution[np.sort(indices)]\n\n    # Ensure the solution is a valid tour (visits each node exactly once)\n    assert len(new_solution) == len(base_solution), \"Solution length changed\"\n    assert len(np.unique(new_solution)) == len(new_solution), \"Solution contains duplicates\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 78,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their combined objective values and pick a non-dominated one\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        selected_idx = min(len(sorted_archive) // 2, len(sorted_archive) - 1)\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: 3-opt with biased segment selection\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Select three distinct random segments with bias towards longer segments\n    segments = random.sample(range(n), 3)\n    segments.sort()\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Apply 3-opt: reverse the middle segment\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Additional improvement: swap two random nodes in the solution\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # If infeasible, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6826723272690619,
            2.5411558151245117
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their combined objective values and pick a non-dominated one\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        selected_idx = min(len(sorted_archive) // 2, len(sorted_archive) - 1)\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: 3-opt with biased segment selection\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Select three distinct random segments with bias towards longer segments\n    segments = random.sample(range(n), 3)\n    segments.sort()\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Apply 3-opt: reverse the middle segment\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Additional improvement: swap two random nodes in the solution\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # If infeasible, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 79,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest cost)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = np.random.choice(min(5, len(archive_sorted)))\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: combine 3-opt with a biased random swap\n    if n >= 4:\n        # Select three random positions\n        i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n\n        # Apply 3-opt-like move\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n        # With 50% probability, perform an additional biased swap\n        if np.random.rand() < 0.5:\n            # Find the node with the highest combined distance in both spaces\n            max_dist_idx = -1\n            max_dist = -1\n            for idx in range(1, n):\n                prev = new_solution[idx-1]\n                current = new_solution[idx]\n                dist = distance_matrix_1[prev, current] + distance_matrix_2[prev, current]\n                if dist > max_dist:\n                    max_dist = dist\n                    max_dist_idx = idx\n\n            if max_dist_idx != -1:\n                # Swap with a random node to break the high-distance edge\n                swap_idx = np.random.choice([i for i in range(n) if i != max_dist_idx])\n                new_solution[max_dist_idx], new_solution[swap_idx] = new_solution[swap_idx], new_solution[max_dist_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.929759757834179,
            2.823815166950226
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest cost)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = np.random.choice(min(5, len(archive_sorted)))\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: combine 3-opt with a biased random swap\n    if n >= 4:\n        # Select three random positions\n        i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n\n        # Apply 3-opt-like move\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n        # With 50% probability, perform an additional biased swap\n        if np.random.rand() < 0.5:\n            # Find the node with the highest combined distance in both spaces\n            max_dist_idx = -1\n            max_dist = -1\n            for idx in range(1, n):\n                prev = new_solution[idx-1]\n                current = new_solution[idx]\n                dist = distance_matrix_1[prev, current] + distance_matrix_2[prev, current]\n                if dist > max_dist:\n                    max_dist = dist\n                    max_dist_idx = idx\n\n            if max_dist_idx != -1:\n                # Swap with a random node to break the high-distance edge\n                swap_idx = np.random.choice([i for i in range(n) if i != max_dist_idx])\n                new_solution[max_dist_idx], new_solution[swap_idx] = new_solution[swap_idx], new_solution[max_dist_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 80,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest combined improvement potential (lower cost in both objectives)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: edge exchange followed by node reinsertion\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Step 1: Edge exchange (similar to 2-opt but with a twist)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Node reinsertion with objective-aware selection\n    # Select a node with high potential for improvement in either objective\n    candidate_nodes = np.random.choice(range(n), min(3, n), replace=False)\n    best_node = None\n    best_improvement = 0\n\n    for node in candidate_nodes:\n        # Remove the node\n        removed_node = new_solution[node]\n        remaining = np.delete(new_solution, node)\n\n        # Try inserting it in different positions\n        for pos in range(n-1):\n            if pos == node or pos == (node-1)%n:\n                continue\n\n            # Insert the node at position pos\n            candidate = np.insert(remaining, pos, removed_node)\n\n            # Calculate the cost change in both objectives\n            cost_change_1 = (distance_matrix_1[candidate[pos-1], candidate[pos]] +\n                            distance_matrix_1[candidate[pos], candidate[(pos+1)%n]] -\n                            distance_matrix_1[candidate[pos-1], removed_node] -\n                            distance_matrix_1[removed_node, candidate[(pos+1)%n]])\n\n            cost_change_2 = (distance_matrix_2[candidate[pos-1], candidate[pos]] +\n                            distance_matrix_2[candidate[pos], candidate[(pos+1)%n]] -\n                            distance_matrix_2[candidate[pos-1], removed_node] -\n                            distance_matrix_2[removed_node, candidate[(pos+1)%n]])\n\n            # Evaluate improvement (weighted sum of both objectives)\n            improvement = -cost_change_1 - cost_change_2  # Negative because we want to minimize\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_node = node\n                best_pos = pos\n\n    if best_node is not None:\n        # Apply the best found insertion\n        removed_node = new_solution[best_node]\n        new_solution = np.delete(new_solution, best_node)\n        new_solution = np.insert(new_solution, best_pos, removed_node)\n\n    return new_solution\n\n",
        "score": [
            -0.7817504439789101,
            7.714042961597443
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest combined improvement potential (lower cost in both objectives)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: edge exchange followed by node reinsertion\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Step 1: Edge exchange (similar to 2-opt but with a twist)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Node reinsertion with objective-aware selection\n    # Select a node with high potential for improvement in either objective\n    candidate_nodes = np.random.choice(range(n), min(3, n), replace=False)\n    best_node = None\n    best_improvement = 0\n\n    for node in candidate_nodes:\n        # Remove the node\n        removed_node = new_solution[node]\n        remaining = np.delete(new_solution, node)\n\n        # Try inserting it in different positions\n        for pos in range(n-1):\n            if pos == node or pos == (node-1)%n:\n                continue\n\n            # Insert the node at position pos\n            candidate = np.insert(remaining, pos, removed_node)\n\n            # Calculate the cost change in both objectives\n            cost_change_1 = (distance_matrix_1[candidate[pos-1], candidate[pos]] +\n                            distance_matrix_1[candidate[pos], candidate[(pos+1)%n]] -\n                            distance_matrix_1[candidate[pos-1], removed_node] -\n                            distance_matrix_1[removed_node, candidate[(pos+1)%n]])\n\n            cost_change_2 = (distance_matrix_2[candidate[pos-1], candidate[pos]] +\n                            distance_matrix_2[candidate[pos], candidate[(pos+1)%n]] -\n                            distance_matrix_2[candidate[pos-1], removed_node] -\n                            distance_matrix_2[removed_node, candidate[(pos+1)%n]])\n\n            # Evaluate improvement (weighted sum of both objectives)\n            improvement = -cost_change_1 - cost_change_2  # Negative because we want to minimize\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_node = node\n                best_pos = pos\n\n    if best_node is not None:\n        # Apply the best found insertion\n        removed_node = new_solution[best_node]\n        new_solution = np.delete(new_solution, best_node)\n        new_solution = np.insert(new_solution, best_pos, removed_node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 81,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    total_costs = objectives.sum(axis=1)\n    probabilities = (1 / total_costs) / (1 / total_costs).sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combination of node insertion and edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select segments for modification\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Perform node insertion\n    if a != c and b != d:\n        inserted_segment = new_solution[a:b]\n        remaining = np.delete(new_solution, slice(a, b))\n        insert_pos = random.randint(0, len(remaining))\n        new_solution = np.insert(remaining, insert_pos, inserted_segment)\n\n    # Perform edge exchange if it improves both objectives\n    if a != c and b != d and c != a and d != b:\n        # Calculate current and potential costs\n        current_cost1 = distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[c], new_solution[d]]\n        current_cost2 = distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[c], new_solution[d]]\n\n        new_cost1 = distance_matrix_1[new_solution[a], new_solution[c]] + distance_matrix_1[new_solution[b], new_solution[d]]\n        new_cost2 = distance_matrix_2[new_solution[a], new_solution[c]] + distance_matrix_2[new_solution[b], new_solution[d]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2):\n            # Perform edge exchange\n            new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n            new_solution[b], new_solution[d] = new_solution[d], new_solution[b]\n\n    return new_solution\n\n",
        "score": [
            -0.8871026395222805,
            1.7016767263412476
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    total_costs = objectives.sum(axis=1)\n    probabilities = (1 / total_costs) / (1 / total_costs).sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combination of node insertion and edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select segments for modification\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Perform node insertion\n    if a != c and b != d:\n        inserted_segment = new_solution[a:b]\n        remaining = np.delete(new_solution, slice(a, b))\n        insert_pos = random.randint(0, len(remaining))\n        new_solution = np.insert(remaining, insert_pos, inserted_segment)\n\n    # Perform edge exchange if it improves both objectives\n    if a != c and b != d and c != a and d != b:\n        # Calculate current and potential costs\n        current_cost1 = distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[c], new_solution[d]]\n        current_cost2 = distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[c], new_solution[d]]\n\n        new_cost1 = distance_matrix_1[new_solution[a], new_solution[c]] + distance_matrix_1[new_solution[b], new_solution[d]]\n        new_cost2 = distance_matrix_2[new_solution[a], new_solution[c]] + distance_matrix_2[new_solution[b], new_solution[d]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2):\n            # Perform edge exchange\n            new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n            new_solution[b], new_solution[d] = new_solution[d], new_solution[b]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 82,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    def potential_score(solution, obj):\n        # Simple heuristic: higher potential if the solution is not too good (not dominated by many others)\n        # and has a good balance between objectives\n        obj1, obj2 = obj\n        dominance_count = sum(1 for (_, (o1, o2)) in archive if (o1 <= obj1 and o2 <= obj2) and (o1 < obj1 or o2 < obj2))\n        balance = min(obj1, obj2) / max(obj1, obj2) if max(obj1, obj2) != 0 else 1.0\n        return balance / (1 + dominance_count)\n\n    scored_solutions = [(sol, obj, potential_score(sol, obj)) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: -x[2])  # Sort by potential score descending\n    base_solution = scored_solutions[0][0].copy()\n\n    # Hybrid local search: 3-opt with probabilistic insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select 3 random segments to perform 3-opt\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Create 7 possible 3-opt neighbors\n    candidates = [\n        np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j], new_solution[k:]]),\n        np.concatenate([new_solution[:i], new_solution[k-1:j-1:-1], new_solution[i:j], new_solution[k:]]),\n        np.concatenate([new_solution[:j], new_solution[i:j], new_solution[k-1:i-1:-1], new_solution[j:k], new_solution[k:]]),\n        np.concatenate([new_solution[:i], new_solution[k-1:j-1:-1], new_solution[j:k], new_solution[i:j], new_solution[k:]]),\n        np.concatenate([new_solution[:j], new_solution[i:j], new_solution[k-1:i-1:-1], new_solution[j:k], new_solution[k:]]),\n        np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j], new_solution[k:]]),\n        np.concatenate([new_solution[:i], new_solution[k-1:j-1:-1], new_solution[i:j], new_solution[k:]])\n    ]\n\n    # Evaluate all candidates using both objectives\n    def evaluate(sol):\n        cost1 = sum(distance_matrix_1[sol[i-1], sol[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[sol[i-1], sol[i]] for i in range(n))\n        return cost1, cost2\n\n    # Select the best candidate based on Pareto dominance\n    best_candidate = None\n    best_costs = (float('inf'), float('inf'))\n\n    for candidate in candidates:\n        if len(set(candidate)) != n:  # Ensure no duplicates\n            continue\n        cost1, cost2 = evaluate(candidate)\n        # Pareto dominance check\n        if (cost1 <= best_costs[0] and cost2 <= best_costs[1] and\n            (cost1 < best_costs[0] or cost2 < best_costs[1])):\n            best_costs = (cost1, cost2)\n            best_candidate = candidate\n\n    if best_candidate is not None:\n        new_solution = best_candidate.copy()\n    else:\n        # If no improvement, try a random insertion\n        i, j = random.sample(range(1, n), 2)\n        new_solution = np.concatenate([new_solution[:i], [new_solution[j]], new_solution[i:j], new_solution[j+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.6891235081252121,
            1.238131046295166
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    def potential_score(solution, obj):\n        # Simple heuristic: higher potential if the solution is not too good (not dominated by many others)\n        # and has a good balance between objectives\n        obj1, obj2 = obj\n        dominance_count = sum(1 for (_, (o1, o2)) in archive if (o1 <= obj1 and o2 <= obj2) and (o1 < obj1 or o2 < obj2))\n        balance = min(obj1, obj2) / max(obj1, obj2) if max(obj1, obj2) != 0 else 1.0\n        return balance / (1 + dominance_count)\n\n    scored_solutions = [(sol, obj, potential_score(sol, obj)) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: -x[2])  # Sort by potential score descending\n    base_solution = scored_solutions[0][0].copy()\n\n    # Hybrid local search: 3-opt with probabilistic insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select 3 random segments to perform 3-opt\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Create 7 possible 3-opt neighbors\n    candidates = [\n        np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j], new_solution[k:]]),\n        np.concatenate([new_solution[:i], new_solution[k-1:j-1:-1], new_solution[i:j], new_solution[k:]]),\n        np.concatenate([new_solution[:j], new_solution[i:j], new_solution[k-1:i-1:-1], new_solution[j:k], new_solution[k:]]),\n        np.concatenate([new_solution[:i], new_solution[k-1:j-1:-1], new_solution[j:k], new_solution[i:j], new_solution[k:]]),\n        np.concatenate([new_solution[:j], new_solution[i:j], new_solution[k-1:i-1:-1], new_solution[j:k], new_solution[k:]]),\n        np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j], new_solution[k:]]),\n        np.concatenate([new_solution[:i], new_solution[k-1:j-1:-1], new_solution[i:j], new_solution[k:]])\n    ]\n\n    # Evaluate all candidates using both objectives\n    def evaluate(sol):\n        cost1 = sum(distance_matrix_1[sol[i-1], sol[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[sol[i-1], sol[i]] for i in range(n))\n        return cost1, cost2\n\n    # Select the best candidate based on Pareto dominance\n    best_candidate = None\n    best_costs = (float('inf'), float('inf'))\n\n    for candidate in candidates:\n        if len(set(candidate)) != n:  # Ensure no duplicates\n            continue\n        cost1, cost2 = evaluate(candidate)\n        # Pareto dominance check\n        if (cost1 <= best_costs[0] and cost2 <= best_costs[1] and\n            (cost1 < best_costs[0] or cost2 < best_costs[1])):\n            best_costs = (cost1, cost2)\n            best_candidate = candidate\n\n    if best_candidate is not None:\n        new_solution = best_candidate.copy()\n    else:\n        # If no improvement, try a random insertion\n        i, j = random.sample(range(1, n), 2)\n        new_solution = np.concatenate([new_solution[:i], [new_solution[j]], new_solution[i:j], new_solution[j+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 83,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability of being non-dominated or having high diversity\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1 / (1 + i) for i in range(len(archive))],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of edge insertion and segment reversal\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to reverse (segment reversal)\n    start = random.randint(0, n - 4)\n    end = random.randint(start + 2, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Randomly select an edge to insert elsewhere (edge insertion)\n    edge_pos = random.randint(0, n - 2)\n    edge_node1, edge_node2 = new_solution[edge_pos], new_solution[edge_pos + 1]\n\n    # Remove the edge\n    new_solution = np.concatenate([new_solution[:edge_pos], new_solution[edge_pos+2:]])\n\n    # Insert the edge at a random position\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, [edge_node1, edge_node2])\n\n    # Ensure the solution remains a valid tour\n    if len(new_solution) != n:\n        # Fallback to a simple swap if the insertion fails\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.853924083595865,
            1.4518897533416748
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability of being non-dominated or having high diversity\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1 / (1 + i) for i in range(len(archive))],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of edge insertion and segment reversal\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to reverse (segment reversal)\n    start = random.randint(0, n - 4)\n    end = random.randint(start + 2, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Randomly select an edge to insert elsewhere (edge insertion)\n    edge_pos = random.randint(0, n - 2)\n    edge_node1, edge_node2 = new_solution[edge_pos], new_solution[edge_pos + 1]\n\n    # Remove the edge\n    new_solution = np.concatenate([new_solution[:edge_pos], new_solution[edge_pos+2:]])\n\n    # Insert the edge at a random position\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, [edge_node1, edge_node2])\n\n    # Ensure the solution remains a valid tour\n    if len(new_solution) != n:\n        # Fallback to a simple swap if the insertion fails\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 84,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by objective diversity (difference between the two objectives)\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.abs(objectives[:, 0] - objectives[:, 1])\n        sorted_indices = np.argsort(diversity)[::-1]  # Descending order of diversity\n        selected_idx = random.choice(sorted_indices[:max(1, len(archive)//2)])  # Randomly select from top half\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of 3-opt and node insertion\n    n = len(new_solution)\n    if n >= 4:\n        # 3-opt move\n        a, b, c = sorted(random.sample(range(n), 3))\n        # Create three possible 3-opt configurations\n        option1 = new_solution.copy()\n        option1[a:b+1] = new_solution[a:b+1][::-1]\n        option1[b:c+1] = new_solution[b:c+1][::-1]\n\n        option2 = new_solution.copy()\n        option2[a:c+1] = new_solution[a:c+1][::-1]\n\n        option3 = new_solution.copy()\n        option3[a:b+1] = new_solution[a:b+1][::-1]\n        option3[b:c+1] = new_solution[b:c+1][::-1]\n\n        # Evaluate all options based on both objectives\n        def evaluate(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            return cost1 + cost2  # Combined cost for selection\n\n        options = [option1, option2, option3]\n        best_option = min(options, key=evaluate)\n        new_solution = best_option.copy()\n\n    # Node insertion move (for further improvement)\n    if n >= 3:\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            # Remove node at i and insert it after j\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, (j+1) % n, node)\n\n    return new_solution\n\n",
        "score": [
            -0.3961222933716467,
            0.802890419960022
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by objective diversity (difference between the two objectives)\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.abs(objectives[:, 0] - objectives[:, 1])\n        sorted_indices = np.argsort(diversity)[::-1]  # Descending order of diversity\n        selected_idx = random.choice(sorted_indices[:max(1, len(archive)//2)])  # Randomly select from top half\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of 3-opt and node insertion\n    n = len(new_solution)\n    if n >= 4:\n        # 3-opt move\n        a, b, c = sorted(random.sample(range(n), 3))\n        # Create three possible 3-opt configurations\n        option1 = new_solution.copy()\n        option1[a:b+1] = new_solution[a:b+1][::-1]\n        option1[b:c+1] = new_solution[b:c+1][::-1]\n\n        option2 = new_solution.copy()\n        option2[a:c+1] = new_solution[a:c+1][::-1]\n\n        option3 = new_solution.copy()\n        option3[a:b+1] = new_solution[a:b+1][::-1]\n        option3[b:c+1] = new_solution[b:c+1][::-1]\n\n        # Evaluate all options based on both objectives\n        def evaluate(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            return cost1 + cost2  # Combined cost for selection\n\n        options = [option1, option2, option3]\n        best_option = min(options, key=evaluate)\n        new_solution = best_option.copy()\n\n    # Node insertion move (for further improvement)\n    if n >= 3:\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            # Remove node at i and insert it after j\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, (j+1) % n, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 85,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a novel segment reversal strategy\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select three distinct positions\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt (swap segments)\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n\n    # Reverse one of the segments with probability 0.5\n    if random.random() < 0.5:\n        segment1 = segment1[::-1]\n    else:\n        segment2 = segment2[::-1]\n\n    # Reconstruct the solution\n    new_solution = np.concatenate([new_solution[:i], segment1, segment2, new_solution[k:]])\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if 3-opt fails\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8421298328201716,
            1.1624512672424316
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a novel segment reversal strategy\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select three distinct positions\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt (swap segments)\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n\n    # Reverse one of the segments with probability 0.5\n    if random.random() < 0.5:\n        segment1 = segment1[::-1]\n    else:\n        segment2 = segment2[::-1]\n\n    # Reconstruct the solution\n    new_solution = np.concatenate([new_solution[:i], segment1, segment2, new_solution[k:]])\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if 3-opt fails\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 86,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    candidates = []\n    for sol, obj in archive:\n        is_dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                is_dominated = True\n                break\n        if not is_dominated:\n            candidates.append(sol)\n\n    base_solution = random.choice(candidates).copy() if candidates else archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Edge insertion with segment relocation\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    while abs(i - j) < 2:\n        j = random.randint(0, n-1)\n\n    # Determine the segment to relocate\n    start, end = min(i, j), max(i, j)\n    segment = new_solution[start:end+1]\n\n    # Remove the segment\n    new_solution = np.concatenate([new_solution[:start], new_solution[end+1:]])\n\n    # Find the best insertion point for the segment\n    best_insertion = 0\n    min_cost = float('inf')\n    for k in range(len(new_solution)):\n        # Insert segment after position k\n        candidate = np.concatenate([new_solution[:k+1], segment, new_solution[k+1:]])\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(1, len(candidate)))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(1, len(candidate)))\n        total_cost = cost1 + cost2  # Weighted sum or other combination could be used\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_insertion = k\n\n    # Insert the segment at the best position\n    new_solution = np.concatenate([new_solution[:best_insertion+1], segment, new_solution[best_insertion+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.6682969912554703,
            7.93067330121994
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    candidates = []\n    for sol, obj in archive:\n        is_dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                is_dominated = True\n                break\n        if not is_dominated:\n            candidates.append(sol)\n\n    base_solution = random.choice(candidates).copy() if candidates else archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Edge insertion with segment relocation\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    while abs(i - j) < 2:\n        j = random.randint(0, n-1)\n\n    # Determine the segment to relocate\n    start, end = min(i, j), max(i, j)\n    segment = new_solution[start:end+1]\n\n    # Remove the segment\n    new_solution = np.concatenate([new_solution[:start], new_solution[end+1:]])\n\n    # Find the best insertion point for the segment\n    best_insertion = 0\n    min_cost = float('inf')\n    for k in range(len(new_solution)):\n        # Insert segment after position k\n        candidate = np.concatenate([new_solution[:k+1], segment, new_solution[k+1:]])\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(1, len(candidate)))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(1, len(candidate)))\n        total_cost = cost1 + cost2  # Weighted sum or other combination could be used\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_insertion = k\n\n    # Insert the segment at the best position\n    new_solution = np.concatenate([new_solution[:best_insertion+1], segment, new_solution[best_insertion+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 87,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their combined cost (sum of both objectives)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 20% solutions\n        top_solutions = archive_sorted[:max(1, len(archive_sorted) // 5)]\n        # Randomly select one from top solutions\n        selected_solution = random.choice(top_solutions)[0]\n    else:\n        selected_solution = archive[0][0]\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Choose a local search operator randomly\n    operator = random.choice(['edge_insertion', 'node_relocation', 'segment_reversal'])\n\n    if operator == 'edge_insertion':\n        # Randomly select two edges and insert one between the other\n        i, j = sorted(random.sample(range(n), 2))\n        if i + 1 == j:  # Adjacent nodes, skip to avoid trivial case\n            return new_solution\n        # Remove edge between j and j+1\n        removed = new_solution[j]\n        # Insert between i and i+1\n        new_solution = np.concatenate([new_solution[:i+1], [removed], new_solution[i+1:j], new_solution[j+1:]])\n\n    elif operator == 'node_relocation':\n        # Randomly select a node and relocate it to a new position\n        i = random.randint(0, n-1)\n        removed = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        j = random.randint(0, n-2)\n        new_solution = np.concatenate([new_solution[:j], [removed], new_solution[j:]])\n\n    elif operator == 'segment_reversal':\n        # Randomly select a segment and reverse its order\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        new_solution[i:j+1] = segment[::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    assert len(new_solution) == n, \"Solution length changed\"\n    assert len(np.unique(new_solution)) == n, \"Duplicate nodes in solution\"\n\n    return new_solution\n\n",
        "score": [
            -0.7617929097686078,
            1.4471219182014465
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their combined cost (sum of both objectives)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 20% solutions\n        top_solutions = archive_sorted[:max(1, len(archive_sorted) // 5)]\n        # Randomly select one from top solutions\n        selected_solution = random.choice(top_solutions)[0]\n    else:\n        selected_solution = archive[0][0]\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Choose a local search operator randomly\n    operator = random.choice(['edge_insertion', 'node_relocation', 'segment_reversal'])\n\n    if operator == 'edge_insertion':\n        # Randomly select two edges and insert one between the other\n        i, j = sorted(random.sample(range(n), 2))\n        if i + 1 == j:  # Adjacent nodes, skip to avoid trivial case\n            return new_solution\n        # Remove edge between j and j+1\n        removed = new_solution[j]\n        # Insert between i and i+1\n        new_solution = np.concatenate([new_solution[:i+1], [removed], new_solution[i+1:j], new_solution[j+1:]])\n\n    elif operator == 'node_relocation':\n        # Randomly select a node and relocate it to a new position\n        i = random.randint(0, n-1)\n        removed = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        j = random.randint(0, n-2)\n        new_solution = np.concatenate([new_solution[:j], [removed], new_solution[j:]])\n\n    elif operator == 'segment_reversal':\n        # Randomly select a segment and reverse its order\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        new_solution[i:j+1] = segment[::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    assert len(new_solution) == n, \"Solution length changed\"\n    assert len(np.unique(new_solution)) == n, \"Duplicate nodes in solution\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 88,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest sum of objectives)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge insertion\n    N = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # 3-opt move (select three non-consecutive edges and reconnect them)\n    i, j, k = sorted(random.sample(range(N), 3))\n    segment1 = new_solution[:i+1]\n    segment2 = new_solution[i+1:j+1]\n    segment3 = new_solution[j+1:k+1]\n    segment4 = new_solution[k+1:]\n\n    # Reconnect segments in a different order\n    new_segments = [segment1, segment2, segment3, segment4]\n    random.shuffle(new_segments)\n    new_solution = np.concatenate(new_segments)\n\n    # Custom edge insertion: insert a random node in a random position\n    if N > 3:\n        node_to_insert = random.choice(new_solution)\n        pos = random.randint(0, N-1)\n        new_solution = np.insert(new_solution, pos, node_to_insert)\n\n    # Ensure solution remains valid (no duplicates and all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != N:\n        # If invalid, revert to original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0165507121237136,
            0.2780371904373169
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest sum of objectives)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge insertion\n    N = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # 3-opt move (select three non-consecutive edges and reconnect them)\n    i, j, k = sorted(random.sample(range(N), 3))\n    segment1 = new_solution[:i+1]\n    segment2 = new_solution[i+1:j+1]\n    segment3 = new_solution[j+1:k+1]\n    segment4 = new_solution[k+1:]\n\n    # Reconnect segments in a different order\n    new_segments = [segment1, segment2, segment3, segment4]\n    random.shuffle(new_segments)\n    new_solution = np.concatenate(new_segments)\n\n    # Custom edge insertion: insert a random node in a random position\n    if N > 3:\n        node_to_insert = random.choice(new_solution)\n        pos = random.randint(0, N-1)\n        new_solution = np.insert(new_solution, pos, node_to_insert)\n\n    # Ensure solution remains valid (no duplicates and all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != N:\n        # If invalid, revert to original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 88,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest sum of objectives)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge insertion\n    N = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # 3-opt move (select three non-consecutive edges and reconnect them)\n    i, j, k = sorted(random.sample(range(N), 3))\n    segment1 = new_solution[:i+1]\n    segment2 = new_solution[i+1:j+1]\n    segment3 = new_solution[j+1:k+1]\n    segment4 = new_solution[k+1:]\n\n    # Reconnect segments in a different order\n    new_segments = [segment1, segment2, segment3, segment4]\n    random.shuffle(new_segments)\n    new_solution = np.concatenate(new_segments)\n\n    # Custom edge insertion: insert a random node in a random position\n    if N > 3:\n        node_to_insert = random.choice(new_solution)\n        pos = random.randint(0, N-1)\n        new_solution = np.insert(new_solution, pos, node_to_insert)\n\n    # Ensure solution remains valid (no duplicates and all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != N:\n        # If invalid, revert to original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0165507121237136,
            0.2780371904373169
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest sum of objectives)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge insertion\n    N = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # 3-opt move (select three non-consecutive edges and reconnect them)\n    i, j, k = sorted(random.sample(range(N), 3))\n    segment1 = new_solution[:i+1]\n    segment2 = new_solution[i+1:j+1]\n    segment3 = new_solution[j+1:k+1]\n    segment4 = new_solution[k+1:]\n\n    # Reconnect segments in a different order\n    new_segments = [segment1, segment2, segment3, segment4]\n    random.shuffle(new_segments)\n    new_solution = np.concatenate(new_segments)\n\n    # Custom edge insertion: insert a random node in a random position\n    if N > 3:\n        node_to_insert = random.choice(new_solution)\n        pos = random.randint(0, N-1)\n        new_solution = np.insert(new_solution, pos, node_to_insert)\n\n    # Ensure solution remains valid (no duplicates and all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != N:\n        # If invalid, revert to original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 89,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with high variance in objectives)\n    objectives = np.array([obj for (sol, obj) in archive])\n    objective_variance = np.var(objectives, axis=0)\n    selected_idx = np.argmax(objective_variance)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine 3-opt with a biased random swap\n    for _ in range(3):  # Number of perturbation attempts\n        # Randomly select three distinct positions\n        i, j, k = np.random.choice(n, size=3, replace=False)\n        i, j, k = sorted([i, j, k])\n\n        # Apply 3-opt move: reverse segments between i,j and j,k\n        new_solution[i:j] = np.flip(new_solution[i:j])\n        new_solution[j:k] = np.flip(new_solution[j:k])\n\n        # With 30% probability, apply a biased swap based on distance matrices\n        if np.random.random() < 0.3:\n            # Find the most \"improving\" swap based on both distance matrices\n            best_swap = None\n            min_improvement = 0\n\n            for a in range(n):\n                for b in range(a+1, n):\n                    # Calculate improvement in both objectives\n                    delta1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                             distance_matrix_1[new_solution[b], new_solution[a]] -\n                             distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                             distance_matrix_1[new_solution[b], new_solution[b-1]])\n\n                    delta2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                             distance_matrix_2[new_solution[b], new_solution[a]] -\n                             distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                             distance_matrix_2[new_solution[b], new_solution[b-1]])\n\n                    total_improvement = delta1 + delta2\n\n                    if total_improvement < min_improvement:\n                        min_improvement = total_improvement\n                        best_swap = (a, b)\n\n            if best_swap is not None:\n                a, b = best_swap\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9236241361633952,
            10.80284208059311
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with high variance in objectives)\n    objectives = np.array([obj for (sol, obj) in archive])\n    objective_variance = np.var(objectives, axis=0)\n    selected_idx = np.argmax(objective_variance)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine 3-opt with a biased random swap\n    for _ in range(3):  # Number of perturbation attempts\n        # Randomly select three distinct positions\n        i, j, k = np.random.choice(n, size=3, replace=False)\n        i, j, k = sorted([i, j, k])\n\n        # Apply 3-opt move: reverse segments between i,j and j,k\n        new_solution[i:j] = np.flip(new_solution[i:j])\n        new_solution[j:k] = np.flip(new_solution[j:k])\n\n        # With 30% probability, apply a biased swap based on distance matrices\n        if np.random.random() < 0.3:\n            # Find the most \"improving\" swap based on both distance matrices\n            best_swap = None\n            min_improvement = 0\n\n            for a in range(n):\n                for b in range(a+1, n):\n                    # Calculate improvement in both objectives\n                    delta1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                             distance_matrix_1[new_solution[b], new_solution[a]] -\n                             distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                             distance_matrix_1[new_solution[b], new_solution[b-1]])\n\n                    delta2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                             distance_matrix_2[new_solution[b], new_solution[a]] -\n                             distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                             distance_matrix_2[new_solution[b], new_solution[b-1]])\n\n                    total_improvement = delta1 + delta2\n\n                    if total_improvement < min_improvement:\n                        min_improvement = total_improvement\n                        best_swap = (a, b)\n\n            if best_swap is not None:\n                a, b = best_swap\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 90,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with the best combined objective (weighted sum)\n    weights = [0.5, 0.5]  # Equal weights for both objectives\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Apply a hybrid local search strategy: combine 2-opt with a novel segment reversal\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two non-adjacent segments to reverse\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i:j+1] = new_solution[j:i-1:-1]\n\n    # Apply a novel segment rotation to further explore the neighborhood\n    k = random.randint(1, n-2)\n    rotated_segment = np.roll(new_solution[k:], 1)\n    new_solution[k:] = rotated_segment\n\n    return new_solution\n\n",
        "score": [
            -0.6312371496445924,
            1.0465357899665833
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with the best combined objective (weighted sum)\n    weights = [0.5, 0.5]  # Equal weights for both objectives\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Apply a hybrid local search strategy: combine 2-opt with a novel segment reversal\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two non-adjacent segments to reverse\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i:j+1] = new_solution[j:i-1:-1]\n\n    # Apply a novel segment rotation to further explore the neighborhood\n    k = random.randint(1, n-2)\n    rotated_segment = np.roll(new_solution[k:], 1)\n    new_solution[k:] = rotated_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 91,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate potential improvement score for each solution\n    potentials = []\n    for sol, (cost1, cost2) in archive:\n        # Potential is inversely proportional to the sum of costs (higher cost = higher potential)\n        potential = 1.0 / (cost1 + cost2 + 1e-6)  # Add small epsilon to avoid division by zero\n        potentials.append(potential)\n\n    # Normalize potentials to form a probability distribution\n    total_potential = sum(potentials)\n    probabilities = [p / total_potential for p in potentials]\n\n    # Select a solution based on the probability distribution\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge insertion + segment reversal + swap\n    n = len(new_solution)\n\n    # Edge insertion: move a random edge to a random position\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    if i != j:\n        # Remove edge (i, i+1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        # Insert node after position j\n        new_solution = np.insert(new_solution, j, node)\n\n    # Segment reversal: reverse a random segment\n    if n > 2:\n        seg_start = random.randint(0, n-2)\n        seg_end = random.randint(seg_start+1, n-1)\n        new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    # Swap: swap two random nodes\n    if n > 1:\n        swap_i = random.randint(0, n-1)\n        swap_j = random.randint(0, n-1)\n        new_solution[swap_i], new_solution[swap_j] = new_solution[swap_j], new_solution[swap_i]\n\n    return new_solution\n\n",
        "score": [
            -0.8646348161349416,
            1.5820873379707336
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate potential improvement score for each solution\n    potentials = []\n    for sol, (cost1, cost2) in archive:\n        # Potential is inversely proportional to the sum of costs (higher cost = higher potential)\n        potential = 1.0 / (cost1 + cost2 + 1e-6)  # Add small epsilon to avoid division by zero\n        potentials.append(potential)\n\n    # Normalize potentials to form a probability distribution\n    total_potential = sum(potentials)\n    probabilities = [p / total_potential for p in potentials]\n\n    # Select a solution based on the probability distribution\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge insertion + segment reversal + swap\n    n = len(new_solution)\n\n    # Edge insertion: move a random edge to a random position\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    if i != j:\n        # Remove edge (i, i+1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        # Insert node after position j\n        new_solution = np.insert(new_solution, j, node)\n\n    # Segment reversal: reverse a random segment\n    if n > 2:\n        seg_start = random.randint(0, n-2)\n        seg_end = random.randint(seg_start+1, n-1)\n        new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    # Swap: swap two random nodes\n    if n > 1:\n        swap_i = random.randint(0, n-1)\n        swap_j = random.randint(0, n-1)\n        new_solution[swap_i], new_solution[swap_j] = new_solution[swap_j], new_solution[swap_i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 92,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability of being non-dominated or having high potential for improvement\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of edge insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Determine which objective to prioritize for improvement\n        obj1, obj2 = archive[selected_idx][1]\n        if obj1 > obj2:\n            # Prioritize improving the first objective\n            distance_matrix = distance_matrix_1\n        else:\n            # Prioritize improving the second objective\n            distance_matrix = distance_matrix_2\n\n        # Find the worst edge in the current solution\n        worst_edge = -1\n        max_gain = -np.inf\n        for i in range(n):\n            u = new_solution[i]\n            v = new_solution[(i + 1) % n]\n            current_dist = distance_matrix[u, v]\n\n            # Check all possible insertions of this edge\n            for j in range(i + 2, n):\n                if j == i + 1:\n                    continue\n                a = new_solution[j]\n                b = new_solution[(j + 1) % n]\n\n                # Calculate potential gain\n                gain = (distance_matrix[u, a] + distance_matrix[v, b]) - current_dist\n\n                if gain > max_gain:\n                    max_gain = gain\n                    worst_edge = (i, j)\n\n        if worst_edge is not None and max_gain > 0:\n            i, j = worst_edge\n            # Perform edge insertion and segment reversal\n            if (i + 1) % n == j:\n                # Simple swap if adjacent\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                # Reverse the segment between the two edges\n                segment = new_solution[i+1:j+1]\n                new_solution[i+1:j+1] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9226249491116562,
            3.4049046635627747
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability of being non-dominated or having high potential for improvement\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of edge insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Determine which objective to prioritize for improvement\n        obj1, obj2 = archive[selected_idx][1]\n        if obj1 > obj2:\n            # Prioritize improving the first objective\n            distance_matrix = distance_matrix_1\n        else:\n            # Prioritize improving the second objective\n            distance_matrix = distance_matrix_2\n\n        # Find the worst edge in the current solution\n        worst_edge = -1\n        max_gain = -np.inf\n        for i in range(n):\n            u = new_solution[i]\n            v = new_solution[(i + 1) % n]\n            current_dist = distance_matrix[u, v]\n\n            # Check all possible insertions of this edge\n            for j in range(i + 2, n):\n                if j == i + 1:\n                    continue\n                a = new_solution[j]\n                b = new_solution[(j + 1) % n]\n\n                # Calculate potential gain\n                gain = (distance_matrix[u, a] + distance_matrix[v, b]) - current_dist\n\n                if gain > max_gain:\n                    max_gain = gain\n                    worst_edge = (i, j)\n\n        if worst_edge is not None and max_gain > 0:\n            i, j = worst_edge\n            # Perform edge insertion and segment reversal\n            if (i + 1) % n == j:\n                # Simple swap if adjacent\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                # Reverse the segment between the two edges\n                segment = new_solution[i+1:j+1]\n                new_solution[i+1:j+1] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 93,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol[0] for sol in archive]\n    archive_costs = [sol[1][0] + sol[1][1] for sol in archive]\n    base_solution = archive_solutions[np.argmin(archive_costs)].copy()\n\n    # Hybrid local search operator: 3-opt with biased edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select three random edges to modify\n    i, j, k = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Apply 3-opt move: reverse the segment between j and k\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if 3-opt causes duplicates\n        i, j = np.random.choice(n, size=2, replace=False)\n        i, j = sorted([i, j])\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.5914577847860246,
            1.2206978797912598
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol[0] for sol in archive]\n    archive_costs = [sol[1][0] + sol[1][1] for sol in archive]\n    base_solution = archive_solutions[np.argmin(archive_costs)].copy()\n\n    # Hybrid local search operator: 3-opt with biased edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select three random edges to modify\n    i, j, k = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Apply 3-opt move: reverse the segment between j and k\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if 3-opt causes duplicates\n        i, j = np.random.choice(n, size=2, replace=False)\n        i, j = sorted([i, j])\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 94,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., low-cost solutions)\n    archive.sort(key=lambda x: x[1][0] + x[1][1])  # Sort by sum of objectives\n    selected_idx = np.random.choice(min(5, len(archive)))  # Randomly select from top 5 or fewer\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with edge insertion\n    n = len(base_solution)\n    if n < 3:\n        return new_solution  # Too small for local search\n\n    # Randomly select three distinct edges to modify\n    a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Apply 3-opt-like modification\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order\n    new_order = np.concatenate([segment1, segment2[::-1], segment3, segment4[::-1]])\n    if len(np.unique(new_order)) == n:  # Ensure feasibility\n        new_solution = new_order\n\n    # Apply edge insertion to further improve\n    if n > 3:\n        # Randomly select a node to relocate\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n\n        # Find best insertion position\n        min_cost = float('inf')\n        best_pos = node_idx\n        for i in range(n):\n            if i == node_idx:\n                continue\n            # Temporarily insert node at position i\n            temp_solution = np.insert(np.delete(new_solution, node_idx), i, node)\n            # Calculate cost for both objectives\n            cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n            cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n            total_cost = cost1 + cost2\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = i\n\n        # Apply the best insertion\n        new_solution = np.insert(np.delete(new_solution, node_idx), best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8125647098084203,
            9.810874462127686
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., low-cost solutions)\n    archive.sort(key=lambda x: x[1][0] + x[1][1])  # Sort by sum of objectives\n    selected_idx = np.random.choice(min(5, len(archive)))  # Randomly select from top 5 or fewer\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with edge insertion\n    n = len(base_solution)\n    if n < 3:\n        return new_solution  # Too small for local search\n\n    # Randomly select three distinct edges to modify\n    a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Apply 3-opt-like modification\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order\n    new_order = np.concatenate([segment1, segment2[::-1], segment3, segment4[::-1]])\n    if len(np.unique(new_order)) == n:  # Ensure feasibility\n        new_solution = new_order\n\n    # Apply edge insertion to further improve\n    if n > 3:\n        # Randomly select a node to relocate\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n\n        # Find best insertion position\n        min_cost = float('inf')\n        best_pos = node_idx\n        for i in range(n):\n            if i == node_idx:\n                continue\n            # Temporarily insert node at position i\n            temp_solution = np.insert(np.delete(new_solution, node_idx), i, node)\n            # Calculate cost for both objectives\n            cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n            cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n            total_cost = cost1 + cost2\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = i\n\n        # Apply the best insertion\n        new_solution = np.insert(np.delete(new_solution, node_idx), best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 95,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly biased towards lower costs)\n    costs = [sum(obj) for _, obj in archive]\n    min_cost = min(costs)\n    probabilities = [(min_cost / cost) ** 2 for cost in costs]  # Higher probability for better solutions\n    probabilities = [p / sum(probabilities) for p in probabilities]  # Normalize\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    # Phase 1: Edge exchange (similar to 2-opt but with a twist)\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        i, j = sorted(random.sample(range(n), 2))\n        if i == j or j == (i + 1) % n:\n            continue\n\n        # Try reversing a segment (like 2-opt but more flexible)\n        segment = new_solution[i:j]\n        new_segment = segment[::-1]\n\n        # Check both objectives to decide if the move is beneficial\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j % n]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_segment[0]] + distance_matrix_1[new_segment[-1], new_solution[j % n]]\n        delta1 = new_cost1 - old_cost1\n\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j % n]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_segment[0]] + distance_matrix_2[new_segment[-1], new_solution[j % n]]\n        delta2 = new_cost2 - old_cost2\n\n        if delta1 < 0 or delta2 < 0:  # At least one objective improves\n            new_solution[i:j] = new_segment\n\n    # Phase 2: Node insertion with objective-aware selection\n    for _ in range(5):  # Limit iterations\n        # Select a node to remove (biased towards nodes with high cost)\n        costs = []\n        for k in range(n):\n            prev = new_solution[k-1]\n            curr = new_solution[k]\n            next_node = new_solution[(k+1) % n]\n            cost1 = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]\n            cost2 = distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n            costs.append(cost1 + cost2)\n        costs = np.array(costs)\n        costs = costs / costs.sum()  # Normalize\n        node_idx = np.random.choice(n, p=costs)\n        node = new_solution[node_idx]\n\n        # Remove the node\n        new_solution = np.delete(new_solution, node_idx)\n        n = len(new_solution)\n\n        # Find best insertion point considering both objectives\n        best_pos = 0\n        min_delta = float('inf')\n        for pos in range(n):\n            prev = new_solution[pos-1]\n            next_node = new_solution[pos % n]\n            delta1 = distance_matrix_1[prev, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev, next_node]\n            delta2 = distance_matrix_2[prev, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev, next_node]\n            delta = delta1 + delta2  # Combined delta\n            if delta < min_delta:\n                min_delta = delta\n                best_pos = pos\n\n        # Insert the node at the best position\n        new_solution = np.insert(new_solution, best_pos, node)\n        n = len(new_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.885741722948448,
            4.240174651145935
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly biased towards lower costs)\n    costs = [sum(obj) for _, obj in archive]\n    min_cost = min(costs)\n    probabilities = [(min_cost / cost) ** 2 for cost in costs]  # Higher probability for better solutions\n    probabilities = [p / sum(probabilities) for p in probabilities]  # Normalize\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    # Phase 1: Edge exchange (similar to 2-opt but with a twist)\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        i, j = sorted(random.sample(range(n), 2))\n        if i == j or j == (i + 1) % n:\n            continue\n\n        # Try reversing a segment (like 2-opt but more flexible)\n        segment = new_solution[i:j]\n        new_segment = segment[::-1]\n\n        # Check both objectives to decide if the move is beneficial\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j % n]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_segment[0]] + distance_matrix_1[new_segment[-1], new_solution[j % n]]\n        delta1 = new_cost1 - old_cost1\n\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j % n]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_segment[0]] + distance_matrix_2[new_segment[-1], new_solution[j % n]]\n        delta2 = new_cost2 - old_cost2\n\n        if delta1 < 0 or delta2 < 0:  # At least one objective improves\n            new_solution[i:j] = new_segment\n\n    # Phase 2: Node insertion with objective-aware selection\n    for _ in range(5):  # Limit iterations\n        # Select a node to remove (biased towards nodes with high cost)\n        costs = []\n        for k in range(n):\n            prev = new_solution[k-1]\n            curr = new_solution[k]\n            next_node = new_solution[(k+1) % n]\n            cost1 = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]\n            cost2 = distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n            costs.append(cost1 + cost2)\n        costs = np.array(costs)\n        costs = costs / costs.sum()  # Normalize\n        node_idx = np.random.choice(n, p=costs)\n        node = new_solution[node_idx]\n\n        # Remove the node\n        new_solution = np.delete(new_solution, node_idx)\n        n = len(new_solution)\n\n        # Find best insertion point considering both objectives\n        best_pos = 0\n        min_delta = float('inf')\n        for pos in range(n):\n            prev = new_solution[pos-1]\n            next_node = new_solution[pos % n]\n            delta1 = distance_matrix_1[prev, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev, next_node]\n            delta2 = distance_matrix_2[prev, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev, next_node]\n            delta = delta1 + delta2  # Combined delta\n            if delta < min_delta:\n                min_delta = delta\n                best_pos = pos\n\n        # Insert the node at the best position\n        new_solution = np.insert(new_solution, best_pos, node)\n        n = len(new_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 96,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a probability proportional to its objective values (inverse of cost)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = 1.0 / (objectives + 1e-6)  # Avoid division by zero\n    weights = normalized_costs[:, 0] * normalized_costs[:, 1]  # Combine both objectives\n    weights = weights / weights.sum()  # Normalize to probabilities\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: edge exchange + node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge exchange (similar to 2-opt but with randomness)\n    i, j = sorted(random.sample(range(1, n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Node insertion (escape local optima)\n    if n > 3:\n        k = random.randint(1, n-2)\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility (no duplicates and all nodes are visited)\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.813333573952056,
            1.0859878659248352
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a probability proportional to its objective values (inverse of cost)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = 1.0 / (objectives + 1e-6)  # Avoid division by zero\n    weights = normalized_costs[:, 0] * normalized_costs[:, 1]  # Combine both objectives\n    weights = weights / weights.sum()  # Normalize to probabilities\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: edge exchange + node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge exchange (similar to 2-opt but with randomness)\n    i, j = sorted(random.sample(range(1, n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Node insertion (escape local optima)\n    if n > 3:\n        k = random.randint(1, n-2)\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility (no duplicates and all nodes are visited)\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 97,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal in the archive)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # 3-opt move (select 3 edges and reconnect them in a different way)\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Reconnect segments in a different order\n    new_order = [segment1, segment2[::-1], segment3, segment4[::-1]]\n    new_solution = np.concatenate(new_order)\n\n    # Additional node insertion to further improve the solution\n    if n > 4:\n        # Randomly select a node to relocate\n        node_to_move = random.choice(new_solution)\n        # Find its position and remove it\n        pos = np.where(new_solution == node_to_move)[0][0]\n        new_solution = np.delete(new_solution, pos)\n        # Insert it at a random position\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.8109375551319764,
            1.4718657732009888
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal in the archive)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # 3-opt move (select 3 edges and reconnect them in a different way)\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Reconnect segments in a different order\n    new_order = [segment1, segment2[::-1], segment3, segment4[::-1]]\n    new_solution = np.concatenate(new_order)\n\n    # Additional node insertion to further improve the solution\n    if n > 4:\n        # Randomly select a node to relocate\n        node_to_move = random.choice(new_solution)\n        # Find its position and remove it\n        pos = np.where(new_solution == node_to_move)[0][0]\n        new_solution = np.delete(new_solution, pos)\n        # Insert it at a random position\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 98,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = best_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment swap\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No enough nodes for meaningful operation\n\n    # Perform 3-opt: select 3 random non-adjacent edges and reconnect them\n    i, j, k = sorted(np.random.choice(range(1, n-1), 3, replace=False))\n\n    # Try all 8 possible 3-opt reconnections\n    candidates = []\n    for a, b, c in [(i, j, k), (i, k, j), (j, i, k), (j, k, i), (k, i, j), (k, j, i)]:\n        temp = new_solution.copy()\n        temp[a:b] = temp[a:b][::-1]\n        temp[b:c] = temp[b:c][::-1]\n        candidates.append(temp)\n\n    # Also consider a novel segment swap operation\n    segment_length = max(2, n // 5)\n    start = np.random.randint(1, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n    temp = np.concatenate([new_solution[:start], new_solution[start+segment_length:], segment])\n    candidates.append(temp)\n\n    # Evaluate all candidates and select the best one\n    def evaluate(sol):\n        cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        return cost1 + cost2\n\n    best_candidate = min(candidates, key=evaluate)\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(best_candidate)) == n:\n        return best_candidate\n    else:\n        return best_solution  # Fallback to original if invalid\n\n",
        "score": [
            -0.5325858252849579,
            3.7324025630950928
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = best_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment swap\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No enough nodes for meaningful operation\n\n    # Perform 3-opt: select 3 random non-adjacent edges and reconnect them\n    i, j, k = sorted(np.random.choice(range(1, n-1), 3, replace=False))\n\n    # Try all 8 possible 3-opt reconnections\n    candidates = []\n    for a, b, c in [(i, j, k), (i, k, j), (j, i, k), (j, k, i), (k, i, j), (k, j, i)]:\n        temp = new_solution.copy()\n        temp[a:b] = temp[a:b][::-1]\n        temp[b:c] = temp[b:c][::-1]\n        candidates.append(temp)\n\n    # Also consider a novel segment swap operation\n    segment_length = max(2, n // 5)\n    start = np.random.randint(1, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n    temp = np.concatenate([new_solution[:start], new_solution[start+segment_length:], segment])\n    candidates.append(temp)\n\n    # Evaluate all candidates and select the best one\n    def evaluate(sol):\n        cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        return cost1 + cost2\n\n    best_candidate = min(candidates, key=evaluate)\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(best_candidate)) == n:\n        return best_candidate\n    else:\n        return best_solution  # Fallback to original if invalid\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 99,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Weighted random selection favoring solutions with better combined objectives\n        objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n        weights = 1 / (objectives + 1e-6)  # Avoid division by zero\n        weights = weights / np.sum(weights)\n        idx = np.random.choice(len(archive), p=weights)\n    else:\n        idx = 0\n\n    base_solution = archive[idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    if random.random() < 0.7:  # 70% chance for 3-opt\n        # Perform 3-opt on a randomly selected segment\n        n = len(new_solution)\n        i, j, k = sorted(random.sample(range(n), 3))\n\n        # Try all possible 3-opt configurations\n        best_config = None\n        best_improvement = 0\n\n        # Original segment order: i-j-k\n        current_order = new_solution.copy()\n        current_cost = (sum(distance_matrix_1[current_order[l], current_order[l+1]] for l in range(n-1)) +\n                        distance_matrix_1[current_order[-1], current_order[0]] +\n                        sum(distance_matrix_2[current_order[l], current_order[l+1]] for l in range(n-1)) +\n                        distance_matrix_2[current_order[-1], current_order[0]])\n\n        # Try all 8 possible configurations\n        for a, b, c in [(i, j, k), (i, k, j), (j, i, k), (j, k, i), (k, i, j), (k, j, i)]:\n            if a == b or b == c or a == c:\n                continue\n\n            temp_order = current_order.copy()\n            temp_order[a:b+1] = temp_order[a:b+1][::-1]\n            temp_order[b:c+1] = temp_order[b:c+1][::-1]\n\n            new_cost = (sum(distance_matrix_1[temp_order[l], temp_order[l+1]] for l in range(n-1)) +\n                        distance_matrix_1[temp_order[-1], temp_order[0]] +\n                        sum(distance_matrix_2[temp_order[l], temp_order[l+1]] for l in range(n-1)) +\n                        distance_matrix_2[temp_order[-1], temp_order[0]])\n\n            improvement = current_cost - new_cost\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_config = temp_order.copy()\n\n        if best_config is not None:\n            new_solution = best_config\n    else:  # 30% chance for segment relocation\n        # Novel segment relocation heuristic\n        n = len(new_solution)\n        if n < 4:\n            return new_solution\n\n        # Select a random segment of length 2-3\n        segment_length = random.randint(2, min(3, n//2))\n        start = random.randint(0, n - segment_length - 1)\n        segment = new_solution[start:start+segment_length]\n\n        # Find the best insertion point that minimizes both objectives\n        best_pos = -1\n        best_cost = float('inf')\n\n        for pos in range(n):\n            if pos >= start and pos <= start + segment_length - 1:\n                continue  # Skip positions within the original segment\n\n            # Create a candidate solution\n            candidate = np.concatenate([\n                new_solution[:start],\n                new_solution[start+segment_length:pos],\n                segment,\n                new_solution[pos:]\n            ])\n\n            # Calculate the cost for both objectives\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            # Apply the best relocation\n            new_solution = np.concatenate([\n                new_solution[:start],\n                new_solution[start+segment_length:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    return new_solution\n\n",
        "score": [
            -0.6351823820934632,
            3.980090618133545
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Weighted random selection favoring solutions with better combined objectives\n        objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n        weights = 1 / (objectives + 1e-6)  # Avoid division by zero\n        weights = weights / np.sum(weights)\n        idx = np.random.choice(len(archive), p=weights)\n    else:\n        idx = 0\n\n    base_solution = archive[idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    if random.random() < 0.7:  # 70% chance for 3-opt\n        # Perform 3-opt on a randomly selected segment\n        n = len(new_solution)\n        i, j, k = sorted(random.sample(range(n), 3))\n\n        # Try all possible 3-opt configurations\n        best_config = None\n        best_improvement = 0\n\n        # Original segment order: i-j-k\n        current_order = new_solution.copy()\n        current_cost = (sum(distance_matrix_1[current_order[l], current_order[l+1]] for l in range(n-1)) +\n                        distance_matrix_1[current_order[-1], current_order[0]] +\n                        sum(distance_matrix_2[current_order[l], current_order[l+1]] for l in range(n-1)) +\n                        distance_matrix_2[current_order[-1], current_order[0]])\n\n        # Try all 8 possible configurations\n        for a, b, c in [(i, j, k), (i, k, j), (j, i, k), (j, k, i), (k, i, j), (k, j, i)]:\n            if a == b or b == c or a == c:\n                continue\n\n            temp_order = current_order.copy()\n            temp_order[a:b+1] = temp_order[a:b+1][::-1]\n            temp_order[b:c+1] = temp_order[b:c+1][::-1]\n\n            new_cost = (sum(distance_matrix_1[temp_order[l], temp_order[l+1]] for l in range(n-1)) +\n                        distance_matrix_1[temp_order[-1], temp_order[0]] +\n                        sum(distance_matrix_2[temp_order[l], temp_order[l+1]] for l in range(n-1)) +\n                        distance_matrix_2[temp_order[-1], temp_order[0]])\n\n            improvement = current_cost - new_cost\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_config = temp_order.copy()\n\n        if best_config is not None:\n            new_solution = best_config\n    else:  # 30% chance for segment relocation\n        # Novel segment relocation heuristic\n        n = len(new_solution)\n        if n < 4:\n            return new_solution\n\n        # Select a random segment of length 2-3\n        segment_length = random.randint(2, min(3, n//2))\n        start = random.randint(0, n - segment_length - 1)\n        segment = new_solution[start:start+segment_length]\n\n        # Find the best insertion point that minimizes both objectives\n        best_pos = -1\n        best_cost = float('inf')\n\n        for pos in range(n):\n            if pos >= start and pos <= start + segment_length - 1:\n                continue  # Skip positions within the original segment\n\n            # Create a candidate solution\n            candidate = np.concatenate([\n                new_solution[:start],\n                new_solution[start+segment_length:pos],\n                segment,\n                new_solution[pos:]\n            ])\n\n            # Calculate the cost for both objectives\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            # Apply the best relocation\n            new_solution = np.concatenate([\n                new_solution[:start],\n                new_solution[start+segment_length:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 100,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive cannot be empty\")\n\n    # Select a solution with high potential for improvement (lower cost but not already explored)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selection_candidates = archive_sorted[:max(1, len(archive_sorted) // 2)]\n    selected_idx = random.randint(0, len(selection_candidates) - 1)\n    base_solution = selection_candidates[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search strategy\n    if N > 3:\n        # Adaptive perturbation: randomly choose between 2-opt and 3-opt\n        if random.random() < 0.7:  # Higher probability for 3-opt\n            # 3-opt local search\n            i, j, k = sorted(random.sample(range(1, N-1), 3))\n            segment1 = new_solution[i:j]\n            segment2 = new_solution[j:k]\n\n            # Reverse segments with probability 0.5 to explore different configurations\n            if random.random() < 0.5:\n                segment1 = segment1[::-1]\n            if random.random() < 0.5:\n                segment2 = segment2[::-1]\n\n            new_solution = np.concatenate([\n                new_solution[:i],\n                segment1,\n                segment2,\n                new_solution[k:]\n            ])\n        else:\n            # 2-opt local search for comparison\n            i, j = sorted(random.sample(range(1, N-1), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Additional adaptive perturbation: swap two nodes if it improves both objectives\n        if N > 4:\n            a, b = random.sample(range(1, N-1), 2)\n            original_cost = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                            distance_matrix_1[new_solution[b], new_solution[b+1]] +\n                            distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                            distance_matrix_2[new_solution[b], new_solution[b+1]])\n\n            new_cost = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[a+1]] +\n                        distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[a+1]])\n\n            if new_cost < original_cost:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8166319718430098,
            1.5125181078910828
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive cannot be empty\")\n\n    # Select a solution with high potential for improvement (lower cost but not already explored)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selection_candidates = archive_sorted[:max(1, len(archive_sorted) // 2)]\n    selected_idx = random.randint(0, len(selection_candidates) - 1)\n    base_solution = selection_candidates[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search strategy\n    if N > 3:\n        # Adaptive perturbation: randomly choose between 2-opt and 3-opt\n        if random.random() < 0.7:  # Higher probability for 3-opt\n            # 3-opt local search\n            i, j, k = sorted(random.sample(range(1, N-1), 3))\n            segment1 = new_solution[i:j]\n            segment2 = new_solution[j:k]\n\n            # Reverse segments with probability 0.5 to explore different configurations\n            if random.random() < 0.5:\n                segment1 = segment1[::-1]\n            if random.random() < 0.5:\n                segment2 = segment2[::-1]\n\n            new_solution = np.concatenate([\n                new_solution[:i],\n                segment1,\n                segment2,\n                new_solution[k:]\n            ])\n        else:\n            # 2-opt local search for comparison\n            i, j = sorted(random.sample(range(1, N-1), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Additional adaptive perturbation: swap two nodes if it improves both objectives\n        if N > 4:\n            a, b = random.sample(range(1, N-1), 2)\n            original_cost = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                            distance_matrix_1[new_solution[b], new_solution[b+1]] +\n                            distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                            distance_matrix_2[new_solution[b], new_solution[b+1]])\n\n            new_cost = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[a+1]] +\n                        distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[a+1]])\n\n            if new_cost < original_cost:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 101,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import numpy as np\n    from random import randint, choice\n\n    if not archive:\n        raise ValueError(\"Archive cannot be empty\")\n\n    # Select a solution with a probability inversely proportional to its current cost\n    costs = np.array([sum(obj) for _, obj in archive])\n    probabilities = 1 / (costs + 1e-6)  # Avoid division by zero\n    probabilities = probabilities / np.sum(probabilities)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    # 1. Random segment relocation (novel operator)\n    if n > 3:\n        segment_length = randint(1, min(3, n // 2))  # Random segment length (1-3 nodes)\n        start_pos = randint(0, n - segment_length - 1)\n        segment = new_solution[start_pos:start_pos + segment_length]\n\n        # Remove the segment and insert elsewhere\n        new_solution = np.concatenate([new_solution[:start_pos], new_solution[start_pos + segment_length:]])\n        insert_pos = randint(0, len(new_solution) - 1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # 2. Edge swap (standard operator)\n    if n > 2:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == len(base_solution), \"Invalid solution length\"\n    assert len(np.unique(new_solution)) == len(new_solution), \"Duplicate nodes in solution\"\n\n    return new_solution\n\n",
        "score": [
            -0.8102297148892655,
            1.2083640098571777
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import numpy as np\n    from random import randint, choice\n\n    if not archive:\n        raise ValueError(\"Archive cannot be empty\")\n\n    # Select a solution with a probability inversely proportional to its current cost\n    costs = np.array([sum(obj) for _, obj in archive])\n    probabilities = 1 / (costs + 1e-6)  # Avoid division by zero\n    probabilities = probabilities / np.sum(probabilities)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    # 1. Random segment relocation (novel operator)\n    if n > 3:\n        segment_length = randint(1, min(3, n // 2))  # Random segment length (1-3 nodes)\n        start_pos = randint(0, n - segment_length - 1)\n        segment = new_solution[start_pos:start_pos + segment_length]\n\n        # Remove the segment and insert elsewhere\n        new_solution = np.concatenate([new_solution[:start_pos], new_solution[start_pos + segment_length:]])\n        insert_pos = randint(0, len(new_solution) - 1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # 2. Edge swap (standard operator)\n    if n > 2:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == len(base_solution), \"Invalid solution length\"\n    assert len(np.unique(new_solution)) == len(new_solution), \"Duplicate nodes in solution\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 102,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal)\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three edges to perform 3-opt\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Perform 3-opt move\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n    new_solution[j:k+1] = np.flip(new_solution[j:k+1])\n\n    # Custom edge insertion: try to improve by inserting a node in a better position\n    if n > 3:\n        # Select a random node to relocate\n        node_to_relocate = random.choice(new_solution)\n        idx = np.where(new_solution == node_to_relocate)[0][0]\n\n        # Remove the node\n        new_solution = np.delete(new_solution, idx)\n\n        # Find the best insertion position based on both distance matrices\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(len(new_solution)):\n            # Insert temporarily\n            temp_solution = np.insert(new_solution, pos, node_to_relocate)\n\n            # Calculate cost for both objectives\n            cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1))\n            cost1 += distance_matrix_1[temp_solution[-1], temp_solution[0]]\n\n            cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1))\n            cost2 += distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        # Insert at the best position\n        new_solution = np.insert(new_solution, best_pos, node_to_relocate)\n\n    return new_solution\n\n",
        "score": [
            -0.7853622030982453,
            7.780524432659149
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal)\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three edges to perform 3-opt\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Perform 3-opt move\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n    new_solution[j:k+1] = np.flip(new_solution[j:k+1])\n\n    # Custom edge insertion: try to improve by inserting a node in a better position\n    if n > 3:\n        # Select a random node to relocate\n        node_to_relocate = random.choice(new_solution)\n        idx = np.where(new_solution == node_to_relocate)[0][0]\n\n        # Remove the node\n        new_solution = np.delete(new_solution, idx)\n\n        # Find the best insertion position based on both distance matrices\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(len(new_solution)):\n            # Insert temporarily\n            temp_solution = np.insert(new_solution, pos, node_to_relocate)\n\n            # Calculate cost for both objectives\n            cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1))\n            cost1 += distance_matrix_1[temp_solution[-1], temp_solution[0]]\n\n            cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1))\n            cost2 += distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        # Insert at the best position\n        new_solution = np.insert(new_solution, best_pos, node_to_relocate)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 103,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution with a higher chance for solutions with lower objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / (objectives.sum(axis=0) + 1e-10)\n    weights = 1 / (normalized_objectives.sum(axis=1) + 1e-10)\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a biased random swap\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select a segment to perturb\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 2, min(start + 5, n - 1))\n\n    # Apply 3-opt within the selected segment\n    i, j, k = sorted(random.sample(range(start, end + 1), 3))\n    new_solution[i:j] = np.flip(new_solution[i:j])\n\n    # Apply a biased random swap to further improve the solution\n    if random.random() < 0.7:  # 70% chance to apply swap\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains a valid tour\n    assert len(np.unique(new_solution)) == n, \"Invalid tour generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.8132119561363245,
            1.8401848077774048
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution with a higher chance for solutions with lower objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / (objectives.sum(axis=0) + 1e-10)\n    weights = 1 / (normalized_objectives.sum(axis=1) + 1e-10)\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a biased random swap\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select a segment to perturb\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 2, min(start + 5, n - 1))\n\n    # Apply 3-opt within the selected segment\n    i, j, k = sorted(random.sample(range(start, end + 1), 3))\n    new_solution[i:j] = np.flip(new_solution[i:j])\n\n    # Apply a biased random swap to further improve the solution\n    if random.random() < 0.7:  # 70% chance to apply swap\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains a valid tour\n    assert len(np.unique(new_solution)) == n, \"Invalid tour generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 104,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = [sol for sol, obj in archive if obj[0] > 0 or obj[1] > 0]\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates)\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a custom edge swap\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select three distinct indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move (reverse the middle segment)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Custom edge swap: swap two edges if it improves both objectives\n    for _ in range(10):  # Limit the number of attempts to avoid excessive computation\n        a, b = sorted(random.sample(range(n), 2))\n        if a == b or abs(a - b) == 1:\n            continue\n\n        # Current edges: (a, a+1), (b, b+1)\n        # Proposed edges: (a, b), (a+1, b+1)\n        current_cost1 = distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n        proposed_cost1 = distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[(a+1)%n], new_solution[(b+1)%n]]\n\n        current_cost2 = distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n        proposed_cost2 = distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[(a+1)%n], new_solution[(b+1)%n]]\n\n        if (proposed_cost1 < current_cost1 and proposed_cost2 < current_cost2):\n            # Perform the swap\n            new_solution[a+1:b+1] = new_solution[a+1:b+1][::-1]\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8966802964586043,
            1.0443519353866577
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = [sol for sol, obj in archive if obj[0] > 0 or obj[1] > 0]\n    if not candidates:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(candidates)\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a custom edge swap\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select three distinct indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move (reverse the middle segment)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Custom edge swap: swap two edges if it improves both objectives\n    for _ in range(10):  # Limit the number of attempts to avoid excessive computation\n        a, b = sorted(random.sample(range(n), 2))\n        if a == b or abs(a - b) == 1:\n            continue\n\n        # Current edges: (a, a+1), (b, b+1)\n        # Proposed edges: (a, b), (a+1, b+1)\n        current_cost1 = distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n        proposed_cost1 = distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[(a+1)%n], new_solution[(b+1)%n]]\n\n        current_cost2 = distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n        proposed_cost2 = distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[(a+1)%n], new_solution[(b+1)%n]]\n\n        if (proposed_cost1 < current_cost1 and proposed_cost2 < current_cost2):\n            # Perform the swap\n            new_solution[a+1:b+1] = new_solution[a+1:b+1][::-1]\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 105,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their combined cost (sum of both objectives)\n        sorted_archive = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n        # Select the top 10% of solutions\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 10)]\n        # Randomly select one from the top solutions\n        base_solution = random.choice(top_solutions)[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt and insertion\n    n = len(new_solution)\n    if n >= 4:\n        # Randomly select 3 distinct positions\n        i, j, k = sorted(random.sample(range(n), 3))\n\n        # Apply 3-opt move\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        segment3 = new_solution[k:]\n\n        # Recombine segments in a new order\n        new_order = np.concatenate([segment1, segment2[::-1], segment3])\n        new_solution = np.concatenate([new_solution[:i], new_order])\n\n        # Apply insertion move\n        if n >= 5:\n            a, b = random.sample(range(n), 2)\n            if a > b:\n                a, b = b, a\n            node_to_insert = new_solution[a]\n            new_solution = np.concatenate([new_solution[:a], new_solution[a+1:b], [node_to_insert], new_solution[b:]])\n\n    # Ensure the solution is feasible (visits each node exactly once)\n    assert len(np.unique(new_solution)) == len(new_solution), \"Generated solution is not feasible\"\n\n    return new_solution\n\n",
        "score": [
            -1.008347973428224,
            1.3253350853919983
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their combined cost (sum of both objectives)\n        sorted_archive = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n        # Select the top 10% of solutions\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 10)]\n        # Randomly select one from the top solutions\n        base_solution = random.choice(top_solutions)[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt and insertion\n    n = len(new_solution)\n    if n >= 4:\n        # Randomly select 3 distinct positions\n        i, j, k = sorted(random.sample(range(n), 3))\n\n        # Apply 3-opt move\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        segment3 = new_solution[k:]\n\n        # Recombine segments in a new order\n        new_order = np.concatenate([segment1, segment2[::-1], segment3])\n        new_solution = np.concatenate([new_solution[:i], new_order])\n\n        # Apply insertion move\n        if n >= 5:\n            a, b = random.sample(range(n), 2)\n            if a > b:\n                a, b = b, a\n            node_to_insert = new_solution[a]\n            new_solution = np.concatenate([new_solution[:a], new_solution[a+1:b], [node_to_insert], new_solution[b:]])\n\n    # Ensure the solution is feasible (visits each node exactly once)\n    assert len(np.unique(new_solution)) == len(new_solution), \"Generated solution is not feasible\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 106,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential for improvement (inverse of current objective values)\n    potentials = [1.0 / (obj[0] + obj[1]) for obj in objectives]\n    total_potential = sum(potentials)\n    probabilities = [p / total_potential for p in potentials]\n\n    # Select a solution based on calculated probabilities\n    selected_idx = np.random.choice(len(solutions), p=probabilities)\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search strategy: combination of edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose a segment to reverse\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, min(start + 5, n - 1))  # Limit segment length to 5 for efficiency\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly insert a node elsewhere\n    if n > 2:\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n - 2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure the solution remains a valid TSP tour\n    if len(new_solution) != n:\n        raise ValueError(\"Invalid solution generated\")\n\n    return new_solution\n\n",
        "score": [
            -0.8095996646659745,
            0.9423289895057678
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential for improvement (inverse of current objective values)\n    potentials = [1.0 / (obj[0] + obj[1]) for obj in objectives]\n    total_potential = sum(potentials)\n    probabilities = [p / total_potential for p in potentials]\n\n    # Select a solution based on calculated probabilities\n    selected_idx = np.random.choice(len(solutions), p=probabilities)\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search strategy: combination of edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose a segment to reverse\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, min(start + 5, n - 1))  # Limit segment length to 5 for efficiency\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly insert a node elsewhere\n    if n > 2:\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n - 2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure the solution remains a valid TSP tour\n    if len(new_solution) != n:\n        raise ValueError(\"Invalid solution generated\")\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 107,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly among top 30% solutions)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    top_k = max(1, len(sorted_archive) // 3)\n    selected_idx = random.randint(0, top_k - 1)\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    # 1. Edge insertion: randomly select a node and insert it in a new position\n    if n > 3 and random.random() < 0.7:\n        node_idx = random.randint(0, n - 1)\n        node = new_solution[node_idx]\n        # Remove the node\n        new_solution = np.delete(new_solution, node_idx)\n        # Insert at a random position\n        insert_pos = random.randint(0, n - 2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # 2. Segment reversal: reverse a random segment of the tour\n    elif n > 4 and random.random() < 0.7:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, n - 1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # 3. Swap two random nodes if no improvement found\n    else:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains valid (no duplicates, all nodes present)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n    assert np.array_equal(np.sort(new_solution), np.sort(base_solution)), \"Nodes missing or duplicated\"\n\n    return new_solution\n\n",
        "score": [
            -0.8802406866357169,
            1.5834824442863464
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly among top 30% solutions)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    top_k = max(1, len(sorted_archive) // 3)\n    selected_idx = random.randint(0, top_k - 1)\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    # 1. Edge insertion: randomly select a node and insert it in a new position\n    if n > 3 and random.random() < 0.7:\n        node_idx = random.randint(0, n - 1)\n        node = new_solution[node_idx]\n        # Remove the node\n        new_solution = np.delete(new_solution, node_idx)\n        # Insert at a random position\n        insert_pos = random.randint(0, n - 2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # 2. Segment reversal: reverse a random segment of the tour\n    elif n > 4 and random.random() < 0.7:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, n - 1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # 3. Swap two random nodes if no improvement found\n    else:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains valid (no duplicates, all nodes present)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n    assert np.array_equal(np.sort(new_solution), np.sort(base_solution)), \"Nodes missing or duplicated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 108,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability for those with lower costs\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = 1 / (1 + normalized_costs.sum(axis=1))\n    probabilities = scores / scores.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment reversal strategy\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # 2-opt move (standard but effective)\n    i, j = sorted(random.sample(range(n_nodes), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Novel segment reversal strategy: reverse a random segment and then apply a partial shift\n    if random.random() < 0.5:  # 50% chance to apply the novel strategy\n        i, j = sorted(random.sample(range(n_nodes), 2))\n        segment = new_solution[i:j+1]\n        reversed_segment = segment[::-1]\n\n        # Apply partial shift to the reversed segment\n        shift = random.randint(1, len(segment)-1) if len(segment) > 1 else 1\n        shifted_segment = np.roll(reversed_segment, shift)\n\n        new_solution[i:j+1] = shifted_segment\n\n    # Ensure the solution remains valid (no duplicates, all nodes present)\n    assert len(np.unique(new_solution)) == n_nodes, \"Invalid solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.8959345493691571,
            1.0092026591300964
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability for those with lower costs\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = 1 / (1 + normalized_costs.sum(axis=1))\n    probabilities = scores / scores.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment reversal strategy\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # 2-opt move (standard but effective)\n    i, j = sorted(random.sample(range(n_nodes), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Novel segment reversal strategy: reverse a random segment and then apply a partial shift\n    if random.random() < 0.5:  # 50% chance to apply the novel strategy\n        i, j = sorted(random.sample(range(n_nodes), 2))\n        segment = new_solution[i:j+1]\n        reversed_segment = segment[::-1]\n\n        # Apply partial shift to the reversed segment\n        shift = random.randint(1, len(segment)-1) if len(segment) > 1 else 1\n        shifted_segment = np.roll(reversed_segment, shift)\n\n        new_solution[i:j+1] = shifted_segment\n\n    # Ensure the solution remains valid (no duplicates, all nodes present)\n    assert len(np.unique(new_solution)) == n_nodes, \"Invalid solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 109,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (can be replaced with Pareto dominance)\n        sorted_archive = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n        # Select top 30% of solutions\n        top_solutions = sorted_archive[:max(1, len(archive) // 3)]\n        # Randomly select one solution from the top candidates\n        selected_idx = random.randint(0, len(top_solutions) - 1)\n        base_solution = top_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of edge insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No meaningful improvement possible\n\n    # Step 1: Randomly select a segment to reverse\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 2: Randomly select two edges and perform edge insertion\n    i, j = sorted(random.sample(range(n), 2))\n    if i != j:\n        # Insert node at j after node at i\n        node = new_solution[j]\n        new_solution = np.concatenate([\n            new_solution[:i+1],\n            np.array([node]),\n            new_solution[i+1:j],\n            new_solution[j+1:]\n        ])\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If duplicates exist, revert to the original solution\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.6745737524985899,
            1.5683098435401917
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (can be replaced with Pareto dominance)\n        sorted_archive = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n        # Select top 30% of solutions\n        top_solutions = sorted_archive[:max(1, len(archive) // 3)]\n        # Randomly select one solution from the top candidates\n        selected_idx = random.randint(0, len(top_solutions) - 1)\n        base_solution = top_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of edge insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No meaningful improvement possible\n\n    # Step 1: Randomly select a segment to reverse\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 2: Randomly select two edges and perform edge insertion\n    i, j = sorted(random.sample(range(n), 2))\n    if i != j:\n        # Insert node at j after node at i\n        node = new_solution[j]\n        new_solution = np.concatenate([\n            new_solution[:i+1],\n            np.array([node]),\n            new_solution[i+1:j],\n            new_solution[j+1:]\n        ])\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If duplicates exist, revert to the original solution\n        return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 110,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (can be modified to use Pareto dominance)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a random solution from the top 30% of the archive\n        selected_idx = random.randint(0, max(0, int(0.3 * len(sorted_archive)) - 1))\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    if random.random() < 0.7:  # 70% chance for edge insertion\n        # Randomly select two non-consecutive edges to reconnect\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while abs(i - j) <= 1 or abs(i - j) == n-1:  # Ensure non-consecutive edges\n            j = random.randint(0, n-1)\n\n        # Perform edge insertion\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[j:i:-1], new_solution[j+1:]])\n    else:  # 30% chance for probabilistic swap\n        # Randomly select two nodes to swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(set(new_solution)) != n:\n        # If infeasible, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7121116354843127,
            0.9627066850662231
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (can be modified to use Pareto dominance)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a random solution from the top 30% of the archive\n        selected_idx = random.randint(0, max(0, int(0.3 * len(sorted_archive)) - 1))\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    if random.random() < 0.7:  # 70% chance for edge insertion\n        # Randomly select two non-consecutive edges to reconnect\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while abs(i - j) <= 1 or abs(i - j) == n-1:  # Ensure non-consecutive edges\n            j = random.randint(0, n-1)\n\n        # Perform edge insertion\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[j:i:-1], new_solution[j+1:]])\n    else:  # 30% chance for probabilistic swap\n        # Randomly select two nodes to swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(set(new_solution)) != n:\n        # If infeasible, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 111,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weights = np.random.uniform(0.3, 0.7)  # Randomly weight the objectives\n    ranked_solutions = sorted(archive, key=lambda x: weights * x[1][0] + (1 - weights) * x[1][1])\n    base_solution = ranked_solutions[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom move\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select three distinct positions\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Perform a custom 3-opt move with probabilistic acceptance\n    if np.random.rand() < 0.7:  # Higher probability for this move\n        # Reverse the segment between a and b, then between b and c\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n    else:\n        # Alternative: swap segments with different lengths\n        segment_length = min(3, n // 4)  # Ensure we don't exceed array bounds\n        if b + segment_length <= n:\n            # Swap segments of random length\n            segment = new_solution[b:b+segment_length].copy()\n            new_solution[b:b+segment_length] = new_solution[a:a+segment_length]\n            new_solution[a:a+segment_length] = segment\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9192201930907975,
            1.2678837180137634
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weights = np.random.uniform(0.3, 0.7)  # Randomly weight the objectives\n    ranked_solutions = sorted(archive, key=lambda x: weights * x[1][0] + (1 - weights) * x[1][1])\n    base_solution = ranked_solutions[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom move\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select three distinct positions\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Perform a custom 3-opt move with probabilistic acceptance\n    if np.random.rand() < 0.7:  # Higher probability for this move\n        # Reverse the segment between a and b, then between b and c\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n    else:\n        # Alternative: swap segments with different lengths\n        segment_length = min(3, n // 4)  # Ensure we don't exceed array bounds\n        if b + segment_length <= n:\n            # Swap segments of random length\n            segment = new_solution[b:b+segment_length].copy()\n            new_solution[b:b+segment_length] = new_solution[a:a+segment_length]\n            new_solution[a:a+segment_length] = segment\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 112,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated solutions)\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search operator: combination of 3-opt and a novel edge insertion\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to perform 3-opt\n    i, j, k = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Perform 3-opt move\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Novel edge insertion: randomly select two nodes and insert one between the other\n    if n > 3:\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n        if b - a > 1:\n            # Insert node at position a between a and b\n            node_to_insert = new_solution[b]\n            new_solution[a+1:b+1] = np.roll(new_solution[a+1:b+1], 1)\n            new_solution[a+1] = node_to_insert\n\n    return new_solution\n\n",
        "score": [
            -0.8891414036476296,
            1.5294360518455505
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated solutions)\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search operator: combination of 3-opt and a novel edge insertion\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to perform 3-opt\n    i, j, k = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Perform 3-opt move\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Novel edge insertion: randomly select two nodes and insert one between the other\n    if n > 3:\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n        if b - a > 1:\n            # Insert node at position a between a and b\n            node_to_insert = new_solution[b]\n            new_solution[a+1:b+1] = np.roll(new_solution[a+1:b+1], 1)\n            new_solution[a+1] = node_to_insert\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 113,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (ascending order)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 20% of solutions\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 5)]\n        # Randomly select one from the top solutions\n        selected_idx = random.randint(0, len(top_solutions) - 1)\n        base_solution = top_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    # Step 2: Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between two operators based on a probability\n    if random.random() < 0.7:  # 70% chance for the first operator\n        # Operator 1: Randomly select two segments and reverse one of them\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j)\n        segment = new_solution[i:k]\n        new_solution[i:k] = segment[::-1]\n    else:  # 30% chance for the second operator\n        # Operator 2: Randomly select a node and insert it in a different position\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        # Remove the node\n        new_solution = np.delete(new_solution, node_idx)\n        # Insert it at a random position\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.8308345636846481,
            1.4031602144241333
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (ascending order)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 20% of solutions\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 5)]\n        # Randomly select one from the top solutions\n        selected_idx = random.randint(0, len(top_solutions) - 1)\n        base_solution = top_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    # Step 2: Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between two operators based on a probability\n    if random.random() < 0.7:  # 70% chance for the first operator\n        # Operator 1: Randomly select two segments and reverse one of them\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(i, j)\n        segment = new_solution[i:k]\n        new_solution[i:k] = segment[::-1]\n    else:  # 30% chance for the second operator\n        # Operator 2: Randomly select a node and insert it in a different position\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        # Remove the node\n        new_solution = np.delete(new_solution, node_idx)\n        # Insert it at a random position\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 114,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest cost)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Apply a hybrid local search: combination of 2-opt and relocate\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments for 2-opt\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select a node and relocate it to a new position\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure the solution remains feasible (no duplicates, all nodes present)\n    if len(set(new_solution)) != len(instance):\n        # Fallback to a simple swap if the operation fails\n        a, b = np.random.choice(n, size=2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7154753785539367,
            1.4116265773773193
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest cost)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Apply a hybrid local search: combination of 2-opt and relocate\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments for 2-opt\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select a node and relocate it to a new position\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure the solution remains feasible (no duplicates, all nodes present)\n    if len(set(new_solution)) != len(instance):\n        # Fallback to a simple swap if the operation fails\n        a, b = np.random.choice(n, size=2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 115,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate dominance ranks (simplified: higher rank for better solutions)\n    objectives = [obj for _, obj in archive]\n    ranks = np.argsort(np.argsort(objectives, axis=0)[:, 0] + np.argsort(objectives, axis=0)[:, 1])\n    ranks = np.max(ranks) - ranks  # Higher rank for better solutions\n\n    # Select a solution with probability proportional to its rank\n    selected_idx = random.choices(range(len(archive)), weights=ranks, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine segment inversion and edge-swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Random segment inversion (similar to 2-opt but more flexible)\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Edge-swap heuristic considering both objectives\n    for _ in range(3):  # Perform a few edge swaps\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j and abs(i-j) > 1:\n            # Calculate cost before swap\n            before_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_1[new_solution[j-1], new_solution[j]])\n            before_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n            # Calculate cost after swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            after_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_1[new_solution[j-1], new_solution[j]])\n            after_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n            # Accept if both objectives improve or randomly with small probability\n            if (after_cost1 + after_cost2) < (before_cost1 + before_cost2) or random.random() < 0.1:\n                continue\n            else:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8296260299373786,
            1.634564220905304
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate dominance ranks (simplified: higher rank for better solutions)\n    objectives = [obj for _, obj in archive]\n    ranks = np.argsort(np.argsort(objectives, axis=0)[:, 0] + np.argsort(objectives, axis=0)[:, 1])\n    ranks = np.max(ranks) - ranks  # Higher rank for better solutions\n\n    # Select a solution with probability proportional to its rank\n    selected_idx = random.choices(range(len(archive)), weights=ranks, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine segment inversion and edge-swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Random segment inversion (similar to 2-opt but more flexible)\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Edge-swap heuristic considering both objectives\n    for _ in range(3):  # Perform a few edge swaps\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j and abs(i-j) > 1:\n            # Calculate cost before swap\n            before_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_1[new_solution[j-1], new_solution[j]])\n            before_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n            # Calculate cost after swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            after_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_1[new_solution[j-1], new_solution[j]])\n            after_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n            # Accept if both objectives improve or randomly with small probability\n            if (after_cost1 + after_cost2) < (before_cost1 + before_cost2) or random.random() < 0.1:\n                continue\n            else:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 116,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probabilistic preference for those with better objectives\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) == 0:\n        return archive[0][0].copy()\n\n    # Normalize objectives for selection probability\n    min_costs = np.min(objectives, axis=0)\n    max_costs = np.max(objectives, axis=0)\n    normalized_costs = (objectives - min_costs) / (max_costs - min_costs + 1e-10)\n    total_costs = np.sum(normalized_costs, axis=1)\n    probabilities = 1 / (total_costs + 1e-10)\n    probabilities = probabilities / np.sum(probabilities)\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge-swapping strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 2, min(start + 5, n - 1))\n\n    # Apply 3-opt within the selected segment\n    i, j, k = sorted(random.sample(range(start, end + 1), 3))\n    segment = new_solution[i:j+1]\n    new_segment = np.concatenate([segment[:k-j], segment[k-j:][::-1]])\n    new_solution[i:j+1] = new_segment\n\n    # Custom edge-swapping strategy for bi-objective optimization\n    for _ in range(2):  # Apply a few swaps\n        a, b = random.sample(range(n), 2)\n        if a > b:\n            a, b = b, a\n\n        # Evaluate the swap in both objectives\n        original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                          distance_matrix_1[new_solution[b-1], new_solution[b]])\n        original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                          distance_matrix_2[new_solution[b-1], new_solution[b]])\n\n        swapped_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_1[new_solution[b-1], new_solution[a]])\n        swapped_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n        # Accept if the swap improves at least one objective\n        if (swapped_cost1 < original_cost1) or (swapped_cost2 < original_cost2):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8557595814881178,
            1.492870569229126
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probabilistic preference for those with better objectives\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) == 0:\n        return archive[0][0].copy()\n\n    # Normalize objectives for selection probability\n    min_costs = np.min(objectives, axis=0)\n    max_costs = np.max(objectives, axis=0)\n    normalized_costs = (objectives - min_costs) / (max_costs - min_costs + 1e-10)\n    total_costs = np.sum(normalized_costs, axis=1)\n    probabilities = 1 / (total_costs + 1e-10)\n    probabilities = probabilities / np.sum(probabilities)\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge-swapping strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 2, min(start + 5, n - 1))\n\n    # Apply 3-opt within the selected segment\n    i, j, k = sorted(random.sample(range(start, end + 1), 3))\n    segment = new_solution[i:j+1]\n    new_segment = np.concatenate([segment[:k-j], segment[k-j:][::-1]])\n    new_solution[i:j+1] = new_segment\n\n    # Custom edge-swapping strategy for bi-objective optimization\n    for _ in range(2):  # Apply a few swaps\n        a, b = random.sample(range(n), 2)\n        if a > b:\n            a, b = b, a\n\n        # Evaluate the swap in both objectives\n        original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                          distance_matrix_1[new_solution[b-1], new_solution[b]])\n        original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                          distance_matrix_2[new_solution[b-1], new_solution[b]])\n\n        swapped_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_1[new_solution[b-1], new_solution[a]])\n        swapped_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n        # Accept if the swap improves at least one objective\n        if (swapped_cost1 < original_cost1) or (swapped_cost2 < original_cost2):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 117,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    weights = [1.0 / (1 + obj[0] + obj[1]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combination of node insertion and edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    seg_start = random.randint(0, n - 3)\n    seg_end = random.randint(seg_start + 2, min(seg_start + 5, n - 1))\n\n    # Extract the segment\n    segment = new_solution[seg_start:seg_end]\n\n    # Determine insertion point (avoid adjacent positions to ensure feasibility)\n    possible_inserts = [i for i in range(n) if i < seg_start - 1 or i > seg_end]\n    if not possible_inserts:\n        return base_solution  # No valid insertion possible\n\n    insert_pos = random.choice(possible_inserts)\n\n    # Remove the segment and insert it at the new position\n    new_solution = np.concatenate([\n        new_solution[:seg_start],\n        new_solution[seg_end:],\n        segment\n    ])\n\n    # Insert the segment at the new position\n    if insert_pos > seg_end:\n        insert_pos -= (seg_end - seg_start)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure the solution is a valid tour\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        return base_solution  # Fallback to original if invalid\n\n    # Additional edge exchange for further improvement\n    for _ in range(2):  # Limit the number of exchanges to maintain diversity\n        i, j = sorted(random.sample(range(1, n), 2))\n        if i == j or j == i + 1 or (i == 0 and j == n - 1):\n            continue  # Skip invalid exchanges\n\n        # Calculate cost change for both objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[j+1]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[j+1]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[j+1]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[j+1]])\n\n        # Accept if both objectives improve or with some probability if one improves\n        if delta1 < 0 and delta2 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif (delta1 < 0 or delta2 < 0) and random.random() < 0.3:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8173148742665322,
            6.077361702919006
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    weights = [1.0 / (1 + obj[0] + obj[1]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combination of node insertion and edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    seg_start = random.randint(0, n - 3)\n    seg_end = random.randint(seg_start + 2, min(seg_start + 5, n - 1))\n\n    # Extract the segment\n    segment = new_solution[seg_start:seg_end]\n\n    # Determine insertion point (avoid adjacent positions to ensure feasibility)\n    possible_inserts = [i for i in range(n) if i < seg_start - 1 or i > seg_end]\n    if not possible_inserts:\n        return base_solution  # No valid insertion possible\n\n    insert_pos = random.choice(possible_inserts)\n\n    # Remove the segment and insert it at the new position\n    new_solution = np.concatenate([\n        new_solution[:seg_start],\n        new_solution[seg_end:],\n        segment\n    ])\n\n    # Insert the segment at the new position\n    if insert_pos > seg_end:\n        insert_pos -= (seg_end - seg_start)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure the solution is a valid tour\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        return base_solution  # Fallback to original if invalid\n\n    # Additional edge exchange for further improvement\n    for _ in range(2):  # Limit the number of exchanges to maintain diversity\n        i, j = sorted(random.sample(range(1, n), 2))\n        if i == j or j == i + 1 or (i == 0 and j == n - 1):\n            continue  # Skip invalid exchanges\n\n        # Calculate cost change for both objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[j+1]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[j+1]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[j+1]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[j+1]])\n\n        # Accept if both objectives improve or with some probability if one improves\n        if delta1 < 0 and delta2 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif (delta1 < 0 or delta2 < 0) and random.random() < 0.3:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 118,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: Edge exchange + Node insertion\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful exchange\n\n    # Step 1: Edge exchange (similar to 2-opt but with a twist)\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Calculate cost before exchange\n    old_cost1 = distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[j-1], base_solution[j]]\n    old_cost2 = distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[j-1], base_solution[j]]\n\n    # Perform exchange\n    new_solution[i:j+1] = base_solution[i:j+1][::-1]\n\n    # Calculate cost after exchange\n    new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n    new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n    # If exchange didn't improve, try node insertion\n    if (new_cost1 >= old_cost1) and (new_cost2 >= old_cost2):\n        # Step 2: Node insertion heuristic\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n\n        # Remove node and insert elsewhere\n        new_solution = np.delete(new_solution, k)\n        new_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8958167015799351,
            1.2398969531059265
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: Edge exchange + Node insertion\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful exchange\n\n    # Step 1: Edge exchange (similar to 2-opt but with a twist)\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Calculate cost before exchange\n    old_cost1 = distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[j-1], base_solution[j]]\n    old_cost2 = distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[j-1], base_solution[j]]\n\n    # Perform exchange\n    new_solution[i:j+1] = base_solution[i:j+1][::-1]\n\n    # Calculate cost after exchange\n    new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n    new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n    # If exchange didn't improve, try node insertion\n    if (new_cost1 >= old_cost1) and (new_cost2 >= old_cost2):\n        # Step 2: Node insertion heuristic\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n\n        # Remove node and insert elsewhere\n        new_solution = np.delete(new_solution, k)\n        new_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 119,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of segment reversal and node insertion\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Randomly select a segment and reverse it (similar to 2-opt but more disruptive)\n    segment_start = random.randint(0, n - 3)\n    segment_end = random.randint(segment_start + 1, n - 1)\n    new_solution[segment_start:segment_end + 1] = new_solution[segment_start:segment_end + 1][::-1]\n\n    # Step 2: Randomly select a node and insert it into a different position\n    node_to_move = random.randint(0, n - 1)\n    new_position = random.randint(0, n - 1)\n    if new_position > node_to_move:\n        new_solution = np.concatenate([new_solution[:node_to_move], new_solution[node_to_move + 1:new_position + 1], [new_solution[node_to_move]], new_solution[new_position + 1:]])\n    else:\n        new_solution = np.concatenate([new_solution[:new_position], [new_solution[node_to_move]], new_solution[new_position:node_to_move], new_solution[node_to_move + 1:]])\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not feasible\"\n\n    return new_solution\n\n",
        "score": [
            -0.507412426766346,
            0.7991097569465637
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of segment reversal and node insertion\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Randomly select a segment and reverse it (similar to 2-opt but more disruptive)\n    segment_start = random.randint(0, n - 3)\n    segment_end = random.randint(segment_start + 1, n - 1)\n    new_solution[segment_start:segment_end + 1] = new_solution[segment_start:segment_end + 1][::-1]\n\n    # Step 2: Randomly select a node and insert it into a different position\n    node_to_move = random.randint(0, n - 1)\n    new_position = random.randint(0, n - 1)\n    if new_position > node_to_move:\n        new_solution = np.concatenate([new_solution[:node_to_move], new_solution[node_to_move + 1:new_position + 1], [new_solution[node_to_move]], new_solution[new_position + 1:]])\n    else:\n        new_solution = np.concatenate([new_solution[:new_position], [new_solution[node_to_move]], new_solution[new_position:node_to_move], new_solution[node_to_move + 1:]])\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not feasible\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 120,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (higher sum may indicate room for improvement)\n        archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n        # Select top 20% of solutions\n        top_solutions = archive_sorted[:max(1, len(archive) // 5)]\n        # Randomly select one from the top solutions\n        base_solution = random.choice(top_solutions)[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom move\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select three distinct positions\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move (reverses the segment between a and b, then between b and c)\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Custom move: swap a segment with its reverse if it improves both objectives\n    if random.random() < 0.5:  # Apply with 50% probability\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j].copy()\n        reversed_segment = segment[::-1]\n\n        # Calculate cost change for both objectives\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], new_solution[j]]\n\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or \\\n           (random.random() < 0.3):  # Accept worse solutions with some probability\n            new_solution[i:j] = reversed_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8992602549709006,
            1.5786771178245544
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (higher sum may indicate room for improvement)\n        archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n        # Select top 20% of solutions\n        top_solutions = archive_sorted[:max(1, len(archive) // 5)]\n        # Randomly select one from the top solutions\n        base_solution = random.choice(top_solutions)[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom move\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select three distinct positions\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move (reverses the segment between a and b, then between b and c)\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Custom move: swap a segment with its reverse if it improves both objectives\n    if random.random() < 0.5:  # Apply with 50% probability\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j].copy()\n        reversed_segment = segment[::-1]\n\n        # Calculate cost change for both objectives\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], new_solution[j]]\n\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or \\\n           (random.random() < 0.3):  # Accept worse solutions with some probability\n            new_solution[i:j] = reversed_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 121,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    archive.sort(key=lambda x: min(x[1][0], x[1][1]))\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search strategy: combination of random swap and edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment for edge insertion\n    if n > 3:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        # Insert the segment at a different random position\n        k = random.randint(0, n - (j - i + 1))\n        if k != i:\n            new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n            # Remove duplicates (since we're inserting a segment, some nodes may appear twice)\n            unique_nodes = np.unique(new_solution)\n            if len(unique_nodes) < n:\n                # Reconstruct the solution by adding missing nodes\n                missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n                for node in missing_nodes:\n                    insert_pos = random.randint(0, len(new_solution) - 1)\n                    new_solution = np.insert(new_solution, insert_pos, node)\n            # Ensure the solution is a valid tour\n            new_solution = new_solution[:n]\n\n    # Perform a random swap to further diversify\n    if n > 1:\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.5678821125355816,
            0.2763299345970154
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    archive.sort(key=lambda x: min(x[1][0], x[1][1]))\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search strategy: combination of random swap and edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment for edge insertion\n    if n > 3:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        # Insert the segment at a different random position\n        k = random.randint(0, n - (j - i + 1))\n        if k != i:\n            new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n            # Remove duplicates (since we're inserting a segment, some nodes may appear twice)\n            unique_nodes = np.unique(new_solution)\n            if len(unique_nodes) < n:\n                # Reconstruct the solution by adding missing nodes\n                missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n                for node in missing_nodes:\n                    insert_pos = random.randint(0, len(new_solution) - 1)\n                    new_solution = np.insert(new_solution, insert_pos, node)\n            # Ensure the solution is a valid tour\n            new_solution = new_solution[:n]\n\n    # Perform a random swap to further diversify\n    if n > 1:\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 121,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    archive.sort(key=lambda x: min(x[1][0], x[1][1]))\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search strategy: combination of random swap and edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment for edge insertion\n    if n > 3:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        # Insert the segment at a different random position\n        k = random.randint(0, n - (j - i + 1))\n        if k != i:\n            new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n            # Remove duplicates (since we're inserting a segment, some nodes may appear twice)\n            unique_nodes = np.unique(new_solution)\n            if len(unique_nodes) < n:\n                # Reconstruct the solution by adding missing nodes\n                missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n                for node in missing_nodes:\n                    insert_pos = random.randint(0, len(new_solution) - 1)\n                    new_solution = np.insert(new_solution, insert_pos, node)\n            # Ensure the solution is a valid tour\n            new_solution = new_solution[:n]\n\n    # Perform a random swap to further diversify\n    if n > 1:\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.5678821125355816,
            0.2763299345970154
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    archive.sort(key=lambda x: min(x[1][0], x[1][1]))\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search strategy: combination of random swap and edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment for edge insertion\n    if n > 3:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        # Insert the segment at a different random position\n        k = random.randint(0, n - (j - i + 1))\n        if k != i:\n            new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n            # Remove duplicates (since we're inserting a segment, some nodes may appear twice)\n            unique_nodes = np.unique(new_solution)\n            if len(unique_nodes) < n:\n                # Reconstruct the solution by adding missing nodes\n                missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n                for node in missing_nodes:\n                    insert_pos = random.randint(0, len(new_solution) - 1)\n                    new_solution = np.insert(new_solution, insert_pos, node)\n            # Ensure the solution is a valid tour\n            new_solution = new_solution[:n]\n\n    # Perform a random swap to further diversify\n    if n > 1:\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 122,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    archive_sorted = sorted(archive, key=lambda x: min(x[1]))\n    selected_idx = min(len(archive) // 2, len(archive) - 1)  # Select from middle to avoid extremes\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    if np.random.rand() < 0.5:  # 50% chance for edge swap\n        # Select two random edges and swap their nodes\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:  # 50% chance for segment reversal\n        # Select a random segment and reverse it\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Additional adaptive improvement: check if the new solution is better in either objective\n    # If not, perform a random swap to ensure diversity\n    if np.random.rand() < 0.2:  # 20% chance for random swap\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6285293403027233,
            1.070493996143341
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    archive_sorted = sorted(archive, key=lambda x: min(x[1]))\n    selected_idx = min(len(archive) // 2, len(archive) - 1)  # Select from middle to avoid extremes\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    if np.random.rand() < 0.5:  # 50% chance for edge swap\n        # Select two random edges and swap their nodes\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:  # 50% chance for segment reversal\n        # Select a random segment and reverse it\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Additional adaptive improvement: check if the new solution is better in either objective\n    # If not, perform a random swap to ensure diversity\n    if np.random.rand() < 0.2:  # 20% chance for random swap\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 123,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with probability inversely proportional to its objective values (promising solutions have lower costs)\n    objectives = np.array([obj for _, obj in archive])\n    total_costs = objectives.sum(axis=1)\n    probabilities = 1 / (total_costs + 1e-6)  # Avoid division by zero\n    probabilities = probabilities / probabilities.sum()\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a biased edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select three random edges to perturb\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Generate all possible 3-opt moves and evaluate them\n    # Move 1: (i, j) -> (i, k), (j, k) -> (j, i)\n    move1 = new_solution.copy()\n    move1[i:j] = move1[i:j][::-1]\n    move1[j:k] = move1[j:k][::-1]\n\n    # Move 2: (i, j) -> (i, k), (j, k) -> (k, j)\n    move2 = new_solution.copy()\n    move2[i:j] = move2[i:j][::-1]\n\n    # Move 3: (i, j) -> (j, k), (i, k) -> (i, j)\n    move3 = new_solution.copy()\n    move3[j:k] = move3[j:k][::-1]\n\n    # Evaluate all moves based on both objectives\n    def evaluate(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n        cost2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n        return (cost1, cost2)\n\n    base_cost = evaluate(new_solution)\n    move1_cost = evaluate(move1)\n    move2_cost = evaluate(move2)\n    move3_cost = evaluate(move3)\n\n    # Select the move that improves at least one objective while not worsening the other too much\n    candidates = [move1, move2, move3]\n    costs = [move1_cost, move2_cost, move3_cost]\n\n    best_move = None\n    for move, cost in zip(candidates, costs):\n        if (cost[0] < base_cost[0] or cost[1] < base_cost[1]) and not (cost[0] > 1.1 * base_cost[0] or cost[1] > 1.1 * base_cost[1]):\n            if best_move is None or sum(cost) < sum(best_move[1]):\n                best_move = (move, cost)\n\n    if best_move is not None:\n        return best_move[0]\n    else:\n        # If no improving move found, perform a random 2-opt as fallback\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n        return new_solution\n\n",
        "score": [
            -0.8239998254479148,
            1.396975338459015
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with probability inversely proportional to its objective values (promising solutions have lower costs)\n    objectives = np.array([obj for _, obj in archive])\n    total_costs = objectives.sum(axis=1)\n    probabilities = 1 / (total_costs + 1e-6)  # Avoid division by zero\n    probabilities = probabilities / probabilities.sum()\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a biased edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select three random edges to perturb\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Generate all possible 3-opt moves and evaluate them\n    # Move 1: (i, j) -> (i, k), (j, k) -> (j, i)\n    move1 = new_solution.copy()\n    move1[i:j] = move1[i:j][::-1]\n    move1[j:k] = move1[j:k][::-1]\n\n    # Move 2: (i, j) -> (i, k), (j, k) -> (k, j)\n    move2 = new_solution.copy()\n    move2[i:j] = move2[i:j][::-1]\n\n    # Move 3: (i, j) -> (j, k), (i, k) -> (i, j)\n    move3 = new_solution.copy()\n    move3[j:k] = move3[j:k][::-1]\n\n    # Evaluate all moves based on both objectives\n    def evaluate(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n        cost2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n        return (cost1, cost2)\n\n    base_cost = evaluate(new_solution)\n    move1_cost = evaluate(move1)\n    move2_cost = evaluate(move2)\n    move3_cost = evaluate(move3)\n\n    # Select the move that improves at least one objective while not worsening the other too much\n    candidates = [move1, move2, move3]\n    costs = [move1_cost, move2_cost, move3_cost]\n\n    best_move = None\n    for move, cost in zip(candidates, costs):\n        if (cost[0] < base_cost[0] or cost[1] < base_cost[1]) and not (cost[0] > 1.1 * base_cost[0] or cost[1] > 1.1 * base_cost[1]):\n            if best_move is None or sum(cost) < sum(best_move[1]):\n                best_move = (move, cost)\n\n    if best_move is not None:\n        return best_move[0]\n    else:\n        # If no improving move found, perform a random 2-opt as fallback\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n        return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 124,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest objective values)\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search strategy: edge insertion + segment relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge insertion (randomly select a node and insert it in a better position)\n    if n > 3:\n        i = np.random.randint(1, n-1)\n        node = new_solution[i]\n        # Remove the node\n        new_solution = np.delete(new_solution, i)\n        # Find the best insertion position\n        best_pos = 0\n        min_cost = float('inf')\n        for pos in range(1, n-1):\n            # Temporarily insert and calculate cost\n            candidate = np.insert(new_solution, pos, node)\n            cost1 = sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            total_cost = cost1 + cost2\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Step 2: Segment relocation (move a random segment to a better position)\n    if n > 4:\n        seg_start = np.random.randint(1, n-2)\n        seg_end = np.random.randint(seg_start+1, n)\n        segment = new_solution[seg_start:seg_end]\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n        # Find the best position to insert the segment\n        best_pos = 0\n        min_cost = float('inf')\n        for pos in range(1, n - (seg_end - seg_start)):\n            # Temporarily insert and calculate cost\n            candidate = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n            cost1 = sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            total_cost = cost1 + cost2\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.43748880917881944,
            12.768840968608856
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest objective values)\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search strategy: edge insertion + segment relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge insertion (randomly select a node and insert it in a better position)\n    if n > 3:\n        i = np.random.randint(1, n-1)\n        node = new_solution[i]\n        # Remove the node\n        new_solution = np.delete(new_solution, i)\n        # Find the best insertion position\n        best_pos = 0\n        min_cost = float('inf')\n        for pos in range(1, n-1):\n            # Temporarily insert and calculate cost\n            candidate = np.insert(new_solution, pos, node)\n            cost1 = sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            total_cost = cost1 + cost2\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Step 2: Segment relocation (move a random segment to a better position)\n    if n > 4:\n        seg_start = np.random.randint(1, n-2)\n        seg_end = np.random.randint(seg_start+1, n)\n        segment = new_solution[seg_start:seg_end]\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n        # Find the best position to insert the segment\n        best_pos = 0\n        min_cost = float('inf')\n        for pos in range(1, n - (seg_end - seg_start)):\n            # Temporarily insert and calculate cost\n            candidate = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n            cost1 = sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            total_cost = cost1 + cost2\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 125,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    combined_costs = normalized_costs.sum(axis=1)\n    probabilities = 1.0 / (combined_costs + 1e-10)\n    probabilities = probabilities / probabilities.sum()\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combination of segment reversal and node insertion\n    new_solution = base_solution.copy()\n\n    # Segment reversal\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Node insertion\n    if n > 3:\n        k = random.randint(0, n-1)\n        node_to_insert = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        l = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, l, node_to_insert)\n\n    # Ensure the solution is valid (no duplicates, all nodes present)\n    if len(set(new_solution)) != len(base_solution):\n        # If invalid, fall back to a simple swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8210545262742003,
            1.0159945487976074
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    combined_costs = normalized_costs.sum(axis=1)\n    probabilities = 1.0 / (combined_costs + 1e-10)\n    probabilities = probabilities / probabilities.sum()\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combination of segment reversal and node insertion\n    new_solution = base_solution.copy()\n\n    # Segment reversal\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Node insertion\n    if n > 3:\n        k = random.randint(0, n-1)\n        node_to_insert = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        l = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, l, node_to_insert)\n\n    # Ensure the solution is valid (no duplicates, all nodes present)\n    if len(set(new_solution)) != len(base_solution):\n        # If invalid, fall back to a simple swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 126,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution with high diversity\n    def diversity_score(solution, archive):\n        \"\"\"Calculate diversity score by comparing with all other solutions in archive\"\"\"\n        score = 0\n        for (other_sol, _) in archive:\n            if np.array_equal(solution, other_sol):\n                continue\n            # Calculate hamming distance (number of differing positions)\n            score += np.sum(solution != other_sol)\n        return score\n\n    # Sort by diversity (descending) and select top 20% or at least 1\n    sorted_solutions = sorted(archive, key=lambda x: -diversity_score(x[0], archive))\n    candidate_size = max(1, len(sorted_solutions) // 5)\n    candidates = [sol[0] for sol in sorted_solutions[:candidate_size]]\n\n    # Randomly select from top candidates\n    base_solution = random.choice(candidates).copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    n = len(new_solution)\n\n    # First operation: Edge insertion with objective-aware selection\n    if n > 3:\n        # Select a segment to move\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Calculate potential improvement in both objectives\n        def segment_cost(sol, a, b, matrix1, matrix2):\n            cost1 = matrix1[sol[b-1], sol[a]] + matrix1[sol[b], sol[a-1]]\n            cost2 = matrix2[sol[b-1], sol[a]] + matrix2[sol[b], sol[a-1]]\n            orig_cost1 = matrix1[sol[a-1], sol[a]] + matrix1[sol[b-1], sol[b]]\n            orig_cost2 = matrix2[sol[a-1], sol[a]] + matrix2[sol[b-1], sol[b]]\n            delta1 = cost1 - orig_cost1\n            delta2 = cost2 - orig_cost2\n            return delta1, delta2\n\n        # Try different insertion points\n        best_delta1, best_delta2 = float('inf'), float('inf')\n        best_pos = -1\n\n        for pos in range(n):\n            if a <= pos < b:\n                continue  # Skip current segment\n\n            # Calculate cost of inserting at this position\n            if pos == 0:\n                # Insert at beginning\n                delta1 = (distance_matrix_1[new_solution[-1], segment[0]] +\n                          distance_matrix_1[segment[-1], new_solution[1]] -\n                          distance_matrix_1[new_solution[-1], new_solution[1]])\n                delta2 = (distance_matrix_2[new_solution[-1], segment[0]] +\n                          distance_matrix_2[segment[-1], new_solution[1]] -\n                          distance_matrix_2[new_solution[-1], new_solution[1]])\n            elif pos == n:\n                # Insert at end\n                delta1 = (distance_matrix_1[new_solution[-2], segment[0]] +\n                          distance_matrix_1[segment[-1], new_solution[0]] -\n                          distance_matrix_1[new_solution[-2], new_solution[0]])\n                delta2 = (distance_matrix_2[new_solution[-2], segment[0]] +\n                          distance_matrix_2[segment[-1], new_solution[0]] -\n                          distance_matrix_2[new_solution[-2], new_solution[0]])\n            else:\n                # Insert in middle\n                delta1 = (distance_matrix_1[new_solution[pos-1], segment[0]] +\n                          distance_matrix_1[segment[-1], new_solution[pos]] -\n                          distance_matrix_1[new_solution[pos-1], new_solution[pos]])\n                delta2 = (distance_matrix_2[new_solution[pos-1], segment[0]] +\n                          distance_matrix_2[segment[-1], new_solution[pos]] -\n                          distance_matrix_2[new_solution[pos-1], new_solution[pos]])\n\n            # Simple Pareto dominance check\n            if delta1 < best_delta1 and delta2 < best_delta2:\n                best_delta1, best_delta2 = delta1, delta2\n                best_pos = pos\n\n        # Apply the best insertion found\n        if best_pos != -1:\n            # Remove the segment\n            new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n            # Insert at best position\n            if best_pos == 0:\n                new_solution = np.concatenate([segment, new_solution])\n            elif best_pos == n:\n                new_solution = np.concatenate([new_solution, segment])\n            else:\n                new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Second operation: Objective-aware edge exchange\n    if n > 3:\n        # Select two edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Calculate potential improvement\n        def edge_swap_cost(sol, i, j, matrix1, matrix2):\n            # Current edges: (sol[i-1], sol[i]) and (sol[j-1], sol[j])\n            # New edges: (sol[i-1], sol[j]) and (sol[j-1], sol[i])\n            delta1 = (matrix1[sol[i-1], sol[j]] + matrix1[sol[j-1], sol[i]] -\n                     matrix1[sol[i-1], sol[i]] - matrix1[sol[j-1], sol[j]])\n            delta2 = (matrix2[sol[i-1], sol[j]] + matrix2[sol[j-1], sol[i]] -\n                     matrix2[sol[i-1], sol[i]] - matrix2[sol[j-1], sol[j]])\n            return delta1, delta2\n\n        delta1, delta2 = edge_swap_cost(new_solution, i, j, distance_matrix_1, distance_matrix_2)\n\n        # If improvement in both objectives, apply\n        if delta1 < 0 and delta2 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7721270423720246,
            8.03231829404831
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution with high diversity\n    def diversity_score(solution, archive):\n        \"\"\"Calculate diversity score by comparing with all other solutions in archive\"\"\"\n        score = 0\n        for (other_sol, _) in archive:\n            if np.array_equal(solution, other_sol):\n                continue\n            # Calculate hamming distance (number of differing positions)\n            score += np.sum(solution != other_sol)\n        return score\n\n    # Sort by diversity (descending) and select top 20% or at least 1\n    sorted_solutions = sorted(archive, key=lambda x: -diversity_score(x[0], archive))\n    candidate_size = max(1, len(sorted_solutions) // 5)\n    candidates = [sol[0] for sol in sorted_solutions[:candidate_size]]\n\n    # Randomly select from top candidates\n    base_solution = random.choice(candidates).copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    n = len(new_solution)\n\n    # First operation: Edge insertion with objective-aware selection\n    if n > 3:\n        # Select a segment to move\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Calculate potential improvement in both objectives\n        def segment_cost(sol, a, b, matrix1, matrix2):\n            cost1 = matrix1[sol[b-1], sol[a]] + matrix1[sol[b], sol[a-1]]\n            cost2 = matrix2[sol[b-1], sol[a]] + matrix2[sol[b], sol[a-1]]\n            orig_cost1 = matrix1[sol[a-1], sol[a]] + matrix1[sol[b-1], sol[b]]\n            orig_cost2 = matrix2[sol[a-1], sol[a]] + matrix2[sol[b-1], sol[b]]\n            delta1 = cost1 - orig_cost1\n            delta2 = cost2 - orig_cost2\n            return delta1, delta2\n\n        # Try different insertion points\n        best_delta1, best_delta2 = float('inf'), float('inf')\n        best_pos = -1\n\n        for pos in range(n):\n            if a <= pos < b:\n                continue  # Skip current segment\n\n            # Calculate cost of inserting at this position\n            if pos == 0:\n                # Insert at beginning\n                delta1 = (distance_matrix_1[new_solution[-1], segment[0]] +\n                          distance_matrix_1[segment[-1], new_solution[1]] -\n                          distance_matrix_1[new_solution[-1], new_solution[1]])\n                delta2 = (distance_matrix_2[new_solution[-1], segment[0]] +\n                          distance_matrix_2[segment[-1], new_solution[1]] -\n                          distance_matrix_2[new_solution[-1], new_solution[1]])\n            elif pos == n:\n                # Insert at end\n                delta1 = (distance_matrix_1[new_solution[-2], segment[0]] +\n                          distance_matrix_1[segment[-1], new_solution[0]] -\n                          distance_matrix_1[new_solution[-2], new_solution[0]])\n                delta2 = (distance_matrix_2[new_solution[-2], segment[0]] +\n                          distance_matrix_2[segment[-1], new_solution[0]] -\n                          distance_matrix_2[new_solution[-2], new_solution[0]])\n            else:\n                # Insert in middle\n                delta1 = (distance_matrix_1[new_solution[pos-1], segment[0]] +\n                          distance_matrix_1[segment[-1], new_solution[pos]] -\n                          distance_matrix_1[new_solution[pos-1], new_solution[pos]])\n                delta2 = (distance_matrix_2[new_solution[pos-1], segment[0]] +\n                          distance_matrix_2[segment[-1], new_solution[pos]] -\n                          distance_matrix_2[new_solution[pos-1], new_solution[pos]])\n\n            # Simple Pareto dominance check\n            if delta1 < best_delta1 and delta2 < best_delta2:\n                best_delta1, best_delta2 = delta1, delta2\n                best_pos = pos\n\n        # Apply the best insertion found\n        if best_pos != -1:\n            # Remove the segment\n            new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n            # Insert at best position\n            if best_pos == 0:\n                new_solution = np.concatenate([segment, new_solution])\n            elif best_pos == n:\n                new_solution = np.concatenate([new_solution, segment])\n            else:\n                new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Second operation: Objective-aware edge exchange\n    if n > 3:\n        # Select two edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Calculate potential improvement\n        def edge_swap_cost(sol, i, j, matrix1, matrix2):\n            # Current edges: (sol[i-1], sol[i]) and (sol[j-1], sol[j])\n            # New edges: (sol[i-1], sol[j]) and (sol[j-1], sol[i])\n            delta1 = (matrix1[sol[i-1], sol[j]] + matrix1[sol[j-1], sol[i]] -\n                     matrix1[sol[i-1], sol[i]] - matrix1[sol[j-1], sol[j]])\n            delta2 = (matrix2[sol[i-1], sol[j]] + matrix2[sol[j-1], sol[i]] -\n                     matrix2[sol[i-1], sol[i]] - matrix2[sol[j-1], sol[j]])\n            return delta1, delta2\n\n        delta1, delta2 = edge_swap_cost(new_solution, i, j, distance_matrix_1, distance_matrix_2)\n\n        # If improvement in both objectives, apply\n        if delta1 < 0 and delta2 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 127,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Intelligent selection of a promising solution from the archive\n    # Prioritize solutions with lower total cost (sum of both objectives)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Apply hybrid local search\n    new_solution = selected_solution.copy()\n\n    # Edge insertion: randomly select a segment and insert it elsewhere\n    if len(new_solution) > 3:\n        i = random.randint(0, len(new_solution) - 3)\n        j = random.randint(i + 2, len(new_solution) - 1)\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    # Segment reversal: reverse a random segment\n    if len(new_solution) > 2:\n        i = random.randint(0, len(new_solution) - 2)\n        j = random.randint(i + 1, len(new_solution) - 1)\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Novel node-swap heuristic: swap nodes that are close in both objective spaces\n    if len(new_solution) > 1:\n        # Find two nodes that are close in both distance matrices\n        node1 = random.choice(new_solution)\n        idx1 = np.where(new_solution == node1)[0][0]\n        # Find the closest node in both distance matrices\n        dist1 = distance_matrix_1[node1]\n        dist2 = distance_matrix_2[node1]\n        combined_dist = dist1 + dist2\n        combined_dist[node1] = np.inf  # Avoid self-swap\n        closest_node = np.argmin(combined_dist)\n        idx2 = np.where(new_solution == closest_node)[0][0]\n        # Swap the nodes\n        new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    return new_solution\n\n",
        "score": [
            -0.6665754697101943,
            1.1201115250587463
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Intelligent selection of a promising solution from the archive\n    # Prioritize solutions with lower total cost (sum of both objectives)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Apply hybrid local search\n    new_solution = selected_solution.copy()\n\n    # Edge insertion: randomly select a segment and insert it elsewhere\n    if len(new_solution) > 3:\n        i = random.randint(0, len(new_solution) - 3)\n        j = random.randint(i + 2, len(new_solution) - 1)\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    # Segment reversal: reverse a random segment\n    if len(new_solution) > 2:\n        i = random.randint(0, len(new_solution) - 2)\n        j = random.randint(i + 1, len(new_solution) - 1)\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Novel node-swap heuristic: swap nodes that are close in both objective spaces\n    if len(new_solution) > 1:\n        # Find two nodes that are close in both distance matrices\n        node1 = random.choice(new_solution)\n        idx1 = np.where(new_solution == node1)[0][0]\n        # Find the closest node in both distance matrices\n        dist1 = distance_matrix_1[node1]\n        dist2 = distance_matrix_2[node1]\n        combined_dist = dist1 + dist2\n        combined_dist[node1] = np.inf  # Avoid self-swap\n        closest_node = np.argmin(combined_dist)\n        idx2 = np.where(new_solution == closest_node)[0][0]\n        # Swap the nodes\n        new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 128,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with lower total costs\n    costs = np.array([sum(obj) for _, obj in archive])\n    probabilities = 1 / (costs + 1e-6)  # Avoid division by zero\n    probabilities = probabilities / probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    if random.random() < 0.7:  # 70% chance for edge swap\n        # Perform a random edge swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:  # 30% chance for segment relocation\n        # Relocate a random segment to a different position\n        segment_length = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        remaining = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n        insert_pos = random.randint(0, len(remaining))\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure the solution remains feasible (no duplicates, all nodes present)\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.9063724083922096,
            0.9684042930603027
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with lower total costs\n    costs = np.array([sum(obj) for _, obj in archive])\n    probabilities = 1 / (costs + 1e-6)  # Avoid division by zero\n    probabilities = probabilities / probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    if random.random() < 0.7:  # 70% chance for edge swap\n        # Perform a random edge swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:  # 30% chance for segment relocation\n        # Relocate a random segment to a different position\n        segment_length = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        remaining = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n        insert_pos = random.randint(0, len(remaining))\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure the solution remains feasible (no duplicates, all nodes present)\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 129,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    norm_objectives = objectives / (objectives.sum(axis=0) + 1e-10)\n    weights = 1 / (norm_objectives.sum(axis=1) + 1e-10)\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of edge insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select two distinct segments\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    c, d = sorted(random.sample(range(1, n-1), 2))\n\n    # Ensure segments don't overlap\n    if a < c < b < d:\n        # Insert segment [c:d] into position a\n        segment = new_solution[c:d]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:c], new_solution[d:]])\n    elif c < a < d < b:\n        # Insert segment [a:b] into position c\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:c], segment, new_solution[c:a], new_solution[b:]])\n    else:\n        # Reverse one of the segments\n        if random.random() < 0.5:\n            new_solution[a:b] = new_solution[a:b][::-1]\n        else:\n            new_solution[c:d] = new_solution[c:d][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7632236446545515,
            1.0423640012741089
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    norm_objectives = objectives / (objectives.sum(axis=0) + 1e-10)\n    weights = 1 / (norm_objectives.sum(axis=1) + 1e-10)\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of edge insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select two distinct segments\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    c, d = sorted(random.sample(range(1, n-1), 2))\n\n    # Ensure segments don't overlap\n    if a < c < b < d:\n        # Insert segment [c:d] into position a\n        segment = new_solution[c:d]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:c], new_solution[d:]])\n    elif c < a < d < b:\n        # Insert segment [a:b] into position c\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:c], segment, new_solution[c:a], new_solution[b:]])\n    else:\n        # Reverse one of the segments\n        if random.random() < 0.5:\n            new_solution[a:b] = new_solution[a:b][::-1]\n        else:\n            new_solution[c:d] = new_solution[c:d][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 130,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-front solutions or those with high diversity)\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel edge insertion\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Perform 2-opt on a random segment\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Novel edge insertion: insert a random node at a random position while maintaining feasibility\n    if n > 3:\n        node_to_insert = random.choice(new_solution)\n        pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node_to_insert)\n        # Remove duplicate (since we're inserting, not swapping)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_insert)[0][1])\n\n    return new_solution\n\n",
        "score": [
            -0.8668804127309553,
            1.3873270153999329
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-front solutions or those with high diversity)\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel edge insertion\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Perform 2-opt on a random segment\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Novel edge insertion: insert a random node at a random position while maintaining feasibility\n    if n > 3:\n        node_to_insert = random.choice(new_solution)\n        pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node_to_insert)\n        # Remove duplicate (since we're inserting, not swapping)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_insert)[0][1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 131,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest cost in either space)\n    archive_sorted = sorted(archive, key=lambda x: min(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom move\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three segments to perform a 3-opt move\n    a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Reconstruct the solution with segments in different orders\n    new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Apply a custom move: reverse a random segment to improve both objectives\n    if np.random.rand() < 0.5:\n        start, end = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    if not np.array_equal(np.unique(new_solution), np.arange(len(new_solution))):\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.3401726707724099,
            1.5338138341903687
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest cost in either space)\n    archive_sorted = sorted(archive, key=lambda x: min(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom move\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three segments to perform a 3-opt move\n    a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Reconstruct the solution with segments in different orders\n    new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Apply a custom move: reverse a random segment to improve both objectives\n    if np.random.rand() < 0.5:\n        start, end = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    if not np.array_equal(np.unique(new_solution), np.arange(len(new_solution))):\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 132,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_solution = None\n    for sol, _ in archive:\n        # Check if this solution is not dominated by any other in the archive\n        is_dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= sol[0] and other_obj[1] <= sol[1] and\n                (other_obj[0] < sol[0] or other_obj[1] < sol[1])):\n                is_dominated = True\n                break\n        if not is_dominated:\n            selected_solution = sol.copy()\n            break\n\n    if selected_solution is None:\n        # If all solutions are dominated, select the one with the best combined cost\n        selected_solution = min(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: edge swaps + segment relocation\n    for _ in range(10):  # Number of attempts to find improvement\n        # Randomly choose between edge swap or segment relocation\n        if np.random.rand() < 0.5:\n            # Edge swap (2-opt variant)\n            i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Segment relocation (novel operator)\n            i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n            segment = new_solution[i:j]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n        # Ensure the solution remains valid (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.890944419147876,
            1.5486710667610168
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_solution = None\n    for sol, _ in archive:\n        # Check if this solution is not dominated by any other in the archive\n        is_dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= sol[0] and other_obj[1] <= sol[1] and\n                (other_obj[0] < sol[0] or other_obj[1] < sol[1])):\n                is_dominated = True\n                break\n        if not is_dominated:\n            selected_solution = sol.copy()\n            break\n\n    if selected_solution is None:\n        # If all solutions are dominated, select the one with the best combined cost\n        selected_solution = min(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: edge swaps + segment relocation\n    for _ in range(10):  # Number of attempts to find improvement\n        # Randomly choose between edge swap or segment relocation\n        if np.random.rand() < 0.5:\n            # Edge swap (2-opt variant)\n            i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Segment relocation (novel operator)\n            i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n            segment = new_solution[i:j]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n        # Ensure the solution remains valid (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 133,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by a combined objective score (e.g., sum of normalized objectives)\n        objectives = np.array([obj for _, obj in archive])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n        scores = normalized.sum(axis=1)\n        # Select solutions with lower scores (better potential)\n        candidates = [sol for sol, _ in archive]\n        selected_idx = np.argmin(scores)\n        base_solution = candidates[selected_idx].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: variable-length segment relocation with edge insertion\n    if n > 4:\n        # Randomly select a segment length (between 2 and min(n//4, 10))\n        segment_length = random.randint(2, min(n // 4, 10))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start + segment_length]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:start], new_solution[start + segment_length:]])\n\n        # Find the best insertion point for the segment\n        best_insertion = 0\n        min_cost = float('inf')\n\n        for i in range(len(new_solution) - segment_length + 1):\n            # Insert the segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n\n            # Evaluate the candidate (combine both objectives)\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(1, len(candidate)))\n            cost1 += distance_matrix_1[candidate[-1], candidate[0]]  # Return to start\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(1, len(candidate)))\n            cost2 += distance_matrix_2[candidate[-1], candidate[0]]  # Return to start\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_insertion = i\n\n        # Perform the best insertion\n        new_solution = np.concatenate([new_solution[:best_insertion], segment, new_solution[best_insertion:]])\n\n    # Edge insertion for fine-tuning\n    for _ in range(2):  # Perform 2 edge insertions\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        # Remove edges (i-1, i) and (j, j+1), and insert (i-1, j) and (i, j+1)\n        new_solution = np.concatenate([\n            new_solution[:i],\n            new_solution[i:j+1][::-1],\n            new_solution[j+1:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -0.8095033813078947,
            5.726255714893341
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by a combined objective score (e.g., sum of normalized objectives)\n        objectives = np.array([obj for _, obj in archive])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n        scores = normalized.sum(axis=1)\n        # Select solutions with lower scores (better potential)\n        candidates = [sol for sol, _ in archive]\n        selected_idx = np.argmin(scores)\n        base_solution = candidates[selected_idx].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: variable-length segment relocation with edge insertion\n    if n > 4:\n        # Randomly select a segment length (between 2 and min(n//4, 10))\n        segment_length = random.randint(2, min(n // 4, 10))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start + segment_length]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:start], new_solution[start + segment_length:]])\n\n        # Find the best insertion point for the segment\n        best_insertion = 0\n        min_cost = float('inf')\n\n        for i in range(len(new_solution) - segment_length + 1):\n            # Insert the segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n\n            # Evaluate the candidate (combine both objectives)\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(1, len(candidate)))\n            cost1 += distance_matrix_1[candidate[-1], candidate[0]]  # Return to start\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(1, len(candidate)))\n            cost2 += distance_matrix_2[candidate[-1], candidate[0]]  # Return to start\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_insertion = i\n\n        # Perform the best insertion\n        new_solution = np.concatenate([new_solution[:best_insertion], segment, new_solution[best_insertion:]])\n\n    # Edge insertion for fine-tuning\n    for _ in range(2):  # Perform 2 edge insertions\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        # Remove edges (i-1, i) and (j, j+1), and insert (i-1, j) and (i, j+1)\n        new_solution = np.concatenate([\n            new_solution[:i],\n            new_solution[i:j+1][::-1],\n            new_solution[j+1:]\n        ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 134,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest objective values)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine 3-opt with a novel swap-based operator\n    for _ in range(10):  # Number of iterations to explore\n        i, j, k = sorted(random.sample(range(n), 3))\n\n        # Apply 3-opt move\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        segment3 = new_solution[k:]\n\n        # Reconstruct the solution with the segments in different orders\n        new_solution = np.concatenate([new_solution[:i], segment2, segment1, segment3])\n\n        # Check feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Novel swap-based operator: swap two non-adjacent segments\n    if random.random() < 0.5:\n        a, b = sorted(random.sample(range(n), 2))\n        while b - a < 2:  # Ensure segments are of reasonable size\n            a, b = sorted(random.sample(range(n), 2))\n\n        # Swap two non-adjacent segments\n        segment_a = new_solution[a:b]\n        segment_b = new_solution[b:]\n        new_solution = np.concatenate([new_solution[:a], segment_b, segment_a])\n\n    return new_solution\n\n",
        "score": [
            -0.7521163746905976,
            1.1922174096107483
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest objective values)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine 3-opt with a novel swap-based operator\n    for _ in range(10):  # Number of iterations to explore\n        i, j, k = sorted(random.sample(range(n), 3))\n\n        # Apply 3-opt move\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        segment3 = new_solution[k:]\n\n        # Reconstruct the solution with the segments in different orders\n        new_solution = np.concatenate([new_solution[:i], segment2, segment1, segment3])\n\n        # Check feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Novel swap-based operator: swap two non-adjacent segments\n    if random.random() < 0.5:\n        a, b = sorted(random.sample(range(n), 2))\n        while b - a < 2:  # Ensure segments are of reasonable size\n            a, b = sorted(random.sample(range(n), 2))\n\n        # Swap two non-adjacent segments\n        segment_a = new_solution[a:b]\n        segment_b = new_solution[b:]\n        new_solution = np.concatenate([new_solution[:a], segment_b, segment_a])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 135,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # Here, we select the solution with the highest sum of objectives (could be adjusted)\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with a custom edge-swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform random 2-opt\n    i, j = sorted(random.sample(range(1, n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform custom edge-swap: swap two edges that are not adjacent\n    if n > 4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        if a != b and abs(a - b) > 1:  # Ensure edges are not adjacent\n            # Swap edges (a, a+1) and (b, b+1)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(set(new_solution)) != n or len(new_solution) != n:\n        # Fallback to simple 2-opt if custom operation fails\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9553302057686578,
            1.5916807055473328
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # Here, we select the solution with the highest sum of objectives (could be adjusted)\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with a custom edge-swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform random 2-opt\n    i, j = sorted(random.sample(range(1, n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform custom edge-swap: swap two edges that are not adjacent\n    if n > 4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        if a != b and abs(a - b) > 1:  # Ensure edges are not adjacent\n            # Swap edges (a, a+1) and (b, b+1)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(set(new_solution)) != n or len(new_solution) != n:\n        # Fallback to simple 2-opt if custom operation fails\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 136,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-6)\n    weights = 1 - normalized_objectives.mean(axis=1)  # Higher weight for solutions with worse objectives\n    weights = weights / weights.sum()  # Normalize to probability distribution\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: 3-opt with biased randomness\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct indices\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move with probability based on objective improvement\n    current_cost1 = distance_matrix_1[new_solution[a], new_solution[a+1]] + distance_matrix_1[new_solution[b], new_solution[b+1]]\n    current_cost2 = distance_matrix_2[new_solution[a], new_solution[a+1]] + distance_matrix_2[new_solution[b], new_solution[b+1]]\n\n    # Try all possible 3-opt configurations and select the best one\n    possible_swaps = [\n        (a, b, c), (a, c, b),  # Standard 3-opt\n        (a, b, c, 'reverse'), (a, c, b, 'reverse')  # With segment reversal\n    ]\n\n    best_swap = None\n    best_improvement = 0\n\n    for swap in possible_swaps:\n        temp_solution = new_solution.copy()\n\n        if len(swap) == 3:\n            i, j, k = swap\n            temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n            temp_solution[j:k+1] = temp_solution[j:k+1][::-1]\n        else:\n            i, j, k, _ = swap\n            temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n            temp_solution[j:k+1] = temp_solution[j:k+1][::-1]\n            temp_solution[i:k+1] = temp_solution[i:k+1][::-1]\n\n        # Calculate new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        # Calculate improvement (normalized)\n        improvement1 = (current_cost1 - new_cost1) / (current_cost1 + 1e-6)\n        improvement2 = (current_cost2 - new_cost2) / (current_cost2 + 1e-6)\n        total_improvement = (improvement1 + improvement2) / 2\n\n        if total_improvement > best_improvement:\n            best_improvement = total_improvement\n            best_swap = swap\n\n    # Apply the best swap found\n    if best_swap:\n        if len(best_swap) == 3:\n            i, j, k = best_swap\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[j:k+1] = new_solution[j:k+1][::-1]\n        else:\n            i, j, k, _ = best_swap\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[j:k+1] = new_solution[j:k+1][::-1]\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n\n    # Occasionally apply a random 2-opt move for diversification\n    if random.random() < 0.2:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7709889973699214,
            2.0955705642700195
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-6)\n    weights = 1 - normalized_objectives.mean(axis=1)  # Higher weight for solutions with worse objectives\n    weights = weights / weights.sum()  # Normalize to probability distribution\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: 3-opt with biased randomness\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct indices\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move with probability based on objective improvement\n    current_cost1 = distance_matrix_1[new_solution[a], new_solution[a+1]] + distance_matrix_1[new_solution[b], new_solution[b+1]]\n    current_cost2 = distance_matrix_2[new_solution[a], new_solution[a+1]] + distance_matrix_2[new_solution[b], new_solution[b+1]]\n\n    # Try all possible 3-opt configurations and select the best one\n    possible_swaps = [\n        (a, b, c), (a, c, b),  # Standard 3-opt\n        (a, b, c, 'reverse'), (a, c, b, 'reverse')  # With segment reversal\n    ]\n\n    best_swap = None\n    best_improvement = 0\n\n    for swap in possible_swaps:\n        temp_solution = new_solution.copy()\n\n        if len(swap) == 3:\n            i, j, k = swap\n            temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n            temp_solution[j:k+1] = temp_solution[j:k+1][::-1]\n        else:\n            i, j, k, _ = swap\n            temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n            temp_solution[j:k+1] = temp_solution[j:k+1][::-1]\n            temp_solution[i:k+1] = temp_solution[i:k+1][::-1]\n\n        # Calculate new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        # Calculate improvement (normalized)\n        improvement1 = (current_cost1 - new_cost1) / (current_cost1 + 1e-6)\n        improvement2 = (current_cost2 - new_cost2) / (current_cost2 + 1e-6)\n        total_improvement = (improvement1 + improvement2) / 2\n\n        if total_improvement > best_improvement:\n            best_improvement = total_improvement\n            best_swap = swap\n\n    # Apply the best swap found\n    if best_swap:\n        if len(best_swap) == 3:\n            i, j, k = best_swap\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[j:k+1] = new_solution[j:k+1][::-1]\n        else:\n            i, j, k, _ = best_swap\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[j:k+1] = new_solution[j:k+1][::-1]\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n\n    # Occasionally apply a random 2-opt move for diversification\n    if random.random() < 0.2:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 137,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their combined objective values (sum of normalized costs)\n        objectives = np.array([obj for _, obj in archive])\n        normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n        combined_obj = normalized_obj.sum(axis=1)\n        sorted_indices = np.argsort(combined_obj)\n        # Select a solution from the top 30% of non-dominated solutions\n        selection_pool = sorted_indices[:max(1, len(archive) // 3)]\n        selected_idx = random.choice(selection_pool)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: segment relocation with edge insertion\n    if n > 3:\n        # Step 1: Select a random segment of 2-3 nodes\n        segment_start = random.randint(0, n - 3)\n        segment_length = random.randint(2, min(3, n - segment_start - 1))\n        segment = new_solution[segment_start:segment_start + segment_length]\n\n        # Step 2: Remove the segment and insert it elsewhere\n        new_solution = np.concatenate([new_solution[:segment_start], new_solution[segment_start + segment_length:]])\n\n        # Step 3: Find the best insertion point for the segment\n        best_insert_pos = 0\n        best_cost = float('inf')\n\n        for i in range(len(new_solution) - 1):\n            # Try inserting after position i\n            temp_solution = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n            cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(len(temp_solution)-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n            cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(len(temp_solution)-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n            combined_cost = cost1 + cost2\n\n            if combined_cost < best_cost:\n                best_cost = combined_cost\n                best_insert_pos = i + 1\n\n        # Insert the segment at the best position\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n\n        # Step 4: Apply edge insertion for further improvement\n        for _ in range(2):  # Limit to 2 edge insertions for efficiency\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            while abs(i - j) < 2:  # Ensure sufficient distance between nodes\n                j = random.randint(0, n-1)\n\n            # Remove edges (i, i+1) and (j, j+1)\n            temp_solution = new_solution.copy()\n            temp_solution = np.concatenate([temp_solution[:i+1], temp_solution[j+1:]])\n\n            # Insert edge (i, j+1) and (j, i+1)\n            new_segment = np.concatenate([temp_solution[i+1:j+1], temp_solution[i:i+1]])\n            temp_solution = np.concatenate([temp_solution[:i+1], new_segment, temp_solution[j+1:]])\n\n            # Check if the new solution is better\n            cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(len(temp_solution)-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n            cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(len(temp_solution)-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n            # Accept if better or with small probability to escape local optima\n            if (cost1 + cost2) < best_cost or random.random() < 0.1:\n                new_solution = temp_solution.copy()\n                best_cost = cost1 + cost2\n\n    return new_solution\n\n",
        "score": [
            -0.6307941931487496,
            5.684917092323303
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their combined objective values (sum of normalized costs)\n        objectives = np.array([obj for _, obj in archive])\n        normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n        combined_obj = normalized_obj.sum(axis=1)\n        sorted_indices = np.argsort(combined_obj)\n        # Select a solution from the top 30% of non-dominated solutions\n        selection_pool = sorted_indices[:max(1, len(archive) // 3)]\n        selected_idx = random.choice(selection_pool)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: segment relocation with edge insertion\n    if n > 3:\n        # Step 1: Select a random segment of 2-3 nodes\n        segment_start = random.randint(0, n - 3)\n        segment_length = random.randint(2, min(3, n - segment_start - 1))\n        segment = new_solution[segment_start:segment_start + segment_length]\n\n        # Step 2: Remove the segment and insert it elsewhere\n        new_solution = np.concatenate([new_solution[:segment_start], new_solution[segment_start + segment_length:]])\n\n        # Step 3: Find the best insertion point for the segment\n        best_insert_pos = 0\n        best_cost = float('inf')\n\n        for i in range(len(new_solution) - 1):\n            # Try inserting after position i\n            temp_solution = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n            cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(len(temp_solution)-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n            cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(len(temp_solution)-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n            combined_cost = cost1 + cost2\n\n            if combined_cost < best_cost:\n                best_cost = combined_cost\n                best_insert_pos = i + 1\n\n        # Insert the segment at the best position\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n\n        # Step 4: Apply edge insertion for further improvement\n        for _ in range(2):  # Limit to 2 edge insertions for efficiency\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            while abs(i - j) < 2:  # Ensure sufficient distance between nodes\n                j = random.randint(0, n-1)\n\n            # Remove edges (i, i+1) and (j, j+1)\n            temp_solution = new_solution.copy()\n            temp_solution = np.concatenate([temp_solution[:i+1], temp_solution[j+1:]])\n\n            # Insert edge (i, j+1) and (j, i+1)\n            new_segment = np.concatenate([temp_solution[i+1:j+1], temp_solution[i:i+1]])\n            temp_solution = np.concatenate([temp_solution[:i+1], new_segment, temp_solution[j+1:]])\n\n            # Check if the new solution is better\n            cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(len(temp_solution)-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n            cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(len(temp_solution)-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n            # Accept if better or with small probability to escape local optima\n            if (cost1 + cost2) < best_cost or random.random() < 0.1:\n                new_solution = temp_solution.copy()\n                best_cost = cost1 + cost2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 138,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards lower costs\n    costs = np.array([sum(obj) for _, obj in archive])\n    if len(costs) > 1:\n        weights = np.max(costs) - costs + 1e-6  # Inverse cost weighting\n        weights = weights / np.sum(weights)\n        selected_idx = np.random.choice(len(archive), p=weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    if n < 4:\n        # For small instances, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # For larger instances, perform a combination of edge exchange and node insertion\n        # Edge exchange (similar to 2-opt)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Node insertion (similar to Or-opt)\n        if n > 4:\n            k = random.randint(0, n-1)\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            -0.8969096010104706,
            1.5664252638816833
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards lower costs\n    costs = np.array([sum(obj) for _, obj in archive])\n    if len(costs) > 1:\n        weights = np.max(costs) - costs + 1e-6  # Inverse cost weighting\n        weights = weights / np.sum(weights)\n        selected_idx = np.random.choice(len(archive), p=weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    if n < 4:\n        # For small instances, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # For larger instances, perform a combination of edge exchange and node insertion\n        # Edge exchange (similar to 2-opt)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Node insertion (similar to Or-opt)\n        if n > 4:\n            k = random.randint(0, n-1)\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 139,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate potential for improvement (inverse of objective values)\n    potentials = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    total = sum(potentials)\n    probabilities = [p / total for p in potentials]\n\n    # Select a solution based on calculated probabilities\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: a combination of edge exchange and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments to exchange or reverse\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Apply edge exchange or segment reversal based on a random choice\n    if random.random() < 0.5:\n        # Edge exchange: swap two edges\n        if j - i == 1 and l - k == 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n    else:\n        # Segment reversal: reverse a segment\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure the solution remains feasible (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap\n        new_solution = base_solution.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8494596259601588,
            1.5445418953895569
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate potential for improvement (inverse of objective values)\n    potentials = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    total = sum(potentials)\n    probabilities = [p / total for p in potentials]\n\n    # Select a solution based on calculated probabilities\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: a combination of edge exchange and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments to exchange or reverse\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Apply edge exchange or segment reversal based on a random choice\n    if random.random() < 0.5:\n        # Edge exchange: swap two edges\n        if j - i == 1 and l - k == 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n    else:\n        # Segment reversal: reverse a segment\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure the solution remains feasible (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap\n        new_solution = base_solution.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 140,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in at least one objective)\n    archive_sorted = sorted(archive, key=lambda x: min(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    # Step 1: Edge swapping (2-opt variant with multi-objective consideration)\n    a, b = sorted(random.sample(range(n), 2))\n    if a != b:\n        # Reverse the segment between a and b\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 2: Path relocation (novel operator)\n    if n > 4:\n        # Choose a random segment and relocate it to a different position\n        seg_start, seg_end = sorted(random.sample(range(n), 2))\n        if seg_end - seg_start > 1:\n            segment = new_solution[seg_start:seg_end]\n            remaining = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n            insert_pos = random.randint(0, len(remaining))\n            new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.33775319655984,
            0.8191735744476318
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in at least one objective)\n    archive_sorted = sorted(archive, key=lambda x: min(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    # Step 1: Edge swapping (2-opt variant with multi-objective consideration)\n    a, b = sorted(random.sample(range(n), 2))\n    if a != b:\n        # Reverse the segment between a and b\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 2: Path relocation (novel operator)\n    if n > 4:\n        # Choose a random segment and relocate it to a different position\n        seg_start, seg_end = sorted(random.sample(range(n), 2))\n        if seg_end - seg_start > 1:\n            segment = new_solution[seg_start:seg_end]\n            remaining = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n            insert_pos = random.randint(0, len(remaining))\n            new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 141,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_solution = archive[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Apply hybrid local search: edge exchange followed by segment relocation\n    n = len(new_solution)\n    if n <= 3:\n        return new_solution\n\n    # Edge exchange (similar to 2-opt but with a twist)\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    if random.random() < 0.5:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]  # Reverse segment\n    else:\n        # Swap two edges (more disruptive)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment relocation (novel heuristic)\n    if n > 4:\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(1, n - segment_length - 1)\n        segment = new_solution[start:start+segment_length]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:], segment])\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by inserting missing nodes\n        missing = list(set(range(n)) - set(new_solution))\n        for node in missing:\n            pos = random.randint(1, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.4649285402482803,
            1.0574308633804321
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_solution = archive[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Apply hybrid local search: edge exchange followed by segment relocation\n    n = len(new_solution)\n    if n <= 3:\n        return new_solution\n\n    # Edge exchange (similar to 2-opt but with a twist)\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    if random.random() < 0.5:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]  # Reverse segment\n    else:\n        # Swap two edges (more disruptive)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment relocation (novel heuristic)\n    if n > 4:\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(1, n - segment_length - 1)\n        segment = new_solution[start:start+segment_length]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:], segment])\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by inserting missing nodes\n        missing = list(set(range(n)) - set(new_solution))\n        for node in missing:\n            pos = random.randint(1, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 142,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    archive_sorted = sorted(archive, key=lambda x: min(x[1][0], x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine 3-opt with a novel insertion-based operator\n    if n >= 4:\n        # Randomly select 3 distinct indices to perform 3-opt\n        a, b, c = sorted(random.sample(range(n), 3))\n        # Perform 3-opt by reversing segments\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n    else:\n        # For small instances, use a simple swap\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Additional novel operator: try to insert a node from a different solution\n    if len(archive) > 1:\n        other_solution = random.choice(archive)[0]\n        node_to_insert = random.choice(other_solution)\n        if node_to_insert not in new_solution:\n            # Find a position to insert the node that minimizes the total cost\n            best_pos = 0\n            min_cost = float('inf')\n            for i in range(n):\n                temp_solution = np.insert(new_solution, i, node_to_insert)\n                cost1 = sum(distance_matrix_1[temp_solution[j], temp_solution[j+1]] for j in range(n))\n                cost2 = sum(distance_matrix_2[temp_solution[j], temp_solution[j+1]] for j in range(n))\n                total_cost = cost1 + cost2\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_pos = i\n            new_solution = np.insert(new_solution, best_pos, node_to_insert)\n\n    return new_solution\n\n",
        "score": [
            -0.3452114521520936,
            1.6285721063613892
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    archive_sorted = sorted(archive, key=lambda x: min(x[1][0], x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine 3-opt with a novel insertion-based operator\n    if n >= 4:\n        # Randomly select 3 distinct indices to perform 3-opt\n        a, b, c = sorted(random.sample(range(n), 3))\n        # Perform 3-opt by reversing segments\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n    else:\n        # For small instances, use a simple swap\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Additional novel operator: try to insert a node from a different solution\n    if len(archive) > 1:\n        other_solution = random.choice(archive)[0]\n        node_to_insert = random.choice(other_solution)\n        if node_to_insert not in new_solution:\n            # Find a position to insert the node that minimizes the total cost\n            best_pos = 0\n            min_cost = float('inf')\n            for i in range(n):\n                temp_solution = np.insert(new_solution, i, node_to_insert)\n                cost1 = sum(distance_matrix_1[temp_solution[j], temp_solution[j+1]] for j in range(n))\n                cost2 = sum(distance_matrix_2[temp_solution[j], temp_solution[j+1]] for j in range(n))\n                total_cost = cost1 + cost2\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_pos = i\n            new_solution = np.insert(new_solution, best_pos, node_to_insert)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 143,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its dominance\n    # Solutions with higher costs are more likely to be selected for improvement\n    objectives = [obj for _, obj in archive]\n    costs = np.array([sum(obj) for obj in objectives])\n    if np.all(costs == costs[0]):\n        # All solutions have the same cost, select randomly\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        # Invert costs to make higher costs more likely to be selected\n        inverted_costs = 1 / (costs + 1e-10)  # Avoid division by zero\n        probabilities = inverted_costs / np.sum(inverted_costs)\n        selected_idx = np.random.choice(len(archive), p=probabilities)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a custom edge swap\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # No improvement possible for small instances\n\n    # Randomly select three distinct edges to modify\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Perform a 3-opt move: reverse the middle segment\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Custom edge swap: swap edges between i and k to explore different configurations\n    if random.random() < 0.5:\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    # Ensure the tour is valid by checking for duplicates and missing nodes\n    if len(set(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8998209920023887,
            1.0734320282936096
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its dominance\n    # Solutions with higher costs are more likely to be selected for improvement\n    objectives = [obj for _, obj in archive]\n    costs = np.array([sum(obj) for obj in objectives])\n    if np.all(costs == costs[0]):\n        # All solutions have the same cost, select randomly\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        # Invert costs to make higher costs more likely to be selected\n        inverted_costs = 1 / (costs + 1e-10)  # Avoid division by zero\n        probabilities = inverted_costs / np.sum(inverted_costs)\n        selected_idx = np.random.choice(len(archive), p=probabilities)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a custom edge swap\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # No improvement possible for small instances\n\n    # Randomly select three distinct edges to modify\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Perform a 3-opt move: reverse the middle segment\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Custom edge swap: swap edges between i and k to explore different configurations\n    if random.random() < 0.5:\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    # Ensure the tour is valid by checking for duplicates and missing nodes\n    if len(set(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 144,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best but not the worst)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate the dominance rank (simplified) to identify solutions with potential\n    ranks = []\n    for i in range(len(archive_objectives)):\n        dominated = 0\n        for j in range(len(archive_objectives)):\n            if i != j and archive_objectives[j][0] <= archive_objectives[i][0] and archive_objectives[j][1] <= archive_objectives[i][1]:\n                dominated += 1\n        ranks.append(dominated)\n\n    # Select a solution with moderate rank (not top or bottom)\n    if len(ranks) > 2:\n        selected_indices = np.argsort(ranks)[len(ranks)//3 : 2*len(ranks)//3]\n        selected_index = random.choice(selected_indices)\n    else:\n        selected_index = random.randint(0, len(archive) - 1)\n\n    base_solution = archive_solutions[selected_index].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge-swap operator\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Randomly select three edges to modify (3-opt)\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Step 2: Apply 3-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Step 3: Novel edge-swap operator - swap edges between two segments\n    if random.random() < 0.5 and n > 4:\n        l, m = sorted(random.sample(range(n), 2))\n        if l != i and l != j and l != k and m != i and m != j and m != k:\n            # Ensure the swap maintains feasibility\n            if l < m:\n                new_solution[l], new_solution[m] = new_solution[m], new_solution[l]\n\n    # Ensure the solution remains a valid tour\n    if len(set(new_solution)) != n:\n        return base_solution  # Fallback to original if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.7771181562584673,
            2.3012704849243164
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best but not the worst)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate the dominance rank (simplified) to identify solutions with potential\n    ranks = []\n    for i in range(len(archive_objectives)):\n        dominated = 0\n        for j in range(len(archive_objectives)):\n            if i != j and archive_objectives[j][0] <= archive_objectives[i][0] and archive_objectives[j][1] <= archive_objectives[i][1]:\n                dominated += 1\n        ranks.append(dominated)\n\n    # Select a solution with moderate rank (not top or bottom)\n    if len(ranks) > 2:\n        selected_indices = np.argsort(ranks)[len(ranks)//3 : 2*len(ranks)//3]\n        selected_index = random.choice(selected_indices)\n    else:\n        selected_index = random.randint(0, len(archive) - 1)\n\n    base_solution = archive_solutions[selected_index].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge-swap operator\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Randomly select three edges to modify (3-opt)\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Step 2: Apply 3-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Step 3: Novel edge-swap operator - swap edges between two segments\n    if random.random() < 0.5 and n > 4:\n        l, m = sorted(random.sample(range(n), 2))\n        if l != i and l != j and l != k and m != i and m != j and m != k:\n            # Ensure the swap maintains feasibility\n            if l < m:\n                new_solution[l], new_solution[m] = new_solution[m], new_solution[l]\n\n    # Ensure the solution remains a valid tour\n    if len(set(new_solution)) != n:\n        return base_solution  # Fallback to original if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 145,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its dominance rank\n    # (simplified here by selecting the solution with the lowest sum of objectives)\n    objectives = [obj for _, obj in archive]\n    ranks = np.argsort([sum(obj) for obj in objectives])\n    selected_idx = np.random.choice(ranks[:max(1, len(ranks)//2)])  # Select from top half\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply hybrid local search\n    # 1. Random edge swap\n    i, j = np.random.choice(n, 2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # 2. Segment reversal (novel component)\n    start, end = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # 3. Insertion heuristic (novel component)\n    if n > 3:\n        # Randomly select a segment and insert it elsewhere\n        seg_start, seg_end = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[seg_start:seg_end+1]\n        remaining = np.concatenate([new_solution[:seg_start], new_solution[seg_end+1:]])\n\n        # Find best insertion point (minimizing both objectives)\n        best_pos = 0\n        best_cost = float('inf')\n\n        for pos in range(len(remaining)):\n            candidate = np.concatenate([remaining[:pos], segment, remaining[pos:]])\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        new_solution = np.concatenate([remaining[:best_pos], segment, remaining[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.876391210175182,
            4.9512423276901245
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its dominance rank\n    # (simplified here by selecting the solution with the lowest sum of objectives)\n    objectives = [obj for _, obj in archive]\n    ranks = np.argsort([sum(obj) for obj in objectives])\n    selected_idx = np.random.choice(ranks[:max(1, len(ranks)//2)])  # Select from top half\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply hybrid local search\n    # 1. Random edge swap\n    i, j = np.random.choice(n, 2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # 2. Segment reversal (novel component)\n    start, end = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # 3. Insertion heuristic (novel component)\n    if n > 3:\n        # Randomly select a segment and insert it elsewhere\n        seg_start, seg_end = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[seg_start:seg_end+1]\n        remaining = np.concatenate([new_solution[:seg_start], new_solution[seg_end+1:]])\n\n        # Find best insertion point (minimizing both objectives)\n        best_pos = 0\n        best_cost = float('inf')\n\n        for pos in range(len(remaining)):\n            candidate = np.concatenate([remaining[:pos], segment, remaining[pos:]])\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        new_solution = np.concatenate([remaining[:best_pos], segment, remaining[best_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 146,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (non-dominated or with high diversity)\n    selected_solution = max(archive, key=lambda x: np.sum(x[1]))[0].copy()\n\n    # Novel hybrid local search: 3-opt* with objective-aware edge selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Select three random edges (i, j), (k, l), (m, n) ensuring they are not adjacent and form a valid 3-opt move\n    indices = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted(indices)\n\n    # Ensure the selected edges are not adjacent and form a valid 3-opt move\n    if j == i + 1 or k == j + 1:\n        return new_solution  # Fall back to original if invalid\n\n    # Extract the segments to be reordered\n    segment1 = new_solution[:i+1]\n    segment2 = new_solution[i+1:j+1]\n    segment3 = new_solution[j+1:k+1]\n    segment4 = new_solution[k+1:]\n\n    # Reorder segments to form a new tour\n    # Try all possible permutations of the middle segments to minimize both objectives\n    best_permutation = None\n    best_cost = (float('inf'), float('inf'))\n\n    # Generate all possible permutations of the middle segments (3! = 6 possibilities)\n    for perm in [(segment2, segment3), (segment3, segment2)]:\n        candidate = np.concatenate([segment1, perm[0], perm[1], segment4])\n\n        # Calculate the total cost in both objective spaces\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n        # Update best permutation if it dominates the current best\n        if (cost1 <= best_cost[0] and cost2 < best_cost[1]) or (cost1 < best_cost[0] and cost2 <= best_cost[1]):\n            best_permutation = candidate\n            best_cost = (cost1, cost2)\n\n    if best_permutation is not None:\n        new_solution = best_permutation\n\n    return new_solution\n\n",
        "score": [
            -0.802108346924822,
            2.619086980819702
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (non-dominated or with high diversity)\n    selected_solution = max(archive, key=lambda x: np.sum(x[1]))[0].copy()\n\n    # Novel hybrid local search: 3-opt* with objective-aware edge selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Select three random edges (i, j), (k, l), (m, n) ensuring they are not adjacent and form a valid 3-opt move\n    indices = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted(indices)\n\n    # Ensure the selected edges are not adjacent and form a valid 3-opt move\n    if j == i + 1 or k == j + 1:\n        return new_solution  # Fall back to original if invalid\n\n    # Extract the segments to be reordered\n    segment1 = new_solution[:i+1]\n    segment2 = new_solution[i+1:j+1]\n    segment3 = new_solution[j+1:k+1]\n    segment4 = new_solution[k+1:]\n\n    # Reorder segments to form a new tour\n    # Try all possible permutations of the middle segments to minimize both objectives\n    best_permutation = None\n    best_cost = (float('inf'), float('inf'))\n\n    # Generate all possible permutations of the middle segments (3! = 6 possibilities)\n    for perm in [(segment2, segment3), (segment3, segment2)]:\n        candidate = np.concatenate([segment1, perm[0], perm[1], segment4])\n\n        # Calculate the total cost in both objective spaces\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n        # Update best permutation if it dominates the current best\n        if (cost1 <= best_cost[0] and cost2 < best_cost[1]) or (cost1 < best_cost[0] and cost2 <= best_cost[1]):\n            best_permutation = candidate\n            best_cost = (cost1, cost2)\n\n    if best_permutation is not None:\n        new_solution = best_permutation\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 147,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto front solutions or diverse solutions)\n    # Here, we select a random solution with a probability weighted by its objective values\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    fitness = np.sum(normalized_obj, axis=1)\n    probabilities = fitness / np.sum(fitness)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine edge exchange and segment relocation\n    # First, perform a random edge exchange (2-opt-like move)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, perform a segment relocation (similar to LK heuristic)\n    if n > 3:\n        k = np.random.randint(1, n-2)\n        l = np.random.randint(k+1, n-1)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], new_solution[l:], segment])\n\n    # Ensure the solution is valid (no duplicates and all nodes are visited)\n    if len(set(new_solution)) != n or len(new_solution) != n:\n        # Fallback to a simple swap if the above operations are invalid\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8077356634972812,
            1.9430273175239563
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto front solutions or diverse solutions)\n    # Here, we select a random solution with a probability weighted by its objective values\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    fitness = np.sum(normalized_obj, axis=1)\n    probabilities = fitness / np.sum(fitness)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine edge exchange and segment relocation\n    # First, perform a random edge exchange (2-opt-like move)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, perform a segment relocation (similar to LK heuristic)\n    if n > 3:\n        k = np.random.randint(1, n-2)\n        l = np.random.randint(k+1, n-1)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], new_solution[l:], segment])\n\n    # Ensure the solution is valid (no duplicates and all nodes are visited)\n    if len(set(new_solution)) != n or len(new_solution) != n:\n        # Fallback to a simple swap if the above operations are invalid\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 148,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution that is not the best in both objectives to encourage diversity\n    if len(archive) > 1:\n        # Sort by the sum of objectives to find less dominant solutions\n        archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n        # Select a solution that is not the best in both objectives\n        selected_idx = min(1, len(archive_sorted) - 1)\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of 3-opt and edge exchange\n    n = len(new_solution)\n    if n < 4:\n        # If the tour is too small, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform 3-opt move\n        i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n        # Apply edge exchange to further improve the solution\n        for _ in range(min(3, n // 2)):\n            a, b = np.random.choice(n, size=2, replace=False)\n            if a > b:\n                a, b = b, a\n            segment = new_solution[a:b]\n            new_solution[a:b] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7391098344463085,
            1.1993739604949951
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution that is not the best in both objectives to encourage diversity\n    if len(archive) > 1:\n        # Sort by the sum of objectives to find less dominant solutions\n        archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n        # Select a solution that is not the best in both objectives\n        selected_idx = min(1, len(archive_sorted) - 1)\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of 3-opt and edge exchange\n    n = len(new_solution)\n    if n < 4:\n        # If the tour is too small, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform 3-opt move\n        i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n        # Apply edge exchange to further improve the solution\n        for _ in range(min(3, n // 2)):\n            a, b = np.random.choice(n, size=2, replace=False)\n            if a > b:\n                a, b = b, a\n            segment = new_solution[a:b]\n            new_solution[a:b] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 149,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its current cost\n    costs = np.array([obj[0] + obj[1] for _, obj in archive])\n    probabilities = 1 / (costs + 1e-10)  # Add small epsilon to avoid division by zero\n    probabilities = probabilities / probabilities.sum()\n    selected_index = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_index][0].copy()\n\n    # Hybrid local search operator: combine 3-opt with a novel segment relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct positions\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse the middle segment\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Novel segment relocation: move a segment to a new position\n    segment_length = random.randint(2, min(5, n - 3))  # Random segment length between 2 and 5\n    start = random.randint(0, n - segment_length - 1)\n    segment = new_solution[start:start + segment_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start + segment_length:]])\n    insert_pos = random.randint(0, len(new_solution) - segment_length)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure the solution is still a valid tour\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Fallback to original if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.8049337421642448,
            1.557880699634552
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its current cost\n    costs = np.array([obj[0] + obj[1] for _, obj in archive])\n    probabilities = 1 / (costs + 1e-10)  # Add small epsilon to avoid division by zero\n    probabilities = probabilities / probabilities.sum()\n    selected_index = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_index][0].copy()\n\n    # Hybrid local search operator: combine 3-opt with a novel segment relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct positions\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse the middle segment\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Novel segment relocation: move a segment to a new position\n    segment_length = random.randint(2, min(5, n - 3))  # Random segment length between 2 and 5\n    start = random.randint(0, n - segment_length - 1)\n    segment = new_solution[start:start + segment_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start + segment_length:]])\n    insert_pos = random.randint(0, len(new_solution) - segment_length)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure the solution is still a valid tour\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Fallback to original if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 150,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability weighted by its non-dominated rank\n    # Here, we assume the archive is sorted by non-dominated rank (lower is better)\n    ranks = np.arange(len(archive))\n    selection_probs = np.exp(-ranks)  # Higher probability for better-ranked solutions\n    selection_probs /= selection_probs.sum()\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 2-opt with segment relocation\n    if n > 3:\n        # 2-opt operator (standard)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Segment relocation (novel operator)\n        if n > 5:\n            segment_length = random.randint(2, min(5, n // 2))\n            start = random.randint(0, n - segment_length)\n            end = start + segment_length\n            segment = new_solution[start:end]\n\n            # Remove the segment\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n\n            # Insert the segment at a new position\n            insert_pos = random.randint(0, len(new_solution) - segment_length + 1)\n            new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.7733227070707562,
            1.5814419388771057
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability weighted by its non-dominated rank\n    # Here, we assume the archive is sorted by non-dominated rank (lower is better)\n    ranks = np.arange(len(archive))\n    selection_probs = np.exp(-ranks)  # Higher probability for better-ranked solutions\n    selection_probs /= selection_probs.sum()\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 2-opt with segment relocation\n    if n > 3:\n        # 2-opt operator (standard)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Segment relocation (novel operator)\n        if n > 5:\n            segment_length = random.randint(2, min(5, n // 2))\n            start = random.randint(0, n - segment_length)\n            end = start + segment_length\n            segment = new_solution[start:end]\n\n            # Remove the segment\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n\n            # Insert the segment at a new position\n            insert_pos = random.randint(0, len(new_solution) - segment_length + 1)\n            new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 151,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: Combination of edge insertion and segment reversal\n    n = len(base_solution)\n\n    # Step 1: Randomly select a segment to reverse (similar to 2-opt but more flexible)\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, min(start + 5, n - 1))  # Limit segment size for efficiency\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Randomly select two edges and insert one into the other (edge insertion)\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    node = new_solution[j]\n    new_solution = np.concatenate([new_solution[:i+1], [node], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to original solution if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8922136376575363,
            0.9407926201820374
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: Combination of edge insertion and segment reversal\n    n = len(base_solution)\n\n    # Step 1: Randomly select a segment to reverse (similar to 2-opt but more flexible)\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, min(start + 5, n - 1))  # Limit segment size for efficiency\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Randomly select two edges and insert one into the other (edge insertion)\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    node = new_solution[j]\n    new_solution = np.concatenate([new_solution[:i+1], [node], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to original solution if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 152,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select a random solution from the archive (could be improved with more sophisticated selection)\n        selected_idx = random.randint(0, len(archive) - 1)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy:\n    # 1. Randomly select a segment of the tour and reverse it\n    # 2. Apply edge swapping to further refine the solution\n\n    # Segment reversal operator\n    if n > 2:\n        # Randomly select a segment to reverse\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, n - 1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Edge swapping operator\n    if n > 3:\n        # Randomly select two non-adjacent edges and swap them\n        i = random.randint(0, n - 4)\n        j = random.randint(i + 2, n - 2)\n        # Swap edges (i,i+1) and (j,j+1)\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8642603581100323,
            0.9063819646835327
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select a random solution from the archive (could be improved with more sophisticated selection)\n        selected_idx = random.randint(0, len(archive) - 1)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy:\n    # 1. Randomly select a segment of the tour and reverse it\n    # 2. Apply edge swapping to further refine the solution\n\n    # Segment reversal operator\n    if n > 2:\n        # Randomly select a segment to reverse\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, n - 1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Edge swapping operator\n    if n > 3:\n        # Randomly select two non-adjacent edges and swap them\n        i = random.randint(0, n - 4)\n        j = random.randint(i + 2, n - 2)\n        # Swap edges (i,i+1) and (j,j+1)\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 153,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        sorted_archive = sorted(archive, key=lambda x: max(x[1]))\n        candidate_solutions = sorted_archive[:max(1, len(archive) // 5)]\n        selected_solution = random.choice(candidate_solutions)[0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt with segment relocation\n    for _ in range(3):  # Perform multiple iterations for better exploration\n        # Randomly select three distinct edges to modify\n        i, j, k = sorted(random.sample(range(1, n), 3))\n\n        # Create a new segment by relocating a sub-tour\n        segment = new_solution[i:j]\n        remaining = np.concatenate([new_solution[:i], new_solution[j:]])\n\n        # Insert the segment at a new position\n        insert_pos = random.randint(0, len(remaining) - 1)\n        new_solution = np.concatenate([\n            remaining[:insert_pos],\n            segment,\n            remaining[insert_pos:]\n        ])\n\n        # Perform a 2-opt swap to further improve\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.7720023457746508,
            1.1514904499053955
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        sorted_archive = sorted(archive, key=lambda x: max(x[1]))\n        candidate_solutions = sorted_archive[:max(1, len(archive) // 5)]\n        selected_solution = random.choice(candidate_solutions)[0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt with segment relocation\n    for _ in range(3):  # Perform multiple iterations for better exploration\n        # Randomly select three distinct edges to modify\n        i, j, k = sorted(random.sample(range(1, n), 3))\n\n        # Create a new segment by relocating a sub-tour\n        segment = new_solution[i:j]\n        remaining = np.concatenate([new_solution[:i], new_solution[j:]])\n\n        # Insert the segment at a new position\n        insert_pos = random.randint(0, len(remaining) - 1)\n        new_solution = np.concatenate([\n            remaining[:insert_pos],\n            segment,\n            remaining[insert_pos:]\n        ])\n\n        # Perform a 2-opt swap to further improve\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 154,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its dominance rank\n    # (simplified for this example)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(base_solution)\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # 2-opt move (standard)\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Novel edge-swap operator (considering both objectives)\n    if random.random() < 0.5:\n        # Swap edges (a,c) and (b,d) if it improves both objectives\n        if (distance_matrix_1[base_solution[a], base_solution[c]] + distance_matrix_1[base_solution[b], base_solution[d]] <\n            distance_matrix_1[base_solution[a], base_solution[b]] + distance_matrix_1[base_solution[c], base_solution[d]]) and \\\n           (distance_matrix_2[base_solution[a], base_solution[c]] + distance_matrix_2[base_solution[b], base_solution[d]] <\n            distance_matrix_2[base_solution[a], base_solution[b]] + distance_matrix_2[base_solution[c], base_solution[d]]):\n            new_solution[[a, c]] = new_solution[[c, a]]\n            new_solution[[b, d]] = new_solution[[d, b]]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8564444590166995,
            0.9201680421829224
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its dominance rank\n    # (simplified for this example)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(base_solution)\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # 2-opt move (standard)\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Novel edge-swap operator (considering both objectives)\n    if random.random() < 0.5:\n        # Swap edges (a,c) and (b,d) if it improves both objectives\n        if (distance_matrix_1[base_solution[a], base_solution[c]] + distance_matrix_1[base_solution[b], base_solution[d]] <\n            distance_matrix_1[base_solution[a], base_solution[b]] + distance_matrix_1[base_solution[c], base_solution[d]]) and \\\n           (distance_matrix_2[base_solution[a], base_solution[c]] + distance_matrix_2[base_solution[b], base_solution[d]] <\n            distance_matrix_2[base_solution[a], base_solution[b]] + distance_matrix_2[base_solution[c], base_solution[d]]):\n            new_solution[[a, c]] = new_solution[[c, a]]\n            new_solution[[b, d]] = new_solution[[d, b]]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 155,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal or with high variance)\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search operator: combine 3-opt with a custom move\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment to modify\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment = new_solution[a:b+1]\n\n    # Step 2: Apply a custom move (reverse segment and insert elsewhere)\n    if random.random() < 0.5:\n        # Reverse the segment\n        segment = segment[::-1]\n    else:\n        # Rotate the segment\n        segment = np.roll(segment, shift=1)\n\n    # Insert the modified segment at a random position\n    new_solution = np.concatenate([new_solution[:a], segment, new_solution[b+1:]])\n\n    # Ensure the solution remains a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by filling missing nodes\n        missing = [node for node in range(n) if node not in new_solution]\n        for i in range(len(new_solution)):\n            if new_solution[i] in new_solution[:i]:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8892527229813059,
            1.6899945139884949
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal or with high variance)\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search operator: combine 3-opt with a custom move\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment to modify\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment = new_solution[a:b+1]\n\n    # Step 2: Apply a custom move (reverse segment and insert elsewhere)\n    if random.random() < 0.5:\n        # Reverse the segment\n        segment = segment[::-1]\n    else:\n        # Rotate the segment\n        segment = np.roll(segment, shift=1)\n\n    # Insert the modified segment at a random position\n    new_solution = np.concatenate([new_solution[:a], segment, new_solution[b+1:]])\n\n    # Ensure the solution remains a valid tour (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by filling missing nodes\n        missing = [node for node in range(n) if node not in new_solution]\n        for i in range(len(new_solution)):\n            if new_solution[i] in new_solution[:i]:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 156,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    objectives = [obj for (sol, obj) in archive]\n    costs = np.array([sum(obj) for obj in objectives])\n    if len(costs) > 0:\n        probabilities = 1 / (costs + 1e-6)  # Avoid division by zero\n        probabilities = probabilities / np.sum(probabilities)\n        selected_idx = np.random.choice(len(archive), p=probabilities)\n    else:\n        selected_idx = random.randint(0, len(archive) - 1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of 2-opt and node insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful local search\n\n    # Randomly select a segment to apply 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select a node to reinsert somewhere else\n    if n > 2:\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8328354988299369,
            1.531002163887024
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    objectives = [obj for (sol, obj) in archive]\n    costs = np.array([sum(obj) for obj in objectives])\n    if len(costs) > 0:\n        probabilities = 1 / (costs + 1e-6)  # Avoid division by zero\n        probabilities = probabilities / np.sum(probabilities)\n        selected_idx = np.random.choice(len(archive), p=probabilities)\n    else:\n        selected_idx = random.randint(0, len(archive) - 1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of 2-opt and node insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful local search\n\n    # Randomly select a segment to apply 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select a node to reinsert somewhere else\n    if n > 2:\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 157,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # Here we use a simple heuristic: select the solution with the highest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    scores = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 3-opt move\n    if n >= 4:\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Reverse segments between i-j and j-k\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Then, apply a novel edge insertion strategy\n    if n >= 4:\n        # Select two random edges to break\n        a, b = sorted(random.sample(range(n), 2))\n        # Remove the edges between a and b\n        segment = new_solution[a:b]\n        # Reinsert the segment in a different position\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    # Ensure the solution remains valid\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.8704936951573438,
            1.328762173652649
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # Here we use a simple heuristic: select the solution with the highest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    scores = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 3-opt move\n    if n >= 4:\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Reverse segments between i-j and j-k\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Then, apply a novel edge insertion strategy\n    if n >= 4:\n        # Select two random edges to break\n        a, b = sorted(random.sample(range(n), 2))\n        # Remove the edges between a and b\n        segment = new_solution[a:b]\n        # Reinsert the segment in a different position\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    # Ensure the solution remains valid\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 158,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., low cost in one objective but high in the other)\n    selected_solution = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n\n    # Hybrid local search: Combination of 3-opt and random segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct segments\n    i, j, k = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n\n    # Apply 3-opt move\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Recombine segments in a different order\n    new_order = [segment1, segment2, segment3, segment4]\n    np.random.shuffle(new_order)\n    new_solution = np.concatenate(new_order)\n\n    # Randomly reverse a segment to add diversity\n    if np.random.rand() < 0.5:\n        rev_start = np.random.randint(1, n-1)\n        rev_end = np.random.randint(rev_start, n)\n        new_solution[rev_start:rev_end] = new_solution[rev_start:rev_end][::-1]\n\n    # Ensure the solution remains a valid tour\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(np.random.choice(range(1, n), size=2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.3294711537326944,
            1.5631438493728638
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., low cost in one objective but high in the other)\n    selected_solution = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n\n    # Hybrid local search: Combination of 3-opt and random segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct segments\n    i, j, k = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n\n    # Apply 3-opt move\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Recombine segments in a different order\n    new_order = [segment1, segment2, segment3, segment4]\n    np.random.shuffle(new_order)\n    new_solution = np.concatenate(new_order)\n\n    # Randomly reverse a segment to add diversity\n    if np.random.rand() < 0.5:\n        rev_start = np.random.randint(1, n-1)\n        rev_end = np.random.randint(rev_start, n)\n        new_solution[rev_start:rev_end] = new_solution[rev_start:rev_end][::-1]\n\n    # Ensure the solution remains a valid tour\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(np.random.choice(range(1, n), size=2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 159,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its dominance\n    # Solutions with higher costs are more likely to be selected for improvement\n    costs = np.array([sum(obj) for _, obj in archive])\n    if len(costs) > 1:\n        min_cost, max_cost = np.min(costs), np.max(costs)\n        if max_cost > min_cost:\n            normalized_costs = (costs - min_cost) / (max_cost - min_cost)\n            selection_probs = 1 - normalized_costs\n            selection_probs = selection_probs / np.sum(selection_probs)\n        else:\n            selection_probs = np.ones(len(archive)) / len(archive)\n    else:\n        selection_probs = [1.0]\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    n = len(new_solution)\n    if n <= 3:\n        # For small tours, just perform a swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Edge insertion: remove a random edge and reinsert it\n    i = random.randint(0, n-1)\n    j = (i + 1) % n\n    k = random.randint(0, n-1)\n    while k == i or k == j or (k+1)%n == i:\n        k = random.randint(0, n-1)\n\n    # Remove edge between i and j\n    removed_node = new_solution[j]\n    new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n\n    # Reinsert the removed node after k\n    new_solution = np.concatenate([new_solution[:k+1], [removed_node], new_solution[k+1:]])\n\n    # Segment reversal with objective-aware selection\n    # Choose a segment to reverse based on the objective space where the segment has higher cost\n    def calculate_segment_cost(solution, start, end, distance_matrix):\n        cost = 0\n        for i in range(start, end):\n            cost += distance_matrix[solution[i], solution[(i+1)%n]]\n        cost += distance_matrix[solution[end], solution[start]]\n        return cost\n\n    # Find the worst segment in either objective space\n    max_cost_diff = -float('inf')\n    best_start, best_end = 0, 0\n    for start in range(n):\n        for length in range(2, min(5, n-1)):  # Limit segment length to avoid too large changes\n            end = (start + length) % n\n            if end < start:\n                continue  # Skip segments that wrap around the end\n\n            cost1 = calculate_segment_cost(new_solution, start, end, distance_matrix_1)\n            cost2 = calculate_segment_cost(new_solution, start, end, distance_matrix_2)\n            cost_diff = abs(cost1 - cost2)\n\n            if cost_diff > max_cost_diff:\n                max_cost_diff = cost_diff\n                best_start, best_end = start, end\n\n    # Reverse the selected segment\n    if best_end > best_start:\n        new_solution[best_start:best_end+1] = new_solution[best_start:best_end+1][::-1]\n    else:\n        # Handle wrap-around case\n        segment = np.concatenate([new_solution[best_start:], new_solution[:best_end+1]])\n        segment = segment[::-1]\n        new_solution = np.concatenate([segment[-best_end-1:], new_solution[best_end+1:best_start], segment[:len(segment)-best_end-1]])\n\n    return new_solution\n\n",
        "score": [
            -0.7995565770893336,
            3.671501100063324
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its dominance\n    # Solutions with higher costs are more likely to be selected for improvement\n    costs = np.array([sum(obj) for _, obj in archive])\n    if len(costs) > 1:\n        min_cost, max_cost = np.min(costs), np.max(costs)\n        if max_cost > min_cost:\n            normalized_costs = (costs - min_cost) / (max_cost - min_cost)\n            selection_probs = 1 - normalized_costs\n            selection_probs = selection_probs / np.sum(selection_probs)\n        else:\n            selection_probs = np.ones(len(archive)) / len(archive)\n    else:\n        selection_probs = [1.0]\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    n = len(new_solution)\n    if n <= 3:\n        # For small tours, just perform a swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Edge insertion: remove a random edge and reinsert it\n    i = random.randint(0, n-1)\n    j = (i + 1) % n\n    k = random.randint(0, n-1)\n    while k == i or k == j or (k+1)%n == i:\n        k = random.randint(0, n-1)\n\n    # Remove edge between i and j\n    removed_node = new_solution[j]\n    new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n\n    # Reinsert the removed node after k\n    new_solution = np.concatenate([new_solution[:k+1], [removed_node], new_solution[k+1:]])\n\n    # Segment reversal with objective-aware selection\n    # Choose a segment to reverse based on the objective space where the segment has higher cost\n    def calculate_segment_cost(solution, start, end, distance_matrix):\n        cost = 0\n        for i in range(start, end):\n            cost += distance_matrix[solution[i], solution[(i+1)%n]]\n        cost += distance_matrix[solution[end], solution[start]]\n        return cost\n\n    # Find the worst segment in either objective space\n    max_cost_diff = -float('inf')\n    best_start, best_end = 0, 0\n    for start in range(n):\n        for length in range(2, min(5, n-1)):  # Limit segment length to avoid too large changes\n            end = (start + length) % n\n            if end < start:\n                continue  # Skip segments that wrap around the end\n\n            cost1 = calculate_segment_cost(new_solution, start, end, distance_matrix_1)\n            cost2 = calculate_segment_cost(new_solution, start, end, distance_matrix_2)\n            cost_diff = abs(cost1 - cost2)\n\n            if cost_diff > max_cost_diff:\n                max_cost_diff = cost_diff\n                best_start, best_end = start, end\n\n    # Reverse the selected segment\n    if best_end > best_start:\n        new_solution[best_start:best_end+1] = new_solution[best_start:best_end+1][::-1]\n    else:\n        # Handle wrap-around case\n        segment = np.concatenate([new_solution[best_start:], new_solution[:best_end+1]])\n        segment = segment[::-1]\n        new_solution = np.concatenate([segment[-best_end-1:], new_solution[best_end+1:best_start], segment[:len(segment)-best_end-1]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 160,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Step 1: Random edge exchange (similar to 2-opt but more flexible)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    if j - i > 1:\n        new_solution[i:j] = base_solution[i:j][::-1]\n\n    # Step 2: Novel segment relocation (move a segment to a different position)\n    segment_size = min(3, n // 4)\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    # Find optimal insertion point based on combined distance reduction\n    best_insert = start\n    min_cost = float('inf')\n\n    for insert_pos in range(n - segment_size + 1):\n        if insert_pos == start:\n            continue\n\n        # Create candidate solution\n        candidate = np.concatenate([\n            base_solution[:insert_pos],\n            base_solution[start:end],\n            base_solution[insert_pos:start],\n            base_solution[end:]\n        ])\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n        combined_cost = cost1 + cost2\n\n        if combined_cost < min_cost:\n            min_cost = combined_cost\n            best_insert = insert_pos\n\n    # Apply best relocation\n    if best_insert != start:\n        new_solution = np.concatenate([\n            base_solution[:best_insert],\n            base_solution[start:end],\n            base_solution[best_insert:start],\n            base_solution[end:]\n        ])\n\n    # Ensure solution remains valid\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.47911287788842455,
            8.387968242168427
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Step 1: Random edge exchange (similar to 2-opt but more flexible)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    if j - i > 1:\n        new_solution[i:j] = base_solution[i:j][::-1]\n\n    # Step 2: Novel segment relocation (move a segment to a different position)\n    segment_size = min(3, n // 4)\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    # Find optimal insertion point based on combined distance reduction\n    best_insert = start\n    min_cost = float('inf')\n\n    for insert_pos in range(n - segment_size + 1):\n        if insert_pos == start:\n            continue\n\n        # Create candidate solution\n        candidate = np.concatenate([\n            base_solution[:insert_pos],\n            base_solution[start:end],\n            base_solution[insert_pos:start],\n            base_solution[end:]\n        ])\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n        combined_cost = cost1 + cost2\n\n        if combined_cost < min_cost:\n            min_cost = combined_cost\n            best_insert = insert_pos\n\n    # Apply best relocation\n    if best_insert != start:\n        new_solution = np.concatenate([\n            base_solution[:best_insert],\n            base_solution[start:end],\n            base_solution[best_insert:start],\n            base_solution[end:]\n        ])\n\n    # Ensure solution remains valid\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 161,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal or with high variance in objectives)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    objectives = [obj for _, obj in archive]\n\n    # Calculate the variance of objectives to identify solutions with potential for improvement\n    obj1_variance = np.var([obj[0] for obj in objectives])\n    obj2_variance = np.var([obj[1] for obj in objectives])\n\n    # If variance is low, select a random solution to escape local optima\n    if obj1_variance < 1e-6 and obj2_variance < 1e-6:\n        selected_idx = random.randint(0, len(archive) - 1)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge-swap heuristic\n    n = len(new_solution)\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # 3-opt move: reverse segments between i-j, j-k, and k-i\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n    new_solution[k:] = new_solution[k:][::-1]\n\n    # Novel edge-swap heuristic: swap edges based on distance improvement in both objectives\n    for _ in range(2):  # Perform a few edge swaps\n        a, b = sorted(random.sample(range(n), 2))\n        if a == 0 or b == n-1:\n            continue  # Avoid breaking the tour\n\n        # Calculate current and new distances for both objectives\n        current_dist1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n        new_dist1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]]\n\n        current_dist2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n        new_dist2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]]\n\n        # Accept if both objectives improve or one improves significantly\n        if (new_dist1 < current_dist1 and new_dist2 < current_dist2) or \\\n           (new_dist1 < current_dist1 and (current_dist2 - new_dist2) < 0.1 * current_dist2) or \\\n           (new_dist2 < current_dist2 and (current_dist1 - new_dist1) < 0.1 * current_dist1):\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9044854299167409,
            1.8753600120544434
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal or with high variance in objectives)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    objectives = [obj for _, obj in archive]\n\n    # Calculate the variance of objectives to identify solutions with potential for improvement\n    obj1_variance = np.var([obj[0] for obj in objectives])\n    obj2_variance = np.var([obj[1] for obj in objectives])\n\n    # If variance is low, select a random solution to escape local optima\n    if obj1_variance < 1e-6 and obj2_variance < 1e-6:\n        selected_idx = random.randint(0, len(archive) - 1)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge-swap heuristic\n    n = len(new_solution)\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # 3-opt move: reverse segments between i-j, j-k, and k-i\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n    new_solution[k:] = new_solution[k:][::-1]\n\n    # Novel edge-swap heuristic: swap edges based on distance improvement in both objectives\n    for _ in range(2):  # Perform a few edge swaps\n        a, b = sorted(random.sample(range(n), 2))\n        if a == 0 or b == n-1:\n            continue  # Avoid breaking the tour\n\n        # Calculate current and new distances for both objectives\n        current_dist1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n        new_dist1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]]\n\n        current_dist2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n        new_dist2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]]\n\n        # Accept if both objectives improve or one improves significantly\n        if (new_dist1 < current_dist1 and new_dist2 < current_dist2) or \\\n           (new_dist1 < current_dist1 and (current_dist2 - new_dist2) < 0.1 * current_dist2) or \\\n           (new_dist2 < current_dist2 and (current_dist1 - new_dist1) < 0.1 * current_dist1):\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 162,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[min(3, len(archive_sorted) - 1)][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: Edge swaps with segment inversion\n    if n > 4:\n        # Random segment inversion (novel technique)\n        segment_start = np.random.randint(0, n - 3)\n        segment_end = np.random.randint(segment_start + 2, n - 1)\n        new_solution[segment_start:segment_end] = new_solution[segment_start:segment_end][::-1]\n\n        # Edge swap to further improve the solution\n        i, j = np.random.choice(range(n), size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    if not np.array_equal(np.sort(new_solution), np.sort(selected_solution)):\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7510360830006702,
            1.6223272681236267
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[min(3, len(archive_sorted) - 1)][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: Edge swaps with segment inversion\n    if n > 4:\n        # Random segment inversion (novel technique)\n        segment_start = np.random.randint(0, n - 3)\n        segment_end = np.random.randint(segment_start + 2, n - 1)\n        new_solution[segment_start:segment_end] = new_solution[segment_start:segment_end][::-1]\n\n        # Edge swap to further improve the solution\n        i, j = np.random.choice(range(n), size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    if not np.array_equal(np.sort(new_solution), np.sort(selected_solution)):\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 163,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with high total cost)\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search operator: combine 3-opt with a novel edge insertion strategy\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct positions to perform 3-opt\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Perform 3-opt by reversing segments\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    # Novel edge insertion strategy: insert a random node at a position that minimizes both objectives\n    if n > 3:\n        # Remove a random node and reinsert it optimally\n        node_to_insert = random.choice(new_solution)\n        new_solution = np.array([node for node in new_solution if node != node_to_insert])\n\n        # Find the best position to insert the node to minimize both objectives\n        best_pos = 0\n        min_cost = float('inf')\n\n        for i in range(len(new_solution)):\n            # Insert the node at position i\n            temp_solution = np.insert(new_solution, i, node_to_insert)\n\n            # Calculate the cost for the new solution\n            cost1 = sum(distance_matrix_1[temp_solution[j-1], temp_solution[j]] for j in range(len(temp_solution)))\n            cost2 = sum(distance_matrix_2[temp_solution[j-1], temp_solution[j]] for j in range(len(temp_solution)))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = i\n\n        new_solution = np.insert(new_solution, best_pos, node_to_insert)\n\n    return new_solution\n\n",
        "score": [
            -0.9892779924056991,
            10.368528127670288
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with high total cost)\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search operator: combine 3-opt with a novel edge insertion strategy\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct positions to perform 3-opt\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Perform 3-opt by reversing segments\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    # Novel edge insertion strategy: insert a random node at a position that minimizes both objectives\n    if n > 3:\n        # Remove a random node and reinsert it optimally\n        node_to_insert = random.choice(new_solution)\n        new_solution = np.array([node for node in new_solution if node != node_to_insert])\n\n        # Find the best position to insert the node to minimize both objectives\n        best_pos = 0\n        min_cost = float('inf')\n\n        for i in range(len(new_solution)):\n            # Insert the node at position i\n            temp_solution = np.insert(new_solution, i, node_to_insert)\n\n            # Calculate the cost for the new solution\n            cost1 = sum(distance_matrix_1[temp_solution[j-1], temp_solution[j]] for j in range(len(temp_solution)))\n            cost2 = sum(distance_matrix_2[temp_solution[j-1], temp_solution[j]] for j in range(len(temp_solution)))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = i\n\n        new_solution = np.insert(new_solution, best_pos, node_to_insert)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 164,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high variance in objectives)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge insertion\n    n = len(new_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Randomly select three edges to disrupt\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Apply 3-opt: reverse segments between selected edges\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Custom edge insertion: try to insert a random node in a new position\n        node_to_move = random.choice(new_solution)\n        current_pos = np.where(new_solution == node_to_move)[0][0]\n        new_pos = random.randint(0, n - 1)\n        if new_pos != current_pos:\n            # Remove node and insert at new position\n            new_solution = np.delete(new_solution, current_pos)\n            new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.7867472117973611,
            2.333556056022644
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high variance in objectives)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge insertion\n    n = len(new_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Randomly select three edges to disrupt\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Apply 3-opt: reverse segments between selected edges\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Custom edge insertion: try to insert a random node in a new position\n        node_to_move = random.choice(new_solution)\n        current_pos = np.where(new_solution == node_to_move)[0][0]\n        new_pos = random.randint(0, n - 1)\n        if new_pos != current_pos:\n            # Remove node and insert at new position\n            new_solution = np.delete(new_solution, current_pos)\n            new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 165,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append(sol)\n\n    if not non_dominated:\n        non_dominated = [sol for sol, _ in archive]\n\n    # Intelligently select a base solution from non-dominated solutions\n    if len(non_dominated) > 1:\n        # Select based on a combination of randomness and diversity\n        candidates = random.sample(non_dominated, min(3, len(non_dominated)))\n        base_solution = min(candidates, key=lambda x: sum(x))\n    else:\n        base_solution = non_dominated[0]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of edge exchange and node insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select two distinct segments\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Apply edge exchange\n    if a < b < c < d:\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[c:d] = new_solution[c:d][::-1]\n    else:\n        # Handle overlapping segments with a more sophisticated approach\n        # Node insertion with distance consideration\n        node_to_move = new_solution[b]\n        new_solution = np.delete(new_solution, b)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simpler operator if the above fails\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9323411878755681,
            2.020319879055023
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append(sol)\n\n    if not non_dominated:\n        non_dominated = [sol for sol, _ in archive]\n\n    # Intelligently select a base solution from non-dominated solutions\n    if len(non_dominated) > 1:\n        # Select based on a combination of randomness and diversity\n        candidates = random.sample(non_dominated, min(3, len(non_dominated)))\n        base_solution = min(candidates, key=lambda x: sum(x))\n    else:\n        base_solution = non_dominated[0]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of edge exchange and node insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select two distinct segments\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Apply edge exchange\n    if a < b < c < d:\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[c:d] = new_solution[c:d][::-1]\n    else:\n        # Handle overlapping segments with a more sophisticated approach\n        # Node insertion with distance consideration\n        node_to_move = new_solution[b]\n        new_solution = np.delete(new_solution, b)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simpler operator if the above fails\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 166,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a probability weighted by its dominance rank\n    objectives = np.array([obj for sol, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = np.sum(ranks, axis=1)\n    probabilities = 1 / (1 + dominance_scores)\n    probabilities = probabilities / np.sum(probabilities)\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search: 2-opt followed by edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform 2-opt to improve one objective\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i == 1:\n            continue\n\n        # Check if reversing the segment improves either objective\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, perform edge insertion to improve both objectives\n    for _ in range(5):  # Limit iterations\n        # Select a random edge to remove\n        k = random.randint(0, n-1)\n        removed_node = new_solution[k]\n\n        # Remove the node and create a temporary solution\n        temp_solution = np.delete(new_solution, k)\n\n        # Find the best position to reinsert the node\n        best_pos = 0\n        best_improvement = 0\n        for pos in range(len(temp_solution)):\n            # Calculate the cost of inserting the node at position pos\n            prev_node = temp_solution[pos-1]\n            next_node = temp_solution[pos]\n\n            original_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node]\n\n            original_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node]\n\n            improvement = (original_cost1 - new_cost1) + (original_cost2 - new_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        # Insert the node at the best position\n        new_solution = np.insert(temp_solution, best_pos, removed_node)\n\n    return new_solution\n\n",
        "score": [
            -0.8161093802899964,
            2.985088884830475
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a probability weighted by its dominance rank\n    objectives = np.array([obj for sol, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = np.sum(ranks, axis=1)\n    probabilities = 1 / (1 + dominance_scores)\n    probabilities = probabilities / np.sum(probabilities)\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search: 2-opt followed by edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform 2-opt to improve one objective\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i == 1:\n            continue\n\n        # Check if reversing the segment improves either objective\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, perform edge insertion to improve both objectives\n    for _ in range(5):  # Limit iterations\n        # Select a random edge to remove\n        k = random.randint(0, n-1)\n        removed_node = new_solution[k]\n\n        # Remove the node and create a temporary solution\n        temp_solution = np.delete(new_solution, k)\n\n        # Find the best position to reinsert the node\n        best_pos = 0\n        best_improvement = 0\n        for pos in range(len(temp_solution)):\n            # Calculate the cost of inserting the node at position pos\n            prev_node = temp_solution[pos-1]\n            next_node = temp_solution[pos]\n\n            original_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node]\n\n            original_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node]\n\n            improvement = (original_cost1 - new_cost1) + (original_cost2 - new_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        # Insert the node at the best position\n        new_solution = np.insert(temp_solution, best_pos, removed_node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 167,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: np.var(x[1]))  # Select solution with highest variance in objectives\n    base_solution = selected[0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct indices\n    i, j, k = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Apply 3-opt: reverse segments between i-j, j-k, and k-i\n    new_solution[i:j] = np.flip(new_solution[i:j])\n    new_solution[j:k] = np.flip(new_solution[j:k])\n    new_solution[k:] = np.flip(new_solution[k:])\n\n    # Novel segment inversion: reverse a random segment with a higher probability of beneficial changes\n    segment_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - segment_length)\n    if np.random.rand() > 0.7:  # 30% chance to apply segment inversion\n        new_solution[start:start+segment_length] = np.flip(new_solution[start:start+segment_length])\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = np.flip(new_solution[a:b])\n\n    return new_solution\n\n",
        "score": [
            -0.4739618266621425,
            4.103446304798126
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: np.var(x[1]))  # Select solution with highest variance in objectives\n    base_solution = selected[0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct indices\n    i, j, k = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Apply 3-opt: reverse segments between i-j, j-k, and k-i\n    new_solution[i:j] = np.flip(new_solution[i:j])\n    new_solution[j:k] = np.flip(new_solution[j:k])\n    new_solution[k:] = np.flip(new_solution[k:])\n\n    # Novel segment inversion: reverse a random segment with a higher probability of beneficial changes\n    segment_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - segment_length)\n    if np.random.rand() > 0.7:  # 30% chance to apply segment inversion\n        new_solution[start:start+segment_length] = np.flip(new_solution[start:start+segment_length])\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = np.flip(new_solution[a:b])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 168,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest cost)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(len(archive) // 2, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge-swap strategy\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select segments to modify\n    i, j, k = sorted(np.random.choice(range(1, n), 3, replace=False))\n\n    # Apply 3-opt move\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Apply custom edge-swap strategy: swap edges if it improves both objectives\n    for _ in range(3):  # Limit iterations to avoid excessive computation\n        a, b = sorted(np.random.choice(range(n), 2, replace=False))\n        if a == b or (a + 1) % n == b or (b + 1) % n == a:\n            continue\n\n        # Current cost\n        current_cost1 = distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n\n        # Proposed cost after swap\n        new_cost1 = distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[(a+1)%n], new_solution[(b+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[(a+1)%n], new_solution[(b+1)%n]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.random() < 0.2:  # Allow some randomness\n            new_solution[a+1:b+1] = new_solution[a+1:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8574060475977685,
            1.801899790763855
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest cost)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(len(archive) // 2, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge-swap strategy\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select segments to modify\n    i, j, k = sorted(np.random.choice(range(1, n), 3, replace=False))\n\n    # Apply 3-opt move\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Apply custom edge-swap strategy: swap edges if it improves both objectives\n    for _ in range(3):  # Limit iterations to avoid excessive computation\n        a, b = sorted(np.random.choice(range(n), 2, replace=False))\n        if a == b or (a + 1) % n == b or (b + 1) % n == a:\n            continue\n\n        # Current cost\n        current_cost1 = distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n\n        # Proposed cost after swap\n        new_cost1 = distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[(a+1)%n], new_solution[(b+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[(a+1)%n], new_solution[(b+1)%n]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.random() < 0.2:  # Allow some randomness\n            new_solution[a+1:b+1] = new_solution[a+1:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 169,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too far from the Pareto front)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Normalize objectives to find relative improvement potential\n    objectives = np.array(archive_objectives)\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    improvement_potential = normalized_obj.sum(axis=1)  # Combined potential\n\n    # Select solutions with top 30% potential\n    threshold = np.percentile(improvement_potential, 70)\n    candidate_indices = [i for i, pot in enumerate(improvement_potential) if pot >= threshold]\n\n    if not candidate_indices:\n        candidate_indices = [random.randint(0, len(archive) - 1)]\n\n    selected_idx = random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal (novel component)\n    segment_length = random.randint(2, min(5, n//2))  # Random segment length\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Reverse the segment if it improves at least one objective\n    segment = new_solution[start:end]\n    reversed_segment = segment[::-1]\n\n    # Calculate cost before and after reversal\n    def calculate_cost(solution, dist_matrix):\n        cost = 0\n        for i in range(len(solution)):\n            cost += dist_matrix[solution[i-1], solution[i]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    temp_solution = new_solution.copy()\n    temp_solution[start:end] = reversed_segment\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    # Accept if at least one objective improves\n    if (new_cost1 <= current_cost1 and new_cost2 <= current_cost2) and \\\n       (new_cost1 < current_cost1 or new_cost2 < current_cost2):\n        new_solution = temp_solution\n\n    # Step 2: Edge swapping (standard component)\n    i, j = sorted(random.sample(range(n), 2))\n    if i != j:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to base solution if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8660192221704837,
            1.3869754076004028
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too far from the Pareto front)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Normalize objectives to find relative improvement potential\n    objectives = np.array(archive_objectives)\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    improvement_potential = normalized_obj.sum(axis=1)  # Combined potential\n\n    # Select solutions with top 30% potential\n    threshold = np.percentile(improvement_potential, 70)\n    candidate_indices = [i for i, pot in enumerate(improvement_potential) if pot >= threshold]\n\n    if not candidate_indices:\n        candidate_indices = [random.randint(0, len(archive) - 1)]\n\n    selected_idx = random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal (novel component)\n    segment_length = random.randint(2, min(5, n//2))  # Random segment length\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Reverse the segment if it improves at least one objective\n    segment = new_solution[start:end]\n    reversed_segment = segment[::-1]\n\n    # Calculate cost before and after reversal\n    def calculate_cost(solution, dist_matrix):\n        cost = 0\n        for i in range(len(solution)):\n            cost += dist_matrix[solution[i-1], solution[i]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    temp_solution = new_solution.copy()\n    temp_solution[start:end] = reversed_segment\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    # Accept if at least one objective improves\n    if (new_cost1 <= current_cost1 and new_cost2 <= current_cost2) and \\\n       (new_cost1 < current_cost1 or new_cost2 < current_cost2):\n        new_solution = temp_solution\n\n    # Step 2: Edge swapping (standard component)\n    i, j = sorted(random.sample(range(n), 2))\n    if i != j:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to base solution if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 170,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    norm_objectives = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    weights = 1 / (norm_objectives.sum(axis=1) + 1e-10)  # Lower objectives get higher weights\n    weights = weights / weights.sum()  # Normalize to probabilities\n\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge insertion strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, apply a novel edge insertion strategy\n    if n > 3:\n        k, l = sorted(random.sample(range(n), 2))\n        if k != l:\n            # Remove two edges and reconnect with a different configuration\n            segment = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:k], new_solution[l:], segment])\n\n    # Ensure the solution is valid (visits all nodes exactly once)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7990261268830533,
            1.7982234358787537
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    norm_objectives = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    weights = 1 / (norm_objectives.sum(axis=1) + 1e-10)  # Lower objectives get higher weights\n    weights = weights / weights.sum()  # Normalize to probabilities\n\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge insertion strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, apply a novel edge insertion strategy\n    if n > 3:\n        k, l = sorted(random.sample(range(n), 2))\n        if k != l:\n            # Remove two edges and reconnect with a different configuration\n            segment = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:k], new_solution[l:], segment])\n\n    # Ensure the solution is valid (visits all nodes exactly once)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 171,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high objective values)\n    candidates = []\n    for sol, obj in archive:\n        # Simple heuristic: select solutions with high objective values (potential for improvement)\n        if obj[0] > np.median([o[0] for _, o in archive]) or obj[1] > np.median([o[1] for _, o in archive]):\n            candidates.append(sol)\n\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n\n    base_solution = random.choice(candidates).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom move\n    n = len(new_solution)\n    for _ in range(10):  # Limit the number of attempts to avoid excessive computation\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Apply 3-opt move\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n        # Apply a custom move: reverse a segment and swap two nodes\n        l, m = sorted(random.sample(range(n), 2))\n        new_solution[l:m] = new_solution[l:m][::-1]\n        new_solution[l], new_solution[m] = new_solution[m], new_solution[l]\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to a simpler move if the solution is invalid\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7227327731848477,
            2.778377413749695
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high objective values)\n    candidates = []\n    for sol, obj in archive:\n        # Simple heuristic: select solutions with high objective values (potential for improvement)\n        if obj[0] > np.median([o[0] for _, o in archive]) or obj[1] > np.median([o[1] for _, o in archive]):\n            candidates.append(sol)\n\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n\n    base_solution = random.choice(candidates).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom move\n    n = len(new_solution)\n    for _ in range(10):  # Limit the number of attempts to avoid excessive computation\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Apply 3-opt move\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n        # Apply a custom move: reverse a segment and swap two nodes\n        l, m = sorted(random.sample(range(n), 2))\n        new_solution[l:m] = new_solution[l:m][::-1]\n        new_solution[l], new_solution[m] = new_solution[m], new_solution[l]\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to a simpler move if the solution is invalid\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 172,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weights = [0.5, 0.5]  # Equal weights for simplicity; can be adjusted\n    ranked_solutions = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    base_solution = ranked_solutions[0][0].copy()\n\n    # Hybrid local search: edge insertion followed by segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge insertion: randomly select a node and reinsert it at a new position\n    if n > 3:\n        node_index = np.random.randint(1, n-1)  # Avoid start/end (closed tour)\n        node = new_solution[node_index]\n\n        # Remove the node\n        new_solution = np.delete(new_solution, node_index)\n\n        # Insert at a random new position\n        insert_pos = np.random.randint(1, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Segment reversal: reverse a random segment to explore new structures\n    if n > 4:\n        start = np.random.randint(1, n-3)  # Avoid start/end\n        end = np.random.randint(start+1, n-1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.681996271957171,
            1.7234081029891968
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weights = [0.5, 0.5]  # Equal weights for simplicity; can be adjusted\n    ranked_solutions = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    base_solution = ranked_solutions[0][0].copy()\n\n    # Hybrid local search: edge insertion followed by segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge insertion: randomly select a node and reinsert it at a new position\n    if n > 3:\n        node_index = np.random.randint(1, n-1)  # Avoid start/end (closed tour)\n        node = new_solution[node_index]\n\n        # Remove the node\n        new_solution = np.delete(new_solution, node_index)\n\n        # Insert at a random new position\n        insert_pos = np.random.randint(1, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Segment reversal: reverse a random segment to explore new structures\n    if n > 4:\n        start = np.random.randint(1, n-3)  # Avoid start/end\n        end = np.random.randint(start+1, n-1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 173,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 30% in Pareto front)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = np.random.choice(min(3, len(archive_sorted)), 1)[0]\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment-based perturbation\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # 3-opt move (select three random edges and reconnect them optimally)\n    i, j, k = sorted(np.random.choice(n_nodes, 3, replace=False))\n    segment1 = new_solution[:i+1]\n    segment2 = new_solution[i+1:j+1]\n    segment3 = new_solution[j+1:k+1]\n    segment4 = new_solution[k+1:]\n\n    # Try all possible reconnections (3-opt has 8 possible cases)\n    possible_segments = [\n        np.concatenate([segment1, segment2, segment3, segment4]),\n        np.concatenate([segment1, segment3, segment2, segment4]),\n        np.concatenate([segment1, segment2[::-1], segment3, segment4]),\n        np.concatenate([segment1, segment3[::-1], segment2, segment4]),\n        np.concatenate([segment1, segment3, segment2[::-1], segment4]),\n        np.concatenate([segment1, segment2[::-1], segment3[::-1], segment4]),\n        np.concatenate([segment1, segment3[::-1], segment2[::-1], segment4]),\n        np.concatenate([segment1, segment2, segment3[::-1], segment4])\n    ]\n\n    # Evaluate all possibilities and select the best one\n    best_solution = new_solution\n    best_cost = float('inf')\n\n    for candidate in possible_segments:\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n_nodes-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n_nodes-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        total_cost = cost1 + cost2  # Combined cost for selection\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_solution = candidate.copy()\n\n    new_solution = best_solution\n\n    # Novel segment-based perturbation: randomly select a segment and reverse it\n    if np.random.rand() < 0.3:  # 30% chance to apply this perturbation\n        seg_start, seg_end = sorted(np.random.choice(n_nodes, 2, replace=False))\n        new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    # Ensure the solution is valid (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n_nodes, \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.7397285470982093,
            3.3192421197891235
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 30% in Pareto front)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = np.random.choice(min(3, len(archive_sorted)), 1)[0]\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment-based perturbation\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # 3-opt move (select three random edges and reconnect them optimally)\n    i, j, k = sorted(np.random.choice(n_nodes, 3, replace=False))\n    segment1 = new_solution[:i+1]\n    segment2 = new_solution[i+1:j+1]\n    segment3 = new_solution[j+1:k+1]\n    segment4 = new_solution[k+1:]\n\n    # Try all possible reconnections (3-opt has 8 possible cases)\n    possible_segments = [\n        np.concatenate([segment1, segment2, segment3, segment4]),\n        np.concatenate([segment1, segment3, segment2, segment4]),\n        np.concatenate([segment1, segment2[::-1], segment3, segment4]),\n        np.concatenate([segment1, segment3[::-1], segment2, segment4]),\n        np.concatenate([segment1, segment3, segment2[::-1], segment4]),\n        np.concatenate([segment1, segment2[::-1], segment3[::-1], segment4]),\n        np.concatenate([segment1, segment3[::-1], segment2[::-1], segment4]),\n        np.concatenate([segment1, segment2, segment3[::-1], segment4])\n    ]\n\n    # Evaluate all possibilities and select the best one\n    best_solution = new_solution\n    best_cost = float('inf')\n\n    for candidate in possible_segments:\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n_nodes-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n_nodes-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        total_cost = cost1 + cost2  # Combined cost for selection\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_solution = candidate.copy()\n\n    new_solution = best_solution\n\n    # Novel segment-based perturbation: randomly select a segment and reverse it\n    if np.random.rand() < 0.3:  # 30% chance to apply this perturbation\n        seg_start, seg_end = sorted(np.random.choice(n_nodes, 2, replace=False))\n        new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    # Ensure the solution is valid (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n_nodes, \"Generated solution is invalid\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 174,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values (lower is better)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[min(3, len(archive_sorted) - 1)][0].copy()\n\n    # Hybrid local search strategy: combination of edge insertion and segment inversion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to invert (3-opt like operation)\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Randomly select two edges to insert (edge insertion)\n    if n > 4:\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if the solution becomes invalid\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8204571967628953,
            1.6592472791671753
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values (lower is better)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[min(3, len(archive_sorted) - 1)][0].copy()\n\n    # Hybrid local search strategy: combination of edge insertion and segment inversion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to invert (3-opt like operation)\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Randomly select two edges to insert (edge insertion)\n    if n > 4:\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if the solution becomes invalid\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 175,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest cost)\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge-swap strategy\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select segments to modify\n    i, j, k = sorted(random.sample(range(1, n-1), 3))\n\n    # Apply 3-opt: reverse segments between i-j, j-k, and k-i\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n    new_solution[k:] = new_solution[k:][::-1]\n\n    # Custom edge-swap: swap edges between two randomly selected nodes\n    a, b = random.sample(range(1, n-1), 2)\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8375039867130618,
            1.618745744228363
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest cost)\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge-swap strategy\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select segments to modify\n    i, j, k = sorted(random.sample(range(1, n-1), 3))\n\n    # Apply 3-opt: reverse segments between i-j, j-k, and k-i\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n    new_solution[k:] = new_solution[k:][::-1]\n\n    # Custom edge-swap: swap edges between two randomly selected nodes\n    a, b = random.sample(range(1, n-1), 2)\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 176,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected = random.choice(archive)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: Edge insertion + Path relocation\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful improvement possible\n\n    # Step 1: Edge insertion (remove a random edge and reinsert it)\n    i = random.randint(0, n-1)\n    j = (i + random.randint(1, n-2)) % n\n\n    # Remove edge between i and j\n    removed_node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n\n    # Reinsert at a random position\n    k = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, k, removed_node)\n\n    # Step 2: Path relocation (move a random segment to another position)\n    segment_start = random.randint(0, n-3)\n    segment_end = segment_start + random.randint(2, min(4, n-2))  # Relocate 2-4 nodes\n\n    segment = new_solution[segment_start:segment_end]\n    new_solution = np.delete(new_solution, np.s_[segment_start:segment_end])\n\n    insert_pos = random.randint(0, len(new_solution)-1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure the solution is feasible (no duplicates, all nodes present)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or not np.all(counts == 1):\n        # Fallback to a simple 2-opt if the solution becomes invalid\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.774573044824624,
            1.4628045558929443
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected = random.choice(archive)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: Edge insertion + Path relocation\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful improvement possible\n\n    # Step 1: Edge insertion (remove a random edge and reinsert it)\n    i = random.randint(0, n-1)\n    j = (i + random.randint(1, n-2)) % n\n\n    # Remove edge between i and j\n    removed_node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n\n    # Reinsert at a random position\n    k = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, k, removed_node)\n\n    # Step 2: Path relocation (move a random segment to another position)\n    segment_start = random.randint(0, n-3)\n    segment_end = segment_start + random.randint(2, min(4, n-2))  # Relocate 2-4 nodes\n\n    segment = new_solution[segment_start:segment_end]\n    new_solution = np.delete(new_solution, np.s_[segment_start:segment_end])\n\n    insert_pos = random.randint(0, len(new_solution)-1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure the solution is feasible (no duplicates, all nodes present)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or not np.all(counts == 1):\n        # Fallback to a simple 2-opt if the solution becomes invalid\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 177,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine random segment reversal with 3-opt-like move\n    n = len(base_solution)\n    if n < 4:\n        # If too small, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Select three distinct positions for the hybrid operator\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Perform a 3-opt-like move: reverse segments between a-b and b-c\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Additional randomness: sometimes swap two nodes in the reversed segments\n    if random.random() < 0.5:\n        i = random.randint(a, b-1)\n        j = random.randint(b, c-1)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.870514709541212,
            1.3455305695533752
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine random segment reversal with 3-opt-like move\n    n = len(base_solution)\n    if n < 4:\n        # If too small, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Select three distinct positions for the hybrid operator\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Perform a 3-opt-like move: reverse segments between a-b and b-c\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Additional randomness: sometimes swap two nodes in the reversed segments\n    if random.random() < 0.5:\n        i = random.randint(a, b-1)\n        j = random.randint(b, c-1)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 178,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse solutions)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a biased edge selection\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # No improvement possible\n\n    # Randomly select three non-consecutive edges to modify\n    a, b, c = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n\n    # Apply a biased 3-opt move: prioritize edges that improve both objectives\n    def evaluate_move(sol, i, j, k):\n        # Calculate the change in both objectives for the 3-opt move\n        old_edges = [(sol[i-1], sol[i]), (sol[j-1], sol[j]), (sol[k-1], sol[k])]\n        new_edges = [(sol[i-1], sol[k]), (sol[j-1], sol[i]), (sol[k-1], sol[j])]\n\n        delta1 = sum(distance_matrix_1[u][v] for u, v in new_edges) - sum(distance_matrix_1[u][v] for u, v in old_edges)\n        delta2 = sum(distance_matrix_2[u][v] for u, v in new_edges) - sum(distance_matrix_2[u][v] for u, v in old_edges)\n\n        return delta1, delta2\n\n    # Try all possible 3-opt moves and select the one that improves both objectives the most\n    best_delta1, best_delta2 = 0, 0\n    best_a, best_b, best_c = a, b, c\n\n    for i in [a, b, c]:\n        for j in [a, b, c]:\n            for k in [a, b, c]:\n                if i != j and j != k and i != k:\n                    delta1, delta2 = evaluate_move(new_solution, i, j, k)\n                    if delta1 < best_delta1 and delta2 < best_delta2:\n                        best_delta1, best_delta2 = delta1, delta2\n                        best_a, best_b, best_c = i, j, k\n\n    # Apply the best move if it improves both objectives\n    if best_delta1 < 0 and best_delta2 < 0:\n        # Reorder the segment between best_a and best_c\n        segment = new_solution[best_a:best_c]\n        new_solution[best_a:best_c] = segment[::-1]\n\n    # If no improvement, perform a random 2-opt move to escape local optima\n    if best_delta1 >= 0 or best_delta2 >= 0:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8239562171619386,
            1.469839870929718
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse solutions)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a biased edge selection\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # No improvement possible\n\n    # Randomly select three non-consecutive edges to modify\n    a, b, c = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n\n    # Apply a biased 3-opt move: prioritize edges that improve both objectives\n    def evaluate_move(sol, i, j, k):\n        # Calculate the change in both objectives for the 3-opt move\n        old_edges = [(sol[i-1], sol[i]), (sol[j-1], sol[j]), (sol[k-1], sol[k])]\n        new_edges = [(sol[i-1], sol[k]), (sol[j-1], sol[i]), (sol[k-1], sol[j])]\n\n        delta1 = sum(distance_matrix_1[u][v] for u, v in new_edges) - sum(distance_matrix_1[u][v] for u, v in old_edges)\n        delta2 = sum(distance_matrix_2[u][v] for u, v in new_edges) - sum(distance_matrix_2[u][v] for u, v in old_edges)\n\n        return delta1, delta2\n\n    # Try all possible 3-opt moves and select the one that improves both objectives the most\n    best_delta1, best_delta2 = 0, 0\n    best_a, best_b, best_c = a, b, c\n\n    for i in [a, b, c]:\n        for j in [a, b, c]:\n            for k in [a, b, c]:\n                if i != j and j != k and i != k:\n                    delta1, delta2 = evaluate_move(new_solution, i, j, k)\n                    if delta1 < best_delta1 and delta2 < best_delta2:\n                        best_delta1, best_delta2 = delta1, delta2\n                        best_a, best_b, best_c = i, j, k\n\n    # Apply the best move if it improves both objectives\n    if best_delta1 < 0 and best_delta2 < 0:\n        # Reorder the segment between best_a and best_c\n        segment = new_solution[best_a:best_c]\n        new_solution[best_a:best_c] = segment[::-1]\n\n    # If no improvement, perform a random 2-opt move to escape local optima\n    if best_delta1 >= 0 or best_delta2 >= 0:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 179,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% solutions)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    candidate_solutions = sorted_archive[:max(1, len(sorted_archive) // 5)]\n    selected_solution, _ = random.choice(candidate_solutions)\n    base_solution = selected_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment reversal strategy\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select segments to reverse or swap\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    if i > j:\n        i, j = j, i\n\n    # Apply segment reversal (novel operator)\n    segment = new_solution[i:j+1]\n    new_solution[i:j+1] = segment[::-1]\n\n    # Optional: Apply 2-opt if the segment reversal doesn't improve\n    if random.random() < 0.3:  # 30% chance to apply 2-opt\n        k = random.randint(0, n - 1)\n        l = random.randint(0, n - 1)\n        if k > l:\n            k, l = l, k\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6860494133159246,
            0.9132809638977051
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% solutions)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    candidate_solutions = sorted_archive[:max(1, len(sorted_archive) // 5)]\n    selected_solution, _ = random.choice(candidate_solutions)\n    base_solution = selected_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment reversal strategy\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select segments to reverse or swap\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    if i > j:\n        i, j = j, i\n\n    # Apply segment reversal (novel operator)\n    segment = new_solution[i:j+1]\n    new_solution[i:j+1] = segment[::-1]\n\n    # Optional: Apply 2-opt if the segment reversal doesn't improve\n    if random.random() < 0.3:  # 30% chance to apply 2-opt\n        k = random.randint(0, n - 1)\n        l = random.randint(0, n - 1)\n        if k > l:\n            k, l = l, k\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 180,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a probability inversely proportional to its rank (better solutions have higher chance)\n    weights = [1.0 / (i + 1) for i in range(len(archive))]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment to reverse (novel segment reversal)\n    if n > 4:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 2, min(start + 5, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Apply a random edge swap (2-opt like but with constraints)\n    if n > 3:\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:  # Ensure at least one node between i and j\n            new_solution[i+1:j] = new_solution[i+1:j][::-1]\n\n    # Step 3: Random insertion (novel operator)\n    if n > 3:\n        i, j = random.sample(range(n), 2)\n        if i != j:\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n            insert_pos = random.randint(0, n - 2)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution is valid (no duplicates, all nodes present)\n    if len(set(new_solution)) != n or len(new_solution) != n:\n        # Fallback to a simple swap if the above operations caused invalidity\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7297860736521562,
            1.566810429096222
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a probability inversely proportional to its rank (better solutions have higher chance)\n    weights = [1.0 / (i + 1) for i in range(len(archive))]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment to reverse (novel segment reversal)\n    if n > 4:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 2, min(start + 5, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Apply a random edge swap (2-opt like but with constraints)\n    if n > 3:\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:  # Ensure at least one node between i and j\n            new_solution[i+1:j] = new_solution[i+1:j][::-1]\n\n    # Step 3: Random insertion (novel operator)\n    if n > 3:\n        i, j = random.sample(range(n), 2)\n        if i != j:\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n            insert_pos = random.randint(0, n - 2)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution is valid (no duplicates, all nodes present)\n    if len(set(new_solution)) != n or len(new_solution) != n:\n        # Fallback to a simple swap if the above operations caused invalidity\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 181,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    # Step 2: Select base solution - prioritize non-dominated if available\n    if non_dominated:\n        base_solution = random.choice(non_dominated).copy()\n    else:\n        # If no non-dominated, select randomly but bias towards better solutions\n        weights = np.array([1/(1 + obj[0] + obj[1]) for _, obj in archive])\n        weights = weights / np.sum(weights)\n        base_solution = random.choices([sol for sol, _ in archive], weights=weights)[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 3: Hybrid local search operator (3-opt* variation)\n    # Select three distinct edges with probability based on edge quality\n    edges = []\n    for i in range(n):\n        u, v = new_solution[i], new_solution[(i+1)%n]\n        cost1 = distance_matrix_1[u, v]\n        cost2 = distance_matrix_2[u, v]\n        # Edge quality score (lower is better)\n        score = cost1 + cost2\n        edges.append((i, (i+1)%n, score))\n\n    # Sort edges by quality (ascending) to prioritize worse edges\n    edges.sort(key=lambda x: x[2], reverse=True)\n\n    # Select top 3 edges (or fewer if n is small)\n    selected_edges = edges[:min(3, n-3)]\n\n    if len(selected_edges) >= 3:\n        # Get the indices of the selected edges\n        i1, j1, _ = selected_edges[0]\n        i2, j2, _ = selected_edges[1]\n        i3, j3, _ = selected_edges[2]\n\n        # Ensure we have distinct edges\n        if i1 != i2 and i1 != i3 and i2 != i3:\n            # Perform 3-opt* move\n            # Create all possible permutations of the three edges\n            permutations = [\n                [i1, i2, i3],\n                [i1, i3, i2],\n                [i2, i1, i3],\n                [i2, i3, i1],\n                [i3, i1, i2],\n                [i3, i2, i1]\n            ]\n\n            best_perm = None\n            best_cost = float('inf')\n\n            for perm in permutations:\n                # Create a candidate solution\n                candidate = new_solution.copy()\n                # Reorder the edges according to the permutation\n                # This is a simplified version - a full implementation would require more complex edge reordering\n                # For demonstration, we'll just swap the nodes\n                nodes = [new_solution[perm[0]], new_solution[perm[1]], new_solution[perm[2]]]\n                random.shuffle(nodes)\n                candidate[perm[0]] = nodes[0]\n                candidate[perm[1]] = nodes[1]\n                candidate[perm[2]] = nodes[2]\n\n                # Calculate cost\n                cost1 = 0\n                cost2 = 0\n                for k in range(n):\n                    u, v = candidate[k], candidate[(k+1)%n]\n                    cost1 += distance_matrix_1[u, v]\n                    cost2 += distance_matrix_2[u, v]\n\n                if cost1 + cost2 < best_cost:\n                    best_cost = cost1 + cost2\n                    best_perm = candidate\n\n            if best_perm is not None:\n                new_solution = best_perm\n\n    # Step 4: Randomly perturb the solution to maintain diversity\n    if random.random() < 0.3:  # 30% chance of perturbation\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.717224965406758,
            8.929463803768158
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    # Step 2: Select base solution - prioritize non-dominated if available\n    if non_dominated:\n        base_solution = random.choice(non_dominated).copy()\n    else:\n        # If no non-dominated, select randomly but bias towards better solutions\n        weights = np.array([1/(1 + obj[0] + obj[1]) for _, obj in archive])\n        weights = weights / np.sum(weights)\n        base_solution = random.choices([sol for sol, _ in archive], weights=weights)[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 3: Hybrid local search operator (3-opt* variation)\n    # Select three distinct edges with probability based on edge quality\n    edges = []\n    for i in range(n):\n        u, v = new_solution[i], new_solution[(i+1)%n]\n        cost1 = distance_matrix_1[u, v]\n        cost2 = distance_matrix_2[u, v]\n        # Edge quality score (lower is better)\n        score = cost1 + cost2\n        edges.append((i, (i+1)%n, score))\n\n    # Sort edges by quality (ascending) to prioritize worse edges\n    edges.sort(key=lambda x: x[2], reverse=True)\n\n    # Select top 3 edges (or fewer if n is small)\n    selected_edges = edges[:min(3, n-3)]\n\n    if len(selected_edges) >= 3:\n        # Get the indices of the selected edges\n        i1, j1, _ = selected_edges[0]\n        i2, j2, _ = selected_edges[1]\n        i3, j3, _ = selected_edges[2]\n\n        # Ensure we have distinct edges\n        if i1 != i2 and i1 != i3 and i2 != i3:\n            # Perform 3-opt* move\n            # Create all possible permutations of the three edges\n            permutations = [\n                [i1, i2, i3],\n                [i1, i3, i2],\n                [i2, i1, i3],\n                [i2, i3, i1],\n                [i3, i1, i2],\n                [i3, i2, i1]\n            ]\n\n            best_perm = None\n            best_cost = float('inf')\n\n            for perm in permutations:\n                # Create a candidate solution\n                candidate = new_solution.copy()\n                # Reorder the edges according to the permutation\n                # This is a simplified version - a full implementation would require more complex edge reordering\n                # For demonstration, we'll just swap the nodes\n                nodes = [new_solution[perm[0]], new_solution[perm[1]], new_solution[perm[2]]]\n                random.shuffle(nodes)\n                candidate[perm[0]] = nodes[0]\n                candidate[perm[1]] = nodes[1]\n                candidate[perm[2]] = nodes[2]\n\n                # Calculate cost\n                cost1 = 0\n                cost2 = 0\n                for k in range(n):\n                    u, v = candidate[k], candidate[(k+1)%n]\n                    cost1 += distance_matrix_1[u, v]\n                    cost2 += distance_matrix_2[u, v]\n\n                if cost1 + cost2 < best_cost:\n                    best_cost = cost1 + cost2\n                    best_perm = candidate\n\n            if best_perm is not None:\n                new_solution = best_perm\n\n    # Step 4: Randomly perturb the solution to maintain diversity\n    if random.random() < 0.3:  # 30% chance of perturbation\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 182,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its cost\n    costs = [sum(obj) for _, obj in archive]\n    min_cost = min(costs)\n    max_cost = max(costs)\n    if max_cost == min_cost:\n        probabilities = [1.0 / len(archive)] * len(archive)\n    else:\n        normalized_costs = [(max_cost - c) / (max_cost - min_cost) for c in costs]\n        total = sum(normalized_costs)\n        probabilities = [c / total for c in normalized_costs]\n\n    selected_idx = random.choices(range(len(archive)), weights=probabilities, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move\n    if random.random() < 0.5:\n        # Case 1: Reverse segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Case 2: Reverse segment between j and k\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Custom edge swap: swap edges (i,j) and (k,l) where l is randomly chosen\n    if random.random() < 0.3:\n        l = random.randint(0, n-1)\n        if l != i and l != j and l != k:\n            # Ensure the swap maintains feasibility\n            if l < i:\n                new_solution[l], new_solution[i] = new_solution[i], new_solution[l]\n            elif i < l < j:\n                new_solution[i], new_solution[l] = new_solution[l], new_solution[i]\n            elif j < l < k:\n                new_solution[l], new_solution[j] = new_solution[j], new_solution[l]\n            else:\n                new_solution[j], new_solution[l] = new_solution[l], new_solution[j]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8233994186346617,
            1.5945473313331604
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its cost\n    costs = [sum(obj) for _, obj in archive]\n    min_cost = min(costs)\n    max_cost = max(costs)\n    if max_cost == min_cost:\n        probabilities = [1.0 / len(archive)] * len(archive)\n    else:\n        normalized_costs = [(max_cost - c) / (max_cost - min_cost) for c in costs]\n        total = sum(normalized_costs)\n        probabilities = [c / total for c in normalized_costs]\n\n    selected_idx = random.choices(range(len(archive)), weights=probabilities, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move\n    if random.random() < 0.5:\n        # Case 1: Reverse segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Case 2: Reverse segment between j and k\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Custom edge swap: swap edges (i,j) and (k,l) where l is randomly chosen\n    if random.random() < 0.3:\n        l = random.randint(0, n-1)\n        if l != i and l != j and l != k:\n            # Ensure the swap maintains feasibility\n            if l < i:\n                new_solution[l], new_solution[i] = new_solution[i], new_solution[l]\n            elif i < l < j:\n                new_solution[i], new_solution[l] = new_solution[l], new_solution[i]\n            elif j < l < k:\n                new_solution[l], new_solution[j] = new_solution[j], new_solution[l]\n            else:\n                new_solution[j], new_solution[l] = new_solution[l], new_solution[j]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 183,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with lower total cost\n    weights = [1.0 / (obj[0] + obj[1]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion with biased random walk\n    n = len(new_solution)\n    if n <= 3:\n        return new_solution  # No improvement possible for very small tours\n\n    # Step 1: Edge insertion with a bias towards improving both objectives\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i == j:\n            continue\n\n        # Create a candidate solution\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        # Evaluate the candidate\n        cost1 = sum(distance_matrix_1[candidate[k-1], candidate[k]] for k in range(n))\n        cost2 = sum(distance_matrix_2[candidate[k-1], candidate[k]] for k in range(n))\n\n        # Accept if both objectives improve or at least one improves significantly\n        old_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))\n        old_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n\n        if (cost1 < old_cost1 and cost2 < old_cost2) or \\\n           (cost1 < old_cost1 * 0.95 and cost2 < old_cost2 * 1.05) or \\\n           (cost2 < old_cost2 * 0.95 and cost1 < old_cost1 * 1.05):\n            new_solution = candidate\n            break\n\n    # Step 2: Biased random walk to escape local optima\n    if random.random() < 0.3:  # 30% chance to perform a biased random walk\n        k = random.randint(2, min(5, n-1))  # Walk length between 2 and 5 nodes\n        start = random.randint(0, n-1)\n        end = (start + k) % n\n\n        # Reverse the segment to create a new path\n        segment = new_solution[start:end]\n        new_solution[start:end] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.5872852289758176,
            3.5374194979667664
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with lower total cost\n    weights = [1.0 / (obj[0] + obj[1]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion with biased random walk\n    n = len(new_solution)\n    if n <= 3:\n        return new_solution  # No improvement possible for very small tours\n\n    # Step 1: Edge insertion with a bias towards improving both objectives\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i == j:\n            continue\n\n        # Create a candidate solution\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        # Evaluate the candidate\n        cost1 = sum(distance_matrix_1[candidate[k-1], candidate[k]] for k in range(n))\n        cost2 = sum(distance_matrix_2[candidate[k-1], candidate[k]] for k in range(n))\n\n        # Accept if both objectives improve or at least one improves significantly\n        old_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))\n        old_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n\n        if (cost1 < old_cost1 and cost2 < old_cost2) or \\\n           (cost1 < old_cost1 * 0.95 and cost2 < old_cost2 * 1.05) or \\\n           (cost2 < old_cost2 * 0.95 and cost1 < old_cost1 * 1.05):\n            new_solution = candidate\n            break\n\n    # Step 2: Biased random walk to escape local optima\n    if random.random() < 0.3:  # 30% chance to perform a biased random walk\n        k = random.randint(2, min(5, n-1))  # Walk length between 2 and 5 nodes\n        start = random.randint(0, n-1)\n        end = (start + k) % n\n\n        # Reverse the segment to create a new path\n        segment = new_solution[start:end]\n        new_solution[start:end] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 184,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    # Here, we use a simple heuristic: solutions with lower costs in both objectives are more likely to be selected\n    costs = np.array([obj for _, obj in archive])\n    normalized_costs = 1 / (costs.sum(axis=1) + 1e-6)  # Avoid division by zero\n    selection_probs = normalized_costs / normalized_costs.sum()\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge-swapping heuristic\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 2, min(start + 5, n - 1))\n\n    # Apply 3-opt within the selected segment\n    i, j, k = sorted(random.sample(range(start, end + 1), 3))\n    segment = new_solution[i:j+1]\n    new_segment = np.concatenate([segment[:k-j], segment[k-j:][::-1]])\n    new_solution[i:j+1] = new_segment\n\n    # Apply a custom edge-swapping heuristic based on distance matrices\n    for _ in range(2):  # Perform a few swaps\n        a, b = sorted(random.sample(range(n), 2))\n        if a == 0 and b == n - 1:\n            continue  # Avoid breaking the tour\n\n        # Calculate the change in both objectives\n        delta1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                  distance_matrix_1[new_solution[b], new_solution[a]] +\n                  distance_matrix_1[new_solution[a], new_solution[(b+1)%n]]) - \\\n                 (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                  distance_matrix_1[new_solution[a], new_solution[b]] +\n                  distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                  distance_matrix_2[new_solution[b], new_solution[a]] +\n                  distance_matrix_2[new_solution[a], new_solution[(b+1)%n]]) - \\\n                 (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                  distance_matrix_2[new_solution[a], new_solution[b]] +\n                  distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n\n        # Accept the swap if it improves both objectives\n        if delta1 < 0 and delta2 < 0:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6707322635034839,
            1.2430567741394043
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    # Here, we use a simple heuristic: solutions with lower costs in both objectives are more likely to be selected\n    costs = np.array([obj for _, obj in archive])\n    normalized_costs = 1 / (costs.sum(axis=1) + 1e-6)  # Avoid division by zero\n    selection_probs = normalized_costs / normalized_costs.sum()\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge-swapping heuristic\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 2, min(start + 5, n - 1))\n\n    # Apply 3-opt within the selected segment\n    i, j, k = sorted(random.sample(range(start, end + 1), 3))\n    segment = new_solution[i:j+1]\n    new_segment = np.concatenate([segment[:k-j], segment[k-j:][::-1]])\n    new_solution[i:j+1] = new_segment\n\n    # Apply a custom edge-swapping heuristic based on distance matrices\n    for _ in range(2):  # Perform a few swaps\n        a, b = sorted(random.sample(range(n), 2))\n        if a == 0 and b == n - 1:\n            continue  # Avoid breaking the tour\n\n        # Calculate the change in both objectives\n        delta1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                  distance_matrix_1[new_solution[b], new_solution[a]] +\n                  distance_matrix_1[new_solution[a], new_solution[(b+1)%n]]) - \\\n                 (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                  distance_matrix_1[new_solution[a], new_solution[b]] +\n                  distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                  distance_matrix_2[new_solution[b], new_solution[a]] +\n                  distance_matrix_2[new_solution[a], new_solution[(b+1)%n]]) - \\\n                 (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                  distance_matrix_2[new_solution[a], new_solution[b]] +\n                  distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n\n        # Accept the swap if it improves both objectives\n        if delta1 < 0 and delta2 < 0:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 185,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its dominance rank\n    objectives = np.array([obj for _, obj in archive])\n    non_dominated = []\n\n    # Identify non-dominated solutions\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    # If no non-dominated solutions, select randomly\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = random.randint(0, len(archive) - 1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of edge exchange and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Randomly choose between two operators\n    if random.random() < 0.5:\n        # Edge exchange: swap two non-adjacent edges\n        a, b = sorted(random.sample(range(n), 2))\n        if a + 1 < b:\n            new_solution[a+1:b] = new_solution[a+1:b][::-1]\n    else:\n        # Segment reversal with insertion: reverse a segment and insert it elsewhere\n        a, b = sorted(random.sample(range(n), 2))\n        if a + 1 < b:\n            segment = new_solution[a:b].copy()\n            new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n            insert_pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8240307732602015,
            1.8807945847511292
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its dominance rank\n    objectives = np.array([obj for _, obj in archive])\n    non_dominated = []\n\n    # Identify non-dominated solutions\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    # If no non-dominated solutions, select randomly\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = random.randint(0, len(archive) - 1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of edge exchange and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Randomly choose between two operators\n    if random.random() < 0.5:\n        # Edge exchange: swap two non-adjacent edges\n        a, b = sorted(random.sample(range(n), 2))\n        if a + 1 < b:\n            new_solution[a+1:b] = new_solution[a+1:b][::-1]\n    else:\n        # Segment reversal with insertion: reverse a segment and insert it elsewhere\n        a, b = sorted(random.sample(range(n), 2))\n        if a + 1 < b:\n            segment = new_solution[a:b].copy()\n            new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n            insert_pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 186,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    non_dominated = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for _, other_obj in archive:\n            if other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        # Fallback: select a random solution if no non-dominated solutions exist\n        selected_sol = random.choice(archive)[0].copy()\n    else:\n        # Select the solution with the highest sum of objectives (more room for improvement)\n        selected_sol = max(non_dominated, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: Node insertion + limited 3-opt\n    n = len(selected_sol)\n    new_solution = selected_sol.copy()\n\n    # Node insertion: Remove a random node and reinsert it at a new position\n    if n > 3:\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Limited 3-opt: Swap three edges if it improves the solution\n    if n > 5:\n        a, b, c = sorted(random.sample(range(n), 3))\n        # Create a new candidate by reversing segments\n        candidate = new_solution.copy()\n        candidate[a:b+1] = candidate[a:b+1][::-1]\n        candidate[b:c+1] = candidate[b:c+1][::-1]\n\n        # Evaluate the candidate's cost\n        def calculate_cost(solution):\n            cost1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1))\n            cost1 += distance_matrix_1[solution[-1], solution[0]]  # Return to start\n            cost2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1))\n            cost2 += distance_matrix_2[solution[-1], solution[0]]\n            return cost1, cost2\n\n        current_cost1, current_cost2 = calculate_cost(new_solution)\n        candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n        # Accept if at least one objective improves\n        if (candidate_cost1 < current_cost1) or (candidate_cost2 < current_cost2):\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.763548392447042,
            1.029352843761444
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    non_dominated = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for _, other_obj in archive:\n            if other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        # Fallback: select a random solution if no non-dominated solutions exist\n        selected_sol = random.choice(archive)[0].copy()\n    else:\n        # Select the solution with the highest sum of objectives (more room for improvement)\n        selected_sol = max(non_dominated, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: Node insertion + limited 3-opt\n    n = len(selected_sol)\n    new_solution = selected_sol.copy()\n\n    # Node insertion: Remove a random node and reinsert it at a new position\n    if n > 3:\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Limited 3-opt: Swap three edges if it improves the solution\n    if n > 5:\n        a, b, c = sorted(random.sample(range(n), 3))\n        # Create a new candidate by reversing segments\n        candidate = new_solution.copy()\n        candidate[a:b+1] = candidate[a:b+1][::-1]\n        candidate[b:c+1] = candidate[b:c+1][::-1]\n\n        # Evaluate the candidate's cost\n        def calculate_cost(solution):\n            cost1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1))\n            cost1 += distance_matrix_1[solution[-1], solution[0]]  # Return to start\n            cost2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1))\n            cost2 += distance_matrix_2[solution[-1], solution[0]]\n            return cost1, cost2\n\n        current_cost1, current_cost2 = calculate_cost(new_solution)\n        candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n        # Accept if at least one objective improves\n        if (candidate_cost1 < current_cost1) or (candidate_cost2 < current_cost2):\n            new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 187,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high variance in objectives)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel segment inversion\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select three distinct positions\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move: reverse segments between i-j and j-k\n    new_solution[i:j] = np.flip(new_solution[i:j])\n    new_solution[j:k] = np.flip(new_solution[j:k])\n\n    # Novel segment inversion: invert a segment between i and k with probability 0.5\n    if random.random() < 0.5:\n        new_solution[i:k] = np.flip(new_solution[i:k])\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.8100006946789604,
            1.3926770687103271
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high variance in objectives)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel segment inversion\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select three distinct positions\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move: reverse segments between i-j and j-k\n    new_solution[i:j] = np.flip(new_solution[i:j])\n    new_solution[j:k] = np.flip(new_solution[j:k])\n\n    # Novel segment inversion: invert a segment between i and k with probability 0.5\n    if random.random() < 0.5:\n        new_solution[i:k] = np.flip(new_solution[i:k])\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 188,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with promising potential (e.g., not too crowded in the archive)\n    # Here, we select a solution that is not the best in either objective to encourage diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(len(sorted_archive) // 2, len(sorted_archive) - 1)\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel move\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # Too small for meaningful changes\n\n    # Randomly select segments for 3-opt\n    a, b, c = sorted(random.sample(range(1, n), 3))\n\n    # Perform 3-opt move (reverses segments between a-b and b-c)\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Novel move: swap a small segment with a different segment\n    seg_len = max(2, min(5, n // 4))\n    start1 = random.randint(1, n - seg_len - 1)\n    start2 = random.randint(1, n - seg_len - 1)\n    if start1 != start2:\n        seg1 = new_solution[start1:start1 + seg_len].copy()\n        seg2 = new_solution[start2:start2 + seg_len].copy()\n        new_solution[start1:start1 + seg_len] = seg2\n        new_solution[start2:start2 + seg_len] = seg1\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6762920887061308,
            1.0211973786354065
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with promising potential (e.g., not too crowded in the archive)\n    # Here, we select a solution that is not the best in either objective to encourage diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(len(sorted_archive) // 2, len(sorted_archive) - 1)\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel move\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # Too small for meaningful changes\n\n    # Randomly select segments for 3-opt\n    a, b, c = sorted(random.sample(range(1, n), 3))\n\n    # Perform 3-opt move (reverses segments between a-b and b-c)\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Novel move: swap a small segment with a different segment\n    seg_len = max(2, min(5, n // 4))\n    start1 = random.randint(1, n - seg_len - 1)\n    start2 = random.randint(1, n - seg_len - 1)\n    if start1 != start2:\n        seg1 = new_solution[start1:start1 + seg_len].copy()\n        seg2 = new_solution[start2:start2 + seg_len].copy()\n        new_solution[start1:start1 + seg_len] = seg2\n        new_solution[start2:start2 + seg_len] = seg1\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 189,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    weights = 1 / (normalized_objectives.sum(axis=1) + 1e-10)\n    weights = weights / weights.sum()  # Normalize weights\n\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: Combine 3-opt with a novel segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Perform 3-opt to explore different configurations\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n\n    # Reverse segments with a probability to introduce diversity\n    if random.random() < 0.5:\n        segment1 = segment1[::-1]\n    if random.random() < 0.5:\n        segment2 = segment2[::-1]\n\n    # Reconstruct the solution\n    new_solution = np.concatenate([new_solution[:i], segment1, segment2, new_solution[k:]])\n\n    # Step 2: Novel segment reversal with objective-aware selection\n    # Identify segments with high potential for improvement in either objective\n    for _ in range(2):  # Apply the novel operator a few times\n        # Select a random segment\n        seg_start = random.randint(0, n - 3)\n        seg_end = random.randint(seg_start + 2, min(seg_start + 10, n - 1))\n\n        segment = new_solution[seg_start:seg_end]\n\n        # Evaluate the segment's contribution to both objectives\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n        # Reverse the segment\n        reversed_segment = segment[::-1]\n        temp_solution = np.concatenate([new_solution[:seg_start], reversed_segment, new_solution[seg_end:]])\n\n        # Calculate new costs\n        new_cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n))\n\n        # Accept the reversal if it improves at least one objective\n        if new_cost1 < current_cost1 or new_cost2 < current_cost2:\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8252588092826455,
            2.1775113344192505
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    weights = 1 / (normalized_objectives.sum(axis=1) + 1e-10)\n    weights = weights / weights.sum()  # Normalize weights\n\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: Combine 3-opt with a novel segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Perform 3-opt to explore different configurations\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n\n    # Reverse segments with a probability to introduce diversity\n    if random.random() < 0.5:\n        segment1 = segment1[::-1]\n    if random.random() < 0.5:\n        segment2 = segment2[::-1]\n\n    # Reconstruct the solution\n    new_solution = np.concatenate([new_solution[:i], segment1, segment2, new_solution[k:]])\n\n    # Step 2: Novel segment reversal with objective-aware selection\n    # Identify segments with high potential for improvement in either objective\n    for _ in range(2):  # Apply the novel operator a few times\n        # Select a random segment\n        seg_start = random.randint(0, n - 3)\n        seg_end = random.randint(seg_start + 2, min(seg_start + 10, n - 1))\n\n        segment = new_solution[seg_start:seg_end]\n\n        # Evaluate the segment's contribution to both objectives\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n        # Reverse the segment\n        reversed_segment = segment[::-1]\n        temp_solution = np.concatenate([new_solution[:seg_start], reversed_segment, new_solution[seg_end:]])\n\n        # Calculate new costs\n        new_cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n))\n\n        # Accept the reversal if it improves at least one objective\n        if new_cost1 < current_cost1 or new_cost2 < current_cost2:\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 190,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with high variance in objectives)\n    def potential_score(solution, objective):\n        # Normalize objectives to compare them\n        obj1, obj2 = objective\n        norm_obj1 = obj1 / (distance_matrix_1.sum() / len(solution))\n        norm_obj2 = obj2 / (distance_matrix_2.sum() / len(solution))\n        # Potential is higher if objectives are diverse and not too extreme\n        return abs(norm_obj1 - norm_obj2) * (1 - max(norm_obj1, norm_obj2))\n\n    # Sort solutions by potential and select the top 20% for random selection\n    sorted_solutions = sorted(archive, key=lambda x: -potential_score(x[0], x[1]))\n    top_solutions = sorted_solutions[:max(1, len(sorted_solutions) // 5)]\n    selected_solution, _ = random.choice(top_solutions)\n    base_solution = selected_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a multi-objective aware move\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 segments to rearrange\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Create a candidate solution by reversing segments and reordering\n    candidate = new_solution.copy()\n    candidate[i:j] = np.flip(candidate[i:j])\n    candidate[j:k] = np.flip(candidate[j:k])\n\n    # Evaluate the candidate's objectives\n    def compute_objective(sol):\n        obj1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        obj2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        return obj1, obj2\n\n    candidate_obj = compute_objective(candidate)\n    current_obj = compute_objective(new_solution)\n\n    # Accept the candidate if it improves at least one objective\n    if (candidate_obj[0] < current_obj[0]) or (candidate_obj[1] < current_obj[1]):\n        new_solution = candidate\n\n    # Additional multi-objective aware move: swap nodes based on their contribution to both objectives\n    for _ in range(3):  # Limit the number of swaps to avoid excessive computation\n        a, b = random.sample(range(n), 2)\n        if a == b:\n            continue\n\n        # Evaluate the swap\n        original_segment = [new_solution[a-1], new_solution[a], new_solution[(a+1)%n]]\n        new_segment = [new_solution[a-1], new_solution[b], new_solution[(a+1)%n]]\n        original_cost1 = distance_matrix_1[original_segment[0], original_segment[1]] + distance_matrix_1[original_segment[1], original_segment[2]]\n        new_cost1 = distance_matrix_1[new_segment[0], new_segment[1]] + distance_matrix_1[new_segment[1], new_segment[2]]\n\n        original_segment = [new_solution[b-1], new_solution[b], new_solution[(b+1)%n]]\n        new_segment = [new_solution[b-1], new_solution[a], new_solution[(b+1)%n]]\n        original_cost2 = distance_matrix_2[original_segment[0], original_segment[1]] + distance_matrix_2[original_segment[1], original_segment[2]]\n        new_cost2 = distance_matrix_2[new_segment[0], new_segment[1]] + distance_matrix_2[new_segment[1], new_segment[2]]\n\n        # Accept if at least one objective improves\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.48633566753690105,
            2.4760817885398865
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with high variance in objectives)\n    def potential_score(solution, objective):\n        # Normalize objectives to compare them\n        obj1, obj2 = objective\n        norm_obj1 = obj1 / (distance_matrix_1.sum() / len(solution))\n        norm_obj2 = obj2 / (distance_matrix_2.sum() / len(solution))\n        # Potential is higher if objectives are diverse and not too extreme\n        return abs(norm_obj1 - norm_obj2) * (1 - max(norm_obj1, norm_obj2))\n\n    # Sort solutions by potential and select the top 20% for random selection\n    sorted_solutions = sorted(archive, key=lambda x: -potential_score(x[0], x[1]))\n    top_solutions = sorted_solutions[:max(1, len(sorted_solutions) // 5)]\n    selected_solution, _ = random.choice(top_solutions)\n    base_solution = selected_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a multi-objective aware move\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 segments to rearrange\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Create a candidate solution by reversing segments and reordering\n    candidate = new_solution.copy()\n    candidate[i:j] = np.flip(candidate[i:j])\n    candidate[j:k] = np.flip(candidate[j:k])\n\n    # Evaluate the candidate's objectives\n    def compute_objective(sol):\n        obj1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        obj2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        return obj1, obj2\n\n    candidate_obj = compute_objective(candidate)\n    current_obj = compute_objective(new_solution)\n\n    # Accept the candidate if it improves at least one objective\n    if (candidate_obj[0] < current_obj[0]) or (candidate_obj[1] < current_obj[1]):\n        new_solution = candidate\n\n    # Additional multi-objective aware move: swap nodes based on their contribution to both objectives\n    for _ in range(3):  # Limit the number of swaps to avoid excessive computation\n        a, b = random.sample(range(n), 2)\n        if a == b:\n            continue\n\n        # Evaluate the swap\n        original_segment = [new_solution[a-1], new_solution[a], new_solution[(a+1)%n]]\n        new_segment = [new_solution[a-1], new_solution[b], new_solution[(a+1)%n]]\n        original_cost1 = distance_matrix_1[original_segment[0], original_segment[1]] + distance_matrix_1[original_segment[1], original_segment[2]]\n        new_cost1 = distance_matrix_1[new_segment[0], new_segment[1]] + distance_matrix_1[new_segment[1], new_segment[2]]\n\n        original_segment = [new_solution[b-1], new_solution[b], new_solution[(b+1)%n]]\n        new_segment = [new_solution[b-1], new_solution[a], new_solution[(b+1)%n]]\n        original_cost2 = distance_matrix_2[original_segment[0], original_segment[1]] + distance_matrix_2[original_segment[1], original_segment[2]]\n        new_cost2 = distance_matrix_2[new_segment[0], new_segment[1]] + distance_matrix_2[new_segment[1], new_segment[2]]\n\n        # Accept if at least one objective improves\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 191,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weights = [0.5, 0.5]  # Equal weights for both objectives\n    best_idx = np.argmin([weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt + edge-swap\n    if n >= 5:\n        # 3-opt move: select 3 random segments and reconnect them\n        i, j, k = sorted(np.random.choice(range(1, n-1), 3, replace=False))\n        segment1 = new_solution[:i]\n        segment2 = new_solution[i:j]\n        segment3 = new_solution[j:k]\n        segment4 = new_solution[k:]\n\n        # Reconnect segments in a new order\n        new_order = np.concatenate([segment1, segment3, segment2, segment4])\n        new_solution = new_order\n\n        # Edge-swap: swap two edges if it improves both objectives\n        for _ in range(10):  # Limit iterations to avoid excessive computation\n            a, b = sorted(np.random.choice(range(n), 2, replace=False))\n            if a == 0 and b == n-1:\n                continue  # Skip if it would break the tour\n\n            # Current edges: (a-1, a), (a, a+1), (b-1, b), (b, b+1)\n            # New edges: (a-1, b), (b, a+1), (b-1, a), (a, b+1)\n            old_edges = [\n                (new_solution[a-1], new_solution[a]),\n                (new_solution[a], new_solution[(a+1)%n]),\n                (new_solution[b-1], new_solution[b]),\n                (new_solution[b], new_solution[(b+1)%n])\n            ]\n            new_edges = [\n                (new_solution[a-1], new_solution[b]),\n                (new_solution[b], new_solution[(a+1)%n]),\n                (new_solution[b-1], new_solution[a]),\n                (new_solution[a], new_solution[(b+1)%n])\n            ]\n\n            # Calculate change in both objectives\n            delta_obj1 = sum(distance_matrix_1[u][v] for u, v in new_edges) - sum(distance_matrix_1[u][v] for u, v in old_edges)\n            delta_obj2 = sum(distance_matrix_2[u][v] for u, v in new_edges) - sum(distance_matrix_2[u][v] for u, v in old_edges)\n\n            # Accept if both objectives improve\n            if delta_obj1 < 0 and delta_obj2 < 0:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7254462136029283,
            2.318161964416504
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weights = [0.5, 0.5]  # Equal weights for both objectives\n    best_idx = np.argmin([weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt + edge-swap\n    if n >= 5:\n        # 3-opt move: select 3 random segments and reconnect them\n        i, j, k = sorted(np.random.choice(range(1, n-1), 3, replace=False))\n        segment1 = new_solution[:i]\n        segment2 = new_solution[i:j]\n        segment3 = new_solution[j:k]\n        segment4 = new_solution[k:]\n\n        # Reconnect segments in a new order\n        new_order = np.concatenate([segment1, segment3, segment2, segment4])\n        new_solution = new_order\n\n        # Edge-swap: swap two edges if it improves both objectives\n        for _ in range(10):  # Limit iterations to avoid excessive computation\n            a, b = sorted(np.random.choice(range(n), 2, replace=False))\n            if a == 0 and b == n-1:\n                continue  # Skip if it would break the tour\n\n            # Current edges: (a-1, a), (a, a+1), (b-1, b), (b, b+1)\n            # New edges: (a-1, b), (b, a+1), (b-1, a), (a, b+1)\n            old_edges = [\n                (new_solution[a-1], new_solution[a]),\n                (new_solution[a], new_solution[(a+1)%n]),\n                (new_solution[b-1], new_solution[b]),\n                (new_solution[b], new_solution[(b+1)%n])\n            ]\n            new_edges = [\n                (new_solution[a-1], new_solution[b]),\n                (new_solution[b], new_solution[(a+1)%n]),\n                (new_solution[b-1], new_solution[a]),\n                (new_solution[a], new_solution[(b+1)%n])\n            ]\n\n            # Calculate change in both objectives\n            delta_obj1 = sum(distance_matrix_1[u][v] for u, v in new_edges) - sum(distance_matrix_1[u][v] for u, v in old_edges)\n            delta_obj2 = sum(distance_matrix_2[u][v] for u, v in new_edges) - sum(distance_matrix_2[u][v] for u, v in old_edges)\n\n            # Accept if both objectives improve\n            if delta_obj1 < 0 and delta_obj2 < 0:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 192,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (randomly weighted by objective values)\n    weights = np.array([(obj[0] + obj[1]) / (len(archive) + 1) for _, obj in archive])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct nodes to perform 3-opt\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move\n    if a + 1 < b and b + 1 < c:\n        # Reverse the middle segment\n        new_solution[a+1:b+1] = new_solution[a+1:b+1][::-1]\n        new_solution[b+1:c+1] = new_solution[b+1:c+1][::-1]\n\n    # Custom edge insertion: try to improve by inserting a random edge\n    i, j = sorted(random.sample(range(n), 2))\n    if j - i > 1:\n        # Remove edge between i and j\n        temp = new_solution[i+1:j].copy()\n        # Insert in reverse order\n        new_solution[i+1:j] = temp[::-1]\n\n    # Ensure solution remains valid (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or not np.array_equal(np.sort(unique_nodes), np.arange(n)):\n        # If invalid, fall back to a valid random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8294508037397039,
            1.1998382806777954
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (randomly weighted by objective values)\n    weights = np.array([(obj[0] + obj[1]) / (len(archive) + 1) for _, obj in archive])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct nodes to perform 3-opt\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move\n    if a + 1 < b and b + 1 < c:\n        # Reverse the middle segment\n        new_solution[a+1:b+1] = new_solution[a+1:b+1][::-1]\n        new_solution[b+1:c+1] = new_solution[b+1:c+1][::-1]\n\n    # Custom edge insertion: try to improve by inserting a random edge\n    i, j = sorted(random.sample(range(n), 2))\n    if j - i > 1:\n        # Remove edge between i and j\n        temp = new_solution[i+1:j].copy()\n        # Insert in reverse order\n        new_solution[i+1:j] = temp[::-1]\n\n    # Ensure solution remains valid (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or not np.array_equal(np.sort(unique_nodes), np.arange(n)):\n        # If invalid, fall back to a valid random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 193,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    # Here, we use the inverse of the sum of objectives as a proxy for potential\n    objectives = [obj for _, obj in archive]\n    total_cost = sum(obj[0] + obj[1] for obj in objectives)\n    if total_cost == 0:\n        weights = [1.0 / len(archive)] * len(archive)\n    else:\n        weights = [(1 - (obj[0] + obj[1]) / total_cost) for obj in objectives]\n        weights = [max(w, 0.01) for w in weights]  # Ensure no zero weights\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combination of edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment to reverse\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Step 2: Randomly select two nodes and perform edge insertion\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    if i != 0 or j != n-1:  # Ensure we don't break the tour\n        if j - i > 1:\n            # Insert the segment between i and j\n            segment = new_solution[i+1:j]\n            new_solution = np.concatenate([new_solution[:i+1], segment[::-1], new_solution[j:]])\n\n    # Verify the solution is valid (all nodes visited exactly once)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, fall back to a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8405931948435947,
            0.9678384065628052
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    # Here, we use the inverse of the sum of objectives as a proxy for potential\n    objectives = [obj for _, obj in archive]\n    total_cost = sum(obj[0] + obj[1] for obj in objectives)\n    if total_cost == 0:\n        weights = [1.0 / len(archive)] * len(archive)\n    else:\n        weights = [(1 - (obj[0] + obj[1]) / total_cost) for obj in objectives]\n        weights = [max(w, 0.01) for w in weights]  # Ensure no zero weights\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combination of edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment to reverse\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Step 2: Randomly select two nodes and perform edge insertion\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    if i != 0 or j != n-1:  # Ensure we don't break the tour\n        if j - i > 1:\n            # Insert the segment between i and j\n            segment = new_solution[i+1:j]\n            new_solution = np.concatenate([new_solution[:i+1], segment[::-1], new_solution[j:]])\n\n    # Verify the solution is valid (all nodes visited exactly once)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, fall back to a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 194,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a combination of objective values and diversity\n    candidates = []\n    for sol, obj in archive:\n        # Calculate a score based on objective values (lower is better)\n        score = obj[0] + obj[1]\n        candidates.append((score, sol))\n\n    # Sort candidates by score and select the top 30% for further consideration\n    candidates.sort(key=lambda x: x[0])\n    top_candidates = [sol for score, sol in candidates[:max(1, len(candidates) // 3)]]\n\n    # Randomly select one of the top candidates\n    base_solution = random.choice(top_candidates).copy()\n\n    # Hybrid local search strategy: combination of edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    start = random.randint(0, n - 1)\n    end = random.randint(start, min(start + 3, n - 1))  # Small segment for local improvement\n\n    # Extract the selected segment\n    segment = new_solution[start:end+1]\n\n    # Try different operations on the segment\n    operations = [\n        lambda s: np.roll(s, 1),  # Rotate segment\n        lambda s: s[::-1],        # Reverse segment\n        lambda s: np.concatenate([s[1:], [s[0]]])  # Shift segment\n    ]\n\n    best_neighbor = new_solution.copy()\n    best_improvement = 0\n\n    for op in operations:\n        modified_segment = op(segment.copy())\n        candidate = new_solution.copy()\n        candidate[start:end+1] = modified_segment\n\n        # Calculate cost difference\n        old_cost = (distance_matrix_1[new_solution[-1], new_solution[0]] +\n                    distance_matrix_1[new_solution[-2], new_solution[-1]] +\n                    distance_matrix_2[new_solution[-1], new_solution[0]] +\n                    distance_matrix_2[new_solution[-2], new_solution[-1]])\n\n        new_cost = (distance_matrix_1[candidate[-1], candidate[0]] +\n                    distance_matrix_1[candidate[-2], candidate[-1]] +\n                    distance_matrix_2[candidate[-1], candidate[0]] +\n                    distance_matrix_2[candidate[-2], candidate[-1]])\n\n        improvement = old_cost - new_cost\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_neighbor = candidate.copy()\n\n    # If no improvement, try a random swap\n    if best_improvement <= 0:\n        i, j = random.sample(range(n), 2)\n        best_neighbor[i], best_neighbor[j] = best_neighbor[j], best_neighbor[i]\n\n    return best_neighbor\n\n",
        "score": [
            -0.835124552720608,
            1.206666648387909
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a combination of objective values and diversity\n    candidates = []\n    for sol, obj in archive:\n        # Calculate a score based on objective values (lower is better)\n        score = obj[0] + obj[1]\n        candidates.append((score, sol))\n\n    # Sort candidates by score and select the top 30% for further consideration\n    candidates.sort(key=lambda x: x[0])\n    top_candidates = [sol for score, sol in candidates[:max(1, len(candidates) // 3)]]\n\n    # Randomly select one of the top candidates\n    base_solution = random.choice(top_candidates).copy()\n\n    # Hybrid local search strategy: combination of edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    start = random.randint(0, n - 1)\n    end = random.randint(start, min(start + 3, n - 1))  # Small segment for local improvement\n\n    # Extract the selected segment\n    segment = new_solution[start:end+1]\n\n    # Try different operations on the segment\n    operations = [\n        lambda s: np.roll(s, 1),  # Rotate segment\n        lambda s: s[::-1],        # Reverse segment\n        lambda s: np.concatenate([s[1:], [s[0]]])  # Shift segment\n    ]\n\n    best_neighbor = new_solution.copy()\n    best_improvement = 0\n\n    for op in operations:\n        modified_segment = op(segment.copy())\n        candidate = new_solution.copy()\n        candidate[start:end+1] = modified_segment\n\n        # Calculate cost difference\n        old_cost = (distance_matrix_1[new_solution[-1], new_solution[0]] +\n                    distance_matrix_1[new_solution[-2], new_solution[-1]] +\n                    distance_matrix_2[new_solution[-1], new_solution[0]] +\n                    distance_matrix_2[new_solution[-2], new_solution[-1]])\n\n        new_cost = (distance_matrix_1[candidate[-1], candidate[0]] +\n                    distance_matrix_1[candidate[-2], candidate[-1]] +\n                    distance_matrix_2[candidate[-1], candidate[0]] +\n                    distance_matrix_2[candidate[-2], candidate[-1]])\n\n        improvement = old_cost - new_cost\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_neighbor = candidate.copy()\n\n    # If no improvement, try a random swap\n    if best_improvement <= 0:\n        i, j = random.sample(range(n), 2)\n        best_neighbor[i], best_neighbor[j] = best_neighbor[j], best_neighbor[i]\n\n    return best_neighbor\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 195,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto front solutions)\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-swap strategy\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three distinct indices\n    i, j, k = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Perform 3-opt move\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    # Novel edge-swap: swap edges between segments to reduce both objectives\n    if np.random.rand() < 0.5:  # 50% chance to apply edge-swap\n        segment1 = new_solution[:i+1]\n        segment2 = new_solution[i+1:j+1]\n        segment3 = new_solution[j+1:]\n\n        # Try to swap edges between segments to reduce both objectives\n        if len(segment1) > 1 and len(segment2) > 1:\n            # Calculate current and potential costs\n            current_cost1 = distance_matrix_1[segment1[-1], segment2[0]]\n            current_cost2 = distance_matrix_2[segment1[-1], segment2[0]]\n\n            potential_cost1 = distance_matrix_1[segment1[-1], segment3[0]] + distance_matrix_1[segment3[-1], segment2[0]]\n            potential_cost2 = distance_matrix_2[segment1[-1], segment3[0]] + distance_matrix_2[segment3[-1], segment2[0]]\n\n            if (potential_cost1 + potential_cost2) < (current_cost1 + current_cost2):\n                # Perform the swap\n                new_solution = np.concatenate([segment1, segment3, segment2])\n\n    return new_solution\n\n",
        "score": [
            -0.6285039487942667,
            1.1317054629325867
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto front solutions)\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-swap strategy\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three distinct indices\n    i, j, k = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Perform 3-opt move\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    # Novel edge-swap: swap edges between segments to reduce both objectives\n    if np.random.rand() < 0.5:  # 50% chance to apply edge-swap\n        segment1 = new_solution[:i+1]\n        segment2 = new_solution[i+1:j+1]\n        segment3 = new_solution[j+1:]\n\n        # Try to swap edges between segments to reduce both objectives\n        if len(segment1) > 1 and len(segment2) > 1:\n            # Calculate current and potential costs\n            current_cost1 = distance_matrix_1[segment1[-1], segment2[0]]\n            current_cost2 = distance_matrix_2[segment1[-1], segment2[0]]\n\n            potential_cost1 = distance_matrix_1[segment1[-1], segment3[0]] + distance_matrix_1[segment3[-1], segment2[0]]\n            potential_cost2 = distance_matrix_2[segment1[-1], segment3[0]] + distance_matrix_2[segment3[-1], segment2[0]]\n\n            if (potential_cost1 + potential_cost2) < (current_cost1 + current_cost2):\n                # Perform the swap\n                new_solution = np.concatenate([segment1, segment3, segment2])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 196,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a probability inversely proportional to its dominance rank\n    # (simplified: here we randomly select among the top 20% of solutions)\n    top_k = max(1, int(0.2 * len(archive)))\n    selected_idx = random.randint(0, top_k - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operators\n\n    # Operator 1: Edge swap (2-opt variant but more selective)\n    i, j = sorted(random.sample(range(n), 2))\n    if j - i > 1:\n        new_solution[i:j] = new_solution[i:j][::-1]  # Reverse the segment\n\n    # Operator 2: Segment relocation (novel operator)\n    if n > 4:\n        segment_size = random.randint(2, min(4, n // 3))\n        start = random.randint(0, n - segment_size - 1)\n        segment = new_solution[start:start + segment_size]\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[start + segment_size:],\n            segment\n        ])\n\n    # Ensure the solution remains valid (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or not np.array_equal(np.sort(unique_nodes), np.sort(base_solution)):\n        # Fallback: revert to base solution if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6576792617103319,
            1.1325640082359314
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a probability inversely proportional to its dominance rank\n    # (simplified: here we randomly select among the top 20% of solutions)\n    top_k = max(1, int(0.2 * len(archive)))\n    selected_idx = random.randint(0, top_k - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operators\n\n    # Operator 1: Edge swap (2-opt variant but more selective)\n    i, j = sorted(random.sample(range(n), 2))\n    if j - i > 1:\n        new_solution[i:j] = new_solution[i:j][::-1]  # Reverse the segment\n\n    # Operator 2: Segment relocation (novel operator)\n    if n > 4:\n        segment_size = random.randint(2, min(4, n // 3))\n        start = random.randint(0, n - segment_size - 1)\n        segment = new_solution[start:start + segment_size]\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[start + segment_size:],\n            segment\n        ])\n\n    # Ensure the solution remains valid (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or not np.array_equal(np.sort(unique_nodes), np.sort(base_solution)):\n        # Fallback: revert to base solution if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 197,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 3:\n        candidates = sorted(archive, key=lambda x: sum(x[1]))[1:-1]  # Exclude best and worst\n        selected = random.choice(candidates)\n    else:\n        selected = random.choice(archive)\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-swap heuristic\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Novel edge-swap heuristic: swap edges (a,b) and (b,c) with (a,c) and (b,b) (but keep tour valid)\n    if a != b and b != c and a != c:\n        # Create a new segment by reversing the middle part\n        new_segment = new_solution[a:b+1]\n        new_segment = np.concatenate([new_segment[:1], new_segment[1:][::-1]])\n        new_solution[a:b+1] = new_segment\n\n        # Reconnect the tour\n        new_solution[b+1:] = np.roll(new_solution[b+1:], -1)\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if the above operation fails\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7931502461876643,
            1.1793012619018555
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 3:\n        candidates = sorted(archive, key=lambda x: sum(x[1]))[1:-1]  # Exclude best and worst\n        selected = random.choice(candidates)\n    else:\n        selected = random.choice(archive)\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-swap heuristic\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Novel edge-swap heuristic: swap edges (a,b) and (b,c) with (a,c) and (b,b) (but keep tour valid)\n    if a != b and b != c and a != c:\n        # Create a new segment by reversing the middle part\n        new_segment = new_solution[a:b+1]\n        new_segment = np.concatenate([new_segment[:1], new_segment[1:][::-1]])\n        new_solution[a:b+1] = new_segment\n\n        # Reconnect the tour\n        new_solution[b+1:] = np.roll(new_solution[b+1:], -1)\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if the above operation fails\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 198,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest combined cost)\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: alternate between edge-swapping and segment-reversal\n    if random.random() < 0.7:  # 70% chance for edge-swapping\n        # Edge-swapping: select two non-adjacent edges and swap their nodes\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        if i + 1 != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:  # 30% chance for segment-reversal\n        # Segment-reversal: reverse a random segment of the tour\n        a, b = sorted(random.sample(range(1, n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.681736545346233,
            1.5224506855010986
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest combined cost)\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: alternate between edge-swapping and segment-reversal\n    if random.random() < 0.7:  # 70% chance for edge-swapping\n        # Edge-swapping: select two non-adjacent edges and swap their nodes\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        if i + 1 != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:  # 30% chance for segment-reversal\n        # Segment-reversal: reverse a random segment of the tour\n        a, b = sorted(random.sample(range(1, n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 199,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Extract solutions and objectives\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Normalize objectives to [0, 1] range for weighted selection\n    min_obj = objectives.min(axis=0)\n    max_obj = objectives.max(axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n    # Calculate weights: prefer solutions with lower objectives\n    weights = 1 - normalized_obj.mean(axis=1)\n    weights = np.maximum(weights, 0)  # Ensure non-negative weights\n    weights = weights / np.sum(weights)  # Normalize to sum to 1\n\n    # Select a solution with probability proportional to weights\n    selected_idx = np.random.choice(len(solutions), p=weights)\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment to reverse (segment reversal)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Randomly select two edges and perform edge insertion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    node_a = new_solution[a]\n    node_b = new_solution[b]\n\n    # Find the positions of node_a and node_b in the current solution\n    pos_a = np.where(new_solution == node_a)[0][0]\n    pos_b = np.where(new_solution == node_b)[0][0]\n\n    # Remove node_a from its current position\n    new_solution = np.delete(new_solution, pos_a)\n    # Insert node_a after node_b\n    if pos_b < pos_a:\n        new_solution = np.insert(new_solution, pos_b + 1, node_a)\n    else:\n        new_solution = np.insert(new_solution, pos_b, node_a)\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.8664776287502256,
            1.128874659538269
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Extract solutions and objectives\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Normalize objectives to [0, 1] range for weighted selection\n    min_obj = objectives.min(axis=0)\n    max_obj = objectives.max(axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n    # Calculate weights: prefer solutions with lower objectives\n    weights = 1 - normalized_obj.mean(axis=1)\n    weights = np.maximum(weights, 0)  # Ensure non-negative weights\n    weights = weights / np.sum(weights)  # Normalize to sum to 1\n\n    # Select a solution with probability proportional to weights\n    selected_idx = np.random.choice(len(solutions), p=weights)\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment to reverse (segment reversal)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Randomly select two edges and perform edge insertion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    node_a = new_solution[a]\n    node_b = new_solution[b]\n\n    # Find the positions of node_a and node_b in the current solution\n    pos_a = np.where(new_solution == node_a)[0][0]\n    pos_b = np.where(new_solution == node_b)[0][0]\n\n    # Remove node_a from its current position\n    new_solution = np.delete(new_solution, pos_a)\n    # Insert node_a after node_b\n    if pos_b < pos_a:\n        new_solution = np.insert(new_solution, pos_b + 1, node_a)\n    else:\n        new_solution = np.insert(new_solution, pos_b, node_a)\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 200,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective values)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with edge-swapping\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select 3 distinct edges to modify\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Perform 3-opt move\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Edge-swapping heuristic: swap edges if it improves both objectives\n    for _ in range(3):  # Limit the number of swaps to avoid excessive computation\n        a, b, c = sorted(random.sample(range(n), 3))\n        current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (random.random() < 0.3 and (new_cost1 < current_cost1 or new_cost2 < current_cost2)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains valid\n    assert len(set(new_solution)) == len(base_solution), \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.7826046776832287,
            0.9902992844581604
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective values)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with edge-swapping\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select 3 distinct edges to modify\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Perform 3-opt move\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Edge-swapping heuristic: swap edges if it improves both objectives\n    for _ in range(3):  # Limit the number of swaps to avoid excessive computation\n        a, b, c = sorted(random.sample(range(n), 3))\n        current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (random.random() < 0.3 and (new_cost1 < current_cost1 or new_cost2 < current_cost2)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains valid\n    assert len(set(new_solution)) == len(base_solution), \"Generated solution is invalid\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 201,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    sorted_archive = sorted(archive, key=lambda x: min(x[1]))\n    selected_solution = sorted_archive[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Apply a combination of 2-opt and a novel edge insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small tours\n\n    # Randomly select a segment to modify\n    segment_size = random.randint(2, min(5, n // 2))\n    start_idx = random.randint(0, n - segment_size - 1)\n    segment = new_solution[start_idx:start_idx + segment_size]\n\n    # Novel edge insertion: Insert the segment in a different position\n    new_pos = random.randint(0, n - segment_size)\n    if new_pos > start_idx:\n        new_pos -= segment_size  # Adjust for insertion after the segment\n\n    # Remove the segment and insert it at the new position\n    new_solution = np.concatenate([\n        new_solution[:start_idx],\n        new_solution[start_idx + segment_size:new_pos],\n        segment,\n        new_solution[new_pos:]\n    ])\n\n    # Verify the solution is valid (no duplicates and all nodes included)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.3338008388535197,
            0.3505043387413025
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    sorted_archive = sorted(archive, key=lambda x: min(x[1]))\n    selected_solution = sorted_archive[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Apply a combination of 2-opt and a novel edge insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small tours\n\n    # Randomly select a segment to modify\n    segment_size = random.randint(2, min(5, n // 2))\n    start_idx = random.randint(0, n - segment_size - 1)\n    segment = new_solution[start_idx:start_idx + segment_size]\n\n    # Novel edge insertion: Insert the segment in a different position\n    new_pos = random.randint(0, n - segment_size)\n    if new_pos > start_idx:\n        new_pos -= segment_size  # Adjust for insertion after the segment\n\n    # Remove the segment and insert it at the new position\n    new_solution = np.concatenate([\n        new_solution[:start_idx],\n        new_solution[start_idx + segment_size:new_pos],\n        segment,\n        new_solution[new_pos:]\n    ])\n\n    # Verify the solution is valid (no duplicates and all nodes included)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 202,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Normalize objectives to avoid scale bias\n        normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n        # Select solutions with high variance or high potential\n        potential_scores = np.std(normalized_obj, axis=1) + np.mean(normalized_obj, axis=1)\n        selected_idx = np.argmax(potential_scores)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combination of edge insertion and segment reversal\n    if n <= 3:\n        # For small tours, just reverse the entire tour\n        new_solution = new_solution[::-1]\n    else:\n        # Select a random segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        # Reverse the segment\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Optionally, perform edge insertion for further improvement\n        if random.random() < 0.3:  # 30% chance to perform insertion\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            while j == i or j == (i+1)%n:\n                j = random.randint(0, n-1)\n            # Insert node at i after node at j\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            if j < i:\n                new_solution = np.insert(new_solution, j+1, node)\n            else:\n                new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9200730889578793,
            1.0976480841636658
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Normalize objectives to avoid scale bias\n        normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n        # Select solutions with high variance or high potential\n        potential_scores = np.std(normalized_obj, axis=1) + np.mean(normalized_obj, axis=1)\n        selected_idx = np.argmax(potential_scores)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combination of edge insertion and segment reversal\n    if n <= 3:\n        # For small tours, just reverse the entire tour\n        new_solution = new_solution[::-1]\n    else:\n        # Select a random segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        # Reverse the segment\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Optionally, perform edge insertion for further improvement\n        if random.random() < 0.3:  # 30% chance to perform insertion\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            while j == i or j == (i+1)%n:\n                j = random.randint(0, n-1)\n            # Insert node at i after node at j\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            if j < i:\n                new_solution = np.insert(new_solution, j+1, node)\n            else:\n                new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 203,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective values)\n    total_costs = [obj[0] + obj[1] for _, obj in archive]\n    if not total_costs:\n        selected_idx = 0\n    else:\n        weights = [1.0 / (cost + 1e-6) for cost in total_costs]  # Inverse of cost as weight\n        selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a novel segment relocation strategy\n    n = len(new_solution)\n    if n < 4:\n        # Simple swap if too small\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # 3-opt like operation (but more sophisticated)\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n\n    # Novel strategy: relocate segments with probabilistic direction\n    if random.random() < 0.5:\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n    else:\n        new_solution = np.concatenate([new_solution[:a], segment1[::-1], segment2[::-1], new_solution[c:]])\n\n    # Ensure feasibility by checking for duplicates (though segments are already part of the solution)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple 2-opt if feasibility is violated\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution = np.concatenate([new_solution[:i], new_solution[i:j][::-1], new_solution[j:]])\n\n    return new_solution\n\n",
        "score": [
            -0.7690318639669163,
            0.9143147468566895
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective values)\n    total_costs = [obj[0] + obj[1] for _, obj in archive]\n    if not total_costs:\n        selected_idx = 0\n    else:\n        weights = [1.0 / (cost + 1e-6) for cost in total_costs]  # Inverse of cost as weight\n        selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a novel segment relocation strategy\n    n = len(new_solution)\n    if n < 4:\n        # Simple swap if too small\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # 3-opt like operation (but more sophisticated)\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n\n    # Novel strategy: relocate segments with probabilistic direction\n    if random.random() < 0.5:\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n    else:\n        new_solution = np.concatenate([new_solution[:a], segment1[::-1], segment2[::-1], new_solution[c:]])\n\n    # Ensure feasibility by checking for duplicates (though segments are already part of the solution)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple 2-opt if feasibility is violated\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution = np.concatenate([new_solution[:i], new_solution[i:j][::-1], new_solution[j:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 204,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on a combination of objective values and diversity\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy\n    def calculate_total_cost(solution, distance_matrix):\n        total = 0.0\n        for i in range(len(solution) - 1):\n            total += distance_matrix[solution[i], solution[i+1]]\n        total += distance_matrix[solution[-1], solution[0]]\n        return total\n\n    current_cost1 = calculate_total_cost(base_solution, distance_matrix_1)\n    current_cost2 = calculate_total_cost(base_solution, distance_matrix_2)\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Try a combination of 2-opt and edge-swap\n    for _ in range(10):  # Number of attempts\n        # Randomly select two distinct edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Perform 2-opt move\n        temp_solution = new_solution.copy()\n        temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n        # Calculate new costs\n        new_cost1 = calculate_total_cost(temp_solution, distance_matrix_1)\n        new_cost2 = calculate_total_cost(temp_solution, distance_matrix_2)\n\n        # If improvement in at least one objective, accept\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution = temp_solution\n            current_cost1, current_cost2 = new_cost1, new_cost2\n        else:\n            # Try edge-swap if 2-opt didn't improve\n            k, l = sorted(random.sample(range(n), 2))\n            temp_solution = new_solution.copy()\n            temp_solution[k], temp_solution[l] = temp_solution[l], temp_solution[k]\n\n            new_cost1 = calculate_total_cost(temp_solution, distance_matrix_1)\n            new_cost2 = calculate_total_cost(temp_solution, distance_matrix_2)\n\n            if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n                new_solution = temp_solution\n                current_cost1, current_cost2 = new_cost1, new_cost2\n\n    return new_solution\n\n",
        "score": [
            -0.9730866723146209,
            3.1883144974708557
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on a combination of objective values and diversity\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy\n    def calculate_total_cost(solution, distance_matrix):\n        total = 0.0\n        for i in range(len(solution) - 1):\n            total += distance_matrix[solution[i], solution[i+1]]\n        total += distance_matrix[solution[-1], solution[0]]\n        return total\n\n    current_cost1 = calculate_total_cost(base_solution, distance_matrix_1)\n    current_cost2 = calculate_total_cost(base_solution, distance_matrix_2)\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Try a combination of 2-opt and edge-swap\n    for _ in range(10):  # Number of attempts\n        # Randomly select two distinct edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Perform 2-opt move\n        temp_solution = new_solution.copy()\n        temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n        # Calculate new costs\n        new_cost1 = calculate_total_cost(temp_solution, distance_matrix_1)\n        new_cost2 = calculate_total_cost(temp_solution, distance_matrix_2)\n\n        # If improvement in at least one objective, accept\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution = temp_solution\n            current_cost1, current_cost2 = new_cost1, new_cost2\n        else:\n            # Try edge-swap if 2-opt didn't improve\n            k, l = sorted(random.sample(range(n), 2))\n            temp_solution = new_solution.copy()\n            temp_solution[k], temp_solution[l] = temp_solution[l], temp_solution[k]\n\n            new_cost1 = calculate_total_cost(temp_solution, distance_matrix_1)\n            new_cost2 = calculate_total_cost(temp_solution, distance_matrix_2)\n\n            if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n                new_solution = temp_solution\n                current_cost1, current_cost2 = new_cost1, new_cost2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 205,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: Segment-based perturbation with edge insertion\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to apply the strategy\n\n    # Step 1: Select a random segment of the tour\n    seg_start = random.randint(0, n - 4)\n    seg_length = random.randint(2, min(5, n - seg_start - 1))\n    segment = base_solution[seg_start:seg_start + seg_length]\n\n    # Step 2: Remove the segment and insert it in a different position\n    remaining = np.concatenate([base_solution[:seg_start], base_solution[seg_start + seg_length:]])\n    insert_pos = random.randint(0, len(remaining) - 1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 3: Apply edge insertion to refine the solution\n    for _ in range(3):  # Limit the number of insertions to avoid excessive computation\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) < 2:\n            continue  # Skip if too close to avoid trivial changes\n\n        # Insert node j between i and i+1\n        if i < j:\n            new_solution = np.concatenate([new_solution[:i+1], [new_solution[j]], new_solution[i+1:j], new_solution[j+1:]])\n        else:\n            new_solution = np.concatenate([new_solution[:j+1], [new_solution[i]], new_solution[j+1:i], new_solution[i+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8499222894054834,
            1.0020915269851685
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: Segment-based perturbation with edge insertion\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to apply the strategy\n\n    # Step 1: Select a random segment of the tour\n    seg_start = random.randint(0, n - 4)\n    seg_length = random.randint(2, min(5, n - seg_start - 1))\n    segment = base_solution[seg_start:seg_start + seg_length]\n\n    # Step 2: Remove the segment and insert it in a different position\n    remaining = np.concatenate([base_solution[:seg_start], base_solution[seg_start + seg_length:]])\n    insert_pos = random.randint(0, len(remaining) - 1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 3: Apply edge insertion to refine the solution\n    for _ in range(3):  # Limit the number of insertions to avoid excessive computation\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) < 2:\n            continue  # Skip if too close to avoid trivial changes\n\n        # Insert node j between i and i+1\n        if i < j:\n            new_solution = np.concatenate([new_solution[:i+1], [new_solution[j]], new_solution[i+1:j], new_solution[j+1:]])\n        else:\n            new_solution = np.concatenate([new_solution[:j+1], [new_solution[i]], new_solution[j+1:i], new_solution[i+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 206,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high variance in objectives)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy combining edge insertion and segment reversal\n    n = len(base_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Edge insertion: move a segment to a different position\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n    insert_pos = random.randint(0, n - (j - i))\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Segment reversal: reverse a segment to potentially improve both objectives\n    if j - i > 1:\n        reverse_pos = random.randint(i, j - 1)\n        new_solution[i:reverse_pos + 1] = new_solution[i:reverse_pos + 1][::-1]\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.8153972341289892,
            1.3858806490898132
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high variance in objectives)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy combining edge insertion and segment reversal\n    n = len(base_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Edge insertion: move a segment to a different position\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n    insert_pos = random.randint(0, n - (j - i))\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Segment reversal: reverse a segment to potentially improve both objectives\n    if j - i > 1:\n        reverse_pos = random.randint(i, j - 1)\n        new_solution[i:reverse_pos + 1] = new_solution[i:reverse_pos + 1][::-1]\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 207,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high variance in objectives)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine edge swapping with node insertion\n    n = len(base_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Edge swapping\n    new_solution[i:j] = base_solution[i:j][::-1]\n\n    # Node insertion (to escape local optima)\n    if random.random() < 0.3:  # 30% chance of applying node insertion\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains feasible (valid tour)\n    if len(np.unique(new_solution)) != n or new_solution[0] != base_solution[0]:\n        # Fallback to a simple swap if the solution becomes invalid\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8186863056959265,
            1.3266753554344177
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high variance in objectives)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine edge swapping with node insertion\n    n = len(base_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Edge swapping\n    new_solution[i:j] = base_solution[i:j][::-1]\n\n    # Node insertion (to escape local optima)\n    if random.random() < 0.3:  # 30% chance of applying node insertion\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains feasible (valid tour)\n    if len(np.unique(new_solution)) != n or new_solution[0] != base_solution[0]:\n        # Fallback to a simple swap if the solution becomes invalid\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 208,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already in the Pareto front)\n    # Here, we select a solution that is not dominated by others in the archive\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if not non_dominated:\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        base_solution = random.choice(non_dominated).copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine edge exchange with node relocation\n    # Step 1: Select two random edges and perform an edge exchange (similar to 2-opt but more flexible)\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Ensure the exchange is valid (no duplicate nodes and maintains tour structure)\n    if i != j and k != l and i != k and j != l:\n        # Perform the edge exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Step 2: Relocate a random node to a better position in the tour\n    node_to_move = random.randint(0, n-1)\n    current_node = new_solution[node_to_move]\n\n    # Evaluate possible insertion positions based on both objectives\n    best_pos = node_to_move\n    best_cost = float('inf')\n\n    for pos in range(n):\n        if pos == node_to_move or pos == (node_to_move + 1) % n:\n            continue\n\n        # Create a temporary tour with the node moved to 'pos'\n        temp_tour = np.roll(new_solution, -pos)\n        temp_tour[0] = current_node\n\n        # Calculate the cost of the temporary tour\n        cost1 = sum(distance_matrix_1[temp_tour[i], temp_tour[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_tour[i], temp_tour[(i+1)%n]] for i in range(n))\n        combined_cost = cost1 + cost2  # Simple weighted sum for selection\n\n        if combined_cost < best_cost:\n            best_cost = combined_cost\n            best_pos = pos\n\n    # Apply the best relocation\n    if best_pos != node_to_move:\n        new_solution = np.roll(new_solution, -best_pos)\n        new_solution[0] = current_node\n\n    return new_solution\n\n",
        "score": [
            -0.8824691209284796,
            6.9654399156570435
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already in the Pareto front)\n    # Here, we select a solution that is not dominated by others in the archive\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if not non_dominated:\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        base_solution = random.choice(non_dominated).copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine edge exchange with node relocation\n    # Step 1: Select two random edges and perform an edge exchange (similar to 2-opt but more flexible)\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Ensure the exchange is valid (no duplicate nodes and maintains tour structure)\n    if i != j and k != l and i != k and j != l:\n        # Perform the edge exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Step 2: Relocate a random node to a better position in the tour\n    node_to_move = random.randint(0, n-1)\n    current_node = new_solution[node_to_move]\n\n    # Evaluate possible insertion positions based on both objectives\n    best_pos = node_to_move\n    best_cost = float('inf')\n\n    for pos in range(n):\n        if pos == node_to_move or pos == (node_to_move + 1) % n:\n            continue\n\n        # Create a temporary tour with the node moved to 'pos'\n        temp_tour = np.roll(new_solution, -pos)\n        temp_tour[0] = current_node\n\n        # Calculate the cost of the temporary tour\n        cost1 = sum(distance_matrix_1[temp_tour[i], temp_tour[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_tour[i], temp_tour[(i+1)%n]] for i in range(n))\n        combined_cost = cost1 + cost2  # Simple weighted sum for selection\n\n        if combined_cost < best_cost:\n            best_cost = combined_cost\n            best_pos = pos\n\n    # Apply the best relocation\n    if best_pos != node_to_move:\n        new_solution = np.roll(new_solution, -best_pos)\n        new_solution[0] = current_node\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 209,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    solutions, objectives = zip(*archive)\n    costs = np.array([sum(obj) for obj in objectives])\n    if len(costs) > 0:\n        weights = np.max(costs) - costs + 1e-6  # Inverse of cost to favor lower-cost solutions\n        weights = weights / np.sum(weights)\n        selected_idx = np.random.choice(len(solutions), p=weights)\n    else:\n        selected_idx = np.random.randint(0, len(solutions))\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment relinking strategy\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Randomly select two segments to relink\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    c, d = sorted(random.sample(range(1, n-1), 2))\n\n    # Step 2: Extract segments and relink them\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    # Step 3: Reverse one segment and swap with the other\n    if random.random() < 0.5:\n        segment1 = segment1[::-1]\n\n    # Step 4: Insert the modified segment back\n    new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    # Step 5: Perform a local 2-opt to refine the solution\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != len(new_solution):\n        # Fallback to a simple swap if the solution is invalid\n        new_solution = base_solution.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8751168322180021,
            1.166735589504242
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    solutions, objectives = zip(*archive)\n    costs = np.array([sum(obj) for obj in objectives])\n    if len(costs) > 0:\n        weights = np.max(costs) - costs + 1e-6  # Inverse of cost to favor lower-cost solutions\n        weights = weights / np.sum(weights)\n        selected_idx = np.random.choice(len(solutions), p=weights)\n    else:\n        selected_idx = np.random.randint(0, len(solutions))\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment relinking strategy\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Randomly select two segments to relink\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    c, d = sorted(random.sample(range(1, n-1), 2))\n\n    # Step 2: Extract segments and relink them\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    # Step 3: Reverse one segment and swap with the other\n    if random.random() < 0.5:\n        segment1 = segment1[::-1]\n\n    # Step 4: Insert the modified segment back\n    new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    # Step 5: Perform a local 2-opt to refine the solution\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != len(new_solution):\n        # Fallback to a simple swap if the solution is invalid\n        new_solution = base_solution.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 210,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Intelligent random selection\n    # Select solutions that are not Pareto-dominated by others in the archive\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        # If no non-dominated solutions, select randomly\n        selected = np.random.choice(len(archive))\n        base_solution = archive[selected][0].copy()\n    else:\n        # Select from non-dominated solutions\n        selected = np.random.choice(len(non_dominated))\n        base_solution = non_dominated[selected][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose a random operation\n    operation = np.random.choice(['inversion', 'relocation', 'exchange'])\n\n    if operation == 'inversion':\n        # Segment inversion\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operation == 'relocation':\n        # Segment relocation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n        pos = np.random.randint(len(new_solution) + 1)\n        new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    elif operation == 'exchange':\n        # Segment exchange\n        i1, j1 = sorted(np.random.choice(n, 2, replace=False))\n        i2, j2 = sorted(np.random.choice(n, 2, replace=False))\n        seg1 = new_solution[i1:j1+1]\n        seg2 = new_solution[i2:j2+1]\n        new_solution = np.concatenate([new_solution[:i1], seg2, new_solution[j1+1:i2], seg1, new_solution[j2+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8156485779930778,
            0.7802162170410156
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Intelligent random selection\n    # Select solutions that are not Pareto-dominated by others in the archive\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        # If no non-dominated solutions, select randomly\n        selected = np.random.choice(len(archive))\n        base_solution = archive[selected][0].copy()\n    else:\n        # Select from non-dominated solutions\n        selected = np.random.choice(len(non_dominated))\n        base_solution = non_dominated[selected][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose a random operation\n    operation = np.random.choice(['inversion', 'relocation', 'exchange'])\n\n    if operation == 'inversion':\n        # Segment inversion\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operation == 'relocation':\n        # Segment relocation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n        pos = np.random.randint(len(new_solution) + 1)\n        new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    elif operation == 'exchange':\n        # Segment exchange\n        i1, j1 = sorted(np.random.choice(n, 2, replace=False))\n        i2, j2 = sorted(np.random.choice(n, 2, replace=False))\n        seg1 = new_solution[i1:j1+1]\n        seg2 = new_solution[i2:j2+1]\n        new_solution = np.concatenate([new_solution[:i1], seg2, new_solution[j1+1:i2], seg1, new_solution[j2+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 211,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weights = np.random.uniform(0.3, 0.7)  # Random weight for objectives\n    best_idx = np.argmin([weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a custom move\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct positions\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Apply a custom 3-opt-like move\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[b:c] = np.flip(new_solution[b:c])\n\n    # Verify the solution remains feasible\n    if len(new_solution) != len(base_solution) or len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7183565215115559,
            1.0557045340538025
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weights = np.random.uniform(0.3, 0.7)  # Random weight for objectives\n    best_idx = np.argmin([weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a custom move\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct positions\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Apply a custom 3-opt-like move\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[b:c] = np.flip(new_solution[b:c])\n\n    # Verify the solution remains feasible\n    if len(new_solution) != len(base_solution) or len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 212,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge insertion strategy\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k = np.random.randint(n)\n\n    # Perform a 2-opt move between i and j\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Insert a random node at position k using a novel strategy\n    if k != i and k != j:\n        node_to_insert = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = np.random.randint(len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == len(base_solution), \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.6429226252768075,
            1.2294753193855286
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge insertion strategy\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k = np.random.randint(n)\n\n    # Perform a 2-opt move between i and j\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Insert a random node at position k using a novel strategy\n    if k != i and k != j:\n        node_to_insert = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = np.random.randint(len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == len(base_solution), \"Generated solution is invalid\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 213,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by a combination of objective values and diversity\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]) - 0.5 * (x[1][0] * x[1][1]))  # Weighted sum with interaction term\n    selected_solution = sorted_archive[0][0].copy()\n\n    # Apply a hybrid local search operator: a combination of 3-opt and edge insertion\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to modify\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n    new_solution[j:k+1] = np.flip(new_solution[j:k+1])\n\n    # Apply edge insertion: move a random segment to a new position\n    seg_start, seg_end = sorted(random.sample(range(n), 2))\n    segment = new_solution[seg_start:seg_end+1]\n    new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end+1:], segment])\n\n    # Ensure the solution remains a valid tour\n    if len(new_solution) != n or len(set(new_solution)) != n:\n        # Fallback to a simple swap if the above operations fail\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8292300353337771,
            1.4706919193267822
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by a combination of objective values and diversity\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]) - 0.5 * (x[1][0] * x[1][1]))  # Weighted sum with interaction term\n    selected_solution = sorted_archive[0][0].copy()\n\n    # Apply a hybrid local search operator: a combination of 3-opt and edge insertion\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to modify\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n    new_solution[j:k+1] = np.flip(new_solution[j:k+1])\n\n    # Apply edge insertion: move a random segment to a new position\n    seg_start, seg_end = sorted(random.sample(range(n), 2))\n    segment = new_solution[seg_start:seg_end+1]\n    new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end+1:], segment])\n\n    # Ensure the solution remains a valid tour\n    if len(new_solution) != n or len(set(new_solution)) != n:\n        # Fallback to a simple swap if the above operations fail\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 214,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by a combined score (lower is better)\n        scores = [sum(obj) for _, obj in archive]\n        sorted_indices = np.argsort(scores)\n        # Select from top 50% with higher probability\n        top_indices = sorted_indices[:len(sorted_indices)//2]\n        base_solution = archive[random.choice(top_indices)][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    if random.random() < 0.7:  # 70% chance for edge insertion\n        # Randomly select two distinct edges and insert one into the other\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        # Insert node j between i and i+1\n        new_solution = np.concatenate([\n            new_solution[:i+1],\n            [new_solution[j]],\n            new_solution[i+1:j],\n            new_solution[j+1:]\n        ])\n    else:  # 30% chance for segment relocation\n        # Select a random segment and relocate it to a different position\n        seg_start, seg_end = sorted(random.sample(range(n), 2))\n        segment = new_solution[seg_start:seg_end]\n        remaining = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n        # Insert segment at a random position in the remaining nodes\n        insert_pos = random.randint(0, len(remaining))\n        new_solution = np.concatenate([\n            remaining[:insert_pos],\n            segment,\n            remaining[insert_pos:]\n        ])\n\n    # Ensure the solution is valid (no duplicates)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.9656099971166289,
            1.6198253631591797
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by a combined score (lower is better)\n        scores = [sum(obj) for _, obj in archive]\n        sorted_indices = np.argsort(scores)\n        # Select from top 50% with higher probability\n        top_indices = sorted_indices[:len(sorted_indices)//2]\n        base_solution = archive[random.choice(top_indices)][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    if random.random() < 0.7:  # 70% chance for edge insertion\n        # Randomly select two distinct edges and insert one into the other\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        # Insert node j between i and i+1\n        new_solution = np.concatenate([\n            new_solution[:i+1],\n            [new_solution[j]],\n            new_solution[i+1:j],\n            new_solution[j+1:]\n        ])\n    else:  # 30% chance for segment relocation\n        # Select a random segment and relocate it to a different position\n        seg_start, seg_end = sorted(random.sample(range(n), 2))\n        segment = new_solution[seg_start:seg_end]\n        remaining = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n        # Insert segment at a random position in the remaining nodes\n        insert_pos = random.randint(0, len(remaining))\n        new_solution = np.concatenate([\n            remaining[:insert_pos],\n            segment,\n            remaining[insert_pos:]\n        ])\n\n    # Ensure the solution is valid (no duplicates)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 215,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high costs)\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_idx = min(int(0.3 * len(archive)), 3)  # Select from top 30% or top 3, whichever is smaller\n    selected_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge insertion (move a random segment to a different position)\n    if n > 3:\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    # Step 2: Node reinsertion (remove and reinsert a random node)\n    if n > 2:\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 3: Novel path reordering (reverse segments based on distance reduction)\n    if n > 4:\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n        reversed_segment = segment[::-1]\n\n        # Calculate cost before and after reversal\n        original_cost = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        reversed_cost = distance_matrix_1[new_solution[a-1], reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], new_solution[b]]\n\n        if reversed_cost < original_cost:\n            new_solution[a:b] = reversed_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8015474674229397,
            1.177634596824646
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high costs)\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_idx = min(int(0.3 * len(archive)), 3)  # Select from top 30% or top 3, whichever is smaller\n    selected_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge insertion (move a random segment to a different position)\n    if n > 3:\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    # Step 2: Node reinsertion (remove and reinsert a random node)\n    if n > 2:\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 3: Novel path reordering (reverse segments based on distance reduction)\n    if n > 4:\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n        reversed_segment = segment[::-1]\n\n        # Calculate cost before and after reversal\n        original_cost = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        reversed_cost = distance_matrix_1[new_solution[a-1], reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], new_solution[b]]\n\n        if reversed_cost < original_cost:\n            new_solution[a:b] = reversed_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 216,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best combined objective value (sum of both objectives)\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment reversal strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and reverse them\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply a novel segment shift to further explore the neighborhood\n    k = random.randint(0, n-1)\n    shift = random.randint(1, n//2)\n    new_solution = np.roll(new_solution, shift=shift, axis=0)\n\n    # Ensure the solution remains a valid tour\n    if len(set(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7528282876220289,
            1.169378936290741
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best combined objective value (sum of both objectives)\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment reversal strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and reverse them\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply a novel segment shift to further explore the neighborhood\n    k = random.randint(0, n-1)\n    shift = random.randint(1, n//2)\n    new_solution = np.roll(new_solution, shift=shift, axis=0)\n\n    # Ensure the solution remains a valid tour\n    if len(set(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 217,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n\n    # Select a solution with a probability inversely proportional to its rank\n    ranks = [i for i in range(len(archive))]\n    selected_idx = random.choices(ranks, weights=[1/(i+1) for i in ranks])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Step 1: 3-opt move (select 3 random edges and reconnect them)\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Reconnect segments in a different order\n    new_order = [segment1, segment2, segment3, segment4]\n    random.shuffle(new_order)\n    new_solution = np.concatenate(new_order)\n\n    # Step 2: Segment relocation (move a random segment to a different position)\n    seg_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Remove the segment\n    remaining = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n\n    # Insert it at a random position\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8466590710613352,
            1.5710463523864746
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n\n    # Select a solution with a probability inversely proportional to its rank\n    ranks = [i for i in range(len(archive))]\n    selected_idx = random.choices(ranks, weights=[1/(i+1) for i in ranks])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Step 1: 3-opt move (select 3 random edges and reconnect them)\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Reconnect segments in a different order\n    new_order = [segment1, segment2, segment3, segment4]\n    random.shuffle(new_order)\n    new_solution = np.concatenate(new_order)\n\n    # Step 2: Segment relocation (move a random segment to a different position)\n    seg_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n\n    # Remove the segment\n    remaining = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n\n    # Insert it at a random position\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 218,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by a combination of objective values and diversity\n    archive.sort(key=lambda x: (x[1][0] + x[1][1], random.random()))  # Secondary sort by randomness for diversity\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search strategy: combination of 3-opt and edge insertion\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to modify\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b]\n\n    # Apply 3-opt within the segment\n    if len(segment) >= 3:\n        i, j, k = sorted(random.sample(range(len(segment)), 3))\n        segment[i], segment[j], segment[k] = segment[k], segment[j], segment[i]\n\n    # Edge insertion: randomly insert a node elsewhere\n    if n > 3:\n        node_to_move = random.choice(segment)\n        new_solution = new_solution[new_solution != node_to_move]\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.5381292259424278,
            1.5916153192520142
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by a combination of objective values and diversity\n    archive.sort(key=lambda x: (x[1][0] + x[1][1], random.random()))  # Secondary sort by randomness for diversity\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search strategy: combination of 3-opt and edge insertion\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to modify\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b]\n\n    # Apply 3-opt within the segment\n    if len(segment) >= 3:\n        i, j, k = sorted(random.sample(range(len(segment)), 3))\n        segment[i], segment[j], segment[k] = segment[k], segment[j], segment[i]\n\n    # Edge insertion: randomly insert a node elsewhere\n    if n > 3:\n        node_to_move = random.choice(segment)\n        new_solution = new_solution[new_solution != node_to_move]\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 219,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    total_rank = np.sum(ranks, axis=1)\n    probabilities = 1 / (total_rank + 1)  # Avoid division by zero\n    probabilities = probabilities / np.sum(probabilities)\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: probabilistic edge swap with node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Probabilistic edge swap (similar to 2-opt but with probability)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if random.random() < 0.3:  # 30% chance to swap\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Node insertion with cost-based probability\n    for _ in range(3):  # Perform 3 insertions\n        # Select a node to remove\n        remove_idx = random.randint(0, n - 1)\n        removed_node = new_solution[remove_idx]\n        temp_solution = np.delete(new_solution, remove_idx)\n\n        # Select insertion positions with probability based on cost reduction\n        insertion_costs = []\n        for pos in range(n - 1):\n            # Cost in both objectives\n            cost1 = distance_matrix_1[temp_solution[pos-1], removed_node] + distance_matrix_1[removed_node, temp_solution[pos]]\n            cost2 = distance_matrix_2[temp_solution[pos-1], removed_node] + distance_matrix_2[removed_node, temp_solution[pos]]\n            insertion_costs.append(cost1 + cost2)\n\n        # Probabilistic insertion\n        if insertion_costs:\n            probabilities = np.exp(-np.array(insertion_costs))  # Higher probability for lower costs\n            probabilities = probabilities / np.sum(probabilities)\n            insert_pos = np.random.choice(len(insertion_costs), p=probabilities)\n            new_solution = np.insert(temp_solution, insert_pos, removed_node)\n\n    # Ensure feasibility (though operations above should maintain it)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            -0.7782599258505647,
            2.7270708680152893
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    total_rank = np.sum(ranks, axis=1)\n    probabilities = 1 / (total_rank + 1)  # Avoid division by zero\n    probabilities = probabilities / np.sum(probabilities)\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: probabilistic edge swap with node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Probabilistic edge swap (similar to 2-opt but with probability)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if random.random() < 0.3:  # 30% chance to swap\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Node insertion with cost-based probability\n    for _ in range(3):  # Perform 3 insertions\n        # Select a node to remove\n        remove_idx = random.randint(0, n - 1)\n        removed_node = new_solution[remove_idx]\n        temp_solution = np.delete(new_solution, remove_idx)\n\n        # Select insertion positions with probability based on cost reduction\n        insertion_costs = []\n        for pos in range(n - 1):\n            # Cost in both objectives\n            cost1 = distance_matrix_1[temp_solution[pos-1], removed_node] + distance_matrix_1[removed_node, temp_solution[pos]]\n            cost2 = distance_matrix_2[temp_solution[pos-1], removed_node] + distance_matrix_2[removed_node, temp_solution[pos]]\n            insertion_costs.append(cost1 + cost2)\n\n        # Probabilistic insertion\n        if insertion_costs:\n            probabilities = np.exp(-np.array(insertion_costs))  # Higher probability for lower costs\n            probabilities = probabilities / np.sum(probabilities)\n            insert_pos = np.random.choice(len(insertion_costs), p=probabilities)\n            new_solution = np.insert(temp_solution, insert_pos, removed_node)\n\n    # Ensure feasibility (though operations above should maintain it)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 220,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions based on a combination of objectives (e.g., sum of normalized costs)\n        normalized_costs = []\n        for sol, (cost1, cost2) in archive:\n            norm_cost1 = cost1 / np.max(distance_matrix_1) if np.max(distance_matrix_1) != 0 else 0\n            norm_cost2 = cost2 / np.max(distance_matrix_2) if np.max(distance_matrix_2) != 0 else 0\n            normalized_costs.append((sol, norm_cost1 + norm_cost2))\n\n        # Select top 30% of solutions with the lowest combined normalized cost\n        top_n = max(1, int(0.3 * len(archive)))\n        top_solutions = sorted(normalized_costs, key=lambda x: x[1])[:top_n]\n        selected_solution = random.choice(top_solutions)[0]\n    else:\n        selected_solution = archive[0][0]\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: 3-opt with objective-aware edge selection\n    n = len(new_solution)\n    if n <= 3:\n        return new_solution\n\n    # Randomly select three non-consecutive edges\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Evaluate all possible 3-opt moves and choose the one that improves both objectives\n    best_move = None\n    best_improvement = 0\n\n    # Generate all possible 3-opt neighbors\n    for a in [i, j, k]:\n        for b in [i, j, k]:\n            if a == b:\n                continue\n            for c in [i, j, k]:\n                if c == a or c == b:\n                    continue\n                # Create the new tour\n                temp_solution = new_solution.copy()\n                temp_solution[a:b] = new_solution[b-1:a-1:-1]\n                temp_solution[b:c] = new_solution[c-1:b-1:-1]\n\n                # Calculate the new objective values\n                new_cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n))\n\n                # Calculate improvement (sum of normalized improvements)\n                improvement1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[temp_solution[i-1], temp_solution[i]]) / np.max(distance_matrix_1)\n                improvement2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[temp_solution[i-1], temp_solution[i]]) / np.max(distance_matrix_2)\n                total_improvement = improvement1 + improvement2\n\n                if total_improvement > best_improvement:\n                    best_improvement = total_improvement\n                    best_move = temp_solution.copy()\n\n    if best_move is not None:\n        new_solution = best_move\n\n    return new_solution\n\n",
        "score": [
            -0.7298470114479733,
            11.612914204597473
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions based on a combination of objectives (e.g., sum of normalized costs)\n        normalized_costs = []\n        for sol, (cost1, cost2) in archive:\n            norm_cost1 = cost1 / np.max(distance_matrix_1) if np.max(distance_matrix_1) != 0 else 0\n            norm_cost2 = cost2 / np.max(distance_matrix_2) if np.max(distance_matrix_2) != 0 else 0\n            normalized_costs.append((sol, norm_cost1 + norm_cost2))\n\n        # Select top 30% of solutions with the lowest combined normalized cost\n        top_n = max(1, int(0.3 * len(archive)))\n        top_solutions = sorted(normalized_costs, key=lambda x: x[1])[:top_n]\n        selected_solution = random.choice(top_solutions)[0]\n    else:\n        selected_solution = archive[0][0]\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: 3-opt with objective-aware edge selection\n    n = len(new_solution)\n    if n <= 3:\n        return new_solution\n\n    # Randomly select three non-consecutive edges\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Evaluate all possible 3-opt moves and choose the one that improves both objectives\n    best_move = None\n    best_improvement = 0\n\n    # Generate all possible 3-opt neighbors\n    for a in [i, j, k]:\n        for b in [i, j, k]:\n            if a == b:\n                continue\n            for c in [i, j, k]:\n                if c == a or c == b:\n                    continue\n                # Create the new tour\n                temp_solution = new_solution.copy()\n                temp_solution[a:b] = new_solution[b-1:a-1:-1]\n                temp_solution[b:c] = new_solution[c-1:b-1:-1]\n\n                # Calculate the new objective values\n                new_cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n))\n\n                # Calculate improvement (sum of normalized improvements)\n                improvement1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[temp_solution[i-1], temp_solution[i]]) / np.max(distance_matrix_1)\n                improvement2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[temp_solution[i-1], temp_solution[i]]) / np.max(distance_matrix_2)\n                total_improvement = improvement1 + improvement2\n\n                if total_improvement > best_improvement:\n                    best_improvement = total_improvement\n                    best_move = temp_solution.copy()\n\n    if best_move is not None:\n        new_solution = best_move\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 221,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best in both objectives)\n    # Here we select a solution that has a good balance between the two objectives\n    selected_idx = np.argmin([(obj[0] + obj[1]) / 2 for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: 3-opt with segment inversion\n    n = len(new_solution)\n    for _ in range(5):  # Perform multiple iterations for better exploration\n        # Randomly select three distinct edges to modify\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n        # Apply 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]  # Reverse segment between a and b\n        new_solution[b:c] = new_solution[b:c][::-1]  # Reverse segment between b and c\n\n        # Apply segment inversion (novel heuristic)\n        segment_length = np.random.randint(2, min(5, n // 2))  # Random segment length\n        start = np.random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n        # Ensure feasibility (no duplicates and all nodes visited)\n        if len(np.unique(new_solution)) == n:\n            break\n        else:\n            new_solution = base_solution.copy()  # Revert if infeasible\n\n    return new_solution\n\n",
        "score": [
            -0.6665383888968813,
            1.2449591755867004
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best in both objectives)\n    # Here we select a solution that has a good balance between the two objectives\n    selected_idx = np.argmin([(obj[0] + obj[1]) / 2 for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: 3-opt with segment inversion\n    n = len(new_solution)\n    for _ in range(5):  # Perform multiple iterations for better exploration\n        # Randomly select three distinct edges to modify\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n        # Apply 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]  # Reverse segment between a and b\n        new_solution[b:c] = new_solution[b:c][::-1]  # Reverse segment between b and c\n\n        # Apply segment inversion (novel heuristic)\n        segment_length = np.random.randint(2, min(5, n // 2))  # Random segment length\n        start = np.random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n        # Ensure feasibility (no duplicates and all nodes visited)\n        if len(np.unique(new_solution)) == n:\n            break\n        else:\n            new_solution = base_solution.copy()  # Revert if infeasible\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 222,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest sum of objectives (Pareto front approximation)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combination of edge exchange and node insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Reverse the segment (edge exchange)\n    new_solution[a:b+1] = segment[::-1]\n\n    # Randomly select a node to reinsert (node insertion)\n    if len(segment) > 1:\n        node = np.random.choice(segment)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0])\n        pos = np.random.randint(0, len(new_solution) + 1)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.855312080320816,
            1.5416464805603027
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest sum of objectives (Pareto front approximation)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combination of edge exchange and node insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Reverse the segment (edge exchange)\n    new_solution[a:b+1] = segment[::-1]\n\n    # Randomly select a node to reinsert (node insertion)\n    if len(segment) > 1:\n        node = np.random.choice(segment)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0])\n        pos = np.random.randint(0, len(new_solution) + 1)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 223,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its diversity (lower cost solutions are more likely to be selected)\n    costs = np.array([obj[0] + obj[1] for _, obj in archive])\n    if np.all(costs == costs[0]):\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        probs = (max(costs) - costs) / (max(costs) - min(costs))\n        probs = probs / probs.sum()\n        selected_idx = np.random.choice(len(archive), p=probs)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 1. Random segment reversal, 2. Novel node insertion\n    # Step 1: Random segment reversal (like 2-opt but with variable segment length)\n    if n > 3:\n        seg_length = random.randint(2, min(10, n // 2))\n        start = random.randint(0, n - seg_length)\n        end = start + seg_length\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Novel node insertion - move a node to a position that improves both objectives\n    if n > 4:\n        # Select a random node to move\n        node_idx = random.randint(0, n - 1)\n        node = new_solution[node_idx]\n\n        # Evaluate possible insertion positions\n        best_pos = -1\n        min_total_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_idx or (pos == node_idx + 1) % n == node_idx:\n                continue  # Skip current position and immediate neighbors\n\n            # Create temporary solution\n            temp_solution = np.concatenate([\n                new_solution[:node_idx],\n                new_solution[node_idx + 1:]\n            ])\n            temp_solution = np.insert(temp_solution, pos, node)\n\n            # Calculate total cost for both objectives\n            cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i + 1) % n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i + 1) % n]] for i in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_total_cost:\n                min_total_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            # Apply the best insertion\n            new_solution = np.concatenate([\n                new_solution[:node_idx],\n                new_solution[node_idx + 1:]\n            ])\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7573267001455768,
            7.245444118976593
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its diversity (lower cost solutions are more likely to be selected)\n    costs = np.array([obj[0] + obj[1] for _, obj in archive])\n    if np.all(costs == costs[0]):\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        probs = (max(costs) - costs) / (max(costs) - min(costs))\n        probs = probs / probs.sum()\n        selected_idx = np.random.choice(len(archive), p=probs)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 1. Random segment reversal, 2. Novel node insertion\n    # Step 1: Random segment reversal (like 2-opt but with variable segment length)\n    if n > 3:\n        seg_length = random.randint(2, min(10, n // 2))\n        start = random.randint(0, n - seg_length)\n        end = start + seg_length\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Novel node insertion - move a node to a position that improves both objectives\n    if n > 4:\n        # Select a random node to move\n        node_idx = random.randint(0, n - 1)\n        node = new_solution[node_idx]\n\n        # Evaluate possible insertion positions\n        best_pos = -1\n        min_total_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_idx or (pos == node_idx + 1) % n == node_idx:\n                continue  # Skip current position and immediate neighbors\n\n            # Create temporary solution\n            temp_solution = np.concatenate([\n                new_solution[:node_idx],\n                new_solution[node_idx + 1:]\n            ])\n            temp_solution = np.insert(temp_solution, pos, node)\n\n            # Calculate total cost for both objectives\n            cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i + 1) % n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i + 1) % n]] for i in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_total_cost:\n                min_total_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            # Apply the best insertion\n            new_solution = np.concatenate([\n                new_solution[:node_idx],\n                new_solution[node_idx + 1:]\n            ])\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 224,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weights = [0.5, 0.5]  # Equal weights for both objectives\n    best_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Hybrid local search strategy: combination of 3-opt and edge insertion\n    N = len(best_solution)\n    new_solution = best_solution.copy()\n\n    # Randomly select a segment to modify (3-opt style)\n    i = np.random.randint(0, N - 2)\n    j = np.random.randint(i + 1, N - 1)\n    k = np.random.randint(j + 1, N)\n\n    # Perform 3-opt move\n    segment1 = new_solution[i:j+1]\n    segment2 = new_solution[j+1:k+1]\n    segment3 = new_solution[k+1:] if k+1 < N else np.array([])\n    new_order = np.concatenate([segment1, segment2[::-1], segment3])\n\n    # Insert a random node elsewhere (edge insertion)\n    if len(new_order) > 3:\n        node_to_move = np.random.choice(new_order)\n        new_order = new_order[new_order != node_to_move]\n        insert_pos = np.random.randint(0, len(new_order))\n        new_order = np.insert(new_order, insert_pos, node_to_move)\n\n    # Ensure the solution remains feasible\n    if len(np.unique(new_order)) != N:\n        return best_solution  # Fallback to original if invalid\n\n    return new_order\n\n",
        "score": [
            -0.7401156988635454,
            3.037142753601074
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weights = [0.5, 0.5]  # Equal weights for both objectives\n    best_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Hybrid local search strategy: combination of 3-opt and edge insertion\n    N = len(best_solution)\n    new_solution = best_solution.copy()\n\n    # Randomly select a segment to modify (3-opt style)\n    i = np.random.randint(0, N - 2)\n    j = np.random.randint(i + 1, N - 1)\n    k = np.random.randint(j + 1, N)\n\n    # Perform 3-opt move\n    segment1 = new_solution[i:j+1]\n    segment2 = new_solution[j+1:k+1]\n    segment3 = new_solution[k+1:] if k+1 < N else np.array([])\n    new_order = np.concatenate([segment1, segment2[::-1], segment3])\n\n    # Insert a random node elsewhere (edge insertion)\n    if len(new_order) > 3:\n        node_to_move = np.random.choice(new_order)\n        new_order = new_order[new_order != node_to_move]\n        insert_pos = np.random.randint(0, len(new_order))\n        new_order = np.insert(new_order, insert_pos, node_to_move)\n\n    # Ensure the solution remains feasible\n    if len(np.unique(new_order)) != N:\n        return best_solution  # Fallback to original if invalid\n\n    return new_order\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 225,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Normalize objectives to identify solutions with high potential\n    if len(objectives) > 1:\n        obj1 = np.array([o[0] for o in objectives])\n        obj2 = np.array([o[1] for o in objectives])\n        obj1_norm = (obj1 - np.min(obj1)) / (np.max(obj1) - np.min(obj1) + 1e-10)\n        obj2_norm = (obj2 - np.min(obj2)) / (np.max(obj2) - np.min(obj2) + 1e-10)\n        scores = obj1_norm + obj2_norm\n        probabilities = scores / np.sum(scores)\n        selected_idx = np.random.choice(len(solutions), p=probabilities)\n    else:\n        selected_idx = 0\n\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search\n    n = len(new_solution)\n\n    # 1. Edge Insertion (with multi-objective consideration)\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # 2. Segment Reversal (with distance improvement check)\n    a = random.randint(0, n-2)\n    b = random.randint(a+1, n-1)\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n\n    # Calculate cost change\n    cost_change = 0\n    if a > 0:\n        cost_change += distance_matrix_1[new_solution[a-1], reversed_segment[0]] - distance_matrix_1[new_solution[a-1], segment[0]]\n        cost_change += distance_matrix_2[new_solution[a-1], reversed_segment[0]] - distance_matrix_2[new_solution[a-1], segment[0]]\n    if b < n-1:\n        cost_change += distance_matrix_1[reversed_segment[-1], new_solution[b+1]] - distance_matrix_1[segment[-1], new_solution[b+1]]\n        cost_change += distance_matrix_2[reversed_segment[-1], new_solution[b+1]] - distance_matrix_2[segment[-1], new_solution[b+1]]\n\n    # Only reverse if it improves both objectives\n    if cost_change < 0:\n        new_solution[a:b+1] = reversed_segment\n\n    # 3. Novel Edge Exchange Heuristic (multi-objective aware)\n    c = random.randint(0, n-1)\n    d = random.randint(0, n-1)\n    if c != d and abs(c - d) > 1:\n        # Calculate potential improvement\n        original_cost1 = distance_matrix_1[new_solution[(c-1)%n], new_solution[c]] + distance_matrix_1[new_solution[d], new_solution[(d+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[(c-1)%n], new_solution[c]] + distance_matrix_2[new_solution[d], new_solution[(d+1)%n]]\n\n        new_cost1 = distance_matrix_1[new_solution[(c-1)%n], new_solution[d]] + distance_matrix_1[new_solution[c], new_solution[(d+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[(c-1)%n], new_solution[d]] + distance_matrix_2[new_solution[c], new_solution[(d+1)%n]]\n\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2):\n            # Perform the exchange\n            temp = new_solution[c]\n            new_solution[c] = new_solution[d]\n            new_solution[d] = temp\n\n    return new_solution\n\n",
        "score": [
            -0.7922063972974,
            1.521094799041748
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Normalize objectives to identify solutions with high potential\n    if len(objectives) > 1:\n        obj1 = np.array([o[0] for o in objectives])\n        obj2 = np.array([o[1] for o in objectives])\n        obj1_norm = (obj1 - np.min(obj1)) / (np.max(obj1) - np.min(obj1) + 1e-10)\n        obj2_norm = (obj2 - np.min(obj2)) / (np.max(obj2) - np.min(obj2) + 1e-10)\n        scores = obj1_norm + obj2_norm\n        probabilities = scores / np.sum(scores)\n        selected_idx = np.random.choice(len(solutions), p=probabilities)\n    else:\n        selected_idx = 0\n\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search\n    n = len(new_solution)\n\n    # 1. Edge Insertion (with multi-objective consideration)\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # 2. Segment Reversal (with distance improvement check)\n    a = random.randint(0, n-2)\n    b = random.randint(a+1, n-1)\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n\n    # Calculate cost change\n    cost_change = 0\n    if a > 0:\n        cost_change += distance_matrix_1[new_solution[a-1], reversed_segment[0]] - distance_matrix_1[new_solution[a-1], segment[0]]\n        cost_change += distance_matrix_2[new_solution[a-1], reversed_segment[0]] - distance_matrix_2[new_solution[a-1], segment[0]]\n    if b < n-1:\n        cost_change += distance_matrix_1[reversed_segment[-1], new_solution[b+1]] - distance_matrix_1[segment[-1], new_solution[b+1]]\n        cost_change += distance_matrix_2[reversed_segment[-1], new_solution[b+1]] - distance_matrix_2[segment[-1], new_solution[b+1]]\n\n    # Only reverse if it improves both objectives\n    if cost_change < 0:\n        new_solution[a:b+1] = reversed_segment\n\n    # 3. Novel Edge Exchange Heuristic (multi-objective aware)\n    c = random.randint(0, n-1)\n    d = random.randint(0, n-1)\n    if c != d and abs(c - d) > 1:\n        # Calculate potential improvement\n        original_cost1 = distance_matrix_1[new_solution[(c-1)%n], new_solution[c]] + distance_matrix_1[new_solution[d], new_solution[(d+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[(c-1)%n], new_solution[c]] + distance_matrix_2[new_solution[d], new_solution[(d+1)%n]]\n\n        new_cost1 = distance_matrix_1[new_solution[(c-1)%n], new_solution[d]] + distance_matrix_1[new_solution[c], new_solution[(d+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[(c-1)%n], new_solution[d]] + distance_matrix_2[new_solution[c], new_solution[(d+1)%n]]\n\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2):\n            # Perform the exchange\n            temp = new_solution[c]\n            new_solution[c] = new_solution[d]\n            new_solution[d] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 226,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    # Higher probability for solutions with higher total distance (more room for improvement)\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n    total_distances = [obj[0] + obj[1] for obj in objectives]\n\n    # Normalize distances to get probabilities\n    if max(total_distances) == min(total_distances):\n        probabilities = [1.0 / len(total_distances)] * len(total_distances)\n    else:\n        normalized = [(d - min(total_distances)) / (max(total_distances) - min(total_distances)) for d in total_distances]\n        probabilities = [n / sum(normalized) for n in normalized]\n\n    selected_solution = random.choices(solutions, weights=probabilities, k=1)[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: combination of edge exchange and node insertion\n    n = len(new_solution)\n\n    # Edge exchange (similar to 2-opt but more selective)\n    if n > 3:\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        if random.random() < 0.5:  # 50% chance for edge exchange\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:  # Node insertion\n            k = random.randint(0, n-1)\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            insert_pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7622086708350782,
            1.8105010986328125
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    # Higher probability for solutions with higher total distance (more room for improvement)\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n    total_distances = [obj[0] + obj[1] for obj in objectives]\n\n    # Normalize distances to get probabilities\n    if max(total_distances) == min(total_distances):\n        probabilities = [1.0 / len(total_distances)] * len(total_distances)\n    else:\n        normalized = [(d - min(total_distances)) / (max(total_distances) - min(total_distances)) for d in total_distances]\n        probabilities = [n / sum(normalized) for n in normalized]\n\n    selected_solution = random.choices(solutions, weights=probabilities, k=1)[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: combination of edge exchange and node insertion\n    n = len(new_solution)\n\n    # Edge exchange (similar to 2-opt but more selective)\n    if n > 3:\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        if random.random() < 0.5:  # 50% chance for edge exchange\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:  # Node insertion\n            k = random.randint(0, n-1)\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            insert_pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 227,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (e.g., not the best but not the worst)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    candidate_solutions = sorted_archive[len(sorted_archive) // 4 : -len(sorted_archive) // 4]\n    if not candidate_solutions:\n        candidate_solutions = archive\n    base_solution, _ = random.choice(candidate_solutions)\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select segments for modification\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Apply 3-opt: reverse segments i-j, j-k, and i-k\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[i:k]\n\n    # Novel segment reversal strategy: reverse segments with probability 0.5\n    if random.random() > 0.5:\n        new_solution[i:j] = segment1[::-1]\n    if random.random() > 0.5:\n        new_solution[j:k] = segment2[::-1]\n    if random.random() > 0.5:\n        new_solution[i:k] = segment3[::-1]\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    # Verify no duplicates and all nodes are visited exactly once\n    if len(set(new_solution)) != n:\n        # Fallback to a simple swap if the above operation fails\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8153319617951629,
            1.2704473733901978
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (e.g., not the best but not the worst)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    candidate_solutions = sorted_archive[len(sorted_archive) // 4 : -len(sorted_archive) // 4]\n    if not candidate_solutions:\n        candidate_solutions = archive\n    base_solution, _ = random.choice(candidate_solutions)\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select segments for modification\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Apply 3-opt: reverse segments i-j, j-k, and i-k\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[i:k]\n\n    # Novel segment reversal strategy: reverse segments with probability 0.5\n    if random.random() > 0.5:\n        new_solution[i:j] = segment1[::-1]\n    if random.random() > 0.5:\n        new_solution[j:k] = segment2[::-1]\n    if random.random() > 0.5:\n        new_solution[i:k] = segment3[::-1]\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    # Verify no duplicates and all nodes are visited exactly once\n    if len(set(new_solution)) != n:\n        # Fallback to a simple swap if the above operation fails\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 228,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0))\n    crowding_dist = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct segments\n    i, j, k = sorted(random.sample(range(1, n-1), 3))\n\n    # Apply 3-opt: reverse segments between i-j, j-k, and k-i\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n    new_solution[k:] = new_solution[k:][::-1]\n\n    # Novel segment relocation: move a segment between two random points\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n    insert_pos = random.randint(1, len(new_solution)-1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if feasibility is violated\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9022819570243514,
            1.278550624847412
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0))\n    crowding_dist = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct segments\n    i, j, k = sorted(random.sample(range(1, n-1), 3))\n\n    # Apply 3-opt: reverse segments between i-j, j-k, and k-i\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n    new_solution[k:] = new_solution[k:][::-1]\n\n    # Novel segment relocation: move a segment between two random points\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[a:b].copy()\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n    insert_pos = random.randint(1, len(new_solution)-1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if feasibility is violated\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 229,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability of being non-dominated or showing potential for improvement\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1 / (1 + i) for i in range(len(archive))],  # Prefer earlier (better) solutions\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion followed by segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful local search\n\n    # Edge insertion: randomly select two edges and insert a segment between them\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    remaining = np.concatenate([new_solution[:i], new_solution[j:]])\n    insert_pos = random.randint(0, len(remaining) - 1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Segment reversal: reverse a random segment to explore different configurations\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if the solution becomes invalid\n        new_solution = base_solution.copy()\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7485028460101838,
            1.5340393781661987
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability of being non-dominated or showing potential for improvement\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1 / (1 + i) for i in range(len(archive))],  # Prefer earlier (better) solutions\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion followed by segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful local search\n\n    # Edge insertion: randomly select two edges and insert a segment between them\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    remaining = np.concatenate([new_solution[:i], new_solution[j:]])\n    insert_pos = random.randint(0, len(remaining) - 1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Segment reversal: reverse a random segment to explore different configurations\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if the solution becomes invalid\n        new_solution = base_solution.copy()\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 230,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best but not the worst)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    candidate_solutions = sorted_archive[max(1, len(archive) // 3): min(len(archive) - 1, 2 * len(archive) // 3)]\n    if not candidate_solutions:\n        candidate_solutions = archive\n\n    selected = random.choice(candidate_solutions)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a novel move\n    N = len(base_solution)\n    if N < 4:\n        # For small instances, just swap two random nodes\n        i, j = random.sample(range(N), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform a 3-opt move (select 3 random edges and reconnect them in a different way)\n        i, j, k = sorted(random.sample(range(1, N), 3))\n\n        # Try different reconnection patterns\n        patterns = [\n            (base_solution[:i], base_solution[i:j][::-1], base_solution[j:k], base_solution[k:]),\n            (base_solution[:i], base_solution[j:k], base_solution[i:j][::-1], base_solution[k:]),\n            (base_solution[:i], base_solution[k:], base_solution[j:k], base_solution[i:j][::-1])\n        ]\n\n        # Select the pattern that improves both objectives the most\n        best_pattern = None\n        best_improvement = 0\n\n        for pattern in patterns:\n            candidate = np.concatenate(pattern)\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(N-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(N-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            improvement = (sum(selected[1]) - (cost1 + cost2)) / sum(selected[1])\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pattern = pattern\n\n        if best_pattern is not None:\n            new_solution = np.concatenate(best_pattern)\n\n        # Apply a novel move: reverse a random segment and insert it at a different position\n        if random.random() < 0.3:  # 30% chance to apply the novel move\n            start, end = sorted(random.sample(range(N), 2))\n            segment = new_solution[start:end][::-1]\n            insertion_point = random.randint(0, N - (end - start))\n            if insertion_point >= start:\n                insertion_point += (end - start)\n            new_solution = np.concatenate([\n                new_solution[:insertion_point],\n                segment,\n                new_solution[insertion_point:start],\n                new_solution[end:]\n            ])\n\n    return new_solution\n\n",
        "score": [
            -0.6431633184805733,
            1.2953073978424072
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best but not the worst)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    candidate_solutions = sorted_archive[max(1, len(archive) // 3): min(len(archive) - 1, 2 * len(archive) // 3)]\n    if not candidate_solutions:\n        candidate_solutions = archive\n\n    selected = random.choice(candidate_solutions)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a novel move\n    N = len(base_solution)\n    if N < 4:\n        # For small instances, just swap two random nodes\n        i, j = random.sample(range(N), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform a 3-opt move (select 3 random edges and reconnect them in a different way)\n        i, j, k = sorted(random.sample(range(1, N), 3))\n\n        # Try different reconnection patterns\n        patterns = [\n            (base_solution[:i], base_solution[i:j][::-1], base_solution[j:k], base_solution[k:]),\n            (base_solution[:i], base_solution[j:k], base_solution[i:j][::-1], base_solution[k:]),\n            (base_solution[:i], base_solution[k:], base_solution[j:k], base_solution[i:j][::-1])\n        ]\n\n        # Select the pattern that improves both objectives the most\n        best_pattern = None\n        best_improvement = 0\n\n        for pattern in patterns:\n            candidate = np.concatenate(pattern)\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(N-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(N-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            improvement = (sum(selected[1]) - (cost1 + cost2)) / sum(selected[1])\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pattern = pattern\n\n        if best_pattern is not None:\n            new_solution = np.concatenate(best_pattern)\n\n        # Apply a novel move: reverse a random segment and insert it at a different position\n        if random.random() < 0.3:  # 30% chance to apply the novel move\n            start, end = sorted(random.sample(range(N), 2))\n            segment = new_solution[start:end][::-1]\n            insertion_point = random.randint(0, N - (end - start))\n            if insertion_point >= start:\n                insertion_point += (end - start)\n            new_solution = np.concatenate([\n                new_solution[:insertion_point],\n                segment,\n                new_solution[insertion_point:start],\n                new_solution[end:]\n            ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 231,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high potential for improvement (e.g., not dominated by others)\n    selected_solution = None\n    for sol, _ in archive:\n        dominated = False\n        for _, obj in archive:\n            if obj[0] <= sol[0] and obj[1] <= sol[1] and (obj[0] < sol[0] or obj[1] < sol[1]):\n                dominated = True\n                break\n        if not dominated:\n            selected_solution = sol.copy()\n            break\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge insertion + partial tour reversal\n    # Step 1: Randomly select a subtour and reverse it\n    if n > 2:\n        start = np.random.randint(0, n - 1)\n        end = np.random.randint(start + 1, n)\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Randomly select two edges and perform edge insertion\n    if n > 3:\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n\n        # Ensure no duplicate nodes in the new edges\n        if {a, b} != {c, d}:\n            # Create new edges (a, c) and (b, d)\n            new_solution[a] = new_solution[c]\n            new_solution[b] = new_solution[d]\n\n    # Ensure the solution remains a valid tour (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9031321752534325,
            0.9192816615104675
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high potential for improvement (e.g., not dominated by others)\n    selected_solution = None\n    for sol, _ in archive:\n        dominated = False\n        for _, obj in archive:\n            if obj[0] <= sol[0] and obj[1] <= sol[1] and (obj[0] < sol[0] or obj[1] < sol[1]):\n                dominated = True\n                break\n        if not dominated:\n            selected_solution = sol.copy()\n            break\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge insertion + partial tour reversal\n    # Step 1: Randomly select a subtour and reverse it\n    if n > 2:\n        start = np.random.randint(0, n - 1)\n        end = np.random.randint(start + 1, n)\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Randomly select two edges and perform edge insertion\n    if n > 3:\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n\n        # Ensure no duplicate nodes in the new edges\n        if {a, b} != {c, d}:\n            # Create new edges (a, c) and (b, d)\n            new_solution[a] = new_solution[c]\n            new_solution[b] = new_solution[d]\n\n    # Ensure the solution remains a valid tour (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 232,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine edge exchange and segment reversal\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # No improvement possible for trivial cases\n\n    # Step 1: Select a random segment to reverse (similar to segment reversal in VND)\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Perform edge exchange between two random edges (similar to edge exchange in VND)\n    if n >= 4:\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n        if a != c and b != d:\n            # Swap edges (a,b) and (c,d) to (a,c) and (b,d)\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n",
        "score": [
            -0.9062362066899647,
            1.1750549674034119
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine edge exchange and segment reversal\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # No improvement possible for trivial cases\n\n    # Step 1: Select a random segment to reverse (similar to segment reversal in VND)\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Perform edge exchange between two random edges (similar to edge exchange in VND)\n    if n >= 4:\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n        if a != c and b != d:\n            # Swap edges (a,b) and (c,d) to (a,c) and (b,d)\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 233,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    archive_sorted = sorted(archive, key=lambda x: min(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Hybrid local search: 3-opt with edge-swap considering both objectives\n    for _ in range(10):  # Limit the number of attempts to avoid excessive computation\n        i, j, k = sorted(random.sample(range(1, n-1), 3))  # Ensure i < j < k\n\n        # Original edges: (i-1, i), (j-1, j), (k-1, k)\n        # New edges: (i-1, j), (i, k), (j-1, k-1) (3-opt)\n        candidate = new_solution.copy()\n        candidate[i:j] = new_solution[j-1:i-1:-1]\n        candidate[j:k] = new_solution[k-1:j-1:-1]\n\n        # Evaluate both objectives\n        def calculate_cost(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            return (cost1, cost2)\n\n        current_cost = calculate_cost(new_solution)\n        candidate_cost = calculate_cost(candidate)\n\n        # Accept if either objective improves\n        if (candidate_cost[0] < current_cost[0]) or (candidate_cost[1] < current_cost[1]):\n            new_solution = candidate\n\n        # Additional edge-swap considering both objectives\n        # Select two random edges and swap their endpoints if it improves either objective\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        swap_candidate = new_solution.copy()\n        swap_candidate[a], swap_candidate[b] = swap_candidate[b], swap_candidate[a]\n\n        swap_cost = calculate_cost(swap_candidate)\n        if (swap_cost[0] < current_cost[0]) or (swap_cost[1] < current_cost[1]):\n            new_solution = swap_candidate\n\n    return new_solution\n\n",
        "score": [
            -0.63300918895757,
            4.285533607006073
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    archive_sorted = sorted(archive, key=lambda x: min(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Hybrid local search: 3-opt with edge-swap considering both objectives\n    for _ in range(10):  # Limit the number of attempts to avoid excessive computation\n        i, j, k = sorted(random.sample(range(1, n-1), 3))  # Ensure i < j < k\n\n        # Original edges: (i-1, i), (j-1, j), (k-1, k)\n        # New edges: (i-1, j), (i, k), (j-1, k-1) (3-opt)\n        candidate = new_solution.copy()\n        candidate[i:j] = new_solution[j-1:i-1:-1]\n        candidate[j:k] = new_solution[k-1:j-1:-1]\n\n        # Evaluate both objectives\n        def calculate_cost(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            return (cost1, cost2)\n\n        current_cost = calculate_cost(new_solution)\n        candidate_cost = calculate_cost(candidate)\n\n        # Accept if either objective improves\n        if (candidate_cost[0] < current_cost[0]) or (candidate_cost[1] < current_cost[1]):\n            new_solution = candidate\n\n        # Additional edge-swap considering both objectives\n        # Select two random edges and swap their endpoints if it improves either objective\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        swap_candidate = new_solution.copy()\n        swap_candidate[a], swap_candidate[b] = swap_candidate[b], swap_candidate[a]\n\n        swap_cost = calculate_cost(swap_candidate)\n        if (swap_cost[0] < current_cost[0]) or (swap_cost[1] < current_cost[1]):\n            new_solution = swap_candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 234,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    import numpy as np\n\n    # Select a solution with probabilistic bias towards those with lower total cost\n    costs = [sum(obj) for _, obj in archive]\n    min_cost = min(costs)\n    max_cost = max(costs)\n    if min_cost == max_cost:\n        probabilities = [1.0 / len(archive) for _ in costs]\n    else:\n        probabilities = [(max_cost - cost + 1e-6) / (max_cost - min_cost + 1e-6) for cost in costs]\n    probabilities = [p / sum(probabilities) for p in probabilities]\n\n    selected_idx = random.choices(range(len(archive)), weights=probabilities, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion with segment reordering\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to reorder\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length - 1)\n    segment = new_solution[start:start + segment_length]\n\n    # Reverse the segment (a simple reordering)\n    reversed_segment = segment[::-1]\n\n    # Insert the reversed segment back\n    new_solution = np.concatenate([\n        new_solution[:start],\n        reversed_segment,\n        new_solution[start + segment_length:]\n    ])\n\n    # Edge insertion: randomly select two edges and reconnect them\n    i, j = sorted(random.sample(range(n), 2))\n    if i + 1 < j:\n        # Swap the segments between i and j\n        new_solution[i+1:j] = new_solution[i+1:j][::-1]\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.unique(new_solution), np.unique(base_solution)):\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7540603811903608,
            1.186223566532135
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    import numpy as np\n\n    # Select a solution with probabilistic bias towards those with lower total cost\n    costs = [sum(obj) for _, obj in archive]\n    min_cost = min(costs)\n    max_cost = max(costs)\n    if min_cost == max_cost:\n        probabilities = [1.0 / len(archive) for _ in costs]\n    else:\n        probabilities = [(max_cost - cost + 1e-6) / (max_cost - min_cost + 1e-6) for cost in costs]\n    probabilities = [p / sum(probabilities) for p in probabilities]\n\n    selected_idx = random.choices(range(len(archive)), weights=probabilities, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion with segment reordering\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to reorder\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length - 1)\n    segment = new_solution[start:start + segment_length]\n\n    # Reverse the segment (a simple reordering)\n    reversed_segment = segment[::-1]\n\n    # Insert the reversed segment back\n    new_solution = np.concatenate([\n        new_solution[:start],\n        reversed_segment,\n        new_solution[start + segment_length:]\n    ])\n\n    # Edge insertion: randomly select two edges and reconnect them\n    i, j = sorted(random.sample(range(n), 2))\n    if i + 1 < j:\n        # Swap the segments between i and j\n        new_solution[i+1:j] = new_solution[i+1:j][::-1]\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.unique(new_solution), np.unique(base_solution)):\n        return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 235,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / (objectives.max(axis=0) + 1e-10)  # Avoid division by zero\n    scores = 1 / (normalized_objectives.sum(axis=1) + 1e-10)\n    scores = scores / scores.sum()  # Normalize to form a probability distribution\n    selected_idx = np.random.choice(len(archive), p=scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge insertion or segment reversal with equal probability\n    if random.random() < 0.5:\n        # Edge insertion: remove a random edge and reinsert it\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, n - 1)\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n    else:\n        # Segment reversal: reverse a random segment of the tour\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, n - 1)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8484241445512883,
            1.0143139362335205
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / (objectives.max(axis=0) + 1e-10)  # Avoid division by zero\n    scores = 1 / (normalized_objectives.sum(axis=1) + 1e-10)\n    scores = scores / scores.sum()  # Normalize to form a probability distribution\n    selected_idx = np.random.choice(len(archive), p=scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge insertion or segment reversal with equal probability\n    if random.random() < 0.5:\n        # Edge insertion: remove a random edge and reinsert it\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, n - 1)\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n    else:\n        # Segment reversal: reverse a random segment of the tour\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, n - 1)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 236,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto optimal in the archive)\n    # Here, we select a solution with the highest sum of objectives as a candidate for improvement\n    candidates = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n    selected = random.choice(candidates[:max(1, len(candidates) // 2)])[0].copy()\n\n    # Hybrid local search operator: combination of edge exchange and node insertion\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge exchange (similar to 2-opt but with a twist)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]  # Reverse the segment\n\n    # Step 2: Node insertion (move a node to a different position)\n    if n > 3:\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure feasibility: no duplicates and all nodes visited\n    assert len(new_solution) == len(selected), \"Invalid neighbor: length mismatch\"\n    assert len(np.unique(new_solution)) == len(selected), \"Invalid neighbor: duplicate nodes\"\n\n    return new_solution\n\n",
        "score": [
            -0.7441015040046159,
            1.3386238813400269
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto optimal in the archive)\n    # Here, we select a solution with the highest sum of objectives as a candidate for improvement\n    candidates = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n    selected = random.choice(candidates[:max(1, len(candidates) // 2)])[0].copy()\n\n    # Hybrid local search operator: combination of edge exchange and node insertion\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge exchange (similar to 2-opt but with a twist)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]  # Reverse the segment\n\n    # Step 2: Node insertion (move a node to a different position)\n    if n > 3:\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure feasibility: no duplicates and all nodes visited\n    assert len(new_solution) == len(selected), \"Invalid neighbor: length mismatch\"\n    assert len(np.unique(new_solution)) == len(selected), \"Invalid neighbor: duplicate nodes\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 237,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel segment reversal\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select three non-adjacent segments\n    a, b, c = sorted(random.sample(range(1, n-1), 3))\n\n    # Apply 3-opt move\n    new_solution[a:b] = base_solution[a:b][::-1]\n    new_solution[b:c] = base_solution[b:c][::-1]\n\n    # Novel segment reversal: reverse a random segment and shift it\n    if random.random() < 0.5:\n        seg_start = random.randint(1, n-3)\n        seg_end = random.randint(seg_start+1, n-1)\n        segment = new_solution[seg_start:seg_end][::-1]\n        shift = random.randint(1, n - (seg_end - seg_start))\n        new_solution = np.concatenate([new_solution[:seg_start], segment, new_solution[seg_end:seg_start+shift], new_solution[seg_start+shift:seg_end], new_solution[seg_end:]])\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        return base_solution  # Fallback to original if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.9520995309696818,
            0.6289993524551392
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel segment reversal\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select three non-adjacent segments\n    a, b, c = sorted(random.sample(range(1, n-1), 3))\n\n    # Apply 3-opt move\n    new_solution[a:b] = base_solution[a:b][::-1]\n    new_solution[b:c] = base_solution[b:c][::-1]\n\n    # Novel segment reversal: reverse a random segment and shift it\n    if random.random() < 0.5:\n        seg_start = random.randint(1, n-3)\n        seg_end = random.randint(seg_start+1, n-1)\n        segment = new_solution[seg_start:seg_end][::-1]\n        shift = random.randint(1, n - (seg_end - seg_start))\n        new_solution = np.concatenate([new_solution[:seg_start], segment, new_solution[seg_end:seg_start+shift], new_solution[seg_start+shift:seg_end], new_solution[seg_end:]])\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        return base_solution  # Fallback to original if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 238,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def selection_criteria(sol_obj_pair):\n        sol, obj = sol_obj_pair\n        return obj[0] + obj[1]  # Sum of objectives as a proxy for potential improvement\n\n    archive_sorted = sorted(archive, key=selection_criteria, reverse=True)\n    if not archive_sorted:\n        return archive[0][0].copy()  # Fallback to first solution if archive is empty\n\n    # Select top 30% of solutions for consideration\n    top_k = max(1, int(0.3 * len(archive_sorted)))\n    selected_solutions = [sol_obj[0] for sol_obj in archive_sorted[:top_k]]\n    base_solution = random.choice(selected_solutions).copy()\n\n    # Hybrid local search: 3-opt with segment reordering\n    def apply_3_opt(solution):\n        n = len(solution)\n        i, j, k = sorted(random.sample(range(1, n-1), 3))\n\n        # Create three segments and reverse the middle segment\n        segment1 = solution[:i]\n        segment2 = solution[i:j][::-1]\n        segment3 = solution[j:k][::-1]\n        segment4 = solution[k:]\n\n        # Reconstruct the tour\n        new_solution = np.concatenate([segment1, segment2, segment3, segment4])\n        return new_solution\n\n    def apply_segment_reordering(solution):\n        n = len(solution)\n        if n < 5:\n            return solution\n\n        # Randomly select two segments and swap their positions\n        split1, split2 = sorted(random.sample(range(1, n-1), 2))\n        segment1 = solution[:split1]\n        segment2 = solution[split1:split2]\n        segment3 = solution[split2:]\n\n        # Reconstruct the tour by swapping segments\n        new_solution = np.concatenate([segment1, segment3, segment2])\n        return new_solution\n\n    # Apply one of the two operators with equal probability\n    if random.random() < 0.5:\n        new_solution = apply_3_opt(base_solution)\n    else:\n        new_solution = apply_segment_reordering(base_solution)\n\n    # Ensure the solution is valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != len(base_solution):\n        # Fallback to 2-opt if the solution becomes invalid\n        i, j = sorted(random.sample(range(1, len(base_solution)-1), 2))\n        new_solution = base_solution.copy()\n        new_solution[i:j] = base_solution[j-1:i-1:-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8908012220128043,
            1.1254636645317078
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def selection_criteria(sol_obj_pair):\n        sol, obj = sol_obj_pair\n        return obj[0] + obj[1]  # Sum of objectives as a proxy for potential improvement\n\n    archive_sorted = sorted(archive, key=selection_criteria, reverse=True)\n    if not archive_sorted:\n        return archive[0][0].copy()  # Fallback to first solution if archive is empty\n\n    # Select top 30% of solutions for consideration\n    top_k = max(1, int(0.3 * len(archive_sorted)))\n    selected_solutions = [sol_obj[0] for sol_obj in archive_sorted[:top_k]]\n    base_solution = random.choice(selected_solutions).copy()\n\n    # Hybrid local search: 3-opt with segment reordering\n    def apply_3_opt(solution):\n        n = len(solution)\n        i, j, k = sorted(random.sample(range(1, n-1), 3))\n\n        # Create three segments and reverse the middle segment\n        segment1 = solution[:i]\n        segment2 = solution[i:j][::-1]\n        segment3 = solution[j:k][::-1]\n        segment4 = solution[k:]\n\n        # Reconstruct the tour\n        new_solution = np.concatenate([segment1, segment2, segment3, segment4])\n        return new_solution\n\n    def apply_segment_reordering(solution):\n        n = len(solution)\n        if n < 5:\n            return solution\n\n        # Randomly select two segments and swap their positions\n        split1, split2 = sorted(random.sample(range(1, n-1), 2))\n        segment1 = solution[:split1]\n        segment2 = solution[split1:split2]\n        segment3 = solution[split2:]\n\n        # Reconstruct the tour by swapping segments\n        new_solution = np.concatenate([segment1, segment3, segment2])\n        return new_solution\n\n    # Apply one of the two operators with equal probability\n    if random.random() < 0.5:\n        new_solution = apply_3_opt(base_solution)\n    else:\n        new_solution = apply_segment_reordering(base_solution)\n\n    # Ensure the solution is valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != len(base_solution):\n        # Fallback to 2-opt if the solution becomes invalid\n        i, j = sorted(random.sample(range(1, len(base_solution)-1), 2))\n        new_solution = base_solution.copy()\n        new_solution[i:j] = base_solution[j-1:i-1:-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 239,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])  # Select the worst solution (highest combined cost)\n    base_solution = selected[0].copy()\n\n    # Hybrid local search operator: combination of 3-opt and node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify (3-opt)\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]  # Reverse the segment\n\n    # Randomly select a node to reinsert (node insertion)\n    node_to_insert = random.choice(new_solution)\n    new_solution = new_solution[new_solution != node_to_insert]\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    # Ensure the solution is valid (no duplicates, all nodes present)\n    if len(new_solution) != len(base_solution) or len(np.unique(new_solution)) != len(base_solution):\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9468859556906327,
            1.556247591972351
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])  # Select the worst solution (highest combined cost)\n    base_solution = selected[0].copy()\n\n    # Hybrid local search operator: combination of 3-opt and node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify (3-opt)\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]  # Reverse the segment\n\n    # Randomly select a node to reinsert (node insertion)\n    node_to_insert = random.choice(new_solution)\n    new_solution = new_solution[new_solution != node_to_insert]\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    # Ensure the solution is valid (no duplicates, all nodes present)\n    if len(new_solution) != len(base_solution) or len(np.unique(new_solution)) != len(base_solution):\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 240,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (higher sum indicates more potential)\n        archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n        # Select top 30% with highest potential\n        top_candidates = archive_sorted[:max(1, len(archive) // 3)]\n        # Randomly select one from top candidates\n        selected_idx = random.randint(0, len(top_candidates) - 1)\n        base_solution = top_candidates[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of edge exchange and segment reversal\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct segments\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Ensure segments are distinct and valid\n    if a == c and b == d:\n        c, d = (c + 1) % n, (d + 1) % n\n\n    # Perform edge exchange between segments\n    if random.random() < 0.7:  # 70% chance for edge exchange\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n\n        # Reverse segments with probability 0.5\n        if random.random() < 0.5:\n            segment1 = segment1[::-1]\n        if random.random() < 0.5:\n            segment2 = segment2[::-1]\n\n        # Swap segments\n        new_solution = np.concatenate([\n            new_solution[:a],\n            segment2,\n            new_solution[b+1:c],\n            segment1,\n            new_solution[d+1:]\n        ])\n\n        # Ensure the tour remains circular\n        if len(new_solution) != n:\n            # If segments overlap, fix by restoring original order\n            new_solution = base_solution.copy()\n    else:\n        # Perform segment reversal (like 2-opt but with random segments)\n        if a != b:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8918713952558259,
            1.1835243105888367
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (higher sum indicates more potential)\n        archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n        # Select top 30% with highest potential\n        top_candidates = archive_sorted[:max(1, len(archive) // 3)]\n        # Randomly select one from top candidates\n        selected_idx = random.randint(0, len(top_candidates) - 1)\n        base_solution = top_candidates[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of edge exchange and segment reversal\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct segments\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Ensure segments are distinct and valid\n    if a == c and b == d:\n        c, d = (c + 1) % n, (d + 1) % n\n\n    # Perform edge exchange between segments\n    if random.random() < 0.7:  # 70% chance for edge exchange\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n\n        # Reverse segments with probability 0.5\n        if random.random() < 0.5:\n            segment1 = segment1[::-1]\n        if random.random() < 0.5:\n            segment2 = segment2[::-1]\n\n        # Swap segments\n        new_solution = np.concatenate([\n            new_solution[:a],\n            segment2,\n            new_solution[b+1:c],\n            segment1,\n            new_solution[d+1:]\n        ])\n\n        # Ensure the tour remains circular\n        if len(new_solution) != n:\n            # If segments overlap, fix by restoring original order\n            new_solution = base_solution.copy()\n    else:\n        # Perform segment reversal (like 2-opt but with random segments)\n        if a != b:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 241,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high potential for improvement (e.g., not dominated by others)\n    selected_solution = None\n    min_improvement_potential = float('inf')\n\n    for sol, obj in archive:\n        # Calculate the sum of squared distances as a proxy for improvement potential\n        improvement_potential = obj[0] + obj[1]\n        if improvement_potential < min_improvement_potential:\n            min_improvement_potential = improvement_potential\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    # Apply hybrid local search: node insertion + edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct positions for node insertion\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n\n    # Insert node at position j after position i (node insertion)\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node_to_insert], new_solution[j+1:]])\n\n    # Randomly select two distinct edges for exchange (edge exchange)\n    a, b = random.sample(range(n), 2)\n    if a > b:\n        a, b = b, a\n\n    # Perform edge exchange if it improves the solution\n    current_cost = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n    new_cost = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n    if new_cost < current_cost:\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8027343745044194,
            1.558657467365265
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high potential for improvement (e.g., not dominated by others)\n    selected_solution = None\n    min_improvement_potential = float('inf')\n\n    for sol, obj in archive:\n        # Calculate the sum of squared distances as a proxy for improvement potential\n        improvement_potential = obj[0] + obj[1]\n        if improvement_potential < min_improvement_potential:\n            min_improvement_potential = improvement_potential\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    # Apply hybrid local search: node insertion + edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct positions for node insertion\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n\n    # Insert node at position j after position i (node insertion)\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node_to_insert], new_solution[j+1:]])\n\n    # Randomly select two distinct edges for exchange (edge exchange)\n    a, b = random.sample(range(n), 2)\n    if a > b:\n        a, b = b, a\n\n    # Perform edge exchange if it improves the solution\n    current_cost = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n    new_cost = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n    if new_cost < current_cost:\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 242,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select three distinct positions\n    i, j, k = sorted(np.random.choice(range(n), size=3, replace=False))\n\n    # Apply 3-opt: reverse segments between i-j, j-k, and i-k\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:] if k < n else []\n\n    # Create new segments by reversing\n    new_segments = [\n        segment1[::-1],  # Reverse first segment\n        segment2[::-1],  # Reverse second segment\n        segment3[::-1]   # Reverse third segment\n    ]\n\n    # Reconstruct the solution\n    new_solution = np.concatenate([\n        new_solution[:i],\n        new_segments[0],\n        new_segments[1],\n        new_segments[2],\n        new_solution[k:] if k < n else []\n    ])\n\n    # Ensure the solution is still a valid tour\n    if len(np.unique(new_solution)) != n:\n        # If invalid, fall back to a simple 2-opt\n        a, b = sorted(np.random.choice(range(n), size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8731314344898877,
            0.2900655269622803
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select three distinct positions\n    i, j, k = sorted(np.random.choice(range(n), size=3, replace=False))\n\n    # Apply 3-opt: reverse segments between i-j, j-k, and i-k\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:] if k < n else []\n\n    # Create new segments by reversing\n    new_segments = [\n        segment1[::-1],  # Reverse first segment\n        segment2[::-1],  # Reverse second segment\n        segment3[::-1]   # Reverse third segment\n    ]\n\n    # Reconstruct the solution\n    new_solution = np.concatenate([\n        new_solution[:i],\n        new_segments[0],\n        new_segments[1],\n        new_segments[2],\n        new_solution[k:] if k < n else []\n    ])\n\n    # Ensure the solution is still a valid tour\n    if len(np.unique(new_solution)) != n:\n        # If invalid, fall back to a simple 2-opt\n        a, b = sorted(np.random.choice(range(n), size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 243,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected = archive[0][0].copy()\n    for sol, _ in archive:\n        if len(set(sol)) == len(sol):  # Ensure valid tour\n            selected = sol.copy()\n            break\n\n    new_solution = selected.copy()\n\n    # Hybrid local search: combine 3-opt with random segment reversal\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform 3-opt (select three random edges and reconnect them)\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Reconnect segments in a different order\n    new_order = [segment1, segment2[::-1], segment3, segment4[::-1]]\n    new_solution = np.concatenate(new_order)\n\n    # Randomly reverse a segment to add diversity\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(set(new_solution)) != len(new_solution):\n        # Fallback to a simpler operation if invalid\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8018677697394127,
            1.0144938230514526
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected = archive[0][0].copy()\n    for sol, _ in archive:\n        if len(set(sol)) == len(sol):  # Ensure valid tour\n            selected = sol.copy()\n            break\n\n    new_solution = selected.copy()\n\n    # Hybrid local search: combine 3-opt with random segment reversal\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform 3-opt (select three random edges and reconnect them)\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Reconnect segments in a different order\n    new_order = [segment1, segment2[::-1], segment3, segment4[::-1]]\n    new_solution = np.concatenate(new_order)\n\n    # Randomly reverse a segment to add diversity\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(set(new_solution)) != len(new_solution):\n        # Fallback to a simpler operation if invalid\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 244,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel segment reversal\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Segment reversal (novel operator)\n    segment = new_solution[i:j+1]\n    reversed_segment = segment[::-1]\n    new_solution[i:j+1] = reversed_segment\n\n    # Apply 2-opt to further improve the solution\n    a, b = sorted(random.sample(range(n), 2))\n    if a != b:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.909648338611387,
            1.5555084943771362
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel segment reversal\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Segment reversal (novel operator)\n    segment = new_solution[i:j+1]\n    reversed_segment = segment[::-1]\n    new_solution[i:j+1] = reversed_segment\n\n    # Apply 2-opt to further improve the solution\n    a, b = sorted(random.sample(range(n), 2))\n    if a != b:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 245,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a high probability of being non-dominated or with potential for improvement\n    selected_solution = random.choices(\n        archive,\n        weights=[1.0 / (1 + obj[0] + obj[1]) for _, obj in archive],  # Inverse objective weighting\n        k=1\n    )[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel segment reversal\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Select 3 distinct random indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Step 2: Perform 3-opt (reverse segments between i and j, j and k)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Step 3: Novel segment reversal - reverse a random segment with a probability\n    if random.random() < 0.5:  # 50% chance to apply the novel operator\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simpler operator if the solution becomes invalid\n        new_solution = selected_solution.copy()\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8620035168527835,
            1.5079769492149353
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a high probability of being non-dominated or with potential for improvement\n    selected_solution = random.choices(\n        archive,\n        weights=[1.0 / (1 + obj[0] + obj[1]) for _, obj in archive],  # Inverse objective weighting\n        k=1\n    )[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel segment reversal\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Select 3 distinct random indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Step 2: Perform 3-opt (reverse segments between i and j, j and k)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Step 3: Novel segment reversal - reverse a random segment with a probability\n    if random.random() < 0.5:  # 50% chance to apply the novel operator\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simpler operator if the solution becomes invalid\n        new_solution = selected_solution.copy()\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 246,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    archive_sorted = sorted(archive, key=lambda x: min(x[1]))\n    selected_idx = min(3, len(archive) - 1)  # Select from top 3 or all available\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive edge insertion + 2-opt\n    n = len(new_solution)\n    for _ in range(2):  # Apply multiple times for better exploration\n        # Edge insertion: randomly select a node and insert it in a new position\n        if n > 2:\n            i = random.randint(0, n - 1)\n            j = random.randint(0, n - 1)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n        # Adaptive 2-opt: only perform if it improves both objectives\n        for _ in range(3):  # Limited attempts to preserve diversity\n            a, b = sorted(random.sample(range(n), 2))\n            if a + 1 < b:\n                # Reverse the segment between a and b\n                candidate = new_solution.copy()\n                candidate[a+1:b+1] = candidate[a+1:b+1][::-1]\n\n                # Check if improvement in both objectives\n                old_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n                old_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n                new_cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n                new_cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n\n                if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or random.random() < 0.1:  # Allow some randomness\n                    new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.6897649592771126,
            2.589317798614502
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    archive_sorted = sorted(archive, key=lambda x: min(x[1]))\n    selected_idx = min(3, len(archive) - 1)  # Select from top 3 or all available\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive edge insertion + 2-opt\n    n = len(new_solution)\n    for _ in range(2):  # Apply multiple times for better exploration\n        # Edge insertion: randomly select a node and insert it in a new position\n        if n > 2:\n            i = random.randint(0, n - 1)\n            j = random.randint(0, n - 1)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n        # Adaptive 2-opt: only perform if it improves both objectives\n        for _ in range(3):  # Limited attempts to preserve diversity\n            a, b = sorted(random.sample(range(n), 2))\n            if a + 1 < b:\n                # Reverse the segment between a and b\n                candidate = new_solution.copy()\n                candidate[a+1:b+1] = candidate[a+1:b+1][::-1]\n\n                # Check if improvement in both objectives\n                old_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n                old_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n                new_cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n                new_cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n\n                if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or random.random() < 0.1:  # Allow some randomness\n                    new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 247,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., high variance in objectives)\n    def potential_score(solution, objective):\n        # Normalize the objectives to avoid scale bias\n        obj1, obj2 = objective\n        normalized_obj1 = (obj1 - min(o[0] for _, o in archive)) / (max(o[0] for _, o in archive) - min(o[0] for _, o in archive) + 1e-10)\n        normalized_obj2 = (obj2 - min(o[1] for _, o in archive)) / (max(o[1] for _, o in archive) - min(o[1] for _, o in archive) + 1e-10)\n        # Potential is higher if the solution is not dominated and has high variance in objectives\n        return (normalized_obj1 + normalized_obj2) * (abs(normalized_obj1 - normalized_obj2) + 1e-10)\n\n    # Sort solutions by potential and select top candidates\n    candidates = sorted(archive, key=lambda x: -potential_score(x[0], x[1]))\n    selected_idx = min(len(candidates) - 1, int(len(candidates) * 0.3))  # Select from top 30%\n    base_solution = candidates[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operators\n\n    # Randomly choose between two operators\n    if random.random() < 0.5:\n        # Operator 1: Edge exchange (swap two non-adjacent edges)\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        if new_solution[i-1] != new_solution[j] and new_solution[i] != new_solution[j+1]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Operator 2: Segment reversal with objective-aware selection\n        # Select a segment that reduces the maximum of the two objectives\n        best_segment = None\n        best_improvement = 0\n\n        for _ in range(5):  # Try a few random segments\n            a, b = sorted(random.sample(range(1, n-1), 2))\n            segment = new_solution[a:b+1][::-1]\n            temp_solution = new_solution.copy()\n            temp_solution[a:b+1] = segment\n\n            # Calculate new objectives\n            def calculate_objective(sol, dist_matrix):\n                total = 0\n                for i in range(n):\n                    total += dist_matrix[sol[i-1], sol[i]]\n                return total\n\n            new_obj1 = calculate_objective(temp_solution, distance_matrix_1)\n            new_obj2 = calculate_objective(temp_solution, distance_matrix_2)\n\n            # Check if this segment improves the maximum objective\n            current_obj1 = calculate_objective(new_solution, distance_matrix_1)\n            current_obj2 = calculate_objective(new_solution, distance_matrix_2)\n            improvement = max(current_obj1, current_obj2) - max(new_obj1, new_obj2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_segment = (a, b)\n\n        if best_segment is not None:\n            a, b = best_segment\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7553842084897177,
            8.66159451007843
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., high variance in objectives)\n    def potential_score(solution, objective):\n        # Normalize the objectives to avoid scale bias\n        obj1, obj2 = objective\n        normalized_obj1 = (obj1 - min(o[0] for _, o in archive)) / (max(o[0] for _, o in archive) - min(o[0] for _, o in archive) + 1e-10)\n        normalized_obj2 = (obj2 - min(o[1] for _, o in archive)) / (max(o[1] for _, o in archive) - min(o[1] for _, o in archive) + 1e-10)\n        # Potential is higher if the solution is not dominated and has high variance in objectives\n        return (normalized_obj1 + normalized_obj2) * (abs(normalized_obj1 - normalized_obj2) + 1e-10)\n\n    # Sort solutions by potential and select top candidates\n    candidates = sorted(archive, key=lambda x: -potential_score(x[0], x[1]))\n    selected_idx = min(len(candidates) - 1, int(len(candidates) * 0.3))  # Select from top 30%\n    base_solution = candidates[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operators\n\n    # Randomly choose between two operators\n    if random.random() < 0.5:\n        # Operator 1: Edge exchange (swap two non-adjacent edges)\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        if new_solution[i-1] != new_solution[j] and new_solution[i] != new_solution[j+1]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Operator 2: Segment reversal with objective-aware selection\n        # Select a segment that reduces the maximum of the two objectives\n        best_segment = None\n        best_improvement = 0\n\n        for _ in range(5):  # Try a few random segments\n            a, b = sorted(random.sample(range(1, n-1), 2))\n            segment = new_solution[a:b+1][::-1]\n            temp_solution = new_solution.copy()\n            temp_solution[a:b+1] = segment\n\n            # Calculate new objectives\n            def calculate_objective(sol, dist_matrix):\n                total = 0\n                for i in range(n):\n                    total += dist_matrix[sol[i-1], sol[i]]\n                return total\n\n            new_obj1 = calculate_objective(temp_solution, distance_matrix_1)\n            new_obj2 = calculate_objective(temp_solution, distance_matrix_2)\n\n            # Check if this segment improves the maximum objective\n            current_obj1 = calculate_objective(new_solution, distance_matrix_1)\n            current_obj2 = calculate_objective(new_solution, distance_matrix_2)\n            improvement = max(current_obj1, current_obj2) - max(new_obj1, new_obj2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_segment = (a, b)\n\n        if best_segment is not None:\n            a, b = best_segment\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 248,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high diversity)\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge exchange\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct indices to perform 3-opt\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse the middle segment\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply custom edge exchange: swap two edges if it improves both objectives\n    a, b = random.sample(range(n), 2)\n    if a > b:\n        a, b = b, a\n\n    # Calculate cost before swap\n    original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                      distance_matrix_1[new_solution[b-1], new_solution[b]])\n    original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                      distance_matrix_2[new_solution[b-1], new_solution[b]])\n\n    # Calculate cost after swap\n    new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                 distance_matrix_1[new_solution[b-1], new_solution[a]])\n    new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                 distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n    # Only perform swap if both objectives improve\n    if new_cost1 < original_cost1 and new_cost2 < original_cost2:\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7717208344666813,
            1.2997350692749023
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high diversity)\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge exchange\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct indices to perform 3-opt\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse the middle segment\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply custom edge exchange: swap two edges if it improves both objectives\n    a, b = random.sample(range(n), 2)\n    if a > b:\n        a, b = b, a\n\n    # Calculate cost before swap\n    original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                      distance_matrix_1[new_solution[b-1], new_solution[b]])\n    original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                      distance_matrix_2[new_solution[b-1], new_solution[b]])\n\n    # Calculate cost after swap\n    new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                 distance_matrix_1[new_solution[b-1], new_solution[a]])\n    new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                 distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n    # Only perform swap if both objectives improve\n    if new_cost1 < original_cost1 and new_cost2 < original_cost2:\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 249,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest cost in either objective)\n    archive.sort(key=lambda x: min(x[1]))\n    selected_solution = archive[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No meaningful local search possible\n\n    # Hybrid local search strategy\n    for _ in range(5):  # Perform multiple iterations for better exploration\n        # Edge insertion: randomly select two edges and insert a segment between them\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        segment = np.random.choice(n, 2, replace=False)\n        if a == b or segment[0] == segment[1]:\n            continue\n\n        # Create a new segment by reversing a random sub-sequence\n        new_segment = new_solution[segment[0]:segment[1]+1][::-1]\n        new_solution = np.concatenate([new_solution[:a+1], new_segment, new_solution[b:]])\n\n        # Ensure the tour remains valid (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            # Segment relocation: move a random segment to a new position\n            c, d = sorted(np.random.choice(n, 2, replace=False))\n            if c == d:\n                continue\n            segment_to_move = new_solution[c:d+1]\n            new_solution = np.concatenate([new_solution[:c], new_solution[d+1:]])\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, segment_to_move)\n\n            # Ensure the tour remains valid\n            if len(np.unique(new_solution)) == n:\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.6346657335725993,
            0.7423290610313416
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest cost in either objective)\n    archive.sort(key=lambda x: min(x[1]))\n    selected_solution = archive[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No meaningful local search possible\n\n    # Hybrid local search strategy\n    for _ in range(5):  # Perform multiple iterations for better exploration\n        # Edge insertion: randomly select two edges and insert a segment between them\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        segment = np.random.choice(n, 2, replace=False)\n        if a == b or segment[0] == segment[1]:\n            continue\n\n        # Create a new segment by reversing a random sub-sequence\n        new_segment = new_solution[segment[0]:segment[1]+1][::-1]\n        new_solution = np.concatenate([new_solution[:a+1], new_segment, new_solution[b:]])\n\n        # Ensure the tour remains valid (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            # Segment relocation: move a random segment to a new position\n            c, d = sorted(np.random.choice(n, 2, replace=False))\n            if c == d:\n                continue\n            segment_to_move = new_solution[c:d+1]\n            new_solution = np.concatenate([new_solution[:c], new_solution[d+1:]])\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, segment_to_move)\n\n            # Ensure the tour remains valid\n            if len(np.unique(new_solution)) == n:\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 250,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal)\n    # Here, we select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a randomized edge swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform a randomized 3-opt move\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Randomly swap edges to further diversify the solution\n    if random.random() < 0.5:  # 50% chance to perform edge swap\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains feasible (no duplicates and all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9954163438570345,
            1.1706836223602295
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal)\n    # Here, we select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a randomized edge swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform a randomized 3-opt move\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Randomly swap edges to further diversify the solution\n    if random.random() < 0.5:  # 50% chance to perform edge swap\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains feasible (no duplicates and all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 251,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution (biased towards lower objectives)\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = 1 / (normalized_objectives.sum(axis=1) + 1e-10)  # Higher score for better solutions\n    selection_probs = scores / scores.sum()\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between edge swap and segment reversal\n    if random.random() < 0.5:\n        # Edge swap (similar to 2-opt but with more randomness)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Segment reversal with random segment length\n        segment_length = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Step 3: Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if the operation is invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.866431359526813,
            1.1268433928489685
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution (biased towards lower objectives)\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = 1 / (normalized_objectives.sum(axis=1) + 1e-10)  # Higher score for better solutions\n    selection_probs = scores / scores.sum()\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between edge swap and segment reversal\n    if random.random() < 0.5:\n        # Edge swap (similar to 2-opt but with more randomness)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Segment reversal with random segment length\n        segment_length = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Step 3: Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if the operation is invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 252,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: np.sum(x[1]))[0].copy()\n\n    # Perform edge insertion to diversify the solution\n    n = len(selected_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution = np.concatenate([selected_solution[:i], selected_solution[j:j+1], selected_solution[i:j], selected_solution[j+1:]])\n\n    # Apply a novel edge-swapping mechanism to refine the solution\n    for _ in range(2):  # Limit the number of swaps to balance exploration and exploitation\n        a, b = sorted(random.sample(range(n), 2))\n        if a != b and (a + 1) % n != b and (b + 1) % n != a:  # Ensure no overlapping or adjacent edges\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(set(new_solution)) != n:\n        # Fallback to a simple swap if the solution is invalid\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9963860159387185,
            1.7174201607704163
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: np.sum(x[1]))[0].copy()\n\n    # Perform edge insertion to diversify the solution\n    n = len(selected_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution = np.concatenate([selected_solution[:i], selected_solution[j:j+1], selected_solution[i:j], selected_solution[j+1:]])\n\n    # Apply a novel edge-swapping mechanism to refine the solution\n    for _ in range(2):  # Limit the number of swaps to balance exploration and exploitation\n        a, b = sorted(random.sample(range(n), 2))\n        if a != b and (a + 1) % n != b and (b + 1) % n != a:  # Ensure no overlapping or adjacent edges\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(set(new_solution)) != n:\n        # Fallback to a simple swap if the solution is invalid\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 253,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its rank\n    ranks = np.argsort([cost1 + cost2 for _, (cost1, cost2) in archive])\n    selected_idx = np.random.choice(ranks, p=np.exp(-ranks) / np.sum(np.exp(-ranks)))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine edge insertion and swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge insertion: remove a random edge and reinsert it\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    while i == j or (i+1)%n == j or (j+1)%n == i:\n        j = random.randint(0, n-1)\n\n    # Extract the edge to be reinserted\n    edge = [new_solution[i], new_solution[(i+1)%n]]\n    # Remove the edge\n    new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:]])\n    # Reinsert the edge at position j\n    new_solution = np.concatenate([new_solution[:j+1], [edge[0], edge[1]], new_solution[j+1:]])\n\n    # Swap two random nodes (with probability 0.5)\n    if random.random() < 0.5:\n        k, l = random.sample(range(n), 2)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != len(base_solution):\n        # If invalid, fall back to a simple swap\n        k, l = random.sample(range(n), 2)\n        new_solution = base_solution.copy()\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.8761075912502928,
            0.34411174058914185
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its rank\n    ranks = np.argsort([cost1 + cost2 for _, (cost1, cost2) in archive])\n    selected_idx = np.random.choice(ranks, p=np.exp(-ranks) / np.sum(np.exp(-ranks)))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine edge insertion and swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge insertion: remove a random edge and reinsert it\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    while i == j or (i+1)%n == j or (j+1)%n == i:\n        j = random.randint(0, n-1)\n\n    # Extract the edge to be reinserted\n    edge = [new_solution[i], new_solution[(i+1)%n]]\n    # Remove the edge\n    new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:]])\n    # Reinsert the edge at position j\n    new_solution = np.concatenate([new_solution[:j+1], [edge[0], edge[1]], new_solution[j+1:]])\n\n    # Swap two random nodes (with probability 0.5)\n    if random.random() < 0.5:\n        k, l = random.sample(range(n), 2)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != len(base_solution):\n        # If invalid, fall back to a simple swap\n        k, l = random.sample(range(n), 2)\n        new_solution = base_solution.copy()\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 254,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    total_cost = sum(obj[0] + obj[1] for _, obj in archive)\n    if total_cost == 0:\n        weights = [1.0 / len(archive)] * len(archive)\n    else:\n        weights = [(obj[0] + obj[1]) / total_cost for _, obj in archive]\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a custom edge exchange\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform 3-opt with a twist: also consider edge exchanges based on both distance matrices\n        i, j, k = sorted(random.sample(range(n), 3))\n\n        # Evaluate all possible 3-opt moves\n        options = [\n            (i, j, k),  # Original order\n            (i, k, j),  # Reverse middle segment\n            (j, i, k),  # Rotate left\n            (j, k, i),  # Rotate right\n            (k, i, j),  # Reverse first segment\n            (k, j, i)   # Reverse last segment\n        ]\n\n        best_option = None\n        best_improvement = 0\n\n        # Evaluate each option based on both objectives\n        for opt in options:\n            a, b, c = opt\n            # Original edges\n            orig_edges = [\n                (base_solution[a], base_solution[(a+1)%n]),\n                (base_solution[b], base_solution[(b+1)%n]),\n                (base_solution[c], base_solution[(c+1)%n])\n            ]\n            # New edges\n            new_edges = [\n                (base_solution[a], base_solution[b]),\n                (base_solution[a], base_solution[c]),\n                (base_solution[b], base_solution[c])\n            ]\n\n            # Calculate improvement in both objectives\n            delta1 = sum(distance_matrix_1[e[0], e[1]] for e in new_edges) - sum(distance_matrix_1[e[0], e[1]] for e in orig_edges)\n            delta2 = sum(distance_matrix_2[e[0], e[1]] for e in new_edges) - sum(distance_matrix_2[e[0], e[1]] for e in orig_edges)\n\n            # Use a weighted sum of improvements (could be more sophisticated)\n            improvement = - (delta1 + delta2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_option = opt\n\n        if best_option:\n            a, b, c = best_option\n            # Apply the best 3-opt move\n            if best_option == (i, k, j):\n                new_solution[b:c+1] = new_solution[b:c+1][::-1]\n            elif best_option == (j, i, k):\n                new_solution[a:b+1] = np.roll(new_solution[a:b+1], 1)\n            elif best_option == (j, k, i):\n                new_solution[a:c+1] = np.roll(new_solution[a:c+1], -1)\n            elif best_option == (k, i, j):\n                new_solution[a:b+1] = new_solution[a:b+1][::-1]\n            elif best_option == (k, j, i):\n                new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n        # With 50% probability, perform an additional edge exchange based on both distance matrices\n        if random.random() < 0.5:\n            # Select two random edges and swap their endpoints\n            i, j = sorted(random.sample(range(n), 2))\n            node1 = new_solution[i]\n            node2 = new_solution[j]\n\n            # Calculate potential improvement\n            orig_edges = [\n                (new_solution[i], new_solution[(i+1)%n]),\n                (new_solution[j], new_solution[(j+1)%n])\n            ]\n            new_edges = [\n                (new_solution[i], new_solution[j]),\n                (new_solution[(i+1)%n], new_solution[(j+1)%n])\n            ]\n\n            delta1 = sum(distance_matrix_1[e[0], e[1]] for e in new_edges) - sum(distance_matrix_1[e[0], e[1]] for e in orig_edges)\n            delta2 = sum(distance_matrix_2[e[0], e[1]] for e in new_edges) - sum(distance_matrix_2[e[0], e[1]] for e in orig_edges)\n\n            if delta1 + delta2 < 0:\n                # Swap the nodes if it improves both objectives\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8208360507557836,
            1.885196030139923
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    total_cost = sum(obj[0] + obj[1] for _, obj in archive)\n    if total_cost == 0:\n        weights = [1.0 / len(archive)] * len(archive)\n    else:\n        weights = [(obj[0] + obj[1]) / total_cost for _, obj in archive]\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a custom edge exchange\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform 3-opt with a twist: also consider edge exchanges based on both distance matrices\n        i, j, k = sorted(random.sample(range(n), 3))\n\n        # Evaluate all possible 3-opt moves\n        options = [\n            (i, j, k),  # Original order\n            (i, k, j),  # Reverse middle segment\n            (j, i, k),  # Rotate left\n            (j, k, i),  # Rotate right\n            (k, i, j),  # Reverse first segment\n            (k, j, i)   # Reverse last segment\n        ]\n\n        best_option = None\n        best_improvement = 0\n\n        # Evaluate each option based on both objectives\n        for opt in options:\n            a, b, c = opt\n            # Original edges\n            orig_edges = [\n                (base_solution[a], base_solution[(a+1)%n]),\n                (base_solution[b], base_solution[(b+1)%n]),\n                (base_solution[c], base_solution[(c+1)%n])\n            ]\n            # New edges\n            new_edges = [\n                (base_solution[a], base_solution[b]),\n                (base_solution[a], base_solution[c]),\n                (base_solution[b], base_solution[c])\n            ]\n\n            # Calculate improvement in both objectives\n            delta1 = sum(distance_matrix_1[e[0], e[1]] for e in new_edges) - sum(distance_matrix_1[e[0], e[1]] for e in orig_edges)\n            delta2 = sum(distance_matrix_2[e[0], e[1]] for e in new_edges) - sum(distance_matrix_2[e[0], e[1]] for e in orig_edges)\n\n            # Use a weighted sum of improvements (could be more sophisticated)\n            improvement = - (delta1 + delta2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_option = opt\n\n        if best_option:\n            a, b, c = best_option\n            # Apply the best 3-opt move\n            if best_option == (i, k, j):\n                new_solution[b:c+1] = new_solution[b:c+1][::-1]\n            elif best_option == (j, i, k):\n                new_solution[a:b+1] = np.roll(new_solution[a:b+1], 1)\n            elif best_option == (j, k, i):\n                new_solution[a:c+1] = np.roll(new_solution[a:c+1], -1)\n            elif best_option == (k, i, j):\n                new_solution[a:b+1] = new_solution[a:b+1][::-1]\n            elif best_option == (k, j, i):\n                new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n        # With 50% probability, perform an additional edge exchange based on both distance matrices\n        if random.random() < 0.5:\n            # Select two random edges and swap their endpoints\n            i, j = sorted(random.sample(range(n), 2))\n            node1 = new_solution[i]\n            node2 = new_solution[j]\n\n            # Calculate potential improvement\n            orig_edges = [\n                (new_solution[i], new_solution[(i+1)%n]),\n                (new_solution[j], new_solution[(j+1)%n])\n            ]\n            new_edges = [\n                (new_solution[i], new_solution[j]),\n                (new_solution[(i+1)%n], new_solution[(j+1)%n])\n            ]\n\n            delta1 = sum(distance_matrix_1[e[0], e[1]] for e in new_edges) - sum(distance_matrix_1[e[0], e[1]] for e in orig_edges)\n            delta2 = sum(distance_matrix_2[e[0], e[1]] for e in new_edges) - sum(distance_matrix_2[e[0], e[1]] for e in orig_edges)\n\n            if delta1 + delta2 < 0:\n                # Swap the nodes if it improves both objectives\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 255,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good potential for improvement (lowest cost in either objective)\n    archive_sorted = sorted(archive, key=lambda x: min(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible with small tours\n\n    # Randomly select 4 distinct indices to perform a 3-opt-like move\n    indices = np.random.choice(n, size=4, replace=False)\n    a, b, c, d = sorted(indices)\n\n    # Perform a novel edge insertion move: insert the segment between c and d after a\n    segment = new_solution[c:d]\n    remaining = np.concatenate([new_solution[:c], new_solution[d:]])\n    insert_pos = np.random.randint(0, len(remaining) - 1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if the move is invalid\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.38534772716959487,
            1.7030181884765625
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good potential for improvement (lowest cost in either objective)\n    archive_sorted = sorted(archive, key=lambda x: min(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible with small tours\n\n    # Randomly select 4 distinct indices to perform a 3-opt-like move\n    indices = np.random.choice(n, size=4, replace=False)\n    a, b, c, d = sorted(indices)\n\n    # Perform a novel edge insertion move: insert the segment between c and d after a\n    segment = new_solution[c:d]\n    remaining = np.concatenate([new_solution[:c], new_solution[d:]])\n    insert_pos = np.random.randint(0, len(remaining) - 1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if the move is invalid\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 256,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values (lower is better)\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))  # Sort by sum of objectives\n    selected_idx = min(3, len(archive) - 1)  # Select top 3 or last if archive is small\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and reverse them\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select a node and reinsert it elsewhere\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    l = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility by checking for duplicates\n    if len(new_solution) != len(np.unique(new_solution)):\n        # Fallback to simple swap if infeasible\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8766871475250848,
            1.4560256600379944
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values (lower is better)\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))  # Sort by sum of objectives\n    selected_idx = min(3, len(archive) - 1)  # Select top 3 or last if archive is small\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and reverse them\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select a node and reinsert it elsewhere\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    l = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility by checking for duplicates\n    if len(new_solution) != len(np.unique(new_solution)):\n        # Fallback to simple swap if infeasible\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 257,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values (prioritize non-dominated solutions)\n    non_dominated = []\n    for sol, _ in archive:\n        is_dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= sol[0] and other_obj[1] <= sol[1] and\n                (other_obj[0] < sol[0] or other_obj[1] < sol[1])):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append(sol)\n\n    if non_dominated:\n        base_solution = random.choice(non_dominated).copy()\n    else:\n        # If no non-dominated solutions, select a random solution with better objective values\n        objectives = [obj for _, obj in archive]\n        avg_obj = np.mean(objectives, axis=0)\n        better_solutions = [sol for sol, obj in archive if (obj[0] <= avg_obj[0] and obj[1] <= avg_obj[1])]\n        if better_solutions:\n            base_solution = random.choice(better_solutions).copy()\n        else:\n            base_solution = random.choice(archive)[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: segment relocation with edge insertion\n    if n >= 4:\n        # Randomly select a segment of nodes to relocate\n        seg_start = random.randint(0, n - 4)\n        seg_length = random.randint(2, min(4, n - seg_start - 1))\n        segment = new_solution[seg_start:seg_start + seg_length]\n\n        # Remove the segment from the solution\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_start + seg_length:]])\n\n        # Find the best insertion point for the segment in both objective spaces\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(new_solution) - 1):\n            # Calculate the cost of inserting the segment at this position\n            cost_1 = (distance_matrix_1[new_solution[pos], segment[0]] +\n                      distance_matrix_1[segment[-1], new_solution[pos + 1]] -\n                      distance_matrix_1[new_solution[pos], new_solution[pos + 1]])\n\n            cost_2 = (distance_matrix_2[new_solution[pos], segment[0]] +\n                      distance_matrix_2[segment[-1], new_solution[pos + 1]] -\n                      distance_matrix_2[new_solution[pos], new_solution[pos + 1]])\n\n            # Combine costs using a simple weighted sum (could be improved)\n            total_cost = cost_1 + cost_2\n\n            if total_cost < best_score:\n                best_score = total_cost\n                best_pos = pos\n\n        # Insert the segment at the best position\n        new_solution = np.concatenate([new_solution[:best_pos + 1], segment, new_solution[best_pos + 1:]])\n\n        # Additional edge insertion to further improve the solution\n        for _ in range(min(3, n // 2)):\n            i, j = sorted(random.sample(range(n), 2))\n            if i + 1 < j:\n                # Reverse the segment between i and j\n                new_solution[i+1:j] = new_solution[i+1:j][::-1]\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7971512853206622,
            2.1994112133979797
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values (prioritize non-dominated solutions)\n    non_dominated = []\n    for sol, _ in archive:\n        is_dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= sol[0] and other_obj[1] <= sol[1] and\n                (other_obj[0] < sol[0] or other_obj[1] < sol[1])):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append(sol)\n\n    if non_dominated:\n        base_solution = random.choice(non_dominated).copy()\n    else:\n        # If no non-dominated solutions, select a random solution with better objective values\n        objectives = [obj for _, obj in archive]\n        avg_obj = np.mean(objectives, axis=0)\n        better_solutions = [sol for sol, obj in archive if (obj[0] <= avg_obj[0] and obj[1] <= avg_obj[1])]\n        if better_solutions:\n            base_solution = random.choice(better_solutions).copy()\n        else:\n            base_solution = random.choice(archive)[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: segment relocation with edge insertion\n    if n >= 4:\n        # Randomly select a segment of nodes to relocate\n        seg_start = random.randint(0, n - 4)\n        seg_length = random.randint(2, min(4, n - seg_start - 1))\n        segment = new_solution[seg_start:seg_start + seg_length]\n\n        # Remove the segment from the solution\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_start + seg_length:]])\n\n        # Find the best insertion point for the segment in both objective spaces\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(new_solution) - 1):\n            # Calculate the cost of inserting the segment at this position\n            cost_1 = (distance_matrix_1[new_solution[pos], segment[0]] +\n                      distance_matrix_1[segment[-1], new_solution[pos + 1]] -\n                      distance_matrix_1[new_solution[pos], new_solution[pos + 1]])\n\n            cost_2 = (distance_matrix_2[new_solution[pos], segment[0]] +\n                      distance_matrix_2[segment[-1], new_solution[pos + 1]] -\n                      distance_matrix_2[new_solution[pos], new_solution[pos + 1]])\n\n            # Combine costs using a simple weighted sum (could be improved)\n            total_cost = cost_1 + cost_2\n\n            if total_cost < best_score:\n                best_score = total_cost\n                best_pos = pos\n\n        # Insert the segment at the best position\n        new_solution = np.concatenate([new_solution[:best_pos + 1], segment, new_solution[best_pos + 1:]])\n\n        # Additional edge insertion to further improve the solution\n        for _ in range(min(3, n // 2)):\n            i, j = sorted(random.sample(range(n), 2))\n            if i + 1 < j:\n                # Reverse the segment between i and j\n                new_solution[i+1:j] = new_solution[i+1:j][::-1]\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 258,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    base_solution = max(archive_solutions, key=lambda x: np.random.random() if len(archive_solutions) == 1 else np.random.random() * (1 + np.mean([distance_matrix_1[x[i-1], x[i]] + distance_matrix_2[x[i-1], x[i]] for i in range(len(x))])))\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: 3-opt + edge insertion\n    if n >= 4:\n        # Select three random edges to break\n        i, j, k = sorted(np.random.choice(range(1, n), 3, replace=False))\n\n        # Apply 3-opt move\n        segment1 = new_solution[:i]\n        segment2 = new_solution[i:j]\n        segment3 = new_solution[j:k]\n        segment4 = new_solution[k:]\n\n        # Create new segments by reversing some parts\n        new_segments = [segment1, segment2[::-1], segment3, segment4[::-1]]\n        new_solution = np.concatenate(new_segments)\n\n        # Edge insertion: try to insert a random node in a better position\n        node_to_move = np.random.choice(new_solution[1:-1])\n        current_pos = np.where(new_solution == node_to_move)[0][0]\n\n        # Find the best insertion position\n        best_pos = current_pos\n        min_cost = float('inf')\n\n        for pos in range(1, n):\n            if pos == current_pos or pos == current_pos + 1:\n                continue\n\n            # Create a temporary solution\n            temp_sol = np.delete(new_solution, current_pos)\n            temp_sol = np.insert(temp_sol, pos, node_to_move)\n\n            # Calculate cost\n            cost = sum(distance_matrix_1[temp_sol[i-1], temp_sol[i]] + distance_matrix_2[temp_sol[i-1], temp_sol[i]] for i in range(1, n))\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        # Apply the best insertion\n        if best_pos != current_pos:\n            new_solution = np.delete(new_solution, current_pos)\n            new_solution = np.insert(new_solution, best_pos, node_to_move)\n\n    # Ensure the solution is valid\n    assert len(new_solution) == len(base_solution) and len(np.unique(new_solution)) == len(new_solution), \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.7213118195459413,
            12.760031461715698
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    base_solution = max(archive_solutions, key=lambda x: np.random.random() if len(archive_solutions) == 1 else np.random.random() * (1 + np.mean([distance_matrix_1[x[i-1], x[i]] + distance_matrix_2[x[i-1], x[i]] for i in range(len(x))])))\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: 3-opt + edge insertion\n    if n >= 4:\n        # Select three random edges to break\n        i, j, k = sorted(np.random.choice(range(1, n), 3, replace=False))\n\n        # Apply 3-opt move\n        segment1 = new_solution[:i]\n        segment2 = new_solution[i:j]\n        segment3 = new_solution[j:k]\n        segment4 = new_solution[k:]\n\n        # Create new segments by reversing some parts\n        new_segments = [segment1, segment2[::-1], segment3, segment4[::-1]]\n        new_solution = np.concatenate(new_segments)\n\n        # Edge insertion: try to insert a random node in a better position\n        node_to_move = np.random.choice(new_solution[1:-1])\n        current_pos = np.where(new_solution == node_to_move)[0][0]\n\n        # Find the best insertion position\n        best_pos = current_pos\n        min_cost = float('inf')\n\n        for pos in range(1, n):\n            if pos == current_pos or pos == current_pos + 1:\n                continue\n\n            # Create a temporary solution\n            temp_sol = np.delete(new_solution, current_pos)\n            temp_sol = np.insert(temp_sol, pos, node_to_move)\n\n            # Calculate cost\n            cost = sum(distance_matrix_1[temp_sol[i-1], temp_sol[i]] + distance_matrix_2[temp_sol[i-1], temp_sol[i]] for i in range(1, n))\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        # Apply the best insertion\n        if best_pos != current_pos:\n            new_solution = np.delete(new_solution, current_pos)\n            new_solution = np.insert(new_solution, best_pos, node_to_move)\n\n    # Ensure the solution is valid\n    assert len(new_solution) == len(base_solution) and len(np.unique(new_solution)) == len(new_solution), \"Generated solution is invalid\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 259,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    weights = [1 / (1 + (obj[0] + obj[1])) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel segment relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, apply 2-opt to improve the solution\n    improved = True\n    while improved:\n        improved = False\n        for i in range(1, n - 2):\n            for j in range(i + 1, n):\n                if j == i + 1:\n                    continue  # Skip adjacent nodes\n                # Calculate the current and new costs\n                a, b, c, d = new_solution[i-1], new_solution[i], new_solution[j-1], new_solution[j]\n                current_cost = distance_matrix_1[a, b] + distance_matrix_1[c, d] + distance_matrix_2[a, b] + distance_matrix_2[c, d]\n                new_cost = distance_matrix_1[a, c] + distance_matrix_1[b, d] + distance_matrix_2[a, c] + distance_matrix_2[b, d]\n\n                if new_cost < current_cost:\n                    # Reverse the segment between i and j-1\n                    new_solution[i:j] = new_solution[i:j][::-1]\n                    improved = True\n                    break\n            if improved:\n                break\n\n    # Then apply a novel segment relocation strategy\n    # Select a random segment and relocate it to a new position\n    segment_length = random.randint(2, min(5, n // 2))\n    segment_start = random.randint(0, n - segment_length)\n    segment = new_solution[segment_start:segment_start + segment_length]\n\n    # Remove the segment\n    new_solution = np.concatenate([new_solution[:segment_start], new_solution[segment_start + segment_length:]])\n\n    # Insert the segment at a new random position\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8715356979139239,
            12.522560596466064
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    weights = [1 / (1 + (obj[0] + obj[1])) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel segment relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, apply 2-opt to improve the solution\n    improved = True\n    while improved:\n        improved = False\n        for i in range(1, n - 2):\n            for j in range(i + 1, n):\n                if j == i + 1:\n                    continue  # Skip adjacent nodes\n                # Calculate the current and new costs\n                a, b, c, d = new_solution[i-1], new_solution[i], new_solution[j-1], new_solution[j]\n                current_cost = distance_matrix_1[a, b] + distance_matrix_1[c, d] + distance_matrix_2[a, b] + distance_matrix_2[c, d]\n                new_cost = distance_matrix_1[a, c] + distance_matrix_1[b, d] + distance_matrix_2[a, c] + distance_matrix_2[b, d]\n\n                if new_cost < current_cost:\n                    # Reverse the segment between i and j-1\n                    new_solution[i:j] = new_solution[i:j][::-1]\n                    improved = True\n                    break\n            if improved:\n                break\n\n    # Then apply a novel segment relocation strategy\n    # Select a random segment and relocate it to a new position\n    segment_length = random.randint(2, min(5, n // 2))\n    segment_start = random.randint(0, n - segment_length)\n    segment = new_solution[segment_start:segment_start + segment_length]\n\n    # Remove the segment\n    new_solution = np.concatenate([new_solution[:segment_start], new_solution[segment_start + segment_length:]])\n\n    # Insert the segment at a new random position\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 260,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge-swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    segment_start = np.random.randint(0, n)\n    segment_end = np.random.randint(segment_start + 1, n + 1)\n    segment = new_solution[segment_start:segment_end]\n\n    # Reverse the segment (2-opt style)\n    segment_reversed = segment[::-1]\n    new_solution[segment_start:segment_end] = segment_reversed\n\n    # Apply novel edge-swap: swap edges between non-adjacent nodes in the segment\n    if len(segment) > 3:\n        swap_indices = np.random.choice(range(1, len(segment)-1), size=2, replace=False)\n        i, j = swap_indices\n        segment[i], segment[j] = segment[j], segment[i]\n        new_solution[segment_start:segment_end] = segment\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original segment\n        new_solution[segment_start:segment_end] = base_solution[segment_start:segment_end]\n\n    return new_solution\n\n",
        "score": [
            -0.8672295657259179,
            1.9714964032173157
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge-swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    segment_start = np.random.randint(0, n)\n    segment_end = np.random.randint(segment_start + 1, n + 1)\n    segment = new_solution[segment_start:segment_end]\n\n    # Reverse the segment (2-opt style)\n    segment_reversed = segment[::-1]\n    new_solution[segment_start:segment_end] = segment_reversed\n\n    # Apply novel edge-swap: swap edges between non-adjacent nodes in the segment\n    if len(segment) > 3:\n        swap_indices = np.random.choice(range(1, len(segment)-1), size=2, replace=False)\n        i, j = swap_indices\n        segment[i], segment[j] = segment[j], segment[i]\n        new_solution[segment_start:segment_end] = segment\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original segment\n        new_solution[segment_start:segment_end] = base_solution[segment_start:segment_end]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 261,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high promising potential (lowest total cost in either objective)\n    archive_sorted = sorted(archive, key=lambda x: min(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n\n    # Apply a hybrid local search strategy\n    for _ in range(10):  # Perform multiple iterations\n        # Randomly select one of three operators\n        operator = np.random.choice(['edge_swap', 'node_reinsertion', 'multi_space_rotation'])\n\n        if operator == 'edge_swap':\n            # Perform a 2-opt swap with a random segment\n            i, j = sorted(np.random.choice(range(1, n), 2, replace=False))\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        elif operator == 'node_reinsertion':\n            # Remove a random node and reinsert it at another position\n            idx = np.random.randint(1, n-1)\n            node = new_solution[idx]\n            new_solution = np.delete(new_solution, idx)\n            new_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, new_pos, node)\n\n        elif operator == 'multi_space_rotation':\n            # Novel operator: rotate a segment of nodes in both spaces simultaneously\n            i, j = sorted(np.random.choice(range(1, n), 2, replace=False))\n            segment = new_solution[i:j]\n\n            # Determine rotation direction based on which objective has higher cost\n            obj1, obj2 = archive_sorted[0][1]\n            if obj1 > obj2:\n                segment = np.roll(segment, 1)  # Rotate left (better for first objective)\n            else:\n                segment = np.roll(segment, -1)  # Rotate right (better for second objective)\n\n            new_solution[i:j] = segment\n\n    # Ensure the solution remains feasible (no duplicates, all nodes present)\n    if len(np.unique(new_solution)) != n or len(new_solution) != n:\n        # If invalid, fall back to a simple edge swap\n        i, j = sorted(np.random.choice(range(1, n), 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.44839327971465115,
            2.6019428372383118
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high promising potential (lowest total cost in either objective)\n    archive_sorted = sorted(archive, key=lambda x: min(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n\n    # Apply a hybrid local search strategy\n    for _ in range(10):  # Perform multiple iterations\n        # Randomly select one of three operators\n        operator = np.random.choice(['edge_swap', 'node_reinsertion', 'multi_space_rotation'])\n\n        if operator == 'edge_swap':\n            # Perform a 2-opt swap with a random segment\n            i, j = sorted(np.random.choice(range(1, n), 2, replace=False))\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        elif operator == 'node_reinsertion':\n            # Remove a random node and reinsert it at another position\n            idx = np.random.randint(1, n-1)\n            node = new_solution[idx]\n            new_solution = np.delete(new_solution, idx)\n            new_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, new_pos, node)\n\n        elif operator == 'multi_space_rotation':\n            # Novel operator: rotate a segment of nodes in both spaces simultaneously\n            i, j = sorted(np.random.choice(range(1, n), 2, replace=False))\n            segment = new_solution[i:j]\n\n            # Determine rotation direction based on which objective has higher cost\n            obj1, obj2 = archive_sorted[0][1]\n            if obj1 > obj2:\n                segment = np.roll(segment, 1)  # Rotate left (better for first objective)\n            else:\n                segment = np.roll(segment, -1)  # Rotate right (better for second objective)\n\n            new_solution[i:j] = segment\n\n    # Ensure the solution remains feasible (no duplicates, all nodes present)\n    if len(np.unique(new_solution)) != n or len(new_solution) != n:\n        # If invalid, fall back to a simple edge swap\n        i, j = sorted(np.random.choice(range(1, n), 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 262,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution (top 30% by combined objective)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selection_pool = sorted_archive[:max(1, len(sorted_archive) // 3)]\n    base_solution, _ = random.choice(selection_pool)\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    n = len(new_solution)\n\n    # Hybrid operator: Segment relocation followed by local swap\n    if n >= 4:\n        # Segment relocation (3-opt inspired)\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n        # Local swap based on combined distance metric\n        i, j = sorted(random.sample(range(n), 2))\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        # Calculate combined distance metric\n        dist_1 = distance_matrix_1[node_i, node_j] + distance_matrix_1[new_solution[(i-1)%n], new_solution[(j+1)%n]]\n        dist_2 = distance_matrix_2[node_i, node_j] + distance_matrix_2[new_solution[(i-1)%n], new_solution[(j+1)%n]]\n\n        if dist_1 + dist_2 < distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + \\\n                          distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure solution is valid (no duplicates, all nodes present)\n    if len(set(new_solution)) != n or len(new_solution) != n:\n        # Fallback to simple swap if something went wrong\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.742524131452127,
            1.5476936101913452
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution (top 30% by combined objective)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selection_pool = sorted_archive[:max(1, len(sorted_archive) // 3)]\n    base_solution, _ = random.choice(selection_pool)\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    n = len(new_solution)\n\n    # Hybrid operator: Segment relocation followed by local swap\n    if n >= 4:\n        # Segment relocation (3-opt inspired)\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n        # Local swap based on combined distance metric\n        i, j = sorted(random.sample(range(n), 2))\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        # Calculate combined distance metric\n        dist_1 = distance_matrix_1[node_i, node_j] + distance_matrix_1[new_solution[(i-1)%n], new_solution[(j+1)%n]]\n        dist_2 = distance_matrix_2[node_i, node_j] + distance_matrix_2[new_solution[(i-1)%n], new_solution[(j+1)%n]]\n\n        if dist_1 + dist_2 < distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + \\\n                          distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure solution is valid (no duplicates, all nodes present)\n    if len(set(new_solution)) != n or len(new_solution) != n:\n        # Fallback to simple swap if something went wrong\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 263,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    archive_sorted = sorted(archive, key=lambda x: min(x[1]))\n    selected_index = min(int(len(archive) * 0.2), len(archive) - 1)  # Select from top 20%\n    base_solution = archive[selected_index][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine 3-opt with guided moves\n    for _ in range(3):  # Perform multiple iterations\n        # Randomly select 4 distinct indices (3-opt move)\n        a, b, c, d = sorted(random.sample(range(n), 4))\n\n        # Generate 3 possible moves\n        move1 = new_solution.copy()\n        move1[a:b+1] = move1[a:b+1][::-1]  # Reverse segment a-b\n\n        move2 = new_solution.copy()\n        move2[b:c+1] = move2[b:c+1][::-1]  # Reverse segment b-c\n\n        move3 = new_solution.copy()\n        move3[a:c+1] = move3[a:c+1][::-1]  # Reverse segment a-c\n\n        # Evaluate all moves based on both objectives\n        moves = [move1, move2, move3]\n        move_costs = []\n\n        for move in moves:\n            cost1 = sum(distance_matrix_1[move[i], move[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[move[i], move[(i+1)%n]] for i in range(n))\n            move_costs.append((cost1, cost2))\n\n        # Select the best move that improves at least one objective\n        best_move = None\n        best_improvement = 0\n\n        for move, costs in zip(moves, move_costs):\n            improvement = 0\n            for i in range(2):\n                if costs[i] < archive[selected_index][1][i]:\n                    improvement += (archive[selected_index][1][i] - costs[i]) / archive[selected_index][1][i]\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_move = move\n\n        if best_move is not None:\n            new_solution = best_move\n\n        # Guided move: swap two nodes that are far apart in both objective spaces\n        if random.random() < 0.3:  # 30% chance for guided move\n            # Find the two nodes with the highest combined distance\n            max_dist = -1\n            i, j = 0, 0\n            for idx in range(n):\n                for jdx in range(idx+1, n):\n                    dist = distance_matrix_1[new_solution[idx], new_solution[jdx]] + distance_matrix_2[new_solution[idx], new_solution[jdx]]\n                    if dist > max_dist:\n                        max_dist = dist\n                        i, j = idx, jdx\n\n            # Swap these nodes if they improve the solution\n            temp = new_solution.copy()\n            temp[i], temp[j] = temp[j], temp[i]\n\n            cost1 = sum(distance_matrix_1[temp[k], temp[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp[k], temp[(k+1)%n]] for k in range(n))\n\n            if (cost1 < archive[selected_index][1][0] or cost2 < archive[selected_index][1][1]):\n                new_solution = temp\n\n    # Ensure the solution is valid (all nodes visited exactly once)\n    assert len(np.unique(new_solution)) == len(instance), \"Invalid solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.685867318236445,
            4.247086882591248
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    archive_sorted = sorted(archive, key=lambda x: min(x[1]))\n    selected_index = min(int(len(archive) * 0.2), len(archive) - 1)  # Select from top 20%\n    base_solution = archive[selected_index][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine 3-opt with guided moves\n    for _ in range(3):  # Perform multiple iterations\n        # Randomly select 4 distinct indices (3-opt move)\n        a, b, c, d = sorted(random.sample(range(n), 4))\n\n        # Generate 3 possible moves\n        move1 = new_solution.copy()\n        move1[a:b+1] = move1[a:b+1][::-1]  # Reverse segment a-b\n\n        move2 = new_solution.copy()\n        move2[b:c+1] = move2[b:c+1][::-1]  # Reverse segment b-c\n\n        move3 = new_solution.copy()\n        move3[a:c+1] = move3[a:c+1][::-1]  # Reverse segment a-c\n\n        # Evaluate all moves based on both objectives\n        moves = [move1, move2, move3]\n        move_costs = []\n\n        for move in moves:\n            cost1 = sum(distance_matrix_1[move[i], move[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[move[i], move[(i+1)%n]] for i in range(n))\n            move_costs.append((cost1, cost2))\n\n        # Select the best move that improves at least one objective\n        best_move = None\n        best_improvement = 0\n\n        for move, costs in zip(moves, move_costs):\n            improvement = 0\n            for i in range(2):\n                if costs[i] < archive[selected_index][1][i]:\n                    improvement += (archive[selected_index][1][i] - costs[i]) / archive[selected_index][1][i]\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_move = move\n\n        if best_move is not None:\n            new_solution = best_move\n\n        # Guided move: swap two nodes that are far apart in both objective spaces\n        if random.random() < 0.3:  # 30% chance for guided move\n            # Find the two nodes with the highest combined distance\n            max_dist = -1\n            i, j = 0, 0\n            for idx in range(n):\n                for jdx in range(idx+1, n):\n                    dist = distance_matrix_1[new_solution[idx], new_solution[jdx]] + distance_matrix_2[new_solution[idx], new_solution[jdx]]\n                    if dist > max_dist:\n                        max_dist = dist\n                        i, j = idx, jdx\n\n            # Swap these nodes if they improve the solution\n            temp = new_solution.copy()\n            temp[i], temp[j] = temp[j], temp[i]\n\n            cost1 = sum(distance_matrix_1[temp[k], temp[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp[k], temp[(k+1)%n]] for k in range(n))\n\n            if (cost1 < archive[selected_index][1][0] or cost2 < archive[selected_index][1][1]):\n                new_solution = temp\n\n    # Ensure the solution is valid (all nodes visited exactly once)\n    assert len(np.unique(new_solution)) == len(instance), \"Invalid solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 264,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate dominance ranks (simplified: lower cost solutions are preferred)\n    objectives = [obj for _, obj in archive]\n    ranks = np.argsort([sum(obj) for obj in objectives])  # Simplified rank based on total cost\n    selected_idx = random.choices(range(len(archive)), weights=[1/(rank+1) for rank in ranks], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge exchange with probabilistic segment reversal\n    if n > 3:\n        # Randomly select two non-adjacent edges to exchange\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        if i != j - 1:  # Ensure edges are not adjacent\n            # Exchange edges (i, i+1) and (j, j+1)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n            # With 50% probability, reverse a segment to escape local optima\n            if random.random() < 0.5:\n                k, l = sorted(random.sample(range(1, n-1), 2))\n                new_solution[k:l] = new_solution[k:l][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9524797112987673,
            1.4729661345481873
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate dominance ranks (simplified: lower cost solutions are preferred)\n    objectives = [obj for _, obj in archive]\n    ranks = np.argsort([sum(obj) for obj in objectives])  # Simplified rank based on total cost\n    selected_idx = random.choices(range(len(archive)), weights=[1/(rank+1) for rank in ranks], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge exchange with probabilistic segment reversal\n    if n > 3:\n        # Randomly select two non-adjacent edges to exchange\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        if i != j - 1:  # Ensure edges are not adjacent\n            # Exchange edges (i, i+1) and (j, j+1)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n            # With 50% probability, reverse a segment to escape local optima\n            if random.random() < 0.5:\n                k, l = sorted(random.sample(range(1, n-1), 2))\n                new_solution[k:l] = new_solution[k:l][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 265,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto optimal)\n    # Here, we select a random solution for simplicity, but in practice, you might use a more sophisticated criterion\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: a combination of edge insertion and segment reversal\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Edge insertion: insert the segment [i:j] after position k\n    if i < k < j:\n        # Avoid invalid operations\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n    else:\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    # Segment reversal: reverse the segment [k:l]\n    if k < l:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.807984916647771,
            0.18600469827651978
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto optimal)\n    # Here, we select a random solution for simplicity, but in practice, you might use a more sophisticated criterion\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: a combination of edge insertion and segment reversal\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Edge insertion: insert the segment [i:j] after position k\n    if i < k < j:\n        # Avoid invalid operations\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n    else:\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    # Segment reversal: reverse the segment [k:l]\n    if k < l:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 265,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto optimal)\n    # Here, we select a random solution for simplicity, but in practice, you might use a more sophisticated criterion\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: a combination of edge insertion and segment reversal\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Edge insertion: insert the segment [i:j] after position k\n    if i < k < j:\n        # Avoid invalid operations\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n    else:\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    # Segment reversal: reverse the segment [k:l]\n    if k < l:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.807984916647771,
            0.18600469827651978
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto optimal)\n    # Here, we select a random solution for simplicity, but in practice, you might use a more sophisticated criterion\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: a combination of edge insertion and segment reversal\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Edge insertion: insert the segment [i:j] after position k\n    if i < k < j:\n        # Avoid invalid operations\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n    else:\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    # Segment reversal: reverse the segment [k:l]\n    if k < l:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 266,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability weighted by its dominance (lower cost is better)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    dominance_scores = 1 / (normalized_costs[:, 0] + normalized_costs[:, 1] + 1e-10)\n    probabilities = dominance_scores / dominance_scores.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt with segment-based perturbation\n    for _ in range(10):  # Perform multiple iterations to explore neighborhood\n        # Randomly select three segments\n        i, j, k = sorted(random.sample(range(1, n-1), 3))\n\n        # Apply 3-opt: reverse segments between i-j, j-k, and k-i\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n        new_solution[k:] = new_solution[k:][::-1]\n\n        # Segment-based perturbation: swap two random segments\n        seg1_start, seg1_end = sorted(random.sample(range(n), 2))\n        seg2_start, seg2_end = sorted(random.sample(range(n), 2))\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        # Ensure segments are of same length for swap\n        min_len = min(len(seg1), len(seg2))\n        if min_len > 0:\n            new_solution[seg1_start:seg1_start+min_len] = seg2[:min_len]\n            new_solution[seg2_start:seg2_start+min_len] = seg1[:min_len]\n\n    return new_solution\n\n",
        "score": [
            -0.9712592196063359,
            0.5770326256752014
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability weighted by its dominance (lower cost is better)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    dominance_scores = 1 / (normalized_costs[:, 0] + normalized_costs[:, 1] + 1e-10)\n    probabilities = dominance_scores / dominance_scores.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt with segment-based perturbation\n    for _ in range(10):  # Perform multiple iterations to explore neighborhood\n        # Randomly select three segments\n        i, j, k = sorted(random.sample(range(1, n-1), 3))\n\n        # Apply 3-opt: reverse segments between i-j, j-k, and k-i\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n        new_solution[k:] = new_solution[k:][::-1]\n\n        # Segment-based perturbation: swap two random segments\n        seg1_start, seg1_end = sorted(random.sample(range(n), 2))\n        seg2_start, seg2_end = sorted(random.sample(range(n), 2))\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        # Ensure segments are of same length for swap\n        min_len = min(len(seg1), len(seg2))\n        if min_len > 0:\n            new_solution[seg1_start:seg1_start+min_len] = seg2[:min_len]\n            new_solution[seg2_start:seg2_start+min_len] = seg1[:min_len]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 267,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with lower total cost\n    total_costs = [sum(obj) for _, obj in archive]\n    probabilities = np.exp(-np.array(total_costs) / np.sum(total_costs))  # Softmax-like selection\n    probabilities = probabilities / np.sum(probabilities)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with biased random walk\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for 3-opt\n\n    # Choose three random segments to modify\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Apply 3-opt move: reverse the segments between i-j, j-k, and i-k\n    # This creates three different ways to reconnect the segments\n    option1 = np.concatenate([new_solution[:i], new_solution[i:j][::-1], new_solution[j:k][::-1], new_solution[k:]])\n    option2 = np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j][::-1], new_solution[k:]])\n    option3 = np.concatenate([new_solution[:i], new_solution[j:k][::-1], new_solution[i:j], new_solution[k:]])\n\n    # Evaluate all options in both objective spaces\n    def evaluate(sol):\n        cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n        return (cost1, cost2)\n\n    costs = [evaluate(opt) for opt in [option1, option2, option3]]\n    total_costs = [sum(c) for c in costs]\n\n    # Select the best option or a biased random option\n    if random.random() < 0.7:  # 70% chance to take the best option\n        best_idx = np.argmin(total_costs)\n        new_solution = [opt for opt in [option1, option2, option3]][best_idx]\n    else:  # 30% chance to take a random option with some bias\n        probabilities = np.exp(-np.array(total_costs) / np.sum(total_costs))\n        probabilities = probabilities / np.sum(probabilities)\n        selected_idx = np.random.choice(3, p=probabilities)\n        new_solution = [opt for opt in [option1, option2, option3]][selected_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8879301909149283,
            2.0726484656333923
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with lower total cost\n    total_costs = [sum(obj) for _, obj in archive]\n    probabilities = np.exp(-np.array(total_costs) / np.sum(total_costs))  # Softmax-like selection\n    probabilities = probabilities / np.sum(probabilities)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with biased random walk\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for 3-opt\n\n    # Choose three random segments to modify\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Apply 3-opt move: reverse the segments between i-j, j-k, and i-k\n    # This creates three different ways to reconnect the segments\n    option1 = np.concatenate([new_solution[:i], new_solution[i:j][::-1], new_solution[j:k][::-1], new_solution[k:]])\n    option2 = np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j][::-1], new_solution[k:]])\n    option3 = np.concatenate([new_solution[:i], new_solution[j:k][::-1], new_solution[i:j], new_solution[k:]])\n\n    # Evaluate all options in both objective spaces\n    def evaluate(sol):\n        cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n        return (cost1, cost2)\n\n    costs = [evaluate(opt) for opt in [option1, option2, option3]]\n    total_costs = [sum(c) for c in costs]\n\n    # Select the best option or a biased random option\n    if random.random() < 0.7:  # 70% chance to take the best option\n        best_idx = np.argmin(total_costs)\n        new_solution = [opt for opt in [option1, option2, option3]][best_idx]\n    else:  # 30% chance to take a random option with some bias\n        probabilities = np.exp(-np.array(total_costs) / np.sum(total_costs))\n        probabilities = probabilities / np.sum(probabilities)\n        selected_idx = np.random.choice(3, p=probabilities)\n        new_solution = [opt for opt in [option1, option2, option3]][selected_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 268,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto front or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a custom operator\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Randomly select segments to modify\n    a, b, c = sorted(random.sample(range(1, n-1), 3))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    segment3 = new_solution[c:]\n\n    # Hybrid operation: reverse middle segment and insert after first segment\n    new_solution = np.concatenate([new_solution[:a], segment1[::-1], segment2, segment3])\n\n    # Optional: Apply a custom operator to further diversify\n    if random.random() < 0.5:\n        # Swap two random segments of unequal length\n        x, y = sorted(random.sample(range(1, n), 2))\n        new_solution[x:y] = new_solution[x:y][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7653745900839733,
            1.2986471056938171
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto front or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a custom operator\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Randomly select segments to modify\n    a, b, c = sorted(random.sample(range(1, n-1), 3))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    segment3 = new_solution[c:]\n\n    # Hybrid operation: reverse middle segment and insert after first segment\n    new_solution = np.concatenate([new_solution[:a], segment1[::-1], segment2, segment3])\n\n    # Optional: Apply a custom operator to further diversify\n    if random.random() < 0.5:\n        # Swap two random segments of unequal length\n        x, y = sorted(random.sample(range(1, n), 2))\n        new_solution[x:y] = new_solution[x:y][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 269,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated solutions or those with high variance in objectives)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_cost1, current_cost2 = archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # Hybrid local search: Combine edge swaps with path segment relocation\n    for _ in range(min(5, n_nodes // 2)):  # Limit the number of operations to avoid excessive computation\n        # Randomly choose between edge swap or path segment relocation\n        if np.random.rand() < 0.7:  # Higher probability for edge swaps\n            # Edge swap: Choose two non-adjacent edges and swap their nodes\n            i = np.random.randint(0, n_nodes)\n            j = np.random.randint(0, n_nodes)\n            while abs(i - j) <= 1 or (i == 0 and j == n_nodes - 1) or (j == 0 and i == n_nodes - 1):\n                j = np.random.randint(0, n_nodes)\n            # Perform the swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Path segment relocation: Move a segment of the path to a different position\n            segment_length = np.random.randint(2, min(5, n_nodes // 2))\n            start = np.random.randint(0, n_nodes - segment_length)\n            end = start + segment_length\n            segment = new_solution[start:end].copy()\n            # Remove the segment\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n            # Insert the segment at a new random position\n            insert_pos = np.random.randint(0, len(new_solution) - segment_length + 1)\n            new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure the solution remains feasible (no duplicates and all nodes are visited)\n    if len(np.unique(new_solution)) != n_nodes:\n        # If duplicates exist, repair by shuffling the invalid part\n        unique_nodes = set(range(n_nodes))\n        missing_nodes = list(unique_nodes - set(new_solution))\n        for i in range(n_nodes):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes.pop()\n\n    return new_solution\n\n",
        "score": [
            -0.8475121701797743,
            1.5812044143676758
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated solutions or those with high variance in objectives)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_cost1, current_cost2 = archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # Hybrid local search: Combine edge swaps with path segment relocation\n    for _ in range(min(5, n_nodes // 2)):  # Limit the number of operations to avoid excessive computation\n        # Randomly choose between edge swap or path segment relocation\n        if np.random.rand() < 0.7:  # Higher probability for edge swaps\n            # Edge swap: Choose two non-adjacent edges and swap their nodes\n            i = np.random.randint(0, n_nodes)\n            j = np.random.randint(0, n_nodes)\n            while abs(i - j) <= 1 or (i == 0 and j == n_nodes - 1) or (j == 0 and i == n_nodes - 1):\n                j = np.random.randint(0, n_nodes)\n            # Perform the swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Path segment relocation: Move a segment of the path to a different position\n            segment_length = np.random.randint(2, min(5, n_nodes // 2))\n            start = np.random.randint(0, n_nodes - segment_length)\n            end = start + segment_length\n            segment = new_solution[start:end].copy()\n            # Remove the segment\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n            # Insert the segment at a new random position\n            insert_pos = np.random.randint(0, len(new_solution) - segment_length + 1)\n            new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure the solution remains feasible (no duplicates and all nodes are visited)\n    if len(np.unique(new_solution)) != n_nodes:\n        # If duplicates exist, repair by shuffling the invalid part\n        unique_nodes = set(range(n_nodes))\n        missing_nodes = list(unique_nodes - set(new_solution))\n        for i in range(n_nodes):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes.pop()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 270,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge-swap strategy\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Perform a random 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform a novel edge-swap: swap edges between two randomly selected nodes\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.8885808976340461,
            1.12970769405365
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge-swap strategy\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Perform a random 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform a novel edge-swap: swap edges between two randomly selected nodes\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 271,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto front candidates or diverse solutions)\n    candidates = [sol for sol, _ in archive]\n    if not candidates:\n        return archive[0][0].copy()\n\n    # Choose a random candidate with higher probability for solutions with lower total cost\n    costs = [sum(obj) for _, obj in archive]\n    probabilities = np.exp(-np.array(costs) / np.sum(costs))  # Higher cost = lower probability\n    probabilities /= probabilities.sum()  # Normalize\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combination of edge exchange and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment to reverse\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Apply edge exchange between two random edges\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[a], new_solution[b], new_solution[c], new_solution[d] = new_solution[c], new_solution[d], new_solution[a], new_solution[b]\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple 2-opt if the above fails\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7997419888062767,
            1.933668851852417
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto front candidates or diverse solutions)\n    candidates = [sol for sol, _ in archive]\n    if not candidates:\n        return archive[0][0].copy()\n\n    # Choose a random candidate with higher probability for solutions with lower total cost\n    costs = [sum(obj) for _, obj in archive]\n    probabilities = np.exp(-np.array(costs) / np.sum(costs))  # Higher cost = lower probability\n    probabilities /= probabilities.sum()  # Normalize\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combination of edge exchange and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment to reverse\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Apply edge exchange between two random edges\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if a != c and b != d:\n        new_solution[a], new_solution[b], new_solution[c], new_solution[d] = new_solution[c], new_solution[d], new_solution[a], new_solution[b]\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple 2-opt if the above fails\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 272,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with lower objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / objectives.max(axis=0)\n    weights = 1 / (1 + np.sum(normalized_obj, axis=1))\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel edge exchange strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a random 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, apply a novel edge exchange strategy based on both distance matrices\n    for _ in range(2):  # Perform a few iterations of the novel operator\n        # Select a random segment to consider for exchange\n        k = random.randint(2, min(5, n-1))\n        segment = random.sample(range(n), k)\n\n        # Calculate potential improvements based on both distance matrices\n        improvements = []\n        for idx in segment:\n            prev = new_solution[(idx-1) % n]\n            curr = new_solution[idx]\n            next_node = new_solution[(idx+1) % n]\n\n            # Calculate potential changes in both objectives\n            delta1 = -distance_matrix_1[prev, curr] - distance_matrix_1[curr, next_node] \\\n                     + distance_matrix_1[prev, next_node] + distance_matrix_1[next_node, curr]\n            delta2 = -distance_matrix_2[prev, curr] - distance_matrix_2[curr, next_node] \\\n                     + distance_matrix_2[prev, next_node] + distance_matrix_2[next_node, curr]\n\n            # Combine improvements using a weighted sum\n            total_improvement = 0.5 * delta1 + 0.5 * delta2\n            improvements.append((total_improvement, idx))\n\n        # Apply the best improvement if it's beneficial\n        improvements.sort()\n        if improvements and improvements[0][0] < 0:\n            idx = improvements[0][1]\n            # Exchange the node with its neighbor\n            new_solution[idx], new_solution[(idx+1)%n] = new_solution[(idx+1)%n], new_solution[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8885841140927442,
            1.854053258895874
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with lower objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / objectives.max(axis=0)\n    weights = 1 / (1 + np.sum(normalized_obj, axis=1))\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel edge exchange strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a random 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, apply a novel edge exchange strategy based on both distance matrices\n    for _ in range(2):  # Perform a few iterations of the novel operator\n        # Select a random segment to consider for exchange\n        k = random.randint(2, min(5, n-1))\n        segment = random.sample(range(n), k)\n\n        # Calculate potential improvements based on both distance matrices\n        improvements = []\n        for idx in segment:\n            prev = new_solution[(idx-1) % n]\n            curr = new_solution[idx]\n            next_node = new_solution[(idx+1) % n]\n\n            # Calculate potential changes in both objectives\n            delta1 = -distance_matrix_1[prev, curr] - distance_matrix_1[curr, next_node] \\\n                     + distance_matrix_1[prev, next_node] + distance_matrix_1[next_node, curr]\n            delta2 = -distance_matrix_2[prev, curr] - distance_matrix_2[curr, next_node] \\\n                     + distance_matrix_2[prev, next_node] + distance_matrix_2[next_node, curr]\n\n            # Combine improvements using a weighted sum\n            total_improvement = 0.5 * delta1 + 0.5 * delta2\n            improvements.append((total_improvement, idx))\n\n        # Apply the best improvement if it's beneficial\n        improvements.sort()\n        if improvements and improvements[0][0] < 0:\n            idx = improvements[0][1]\n            # Exchange the node with its neighbor\n            new_solution[idx], new_solution[(idx+1)%n] = new_solution[(idx+1)%n], new_solution[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 273,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Calculate potential improvement scores (inverse of objective values)\n        scores = np.array([1.0 / (obj[0] + obj[1]) for (_, obj) in archive])\n        scores = scores / np.sum(scores)\n        selected_idx = np.random.choice(len(archive), p=scores)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    if n > 3:\n        # 3-opt with segment inversion\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment = new_solution[a:b]\n        if random.random() < 0.5:\n            segment = segment[::-1]  # Inversion\n        else:\n            segment = np.roll(segment, 1)  # Rotation\n        new_solution[a:b] = segment\n    else:\n        # For small instances, use a simple swap\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains feasible\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.9138686378647196,
            1.2640739679336548
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Calculate potential improvement scores (inverse of objective values)\n        scores = np.array([1.0 / (obj[0] + obj[1]) for (_, obj) in archive])\n        scores = scores / np.sum(scores)\n        selected_idx = np.random.choice(len(archive), p=scores)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    if n > 3:\n        # 3-opt with segment inversion\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment = new_solution[a:b]\n        if random.random() < 0.5:\n            segment = segment[::-1]  # Inversion\n        else:\n            segment = np.roll(segment, 1)  # Rotation\n        new_solution[a:b] = segment\n    else:\n        # For small instances, use a simple swap\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains feasible\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 274,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    # Here, we use a simple heuristic: solutions with higher costs are more likely to be selected\n    costs = np.array([sum(obj) for _, obj in archive])\n    if np.all(costs == costs[0]):\n        # If all costs are equal, select randomly\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        # Normalize costs to get probabilities\n        probabilities = (costs - np.min(costs)) / (np.max(costs) - np.min(costs) + 1e-10)\n        probabilities = probabilities / np.sum(probabilities)\n        selected_idx = np.random.choice(len(archive), p=probabilities)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        # For small instances, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Choose between three local search strategies\n        strategy = random.choice(['edge_swap', 'segment_reversal', 'insertion'])\n\n        if strategy == 'edge_swap':\n            # Randomly select two edges and swap them\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        elif strategy == 'segment_reversal':\n            # Reverse a random segment and insert it at a different position\n            i, j = sorted(random.sample(range(n), 2))\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], segment])\n\n        elif strategy == 'insertion':\n            # Remove a node and insert it at a different position\n            i = random.randint(0, n-1)\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            j = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Verify the solution is feasible (no duplicates and all nodes present)\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.7326016804563401,
            1.6269949674606323
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    # Here, we use a simple heuristic: solutions with higher costs are more likely to be selected\n    costs = np.array([sum(obj) for _, obj in archive])\n    if np.all(costs == costs[0]):\n        # If all costs are equal, select randomly\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        # Normalize costs to get probabilities\n        probabilities = (costs - np.min(costs)) / (np.max(costs) - np.min(costs) + 1e-10)\n        probabilities = probabilities / np.sum(probabilities)\n        selected_idx = np.random.choice(len(archive), p=probabilities)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        # For small instances, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Choose between three local search strategies\n        strategy = random.choice(['edge_swap', 'segment_reversal', 'insertion'])\n\n        if strategy == 'edge_swap':\n            # Randomly select two edges and swap them\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        elif strategy == 'segment_reversal':\n            # Reverse a random segment and insert it at a different position\n            i, j = sorted(random.sample(range(n), 2))\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], segment])\n\n        elif strategy == 'insertion':\n            # Remove a node and insert it at a different position\n            i = random.randint(0, n-1)\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            j = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Verify the solution is feasible (no duplicates and all nodes present)\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 275,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those not on the Pareto front)\n    # Here, we randomly select from the top 30% of solutions by objective values\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selection_pool = sorted_archive[:max(1, len(archive) // 3)]\n    base_solution, _ = random.choice(selection_pool)\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine 3-opt with a novel segment relocation\n    for _ in range(3):  # Perform multiple iterations for better exploration\n        # Randomly select three distinct segments\n        i, j, k = sorted(random.sample(range(1, n), 3))\n\n        # Apply 3-opt move\n        segment1 = new_solution[:i]\n        segment2 = new_solution[i:j]\n        segment3 = new_solution[j:k]\n        segment4 = new_solution[k:]\n\n        # Recombine segments in a different order\n        new_order = [segment1, segment2, segment3, segment4]\n        random.shuffle(new_order)\n        new_solution = np.concatenate(new_order)\n\n        # Novel segment relocation: move a random segment to a different position\n        if random.random() < 0.5:\n            seg_start, seg_end = sorted(random.sample(range(1, n), 2))\n            segment = new_solution[seg_start:seg_end]\n            remaining = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n            insert_pos = random.randint(0, len(remaining))\n            new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.712884628237104,
            1.515716016292572
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those not on the Pareto front)\n    # Here, we randomly select from the top 30% of solutions by objective values\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selection_pool = sorted_archive[:max(1, len(archive) // 3)]\n    base_solution, _ = random.choice(selection_pool)\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine 3-opt with a novel segment relocation\n    for _ in range(3):  # Perform multiple iterations for better exploration\n        # Randomly select three distinct segments\n        i, j, k = sorted(random.sample(range(1, n), 3))\n\n        # Apply 3-opt move\n        segment1 = new_solution[:i]\n        segment2 = new_solution[i:j]\n        segment3 = new_solution[j:k]\n        segment4 = new_solution[k:]\n\n        # Recombine segments in a different order\n        new_order = [segment1, segment2, segment3, segment4]\n        random.shuffle(new_order)\n        new_solution = np.concatenate(new_order)\n\n        # Novel segment relocation: move a random segment to a different position\n        if random.random() < 0.5:\n            seg_start, seg_end = sorted(random.sample(range(1, n), 2))\n            segment = new_solution[seg_start:seg_end]\n            remaining = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n            insert_pos = random.randint(0, len(remaining))\n            new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 276,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best but not the worst)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    candidate_solutions = sorted_archive[int(len(sorted_archive)*0.2):int(len(sorted_archive)*0.8)]\n    if not candidate_solutions:\n        candidate_solutions = sorted_archive\n    base_solution = random.choice(candidate_solutions)[0].copy()\n\n    # Novel local search strategy: \"Bi-objective Segment Reversal with Insertion\"\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Step 1: Select two random segments\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Step 2: Reverse the segments if they overlap or are too short\n    if a < c < b < d:\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[c:d] = new_solution[c:d][::-1]\n    else:\n        # Step 3: Insert one segment into the other\n        segment = new_solution[c:d]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:c], new_solution[d:]])\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6991472899328901,
            0.722561776638031
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best but not the worst)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    candidate_solutions = sorted_archive[int(len(sorted_archive)*0.2):int(len(sorted_archive)*0.8)]\n    if not candidate_solutions:\n        candidate_solutions = sorted_archive\n    base_solution = random.choice(candidate_solutions)[0].copy()\n\n    # Novel local search strategy: \"Bi-objective Segment Reversal with Insertion\"\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Step 1: Select two random segments\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Step 2: Reverse the segments if they overlap or are too short\n    if a < c < b < d:\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[c:d] = new_solution[c:d][::-1]\n    else:\n        # Step 3: Insert one segment into the other\n        segment = new_solution[c:d]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:c], new_solution[d:]])\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 277,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate improvement potential (simplified as inverse of objective sum)\n        objectives = np.array([obj for (sol, obj) in archive])\n        potentials = 1.0 / (objectives[:, 0] + objectives[:, 1] + 1e-6)\n        probabilities = potentials / np.sum(potentials)\n        selected_idx = np.random.choice(len(archive), p=probabilities)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(base_solution)\n    if n < 3:\n        return new_solution  # No possible improvement\n\n    # Step 1: Adaptive segment reversal (novel operator)\n    # Select a segment size based on the solution's current quality\n    current_obj = archive[selected_idx][1]\n    segment_size = max(2, min(n // 4, int(np.sqrt(n))))  # Adaptive segment size\n\n    # Randomly select start and end points for the segment\n    start = random.randint(0, n - segment_size - 1)\n    end = start + segment_size\n\n    # Reverse the segment\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Edge swapping (standard operator)\n    # Perform a random 2-opt move if the segment reversal didn't help\n    if random.random() < 0.3:  # 30% chance to perform additional edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible (all nodes visited exactly once)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9197944636056136,
            1.093479573726654
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate improvement potential (simplified as inverse of objective sum)\n        objectives = np.array([obj for (sol, obj) in archive])\n        potentials = 1.0 / (objectives[:, 0] + objectives[:, 1] + 1e-6)\n        probabilities = potentials / np.sum(potentials)\n        selected_idx = np.random.choice(len(archive), p=probabilities)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(base_solution)\n    if n < 3:\n        return new_solution  # No possible improvement\n\n    # Step 1: Adaptive segment reversal (novel operator)\n    # Select a segment size based on the solution's current quality\n    current_obj = archive[selected_idx][1]\n    segment_size = max(2, min(n // 4, int(np.sqrt(n))))  # Adaptive segment size\n\n    # Randomly select start and end points for the segment\n    start = random.randint(0, n - segment_size - 1)\n    end = start + segment_size\n\n    # Reverse the segment\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Edge swapping (standard operator)\n    # Perform a random 2-opt move if the segment reversal didn't help\n    if random.random() < 0.3:  # 30% chance to perform additional edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible (all nodes visited exactly once)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 278,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with high cost in at least one objective)\n    archive_sorted = sorted(archive, key=lambda x: max(x[1]), reverse=True)\n    selected_idx = min(10, len(archive_sorted) - 1)  # Select from top 10 or entire archive if small\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom move\n    n = len(base_solution)\n    if n < 3:\n        return new_solution  # No improvement possible\n\n    # Randomly select 3 distinct positions to modify\n    i, j, k = random.sample(range(n), 3)\n    i, j, k = sorted([i, j, k])\n\n    # Apply a custom move: reverse segment between i and k, then swap j and k\n    segment = new_solution[i:k+1]\n    new_solution[i:k+1] = np.concatenate([segment[:j-i], segment[j-i:][::-1]])\n    new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if custom move breaks feasibility\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9338575256197755,
            1.0147139430046082
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with high cost in at least one objective)\n    archive_sorted = sorted(archive, key=lambda x: max(x[1]), reverse=True)\n    selected_idx = min(10, len(archive_sorted) - 1)  # Select from top 10 or entire archive if small\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom move\n    n = len(base_solution)\n    if n < 3:\n        return new_solution  # No improvement possible\n\n    # Randomly select 3 distinct positions to modify\n    i, j, k = random.sample(range(n), 3)\n    i, j, k = sorted([i, j, k])\n\n    # Apply a custom move: reverse segment between i and k, then swap j and k\n    segment = new_solution[i:k+1]\n    new_solution[i:k+1] = np.concatenate([segment[:j-i], segment[j-i:][::-1]])\n    new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if custom move breaks feasibility\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 279,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    candidates = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = candidates[min(3, len(candidates) - 1)][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine edge insertion with segment relocation\n    for _ in range(10):  # Perform multiple iterations\n        # Step 1: Edge insertion (for one objective)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n        # Step 2: Segment relocation (for the other objective)\n        segment_length = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start + segment_length]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start + segment_length:]])\n        insert_pos = random.randint(0, len(new_solution) - segment_length)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n        # Ensure feasibility\n        if len(new_solution) != n:\n            new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8063074570082382,
            1.5944731831550598
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    candidates = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = candidates[min(3, len(candidates) - 1)][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine edge insertion with segment relocation\n    for _ in range(10):  # Perform multiple iterations\n        # Step 1: Edge insertion (for one objective)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n        # Step 2: Segment relocation (for the other objective)\n        segment_length = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start + segment_length]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start + segment_length:]])\n        insert_pos = random.randint(0, len(new_solution) - segment_length)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n        # Ensure feasibility\n        if len(new_solution) != n:\n            new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 280,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high objective values)\n    candidates = []\n    for sol, obj in archive:\n        # Penalize solutions that are already very good in both objectives\n        penalty = 0.1 * (obj[0] + obj[1])\n        candidates.append((sol, penalty))\n\n    # Sort by penalty (ascending) to prioritize solutions with higher potential\n    candidates.sort(key=lambda x: x[1])\n    selected_solution = candidates[0][0].copy()\n\n    # Hybrid local search operator: combination of 3-opt and random segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 3-opt or segment reversal\n    if random.random() < 0.7:  # 70% chance for 3-opt\n        # 3-opt: select three random edges and reconnect them in a different order\n        i, j, k = sorted(random.sample(range(1, n), 3))\n        segment1 = new_solution[:i]\n        segment2 = new_solution[i:j]\n        segment3 = new_solution[j:k]\n        segment4 = new_solution[k:]\n\n        # Reconnect segments in a new order\n        new_order = [segment1, segment3, segment2, segment4]\n        new_solution = np.concatenate(new_order)\n    else:\n        # Random segment reversal: reverse a random segment of the tour\n        start, end = sorted(random.sample(range(n), 2))\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility: no duplicates and all nodes are visited\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid.\"\n\n    return new_solution\n\n",
        "score": [
            -0.6473520723289756,
            1.1279507875442505
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high objective values)\n    candidates = []\n    for sol, obj in archive:\n        # Penalize solutions that are already very good in both objectives\n        penalty = 0.1 * (obj[0] + obj[1])\n        candidates.append((sol, penalty))\n\n    # Sort by penalty (ascending) to prioritize solutions with higher potential\n    candidates.sort(key=lambda x: x[1])\n    selected_solution = candidates[0][0].copy()\n\n    # Hybrid local search operator: combination of 3-opt and random segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 3-opt or segment reversal\n    if random.random() < 0.7:  # 70% chance for 3-opt\n        # 3-opt: select three random edges and reconnect them in a different order\n        i, j, k = sorted(random.sample(range(1, n), 3))\n        segment1 = new_solution[:i]\n        segment2 = new_solution[i:j]\n        segment3 = new_solution[j:k]\n        segment4 = new_solution[k:]\n\n        # Reconnect segments in a new order\n        new_order = [segment1, segment3, segment2, segment4]\n        new_solution = np.concatenate(new_order)\n    else:\n        # Random segment reversal: reverse a random segment of the tour\n        start, end = sorted(random.sample(range(n), 2))\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility: no duplicates and all nodes are visited\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid.\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 281,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on the best trade-off between the two objectives\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Normalize objectives to compare them\n    obj1 = np.array([o[0] for o in objectives])\n    obj2 = np.array([o[1] for o in objectives])\n\n    # Normalize objectives to [0, 1]\n    min_obj1, max_obj1 = np.min(obj1), np.max(obj1)\n    min_obj2, max_obj2 = np.min(obj2), np.max(obj2)\n\n    if max_obj1 == min_obj1:\n        normalized_obj1 = np.zeros_like(obj1)\n    else:\n        normalized_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1)\n\n    if max_obj2 == min_obj2:\n        normalized_obj2 = np.zeros_like(obj2)\n    else:\n        normalized_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2)\n\n    # Compute the sum of normalized objectives (simple Pareto front approximation)\n    scores = normalized_obj1 + normalized_obj2\n\n    # Select the solution with the lowest score (best trade-off)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-based swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform a 3-opt move (select 3 random edges and reconnect them)\n    i, j, k = sorted(np.random.choice(range(1, n), 3, replace=False))\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Reconnect the segments in a different order\n    new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Novel edge-based swap: swap edges that are not adjacent but have high potential for improvement\n    # Find the worst edge in the current solution based on both distance matrices\n    worst_edge_idx = -1\n    worst_edge_score = -np.inf\n\n    for idx in range(n):\n        current_node = new_solution[idx]\n        next_node = new_solution[(idx + 1) % n]\n        score = distance_matrix_1[current_node, next_node] + distance_matrix_2[current_node, next_node]\n\n        if score > worst_edge_score:\n            worst_edge_score = score\n            worst_edge_idx = idx\n\n    if worst_edge_idx != -1:\n        # Find the best possible edge to swap with the worst edge\n        best_swap_idx = -1\n        best_swap_score = np.inf\n\n        for idx in range(n):\n            if idx == worst_edge_idx or idx == (worst_edge_idx + 1) % n:\n                continue\n\n            # Try swapping the worst edge with this edge\n            temp_solution = new_solution.copy()\n            temp_solution[worst_edge_idx], temp_solution[idx] = temp_solution[idx], temp_solution[worst_edge_idx]\n\n            # Calculate the new score\n            current_node = temp_solution[worst_edge_idx]\n            next_node = temp_solution[(worst_edge_idx + 1) % n]\n            new_score = distance_matrix_1[current_node, next_node] + distance_matrix_2[current_node, next_node]\n\n            if new_score < best_swap_score:\n                best_swap_score = new_score\n                best_swap_idx = idx\n\n        if best_swap_idx != -1:\n            new_solution[worst_edge_idx], new_solution[best_swap_idx] = new_solution[best_swap_idx], new_solution[worst_edge_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7074113260143908,
            1.3901034593582153
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on the best trade-off between the two objectives\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Normalize objectives to compare them\n    obj1 = np.array([o[0] for o in objectives])\n    obj2 = np.array([o[1] for o in objectives])\n\n    # Normalize objectives to [0, 1]\n    min_obj1, max_obj1 = np.min(obj1), np.max(obj1)\n    min_obj2, max_obj2 = np.min(obj2), np.max(obj2)\n\n    if max_obj1 == min_obj1:\n        normalized_obj1 = np.zeros_like(obj1)\n    else:\n        normalized_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1)\n\n    if max_obj2 == min_obj2:\n        normalized_obj2 = np.zeros_like(obj2)\n    else:\n        normalized_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2)\n\n    # Compute the sum of normalized objectives (simple Pareto front approximation)\n    scores = normalized_obj1 + normalized_obj2\n\n    # Select the solution with the lowest score (best trade-off)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-based swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform a 3-opt move (select 3 random edges and reconnect them)\n    i, j, k = sorted(np.random.choice(range(1, n), 3, replace=False))\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Reconnect the segments in a different order\n    new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Novel edge-based swap: swap edges that are not adjacent but have high potential for improvement\n    # Find the worst edge in the current solution based on both distance matrices\n    worst_edge_idx = -1\n    worst_edge_score = -np.inf\n\n    for idx in range(n):\n        current_node = new_solution[idx]\n        next_node = new_solution[(idx + 1) % n]\n        score = distance_matrix_1[current_node, next_node] + distance_matrix_2[current_node, next_node]\n\n        if score > worst_edge_score:\n            worst_edge_score = score\n            worst_edge_idx = idx\n\n    if worst_edge_idx != -1:\n        # Find the best possible edge to swap with the worst edge\n        best_swap_idx = -1\n        best_swap_score = np.inf\n\n        for idx in range(n):\n            if idx == worst_edge_idx or idx == (worst_edge_idx + 1) % n:\n                continue\n\n            # Try swapping the worst edge with this edge\n            temp_solution = new_solution.copy()\n            temp_solution[worst_edge_idx], temp_solution[idx] = temp_solution[idx], temp_solution[worst_edge_idx]\n\n            # Calculate the new score\n            current_node = temp_solution[worst_edge_idx]\n            next_node = temp_solution[(worst_edge_idx + 1) % n]\n            new_score = distance_matrix_1[current_node, next_node] + distance_matrix_2[current_node, next_node]\n\n            if new_score < best_swap_score:\n                best_swap_score = new_score\n                best_swap_idx = idx\n\n        if best_swap_idx != -1:\n            new_solution[worst_edge_idx], new_solution[best_swap_idx] = new_solution[best_swap_idx], new_solution[worst_edge_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 282,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    weights = 1 / (normalized_objectives.sum(axis=1) + 1e-10)\n    weights = weights / weights.sum()  # Normalize to probabilities\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt with segment relocation\n    if n >= 5:\n        # Randomly select three distinct edges to modify\n        i, j, k = sorted(random.sample(range(1, n), 3))\n\n        # Perform a 3-opt move\n        segment1 = new_solution[:i]\n        segment2 = new_solution[i:j]\n        segment3 = new_solution[j:k]\n        segment4 = new_solution[k:]\n\n        # Reconstruct the tour in a new order\n        new_order = np.concatenate([segment1, segment3, segment2, segment4])\n        new_solution = new_order\n\n        # Apply segment relocation to further improve\n        if n >= 6:\n            a, b = sorted(random.sample(range(1, n-1), 2))\n            if b - a > 1:\n                segment = new_solution[a:b]\n                remaining = np.concatenate([new_solution[:a], new_solution[b:]])\n                insert_pos = random.randint(0, len(remaining)-1)\n                new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure the solution remains feasible\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n, \"Invalid tour generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.7326087401562305,
            1.3455882668495178
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    weights = 1 / (normalized_objectives.sum(axis=1) + 1e-10)\n    weights = weights / weights.sum()  # Normalize to probabilities\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt with segment relocation\n    if n >= 5:\n        # Randomly select three distinct edges to modify\n        i, j, k = sorted(random.sample(range(1, n), 3))\n\n        # Perform a 3-opt move\n        segment1 = new_solution[:i]\n        segment2 = new_solution[i:j]\n        segment3 = new_solution[j:k]\n        segment4 = new_solution[k:]\n\n        # Reconstruct the tour in a new order\n        new_order = np.concatenate([segment1, segment3, segment2, segment4])\n        new_solution = new_order\n\n        # Apply segment relocation to further improve\n        if n >= 6:\n            a, b = sorted(random.sample(range(1, n-1), 2))\n            if b - a > 1:\n                segment = new_solution[a:b]\n                remaining = np.concatenate([new_solution[:a], new_solution[b:]])\n                insert_pos = random.randint(0, len(remaining)-1)\n                new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure the solution remains feasible\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n, \"Invalid tour generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 283,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., one with low cost but high diversity)\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge swap strategy\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select three distinct indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move (swap edges between i, j, k)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Novel edge swap: swap two edges in a way that reduces both objectives\n    if random.random() < 0.5:  # 50% chance to apply novel swap\n        a, b = sorted(random.sample(range(n), 2))\n        if a != b and (b - a) > 1:\n            # Swap edges between a and b\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7181572641609503,
            1.2392169833183289
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., one with low cost but high diversity)\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge swap strategy\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select three distinct indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move (swap edges between i, j, k)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Novel edge swap: swap two edges in a way that reduces both objectives\n    if random.random() < 0.5:  # 50% chance to apply novel swap\n        a, b = sorted(random.sample(range(n), 2))\n        if a != b and (b - a) > 1:\n            # Swap edges between a and b\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 284,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by sum of objectives to prioritize solutions with higher cost\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Randomly select from top 50% of solutions\n        selected_idx = random.randint(0, max(0, len(archive_sorted) // 2 - 1))\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of edge insertion and node relocation\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Edge insertion: remove a random edge and reinsert it in a different position\n        i = random.randint(0, n-2)\n        node_to_insert = new_solution[i+1]\n\n        # Remove the edge (i, i+1)\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:]])\n\n        # Find insertion position that minimizes the sum of both distances\n        min_cost = float('inf')\n        best_pos = i\n        for pos in range(n-1):\n            if pos == i or pos == i+1:\n                continue\n            # Calculate cost of inserting between pos and pos+1\n            if pos == n-2:\n                cost = distance_matrix_1[new_solution[pos], node_to_insert] + distance_matrix_1[node_to_insert, new_solution[0]] + \\\n                       distance_matrix_2[new_solution[pos], node_to_insert] + distance_matrix_2[node_to_insert, new_solution[0]]\n            else:\n                cost = distance_matrix_1[new_solution[pos], node_to_insert] + distance_matrix_1[node_to_insert, new_solution[pos+1]] + \\\n                       distance_matrix_2[new_solution[pos], node_to_insert] + distance_matrix_2[node_to_insert, new_solution[pos+1]]\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        # Insert the node at the best position\n        if best_pos == n-2:\n            new_solution = np.concatenate([new_solution[:best_pos+1], [node_to_insert], new_solution[best_pos+1:]])\n        else:\n            new_solution = np.concatenate([new_solution[:best_pos+1], [node_to_insert], new_solution[best_pos+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8436744339686657,
            1.7684974074363708
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by sum of objectives to prioritize solutions with higher cost\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Randomly select from top 50% of solutions\n        selected_idx = random.randint(0, max(0, len(archive_sorted) // 2 - 1))\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of edge insertion and node relocation\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Edge insertion: remove a random edge and reinsert it in a different position\n        i = random.randint(0, n-2)\n        node_to_insert = new_solution[i+1]\n\n        # Remove the edge (i, i+1)\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:]])\n\n        # Find insertion position that minimizes the sum of both distances\n        min_cost = float('inf')\n        best_pos = i\n        for pos in range(n-1):\n            if pos == i or pos == i+1:\n                continue\n            # Calculate cost of inserting between pos and pos+1\n            if pos == n-2:\n                cost = distance_matrix_1[new_solution[pos], node_to_insert] + distance_matrix_1[node_to_insert, new_solution[0]] + \\\n                       distance_matrix_2[new_solution[pos], node_to_insert] + distance_matrix_2[node_to_insert, new_solution[0]]\n            else:\n                cost = distance_matrix_1[new_solution[pos], node_to_insert] + distance_matrix_1[node_to_insert, new_solution[pos+1]] + \\\n                       distance_matrix_2[new_solution[pos], node_to_insert] + distance_matrix_2[node_to_insert, new_solution[pos+1]]\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        # Insert the node at the best position\n        if best_pos == n-2:\n            new_solution = np.concatenate([new_solution[:best_pos+1], [node_to_insert], new_solution[best_pos+1:]])\n        else:\n            new_solution = np.concatenate([new_solution[:best_pos+1], [node_to_insert], new_solution[best_pos+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 285,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with lower total cost\n    objectives = np.array([obj for _, obj in archive])\n    total_costs = objectives.sum(axis=1)\n    probabilities = 1 / (total_costs + 1e-10)  # Avoid division by zero\n    probabilities = probabilities / probabilities.sum()\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Edge exchange + Segment relocation\n    n = len(base_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Edge exchange (2-opt variant)\n    new_solution[i:j+1] = base_solution[i:j+1][::-1]\n\n    # Segment relocation (novel component)\n    if j - i > 2:\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], segment])\n\n        # Reinsert segment at a better position\n        best_pos = i\n        best_cost = float('inf')\n        for pos in range(n - (j - i) + 1):\n            temp_solution = np.concatenate([\n                new_solution[:pos],\n                segment,\n                new_solution[pos:]\n            ])\n            cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n            cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n            if cost1 + cost2 < best_cost:\n                best_cost = cost1 + cost2\n                best_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            segment,\n            new_solution[best_pos:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -0.6635899289146269,
            2.858174443244934
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with lower total cost\n    objectives = np.array([obj for _, obj in archive])\n    total_costs = objectives.sum(axis=1)\n    probabilities = 1 / (total_costs + 1e-10)  # Avoid division by zero\n    probabilities = probabilities / probabilities.sum()\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Edge exchange + Segment relocation\n    n = len(base_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Edge exchange (2-opt variant)\n    new_solution[i:j+1] = base_solution[i:j+1][::-1]\n\n    # Segment relocation (novel component)\n    if j - i > 2:\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], segment])\n\n        # Reinsert segment at a better position\n        best_pos = i\n        best_cost = float('inf')\n        for pos in range(n - (j - i) + 1):\n            temp_solution = np.concatenate([\n                new_solution[:pos],\n                segment,\n                new_solution[pos:]\n            ])\n            cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n            cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n            if cost1 + cost2 < best_cost:\n                best_cost = cost1 + cost2\n                best_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            segment,\n            new_solution[best_pos:]\n        ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 286,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective dominance)\n    weights = [1 / (obj[0] * obj[1]) for _, obj in archive]  # Higher weights for better solutions\n    selected_idx = np.random.choice(len(archive), p=np.array(weights) / sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Step 1: Edge insertion (like 2-opt but more flexible)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]  # Reverse segment\n\n    # Step 2: Segment relocation (novel operation)\n    k = np.random.randint(1, n//2)  # Random segment length\n    l = np.random.randint(0, n - k)  # Random start position\n\n    segment = new_solution[l:l+k]\n    remaining = np.setdiff1d(new_solution, segment)\n    insert_pos = np.random.randint(0, len(remaining) - k + 1)\n\n    # Reconstruct solution with relocated segment\n    new_solution = np.concatenate([\n        remaining[:insert_pos],\n        segment,\n        remaining[insert_pos:]\n    ])\n\n    # Ensure feasibility (no duplicates, all nodes included)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n    assert len(new_solution) == n, \"Invalid solution length\"\n\n    return new_solution\n\n",
        "score": [
            -0.8314045971393937,
            1.6258330941200256
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective dominance)\n    weights = [1 / (obj[0] * obj[1]) for _, obj in archive]  # Higher weights for better solutions\n    selected_idx = np.random.choice(len(archive), p=np.array(weights) / sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Step 1: Edge insertion (like 2-opt but more flexible)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]  # Reverse segment\n\n    # Step 2: Segment relocation (novel operation)\n    k = np.random.randint(1, n//2)  # Random segment length\n    l = np.random.randint(0, n - k)  # Random start position\n\n    segment = new_solution[l:l+k]\n    remaining = np.setdiff1d(new_solution, segment)\n    insert_pos = np.random.randint(0, len(remaining) - k + 1)\n\n    # Reconstruct solution with relocated segment\n    new_solution = np.concatenate([\n        remaining[:insert_pos],\n        segment,\n        remaining[insert_pos:]\n    ])\n\n    # Ensure feasibility (no duplicates, all nodes included)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n    assert len(new_solution) == n, \"Invalid solution length\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 287,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    # Here, we select a random solution from the top 20% of the archive based on a combined objective score\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    top_k = max(1, len(archive_sorted) // 5)\n    selected_idx = random.randint(0, top_k - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: Edge insertion + partial 2-opt\n    # Step 1: Edge insertion (remove a random edge and reinsert it in a different position)\n    if n > 3:\n        i = random.randint(0, n - 2)\n        j = random.randint(0, n - 2)\n        while j == i or j == (i + 1) % n:\n            j = random.randint(0, n - 2)\n\n        # Remove edge between i and i+1\n        removed_node = new_solution[i + 1]\n        new_solution = np.concatenate([new_solution[:i + 1], new_solution[i + 2:]])\n\n        # Reinsert removed_node at position j\n        new_solution = np.concatenate([new_solution[:j + 1], [removed_node], new_solution[j + 1:]])\n\n    # Step 2: Partial 2-opt (swap a random segment of the tour)\n    if n > 4:\n        start = random.randint(0, n - 4)\n        end = random.randint(start + 2, n - 2)\n        new_solution[start:end + 1] = new_solution[start:end + 1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates and all nodes are visited)\n    assert len(new_solution) == len(base_solution), \"Solution length changed\"\n    assert len(np.unique(new_solution)) == len(base_solution), \"Duplicate nodes in solution\"\n\n    return new_solution\n\n",
        "score": [
            -0.7215206759998822,
            1.1463196873664856
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    # Here, we select a random solution from the top 20% of the archive based on a combined objective score\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    top_k = max(1, len(archive_sorted) // 5)\n    selected_idx = random.randint(0, top_k - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: Edge insertion + partial 2-opt\n    # Step 1: Edge insertion (remove a random edge and reinsert it in a different position)\n    if n > 3:\n        i = random.randint(0, n - 2)\n        j = random.randint(0, n - 2)\n        while j == i or j == (i + 1) % n:\n            j = random.randint(0, n - 2)\n\n        # Remove edge between i and i+1\n        removed_node = new_solution[i + 1]\n        new_solution = np.concatenate([new_solution[:i + 1], new_solution[i + 2:]])\n\n        # Reinsert removed_node at position j\n        new_solution = np.concatenate([new_solution[:j + 1], [removed_node], new_solution[j + 1:]])\n\n    # Step 2: Partial 2-opt (swap a random segment of the tour)\n    if n > 4:\n        start = random.randint(0, n - 4)\n        end = random.randint(start + 2, n - 2)\n        new_solution[start:end + 1] = new_solution[start:end + 1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates and all nodes are visited)\n    assert len(new_solution) == len(base_solution), \"Solution length changed\"\n    assert len(np.unique(new_solution)) == len(base_solution), \"Duplicate nodes in solution\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 288,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    total_costs = [sum(obj) for _, obj in archive]\n    if all(c == 0 for c in total_costs):\n        probs = [1.0 / len(archive)] * len(archive)\n    else:\n        inv_costs = [1.0 / (c + 1e-6) for c in total_costs]\n        total_inv = sum(inv_costs)\n        probs = [c / total_inv for c in inv_costs]\n\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a custom move based on distance matrices\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform a random 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Custom move: select a segment and reinsert it at a position that minimizes both distance matrices\n    if n > 3:\n        seg_len = random.randint(2, min(5, n-1))\n        seg_start = random.randint(0, n - seg_len)\n        segment = new_solution[seg_start:seg_start+seg_len]\n\n        # Find best insertion point\n        best_pos = seg_start\n        best_cost = float('inf')\n\n        for pos in range(0, n - seg_len + 1):\n            if pos == seg_start:\n                continue\n\n            # Create candidate solution\n            candidate = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_len:pos],\n                segment,\n                new_solution[pos:]\n            ])\n\n            # Calculate cost for both objectives\n            cost1 = sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        # Apply the best insertion\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_start+seg_len:best_pos],\n            segment,\n            new_solution[best_pos:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -0.7026182118963512,
            5.899425208568573
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    total_costs = [sum(obj) for _, obj in archive]\n    if all(c == 0 for c in total_costs):\n        probs = [1.0 / len(archive)] * len(archive)\n    else:\n        inv_costs = [1.0 / (c + 1e-6) for c in total_costs]\n        total_inv = sum(inv_costs)\n        probs = [c / total_inv for c in inv_costs]\n\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a custom move based on distance matrices\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform a random 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Custom move: select a segment and reinsert it at a position that minimizes both distance matrices\n    if n > 3:\n        seg_len = random.randint(2, min(5, n-1))\n        seg_start = random.randint(0, n - seg_len)\n        segment = new_solution[seg_start:seg_start+seg_len]\n\n        # Find best insertion point\n        best_pos = seg_start\n        best_cost = float('inf')\n\n        for pos in range(0, n - seg_len + 1):\n            if pos == seg_start:\n                continue\n\n            # Create candidate solution\n            candidate = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_len:pos],\n                segment,\n                new_solution[pos:]\n            ])\n\n            # Calculate cost for both objectives\n            cost1 = sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        # Apply the best insertion\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_start+seg_len:best_pos],\n            segment,\n            new_solution[best_pos:]\n        ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 289,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal)\n    # Here, we select a solution that is not the best in both objectives\n    non_dominated = [sol for sol, obj in archive if not all(obj[0] >= best_obj[0] and obj[1] >= best_obj[1] for _, best_obj in archive)]\n    if not non_dominated:\n        non_dominated = [sol for sol, _ in archive]\n    base_solution = random.choice(non_dominated).copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge insertion heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small instances\n\n    # Step 1: Randomly select 3 distinct nodes\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Step 2: Apply 3-opt local search\n    # Try all possible reconnections of the selected segment\n    for a, b, c in [(i, j, k), (i, k, j)]:\n        for x, y in [(a, b), (b, a)]:\n            # Create a new candidate solution\n            candidate = new_solution.copy()\n            candidate[x:y] = candidate[x:y][::-1]\n\n            # Evaluate the candidate\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n            # If the candidate is better in at least one objective, accept it\n            if (cost1 < sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]) or \\\n               (cost2 < sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]):\n                new_solution = candidate\n                break\n\n    # Step 3: Apply novel edge insertion heuristic\n    # Randomly select a node and try to insert it in a better position\n    node_to_move = random.randint(0, n-1)\n    current_node = new_solution[node_to_move]\n\n    # Remove the node from its current position\n    new_solution = np.concatenate([new_solution[:node_to_move], new_solution[node_to_move+1:]])\n\n    # Find the best insertion position for the removed node\n    best_pos = 0\n    best_cost1 = float('inf')\n    best_cost2 = float('inf')\n\n    for pos in range(n-1):\n        # Insert the node at position pos\n        candidate = np.insert(new_solution, pos, current_node)\n\n        # Calculate costs\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n        # Update best position if this candidate is better in at least one objective\n        if (cost1 < best_cost1) or (cost2 < best_cost2):\n            best_pos = pos\n            best_cost1 = cost1\n            best_cost2 = cost2\n\n    # Insert the node at the best position\n    new_solution = np.insert(new_solution, best_pos, current_node)\n\n    return new_solution\n\n",
        "score": [
            -0.8689615507490281,
            8.369035363197327
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal)\n    # Here, we select a solution that is not the best in both objectives\n    non_dominated = [sol for sol, obj in archive if not all(obj[0] >= best_obj[0] and obj[1] >= best_obj[1] for _, best_obj in archive)]\n    if not non_dominated:\n        non_dominated = [sol for sol, _ in archive]\n    base_solution = random.choice(non_dominated).copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge insertion heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small instances\n\n    # Step 1: Randomly select 3 distinct nodes\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Step 2: Apply 3-opt local search\n    # Try all possible reconnections of the selected segment\n    for a, b, c in [(i, j, k), (i, k, j)]:\n        for x, y in [(a, b), (b, a)]:\n            # Create a new candidate solution\n            candidate = new_solution.copy()\n            candidate[x:y] = candidate[x:y][::-1]\n\n            # Evaluate the candidate\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n            # If the candidate is better in at least one objective, accept it\n            if (cost1 < sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]) or \\\n               (cost2 < sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]):\n                new_solution = candidate\n                break\n\n    # Step 3: Apply novel edge insertion heuristic\n    # Randomly select a node and try to insert it in a better position\n    node_to_move = random.randint(0, n-1)\n    current_node = new_solution[node_to_move]\n\n    # Remove the node from its current position\n    new_solution = np.concatenate([new_solution[:node_to_move], new_solution[node_to_move+1:]])\n\n    # Find the best insertion position for the removed node\n    best_pos = 0\n    best_cost1 = float('inf')\n    best_cost2 = float('inf')\n\n    for pos in range(n-1):\n        # Insert the node at position pos\n        candidate = np.insert(new_solution, pos, current_node)\n\n        # Calculate costs\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n        # Update best position if this candidate is better in at least one objective\n        if (cost1 < best_cost1) or (cost2 < best_cost2):\n            best_pos = pos\n            best_cost1 = cost1\n            best_cost2 = cost2\n\n    # Insert the node at the best position\n    new_solution = np.insert(new_solution, best_pos, current_node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 290,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with better combined objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / np.max(objectives, axis=0)\n    combined_scores = np.sum(normalized_objectives, axis=1)\n    probabilities = combined_scores / np.sum(combined_scores)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: edge insertion + novel node swap\n    if random.random() < 0.7:  # 70% chance for edge insertion\n        # Select two random edges and perform an edge insertion\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(0, n-1)\n        if k < i or k > j:\n            # Perform edge insertion\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], segment[::-1], new_solution[j+1:]])\n    else:  # 30% chance for novel node swap\n        # Select three distinct nodes and perform a cyclic swap\n        a, b, c = random.sample(range(n), 3)\n        if a > b: a, b = b, a\n        if b > c: b, c = c, b\n        if a > b: a, b = b, a\n\n        # Perform cyclic swap: a -> b, b -> c, c -> a\n        temp = new_solution[a]\n        new_solution[a] = new_solution[b]\n        new_solution[b] = new_solution[c]\n        new_solution[c] = temp\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.7430657066499748,
            1.4885239005088806
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with better combined objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / np.max(objectives, axis=0)\n    combined_scores = np.sum(normalized_objectives, axis=1)\n    probabilities = combined_scores / np.sum(combined_scores)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: edge insertion + novel node swap\n    if random.random() < 0.7:  # 70% chance for edge insertion\n        # Select two random edges and perform an edge insertion\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(0, n-1)\n        if k < i or k > j:\n            # Perform edge insertion\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], segment[::-1], new_solution[j+1:]])\n    else:  # 30% chance for novel node swap\n        # Select three distinct nodes and perform a cyclic swap\n        a, b, c = random.sample(range(n), 3)\n        if a > b: a, b = b, a\n        if b > c: b, c = c, b\n        if a > b: a, b = b, a\n\n        # Perform cyclic swap: a -> b, b -> c, c -> a\n        temp = new_solution[a]\n        new_solution[a] = new_solution[b]\n        new_solution[b] = new_solution[c]\n        new_solution[c] = temp\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 291,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of segment reversal and node insertion\n    n = len(new_solution)\n    # Randomly select a segment to reverse\n    start, end = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select a node to reinsert\n    node_to_move = np.random.choice(new_solution)\n    mask = new_solution != node_to_move\n    remaining_solution = new_solution[mask]\n    insert_pos = np.random.randint(len(remaining_solution))\n    new_solution = np.insert(remaining_solution, insert_pos, node_to_move)\n\n    # Ensure the solution remains valid (no duplicates, all nodes present)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if the hybrid approach fails\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7982046249470867,
            1.0861509442329407
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of segment reversal and node insertion\n    n = len(new_solution)\n    # Randomly select a segment to reverse\n    start, end = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select a node to reinsert\n    node_to_move = np.random.choice(new_solution)\n    mask = new_solution != node_to_move\n    remaining_solution = new_solution[mask]\n    insert_pos = np.random.randint(len(remaining_solution))\n    new_solution = np.insert(remaining_solution, insert_pos, node_to_move)\n\n    # Ensure the solution remains valid (no duplicates, all nodes present)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if the hybrid approach fails\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 292,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest cost in either space)\n    selected_solution = min(archive, key=lambda x: min(x[1]))[0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge swap\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Step 1: Perform a 3-opt move on three randomly selected non-consecutive edges\n    i, j, k = sorted(random.sample(range(1, n-1), 3))\n    new_solution[i:j] = selected_solution[i:j][::-1]  # Reverse segment between i and j\n    new_solution[j:k] = selected_solution[j:k][::-1]  # Reverse segment between j and k\n\n    # Step 2: Perform a novel edge swap based on distance matrices\n    # Find the worst edge in the first objective space\n    max_dist_idx1 = np.argmax([distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)])\n    # Find the worst edge in the second objective space\n    max_dist_idx2 = np.argmax([distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)])\n\n    # Swap the nodes of the worst edges if they are different\n    if max_dist_idx1 != max_dist_idx2:\n        new_solution[max_dist_idx1], new_solution[max_dist_idx2] = new_solution[max_dist_idx2], new_solution[max_dist_idx1]\n\n    # Ensure the solution is still valid\n    assert len(set(new_solution)) == len(selected_solution), \"Invalid solution generated\"\n    assert len(new_solution) == len(selected_solution), \"Solution length changed\"\n\n    return new_solution\n\n",
        "score": [
            -0.3655457477760618,
            1.5446898937225342
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest cost in either space)\n    selected_solution = min(archive, key=lambda x: min(x[1]))[0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge swap\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Step 1: Perform a 3-opt move on three randomly selected non-consecutive edges\n    i, j, k = sorted(random.sample(range(1, n-1), 3))\n    new_solution[i:j] = selected_solution[i:j][::-1]  # Reverse segment between i and j\n    new_solution[j:k] = selected_solution[j:k][::-1]  # Reverse segment between j and k\n\n    # Step 2: Perform a novel edge swap based on distance matrices\n    # Find the worst edge in the first objective space\n    max_dist_idx1 = np.argmax([distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)])\n    # Find the worst edge in the second objective space\n    max_dist_idx2 = np.argmax([distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)])\n\n    # Swap the nodes of the worst edges if they are different\n    if max_dist_idx1 != max_dist_idx2:\n        new_solution[max_dist_idx1], new_solution[max_dist_idx2] = new_solution[max_dist_idx2], new_solution[max_dist_idx1]\n\n    # Ensure the solution is still valid\n    assert len(set(new_solution)) == len(selected_solution), \"Invalid solution generated\"\n    assert len(new_solution) == len(selected_solution), \"Solution length changed\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 293,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a bias towards solutions with lower combined cost\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = objectives / np.max(objectives, axis=0)\n    combined_costs = np.sum(normalized_costs, axis=1)\n    probabilities = 1 / (combined_costs + 1e-6)  # Add small epsilon to avoid division by zero\n    probabilities = probabilities / np.sum(probabilities)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Edge insertion with biased random selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to break and reconnect\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Extract the segments to be reconnected\n    segment1 = new_solution[i:j+1]\n    segment2 = np.concatenate([new_solution[:i], new_solution[j+1:]])\n\n    # Reconnect with a bias towards shorter edges in either objective space\n    # Calculate potential edge costs for reconnection\n    if len(segment1) > 1 and len(segment2) > 0:\n        # Try to reconnect with a node from segment2 that forms short edges in either space\n        best_insert_pos = None\n        best_cost = float('inf')\n\n        for k in range(len(segment2)):\n            # Try inserting segment1 after k in segment2\n            candidate = np.concatenate([segment2[:k+1], segment1, segment2[k+1:]])\n            cost1 = sum(distance_matrix_1[candidate[l], candidate[l+1]] for l in range(len(candidate)-1))\n            cost2 = sum(distance_matrix_2[candidate[l], candidate[l+1]] for l in range(len(candidate)-1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_insert_pos = k\n\n        if best_insert_pos is not None:\n            new_solution = np.concatenate([segment2[:best_insert_pos+1], segment1, segment2[best_insert_pos+1:]])\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == n\n    assert len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.7470110586981284,
            5.711815178394318
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a bias towards solutions with lower combined cost\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = objectives / np.max(objectives, axis=0)\n    combined_costs = np.sum(normalized_costs, axis=1)\n    probabilities = 1 / (combined_costs + 1e-6)  # Add small epsilon to avoid division by zero\n    probabilities = probabilities / np.sum(probabilities)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Edge insertion with biased random selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to break and reconnect\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Extract the segments to be reconnected\n    segment1 = new_solution[i:j+1]\n    segment2 = np.concatenate([new_solution[:i], new_solution[j+1:]])\n\n    # Reconnect with a bias towards shorter edges in either objective space\n    # Calculate potential edge costs for reconnection\n    if len(segment1) > 1 and len(segment2) > 0:\n        # Try to reconnect with a node from segment2 that forms short edges in either space\n        best_insert_pos = None\n        best_cost = float('inf')\n\n        for k in range(len(segment2)):\n            # Try inserting segment1 after k in segment2\n            candidate = np.concatenate([segment2[:k+1], segment1, segment2[k+1:]])\n            cost1 = sum(distance_matrix_1[candidate[l], candidate[l+1]] for l in range(len(candidate)-1))\n            cost2 = sum(distance_matrix_2[candidate[l], candidate[l+1]] for l in range(len(candidate)-1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_insert_pos = k\n\n        if best_insert_pos is not None:\n            new_solution = np.concatenate([segment2[:best_insert_pos+1], segment1, segment2[best_insert_pos+1:]])\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == n\n    assert len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 294,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a novel edge-swap strategy\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two random edges\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # For larger instances, perform a 3-opt like operation\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n        # Additional edge-swap based on objective improvement potential\n        # Evaluate the change in both objectives\n        old_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n        old_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n        # Randomly select a pair of edges to swap\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Check if the swap improves at least one objective\n        new_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n        if not (new_cost1 < old_cost1 or new_cost2 < old_cost2):\n            # Revert if no improvement\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9309015322951092,
            1.5834306478500366
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a novel edge-swap strategy\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two random edges\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # For larger instances, perform a 3-opt like operation\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n        # Additional edge-swap based on objective improvement potential\n        # Evaluate the change in both objectives\n        old_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n        old_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n        # Randomly select a pair of edges to swap\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Check if the swap improves at least one objective\n        new_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n        if not (new_cost1 < old_cost1 or new_cost2 < old_cost2):\n            # Revert if no improvement\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 295,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability weighted by its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement scores (inverse of current cost)\n    scores = [1.0 / (obj[0] + obj[1] + 1e-6) for obj in objectives]\n    total_score = sum(scores)\n    probabilities = [score / total_score for score in scores]\n\n    # Select a solution based on weighted random choice\n    selected_idx = random.choices(range(len(solutions)), weights=probabilities, k=1)[0]\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search strategy: combination of segment inversion and edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Apply segment inversion\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply edge exchange if it improves the solution\n    if random.random() < 0.5:  # 50% chance to apply edge exchange\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j:\n            # Swap edges (i, i+1) and (j, j+1)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7542550229654634,
            1.5485116839408875
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability weighted by its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement scores (inverse of current cost)\n    scores = [1.0 / (obj[0] + obj[1] + 1e-6) for obj in objectives]\n    total_score = sum(scores)\n    probabilities = [score / total_score for score in scores]\n\n    # Select a solution based on weighted random choice\n    selected_idx = random.choices(range(len(solutions)), weights=probabilities, k=1)[0]\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search strategy: combination of segment inversion and edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Apply segment inversion\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply edge exchange if it improves the solution\n    if random.random() < 0.5:  # 50% chance to apply edge exchange\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j:\n            # Swap edges (i, i+1) and (j, j+1)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 296,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the best solution in the archive (non-dominated or highest quality)\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))  # Simple sum for selection, can be replaced with Pareto dominance\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, perform a simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Edge insertion with node relocation\n    for _ in range(2):  # Number of iterations can be adjusted\n        # Randomly select a segment to relocate\n        start = np.random.randint(0, n-2)\n        end = np.random.randint(start+2, n)\n\n        # Extract the segment\n        segment = new_solution[start:end]\n        remaining = np.concatenate([new_solution[:start], new_solution[end:]])\n\n        # Find the best insertion point for the segment\n        best_cost = float('inf')\n        best_pos = 0\n        for i in range(len(remaining)):\n            # Insert segment after position i\n            candidate = np.concatenate([remaining[:i], segment, remaining[i:]])\n            cost1 = sum(distance_matrix_1[candidate[k-1], candidate[k]] for k in range(len(candidate)))\n            cost2 = sum(distance_matrix_2[candidate[k-1], candidate[k]] for k in range(len(candidate)))\n            total_cost = cost1 + cost2  # Can be replaced with a more sophisticated Pareto comparison\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the segment at the best position\n        new_solution = np.concatenate([remaining[:best_pos], segment, remaining[best_pos:]])\n\n        # Node relocation within the segment\n        if len(segment) > 1:\n            # Randomly select a node to relocate within the segment\n            node_idx = np.random.randint(0, len(segment))\n            node = segment[node_idx]\n\n            # Find the best position to reinsert the node\n            best_reloc_cost = float('inf')\n            best_reloc_pos = 0\n            for i in range(len(remaining)):\n                # Insert node after position i\n                candidate = np.concatenate([remaining[:i], [node], remaining[i:]])\n                cost1 = sum(distance_matrix_1[candidate[k-1], candidate[k]] for k in range(len(candidate)))\n                cost2 = sum(distance_matrix_2[candidate[k-1], candidate[k]] for k in range(len(candidate)))\n                total_cost = cost1 + cost2\n\n                if total_cost < best_reloc_cost:\n                    best_reloc_cost = total_cost\n                    best_reloc_pos = i\n\n            # Insert the node at the best position\n            new_solution = np.concatenate([remaining[:best_reloc_pos], [node], remaining[best_reloc_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9393518043306105,
            10.837984085083008
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the best solution in the archive (non-dominated or highest quality)\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))  # Simple sum for selection, can be replaced with Pareto dominance\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, perform a simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Edge insertion with node relocation\n    for _ in range(2):  # Number of iterations can be adjusted\n        # Randomly select a segment to relocate\n        start = np.random.randint(0, n-2)\n        end = np.random.randint(start+2, n)\n\n        # Extract the segment\n        segment = new_solution[start:end]\n        remaining = np.concatenate([new_solution[:start], new_solution[end:]])\n\n        # Find the best insertion point for the segment\n        best_cost = float('inf')\n        best_pos = 0\n        for i in range(len(remaining)):\n            # Insert segment after position i\n            candidate = np.concatenate([remaining[:i], segment, remaining[i:]])\n            cost1 = sum(distance_matrix_1[candidate[k-1], candidate[k]] for k in range(len(candidate)))\n            cost2 = sum(distance_matrix_2[candidate[k-1], candidate[k]] for k in range(len(candidate)))\n            total_cost = cost1 + cost2  # Can be replaced with a more sophisticated Pareto comparison\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the segment at the best position\n        new_solution = np.concatenate([remaining[:best_pos], segment, remaining[best_pos:]])\n\n        # Node relocation within the segment\n        if len(segment) > 1:\n            # Randomly select a node to relocate within the segment\n            node_idx = np.random.randint(0, len(segment))\n            node = segment[node_idx]\n\n            # Find the best position to reinsert the node\n            best_reloc_cost = float('inf')\n            best_reloc_pos = 0\n            for i in range(len(remaining)):\n                # Insert node after position i\n                candidate = np.concatenate([remaining[:i], [node], remaining[i:]])\n                cost1 = sum(distance_matrix_1[candidate[k-1], candidate[k]] for k in range(len(candidate)))\n                cost2 = sum(distance_matrix_2[candidate[k-1], candidate[k]] for k in range(len(candidate)))\n                total_cost = cost1 + cost2\n\n                if total_cost < best_reloc_cost:\n                    best_reloc_cost = total_cost\n                    best_reloc_pos = i\n\n            # Insert the node at the best position\n            new_solution = np.concatenate([remaining[:best_reloc_pos], [node], remaining[best_reloc_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 297,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., random selection biased towards non-dominated solutions)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of edge exchange and segment reversal\n    n = len(base_solution)\n    a, b, c, d = sorted(random.sample(range(n), 4))\n\n    # Edge exchange (similar to 2-opt but more flexible)\n    new_solution[a:b] = base_solution[a:b][::-1]\n    new_solution[c:d] = base_solution[c:d][::-1]\n\n    # Segment reversal with objective-aware selection\n    if random.random() < 0.5:  # 50% chance to apply segment reversal\n        segment = base_solution[a:b].copy()\n        if random.random() < 0.5:  # 50% chance to reverse the segment\n            segment = segment[::-1]\n        new_solution[a:b] = segment\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Revert to base if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.8287233626590813,
            1.2658886313438416
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., random selection biased towards non-dominated solutions)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of edge exchange and segment reversal\n    n = len(base_solution)\n    a, b, c, d = sorted(random.sample(range(n), 4))\n\n    # Edge exchange (similar to 2-opt but more flexible)\n    new_solution[a:b] = base_solution[a:b][::-1]\n    new_solution[c:d] = base_solution[c:d][::-1]\n\n    # Segment reversal with objective-aware selection\n    if random.random() < 0.5:  # 50% chance to apply segment reversal\n        segment = base_solution[a:b].copy()\n        if random.random() < 0.5:  # 50% chance to reverse the segment\n            segment = segment[::-1]\n        new_solution[a:b] = segment\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Revert to base if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 298,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate potential improvement score for each solution\n    scores = []\n    for sol, obj in archive:\n        # Potential improvement is inversely proportional to current objective values\n        # and proportional to the variance in the solution's tour\n        tour_length_1 = sum(distance_matrix_1[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n        tour_length_2 = sum(distance_matrix_2[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n        variance = np.var(sol)\n        score = (1 / (obj[0] + obj[1])) * variance\n        scores.append(score)\n\n    # Normalize scores to get probabilities\n    total_score = sum(scores)\n    if total_score == 0:\n        probabilities = [1.0 / len(archive)] * len(archive)\n    else:\n        probabilities = [score / total_score for score in scores]\n\n    # Select a solution based on the calculated probabilities\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combination of edge exchange and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge exchange (like 2-opt but more flexible)\n    i, j = sorted(random.sample(range(n), 2))\n    if j - i > 1:\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Swap nodes if segment is too small for reversal\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Additional segment rotation to further explore the neighborhood\n    if n > 3:\n        k = random.randint(1, n-2)\n        new_solution = np.roll(new_solution, k)\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9140263058600586,
            4.62427294254303
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate potential improvement score for each solution\n    scores = []\n    for sol, obj in archive:\n        # Potential improvement is inversely proportional to current objective values\n        # and proportional to the variance in the solution's tour\n        tour_length_1 = sum(distance_matrix_1[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n        tour_length_2 = sum(distance_matrix_2[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n        variance = np.var(sol)\n        score = (1 / (obj[0] + obj[1])) * variance\n        scores.append(score)\n\n    # Normalize scores to get probabilities\n    total_score = sum(scores)\n    if total_score == 0:\n        probabilities = [1.0 / len(archive)] * len(archive)\n    else:\n        probabilities = [score / total_score for score in scores]\n\n    # Select a solution based on the calculated probabilities\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combination of edge exchange and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge exchange (like 2-opt but more flexible)\n    i, j = sorted(random.sample(range(n), 2))\n    if j - i > 1:\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Swap nodes if segment is too small for reversal\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Additional segment rotation to further explore the neighborhood\n    if n > 3:\n        k = random.randint(1, n-2)\n        new_solution = np.roll(new_solution, k)\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 299,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine edge exchange and partial reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operators\n\n    # Step 1: Randomly select a segment to reverse\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Apply edge exchange between two random edges\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n    if a != c and b != d:\n        # Ensure the exchange maintains feasibility\n        temp = new_solution[a]\n        new_solution[a] = new_solution[c]\n        new_solution[c] = temp\n\n        temp = new_solution[b]\n        new_solution[b] = new_solution[d]\n        new_solution[d] = temp\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.unique(new_solution), np.unique(base_solution)):\n        raise ValueError(\"Generated solution is invalid\")\n\n    return new_solution\n\n",
        "score": [
            -0.8653571566286438,
            1.1858727931976318
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine edge exchange and partial reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operators\n\n    # Step 1: Randomly select a segment to reverse\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Apply edge exchange between two random edges\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n    if a != c and b != d:\n        # Ensure the exchange maintains feasibility\n        temp = new_solution[a]\n        new_solution[a] = new_solution[c]\n        new_solution[c] = temp\n\n        temp = new_solution[b]\n        new_solution[b] = new_solution[d]\n        new_solution[d] = temp\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.unique(new_solution), np.unique(base_solution)):\n        raise ValueError(\"Generated solution is invalid\")\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 300,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_solution = None\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if other_sol is sol:\n                continue\n            if other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            selected_solution = sol.copy()\n            break\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel edge-swap operator\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Perform a random 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply a novel edge-swap operator: swap edges between two random nodes\n    if n > 2:\n        a, b = sorted(random.sample(range(n), 2))\n        if b - a > 1:\n            # Swap edges (a,a+1) and (b,b+1) with (a,b) and (a+1,b+1)\n            new_solution[a+1:b] = new_solution[a+1:b][::-1]\n\n    # Ensure the solution remains feasible\n    if not np.array_equal(np.unique(new_solution), np.arange(len(new_solution))):\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.773956482120008,
            1.3528851866722107
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_solution = None\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if other_sol is sol:\n                continue\n            if other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            selected_solution = sol.copy()\n            break\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel edge-swap operator\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Perform a random 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply a novel edge-swap operator: swap edges between two random nodes\n    if n > 2:\n        a, b = sorted(random.sample(range(n), 2))\n        if b - a > 1:\n            # Swap edges (a,a+1) and (b,b+1) with (a,b) and (a+1,b+1)\n            new_solution[a+1:b] = new_solution[a+1:b][::-1]\n\n    # Ensure the solution remains feasible\n    if not np.array_equal(np.unique(new_solution), np.arange(len(new_solution))):\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    }
]