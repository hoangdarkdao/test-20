[
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 1,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    best_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    base_solution = best_solution.copy()\n\n    # Hybrid local search: combine edge exchange with random segment reversal\n    new_solution = base_solution.copy()\n\n    # Edge exchange (swap two non-adjacent edges)\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    if j - i > 1:  # Ensure edges are not adjacent\n        # Swap edges (i, i+1) and (j, j+1)\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n    # Random segment reversal for diversification\n    if random.random() < 0.3:  # 30% chance to apply\n        start, end = sorted(random.sample(range(n), 2))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != len(base_solution):\n        # If invalid, fall back to a simple 2-opt move\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8450872724551959,
            2.3654507398605347
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    best_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    base_solution = best_solution.copy()\n\n    # Hybrid local search: combine edge exchange with random segment reversal\n    new_solution = base_solution.copy()\n\n    # Edge exchange (swap two non-adjacent edges)\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    if j - i > 1:  # Ensure edges are not adjacent\n        # Swap edges (i, i+1) and (j, j+1)\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n    # Random segment reversal for diversification\n    if random.random() < 0.3:  # 30% chance to apply\n        start, end = sorted(random.sample(range(n), 2))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != len(base_solution):\n        # If invalid, fall back to a simple 2-opt move\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 1,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    best_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    base_solution = best_solution.copy()\n\n    # Hybrid local search: combine edge exchange with random segment reversal\n    new_solution = base_solution.copy()\n\n    # Edge exchange (swap two non-adjacent edges)\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    if j - i > 1:  # Ensure edges are not adjacent\n        # Swap edges (i, i+1) and (j, j+1)\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n    # Random segment reversal for diversification\n    if random.random() < 0.3:  # 30% chance to apply\n        start, end = sorted(random.sample(range(n), 2))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != len(base_solution):\n        # If invalid, fall back to a simple 2-opt move\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8450872724551959,
            2.3654507398605347
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    best_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    base_solution = best_solution.copy()\n\n    # Hybrid local search: combine edge exchange with random segment reversal\n    new_solution = base_solution.copy()\n\n    # Edge exchange (swap two non-adjacent edges)\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    if j - i > 1:  # Ensure edges are not adjacent\n        # Swap edges (i, i+1) and (j, j+1)\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n    # Random segment reversal for diversification\n    if random.random() < 0.3:  # 30% chance to apply\n        start, end = sorted(random.sample(range(n), 2))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != len(base_solution):\n        # If invalid, fall back to a simple 2-opt move\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 1,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    best_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    base_solution = best_solution.copy()\n\n    # Hybrid local search: combine edge exchange with random segment reversal\n    new_solution = base_solution.copy()\n\n    # Edge exchange (swap two non-adjacent edges)\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    if j - i > 1:  # Ensure edges are not adjacent\n        # Swap edges (i, i+1) and (j, j+1)\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n    # Random segment reversal for diversification\n    if random.random() < 0.3:  # 30% chance to apply\n        start, end = sorted(random.sample(range(n), 2))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != len(base_solution):\n        # If invalid, fall back to a simple 2-opt move\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8450872724551959,
            2.3654507398605347
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    best_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    base_solution = best_solution.copy()\n\n    # Hybrid local search: combine edge exchange with random segment reversal\n    new_solution = base_solution.copy()\n\n    # Edge exchange (swap two non-adjacent edges)\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    if j - i > 1:  # Ensure edges are not adjacent\n        # Swap edges (i, i+1) and (j, j+1)\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n    # Random segment reversal for diversification\n    if random.random() < 0.3:  # 30% chance to apply\n        start, end = sorted(random.sample(range(n), 2))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != len(base_solution):\n        # If invalid, fall back to a simple 2-opt move\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 2,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on the Pareto dominance and diversity\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel edge insertion strategy\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful changes\n\n    # Step 1: Randomly select a segment to modify\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Step 2: Reverse the segment (2-opt like move)\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Novel edge insertion strategy\n    if b - a > 1:\n        # Remove a random edge within the segment and reinsert it elsewhere\n        c = random.randint(a + 1, b - 1)\n        node_to_insert = new_solution[c]\n        new_solution = np.delete(new_solution, c)\n\n        # Find the best insertion point for the removed node\n        best_pos = a\n        best_score = float('inf')\n\n        for pos in range(a, b):\n            if pos == c:\n                continue\n            # Calculate the change in both objectives\n            before_node = new_solution[pos - 1] if pos > 0 else new_solution[-1]\n            after_node = new_solution[pos]\n\n            original_cost = distance_matrix_1[before_node, after_node] + distance_matrix_2[before_node, after_node]\n            new_cost = (distance_matrix_1[before_node, node_to_insert] + distance_matrix_1[node_to_insert, after_node] +\n                        distance_matrix_2[before_node, node_to_insert] + distance_matrix_2[node_to_insert, after_node])\n\n            if new_cost < best_score:\n                best_score = new_cost\n                best_pos = pos\n\n        # Insert the node at the best position\n        new_solution = np.insert(new_solution, best_pos, node_to_insert)\n\n    return new_solution\n\n",
        "score": [
            -0.8351271896093726,
            2.566512703895569
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on the Pareto dominance and diversity\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel edge insertion strategy\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful changes\n\n    # Step 1: Randomly select a segment to modify\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Step 2: Reverse the segment (2-opt like move)\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Novel edge insertion strategy\n    if b - a > 1:\n        # Remove a random edge within the segment and reinsert it elsewhere\n        c = random.randint(a + 1, b - 1)\n        node_to_insert = new_solution[c]\n        new_solution = np.delete(new_solution, c)\n\n        # Find the best insertion point for the removed node\n        best_pos = a\n        best_score = float('inf')\n\n        for pos in range(a, b):\n            if pos == c:\n                continue\n            # Calculate the change in both objectives\n            before_node = new_solution[pos - 1] if pos > 0 else new_solution[-1]\n            after_node = new_solution[pos]\n\n            original_cost = distance_matrix_1[before_node, after_node] + distance_matrix_2[before_node, after_node]\n            new_cost = (distance_matrix_1[before_node, node_to_insert] + distance_matrix_1[node_to_insert, after_node] +\n                        distance_matrix_2[before_node, node_to_insert] + distance_matrix_2[node_to_insert, after_node])\n\n            if new_cost < best_score:\n                best_score = new_cost\n                best_pos = pos\n\n        # Insert the node at the best position\n        new_solution = np.insert(new_solution, best_pos, node_to_insert)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 3,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = best_solution.copy()\n\n    # Apply a hybrid local search operator: 3-opt with objective-aware edge selection\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), size=3, replace=False))\n\n    # Create a new candidate by reversing segments between selected points\n    candidate = new_solution.copy()\n    candidate[i:j+1] = np.flip(candidate[i:j+1])\n    candidate[j:k+1] = np.flip(candidate[j:k+1])\n\n    # Evaluate the candidate's quality in both objectives\n    def calculate_cost(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n        cost2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n        return (cost1, cost2)\n\n    candidate_cost = calculate_cost(candidate)\n    original_cost = calculate_cost(new_solution)\n\n    # Accept the candidate if it improves at least one objective\n    if candidate_cost[0] < original_cost[0] or candidate_cost[1] < original_cost[1]:\n        new_solution = candidate\n\n    # Apply a second improvement: objective-aware edge swap\n    for _ in range(10):  # Limit iterations to maintain efficiency\n        a, b = np.random.choice(range(n), size=2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Swap edges a\u2192b and a\u2192(a+1) with b\u2192(a+1) and b\u2192a\n        candidate = new_solution.copy()\n        candidate[a] = new_solution[b]\n        candidate[b] = new_solution[a]\n\n        candidate_cost = calculate_cost(candidate)\n        if candidate_cost[0] < original_cost[0] or candidate_cost[1] < original_cost[1]:\n            new_solution = candidate\n            original_cost = candidate_cost\n\n    return new_solution\n\n",
        "score": [
            -0.8867070470817192,
            5.612837374210358
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = best_solution.copy()\n\n    # Apply a hybrid local search operator: 3-opt with objective-aware edge selection\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), size=3, replace=False))\n\n    # Create a new candidate by reversing segments between selected points\n    candidate = new_solution.copy()\n    candidate[i:j+1] = np.flip(candidate[i:j+1])\n    candidate[j:k+1] = np.flip(candidate[j:k+1])\n\n    # Evaluate the candidate's quality in both objectives\n    def calculate_cost(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n        cost2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n        return (cost1, cost2)\n\n    candidate_cost = calculate_cost(candidate)\n    original_cost = calculate_cost(new_solution)\n\n    # Accept the candidate if it improves at least one objective\n    if candidate_cost[0] < original_cost[0] or candidate_cost[1] < original_cost[1]:\n        new_solution = candidate\n\n    # Apply a second improvement: objective-aware edge swap\n    for _ in range(10):  # Limit iterations to maintain efficiency\n        a, b = np.random.choice(range(n), size=2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Swap edges a\u2192b and a\u2192(a+1) with b\u2192(a+1) and b\u2192a\n        candidate = new_solution.copy()\n        candidate[a] = new_solution[b]\n        candidate[b] = new_solution[a]\n\n        candidate_cost = calculate_cost(candidate)\n        if candidate_cost[0] < original_cost[0] or candidate_cost[1] < original_cost[1]:\n            new_solution = candidate\n            original_cost = candidate_cost\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 3,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = best_solution.copy()\n\n    # Apply a hybrid local search operator: 3-opt with objective-aware edge selection\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), size=3, replace=False))\n\n    # Create a new candidate by reversing segments between selected points\n    candidate = new_solution.copy()\n    candidate[i:j+1] = np.flip(candidate[i:j+1])\n    candidate[j:k+1] = np.flip(candidate[j:k+1])\n\n    # Evaluate the candidate's quality in both objectives\n    def calculate_cost(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n        cost2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n        return (cost1, cost2)\n\n    candidate_cost = calculate_cost(candidate)\n    original_cost = calculate_cost(new_solution)\n\n    # Accept the candidate if it improves at least one objective\n    if candidate_cost[0] < original_cost[0] or candidate_cost[1] < original_cost[1]:\n        new_solution = candidate\n\n    # Apply a second improvement: objective-aware edge swap\n    for _ in range(10):  # Limit iterations to maintain efficiency\n        a, b = np.random.choice(range(n), size=2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Swap edges a\u2192b and a\u2192(a+1) with b\u2192(a+1) and b\u2192a\n        candidate = new_solution.copy()\n        candidate[a] = new_solution[b]\n        candidate[b] = new_solution[a]\n\n        candidate_cost = calculate_cost(candidate)\n        if candidate_cost[0] < original_cost[0] or candidate_cost[1] < original_cost[1]:\n            new_solution = candidate\n            original_cost = candidate_cost\n\n    return new_solution\n\n",
        "score": [
            -0.8867070470817192,
            5.612837374210358
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = best_solution.copy()\n\n    # Apply a hybrid local search operator: 3-opt with objective-aware edge selection\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), size=3, replace=False))\n\n    # Create a new candidate by reversing segments between selected points\n    candidate = new_solution.copy()\n    candidate[i:j+1] = np.flip(candidate[i:j+1])\n    candidate[j:k+1] = np.flip(candidate[j:k+1])\n\n    # Evaluate the candidate's quality in both objectives\n    def calculate_cost(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n        cost2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n        return (cost1, cost2)\n\n    candidate_cost = calculate_cost(candidate)\n    original_cost = calculate_cost(new_solution)\n\n    # Accept the candidate if it improves at least one objective\n    if candidate_cost[0] < original_cost[0] or candidate_cost[1] < original_cost[1]:\n        new_solution = candidate\n\n    # Apply a second improvement: objective-aware edge swap\n    for _ in range(10):  # Limit iterations to maintain efficiency\n        a, b = np.random.choice(range(n), size=2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Swap edges a\u2192b and a\u2192(a+1) with b\u2192(a+1) and b\u2192a\n        candidate = new_solution.copy()\n        candidate[a] = new_solution[b]\n        candidate[b] = new_solution[a]\n\n        candidate_cost = calculate_cost(candidate)\n        if candidate_cost[0] < original_cost[0] or candidate_cost[1] < original_cost[1]:\n            new_solution = candidate\n            original_cost = candidate_cost\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 4,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability of being non-dominated or having high diversity\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1 / (1 + obj[0] + obj[1]) for _, obj in archive],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    operator = random.choice(['edge_insertion', 'node_swap', 'segment_reversal'])\n\n    if operator == 'edge_insertion':\n        # Randomly select two edges and insert one between the other\n        i, j = sorted(random.sample(range(n), 2))\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    elif operator == 'node_swap':\n        # Swap two randomly selected nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    elif operator == 'segment_reversal':\n        # Reverse a randomly selected segment\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    assert len(set(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.8888335939140918,
            1.9604671597480774
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability of being non-dominated or having high diversity\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1 / (1 + obj[0] + obj[1]) for _, obj in archive],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    operator = random.choice(['edge_insertion', 'node_swap', 'segment_reversal'])\n\n    if operator == 'edge_insertion':\n        # Randomly select two edges and insert one between the other\n        i, j = sorted(random.sample(range(n), 2))\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    elif operator == 'node_swap':\n        # Swap two randomly selected nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    elif operator == 'segment_reversal':\n        # Reverse a randomly selected segment\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    assert len(set(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 4,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability of being non-dominated or having high diversity\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1 / (1 + obj[0] + obj[1]) for _, obj in archive],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    operator = random.choice(['edge_insertion', 'node_swap', 'segment_reversal'])\n\n    if operator == 'edge_insertion':\n        # Randomly select two edges and insert one between the other\n        i, j = sorted(random.sample(range(n), 2))\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    elif operator == 'node_swap':\n        # Swap two randomly selected nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    elif operator == 'segment_reversal':\n        # Reverse a randomly selected segment\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    assert len(set(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.8888335939140918,
            1.9604671597480774
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability of being non-dominated or having high diversity\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1 / (1 + obj[0] + obj[1]) for _, obj in archive],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    operator = random.choice(['edge_insertion', 'node_swap', 'segment_reversal'])\n\n    if operator == 'edge_insertion':\n        # Randomly select two edges and insert one between the other\n        i, j = sorted(random.sample(range(n), 2))\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    elif operator == 'node_swap':\n        # Swap two randomly selected nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    elif operator == 'segment_reversal':\n        # Reverse a randomly selected segment\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    assert len(set(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 4,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability of being non-dominated or having high diversity\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1 / (1 + obj[0] + obj[1]) for _, obj in archive],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    operator = random.choice(['edge_insertion', 'node_swap', 'segment_reversal'])\n\n    if operator == 'edge_insertion':\n        # Randomly select two edges and insert one between the other\n        i, j = sorted(random.sample(range(n), 2))\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    elif operator == 'node_swap':\n        # Swap two randomly selected nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    elif operator == 'segment_reversal':\n        # Reverse a randomly selected segment\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    assert len(set(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.8888335939140918,
            1.9604671597480774
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability of being non-dominated or having high diversity\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1 / (1 + obj[0] + obj[1]) for _, obj in archive],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    operator = random.choice(['edge_insertion', 'node_swap', 'segment_reversal'])\n\n    if operator == 'edge_insertion':\n        # Randomly select two edges and insert one between the other\n        i, j = sorted(random.sample(range(n), 2))\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    elif operator == 'node_swap':\n        # Swap two randomly selected nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    elif operator == 'segment_reversal':\n        # Reverse a randomly selected segment\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    assert len(set(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 5,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (lower is better)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select from the top 30% of solutions\n        top_solutions = archive_sorted[:max(1, len(archive) // 3)]\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel segment reversal\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # 3-opt: select three random edges and reconnect them in all possible ways\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        segment3 = np.concatenate([new_solution[c:], new_solution[:a]])\n\n        # Try all 8 possible 3-opt reconnections\n        candidates = [\n            np.concatenate([segment1, segment2[::-1], segment3]),  # Reverse middle segment\n            np.concatenate([segment1[::-1], segment2, segment3]),  # Reverse first segment\n            np.concatenate([segment1, segment2, segment3[::-1]]),  # Reverse last segment\n            np.concatenate([segment1[::-1], segment2[::-1], segment3]),  # Reverse first and middle\n            np.concatenate([segment1, segment2[::-1], segment3[::-1]]),  # Reverse middle and last\n            np.concatenate([segment1[::-1], segment2, segment3[::-1]]),  # Reverse first and last\n            np.concatenate([segment1[::-1], segment2[::-1], segment3[::-1]]),  # Reverse all three\n            np.concatenate([segment2, segment1, segment3]),  # Swap first and middle\n            np.concatenate([segment2, segment3, segment1])  # Rotate segments\n        ]\n\n        # Evaluate all candidates based on both objectives\n        best_candidate = new_solution.copy()\n        best_cost = (float('inf'), float('inf'))\n\n        for candidate in candidates:\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n            if (cost1, cost2) < best_cost:\n                best_cost = (cost1, cost2)\n                best_candidate = candidate.copy()\n\n        # If no improvement, try a novel segment reversal\n        if best_cost == (float('inf'), float('inf')):\n            # Reverse a random segment of size between 2 and n//2\n            seg_size = random.randint(2, n // 2)\n            start = random.randint(0, n - seg_size)\n            new_solution[start:start+seg_size] = new_solution[start+seg_size-1:start-1:-1]\n        else:\n            new_solution = best_candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7106376008550392,
            3.941749393939972
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (lower is better)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select from the top 30% of solutions\n        top_solutions = archive_sorted[:max(1, len(archive) // 3)]\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel segment reversal\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # 3-opt: select three random edges and reconnect them in all possible ways\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        segment3 = np.concatenate([new_solution[c:], new_solution[:a]])\n\n        # Try all 8 possible 3-opt reconnections\n        candidates = [\n            np.concatenate([segment1, segment2[::-1], segment3]),  # Reverse middle segment\n            np.concatenate([segment1[::-1], segment2, segment3]),  # Reverse first segment\n            np.concatenate([segment1, segment2, segment3[::-1]]),  # Reverse last segment\n            np.concatenate([segment1[::-1], segment2[::-1], segment3]),  # Reverse first and middle\n            np.concatenate([segment1, segment2[::-1], segment3[::-1]]),  # Reverse middle and last\n            np.concatenate([segment1[::-1], segment2, segment3[::-1]]),  # Reverse first and last\n            np.concatenate([segment1[::-1], segment2[::-1], segment3[::-1]]),  # Reverse all three\n            np.concatenate([segment2, segment1, segment3]),  # Swap first and middle\n            np.concatenate([segment2, segment3, segment1])  # Rotate segments\n        ]\n\n        # Evaluate all candidates based on both objectives\n        best_candidate = new_solution.copy()\n        best_cost = (float('inf'), float('inf'))\n\n        for candidate in candidates:\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n            if (cost1, cost2) < best_cost:\n                best_cost = (cost1, cost2)\n                best_candidate = candidate.copy()\n\n        # If no improvement, try a novel segment reversal\n        if best_cost == (float('inf'), float('inf')):\n            # Reverse a random segment of size between 2 and n//2\n            seg_size = random.randint(2, n // 2)\n            start = random.randint(0, n - seg_size)\n            new_solution[start:start+seg_size] = new_solution[start+seg_size-1:start-1:-1]\n        else:\n            new_solution = best_candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 6,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with lower variance in objectives to ensure balanced improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n    variances = [np.var(obj) for obj in objectives]\n\n    # Select top 30% solutions with the lowest variance\n    percentile = np.percentile(variances, 30)\n    candidates = [sol for sol, var in zip(solutions, variances) if var <= percentile]\n\n    if not candidates:\n        candidates = solutions  # Fallback to all solutions if no candidates found\n\n    base_solution = random.choice(candidates).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with a biased random walk\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Not enough nodes for 3-opt\n\n    # Randomly select three non-consecutive edges\n    i, j, k = sorted(random.sample(range(1, n), 3))\n    if i == j or j == k or i == k:\n        return new_solution  # Invalid selection\n\n    # Apply 3-opt move\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:]\n\n    # Possible configurations for 3-opt\n    configurations = [\n        np.concatenate([new_solution[:i], segment1[::-1], segment2[::-1], segment3]),\n        np.concatenate([new_solution[:i], segment2[::-1], segment1, segment3]),\n        np.concatenate([new_solution[:i], segment1, segment2[::-1], segment3]),\n        np.concatenate([new_solution[:i], segment1[::-1], segment2, segment3])\n    ]\n\n    # Evaluate configurations based on both objectives\n    best_config = None\n    min_total_cost = float('inf')\n\n    for config in configurations:\n        cost1 = sum(distance_matrix_1[config[i], config[i+1]] for i in range(n-1)) + distance_matrix_1[config[-1], config[0]]\n        cost2 = sum(distance_matrix_2[config[i], config[i+1]] for i in range(n-1)) + distance_matrix_2[config[-1], config[0]]\n        total_cost = cost1 + cost2\n\n        if total_cost < min_total_cost:\n            min_total_cost = total_cost\n            best_config = config\n\n    if best_config is not None:\n        new_solution = best_config\n\n    # Biased random walk: with 30% probability, perform a small perturbation\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.734578601160458,
            5.26029247045517
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with lower variance in objectives to ensure balanced improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n    variances = [np.var(obj) for obj in objectives]\n\n    # Select top 30% solutions with the lowest variance\n    percentile = np.percentile(variances, 30)\n    candidates = [sol for sol, var in zip(solutions, variances) if var <= percentile]\n\n    if not candidates:\n        candidates = solutions  # Fallback to all solutions if no candidates found\n\n    base_solution = random.choice(candidates).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with a biased random walk\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Not enough nodes for 3-opt\n\n    # Randomly select three non-consecutive edges\n    i, j, k = sorted(random.sample(range(1, n), 3))\n    if i == j or j == k or i == k:\n        return new_solution  # Invalid selection\n\n    # Apply 3-opt move\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:]\n\n    # Possible configurations for 3-opt\n    configurations = [\n        np.concatenate([new_solution[:i], segment1[::-1], segment2[::-1], segment3]),\n        np.concatenate([new_solution[:i], segment2[::-1], segment1, segment3]),\n        np.concatenate([new_solution[:i], segment1, segment2[::-1], segment3]),\n        np.concatenate([new_solution[:i], segment1[::-1], segment2, segment3])\n    ]\n\n    # Evaluate configurations based on both objectives\n    best_config = None\n    min_total_cost = float('inf')\n\n    for config in configurations:\n        cost1 = sum(distance_matrix_1[config[i], config[i+1]] for i in range(n-1)) + distance_matrix_1[config[-1], config[0]]\n        cost2 = sum(distance_matrix_2[config[i], config[i+1]] for i in range(n-1)) + distance_matrix_2[config[-1], config[0]]\n        total_cost = cost1 + cost2\n\n        if total_cost < min_total_cost:\n            min_total_cost = total_cost\n            best_config = config\n\n    if best_config is not None:\n        new_solution = best_config\n\n    # Biased random walk: with 30% probability, perform a small perturbation\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 7,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best combined objective (weighted sum)\n    weights = [0.5, 0.5]  # Equal weights for simplicity; can be adjusted\n    archive_with_scores = [(solution, objectives, weights[0] * objectives[0] + weights[1] * objectives[1])\n                           for solution, objectives in archive]\n    archive_with_scores.sort(key=lambda x: x[2])\n    selected_solution = archive_with_scores[0][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment relocation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices\n    i, j, k = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Apply 3-opt: reverse segments between i, j, and k\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Novel segment relocation: move a segment to a new position\n    segment_length = np.random.randint(2, min(5, n // 2))  # Random segment length\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    segment = new_solution[start:end].copy()\n\n    # Find a new position to insert the segment\n    new_pos = np.random.randint(0, n - segment_length)\n    if new_pos >= start:\n        new_pos += segment_length\n\n    # Remove the segment from its original position\n    new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n\n    # Insert the segment at the new position\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9936487961002805,
            2.491328775882721
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best combined objective (weighted sum)\n    weights = [0.5, 0.5]  # Equal weights for simplicity; can be adjusted\n    archive_with_scores = [(solution, objectives, weights[0] * objectives[0] + weights[1] * objectives[1])\n                           for solution, objectives in archive]\n    archive_with_scores.sort(key=lambda x: x[2])\n    selected_solution = archive_with_scores[0][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment relocation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices\n    i, j, k = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Apply 3-opt: reverse segments between i, j, and k\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Novel segment relocation: move a segment to a new position\n    segment_length = np.random.randint(2, min(5, n // 2))  # Random segment length\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    segment = new_solution[start:end].copy()\n\n    # Find a new position to insert the segment\n    new_pos = np.random.randint(0, n - segment_length)\n    if new_pos >= start:\n        new_pos += segment_length\n\n    # Remove the segment from its original position\n    new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n\n    # Insert the segment at the new position\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 7,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best combined objective (weighted sum)\n    weights = [0.5, 0.5]  # Equal weights for simplicity; can be adjusted\n    archive_with_scores = [(solution, objectives, weights[0] * objectives[0] + weights[1] * objectives[1])\n                           for solution, objectives in archive]\n    archive_with_scores.sort(key=lambda x: x[2])\n    selected_solution = archive_with_scores[0][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment relocation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices\n    i, j, k = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Apply 3-opt: reverse segments between i, j, and k\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Novel segment relocation: move a segment to a new position\n    segment_length = np.random.randint(2, min(5, n // 2))  # Random segment length\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    segment = new_solution[start:end].copy()\n\n    # Find a new position to insert the segment\n    new_pos = np.random.randint(0, n - segment_length)\n    if new_pos >= start:\n        new_pos += segment_length\n\n    # Remove the segment from its original position\n    new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n\n    # Insert the segment at the new position\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9936487961002805,
            2.491328775882721
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best combined objective (weighted sum)\n    weights = [0.5, 0.5]  # Equal weights for simplicity; can be adjusted\n    archive_with_scores = [(solution, objectives, weights[0] * objectives[0] + weights[1] * objectives[1])\n                           for solution, objectives in archive]\n    archive_with_scores.sort(key=lambda x: x[2])\n    selected_solution = archive_with_scores[0][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment relocation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices\n    i, j, k = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Apply 3-opt: reverse segments between i, j, and k\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Novel segment relocation: move a segment to a new position\n    segment_length = np.random.randint(2, min(5, n // 2))  # Random segment length\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    segment = new_solution[start:end].copy()\n\n    # Find a new position to insert the segment\n    new_pos = np.random.randint(0, n - segment_length)\n    if new_pos >= start:\n        new_pos += segment_length\n\n    # Remove the segment from its original position\n    new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n\n    # Insert the segment at the new position\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 8,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal)\n    # Here, we select a solution that is not the best in either objective\n    objectives = [obj for _, obj in archive]\n    sorted_obj1 = sorted(objectives, key=lambda x: x[0])\n    sorted_obj2 = sorted(objectives, key=lambda x: x[1])\n\n    # Find solutions that are not the best in either objective\n    candidates = []\n    for sol, obj in archive:\n        if obj not in sorted_obj1[:1] and obj not in sorted_obj2[:1]:\n            candidates.append(sol)\n\n    if not candidates:\n        # If no such solutions, select the worst in one objective\n        worst_sol1 = archive[np.argmax([obj[0] for _, obj in archive])][0]\n        worst_sol2 = archive[np.argmax([obj[1] for _, obj in archive])][0]\n        candidates = [worst_sol1, worst_sol2]\n\n    # Randomly select a candidate solution\n    base_solution = random.choice(candidates).copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge insertion heuristic\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Step 1: Perform a 3-opt move to explore new neighborhoods\n    i, j, k = sorted(random.sample(range(1, n), 3))\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Reconstruct the tour with 3-opt\n    new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Step 2: Novel edge insertion heuristic - insert a random node in a promising position\n    if n > 3:\n        # Select a random node to relocate\n        node_to_move = random.choice(new_solution[1:-1])  # Exclude start/end nodes\n        idx = np.where(new_solution == node_to_move)[0][0]\n\n        # Remove the node\n        new_solution = np.concatenate([new_solution[:idx], new_solution[idx+1:]])\n\n        # Find the best insertion position based on both objectives\n        best_pos = 1\n        min_cost = float('inf')\n\n        for pos in range(1, len(new_solution)):\n            # Insert the node temporarily\n            temp_solution = np.insert(new_solution, pos, node_to_move)\n\n            # Calculate the change in both objectives\n            cost1 = distance_matrix_1[temp_solution[pos-1], temp_solution[pos]] + \\\n                   distance_matrix_1[temp_solution[pos], temp_solution[(pos+1)%n]] - \\\n                   distance_matrix_1[temp_solution[pos-1], temp_solution[(pos+1)%n]]\n\n            cost2 = distance_matrix_2[temp_solution[pos-1], temp_solution[pos]] + \\\n                   distance_matrix_2[temp_solution[pos], temp_solution[(pos+1)%n]] - \\\n                   distance_matrix_2[temp_solution[pos-1], temp_solution[(pos+1)%n]]\n\n            total_cost = cost1 + cost2  # Simple combination (could be weighted)\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        # Insert the node in the best position\n        new_solution = np.insert(new_solution, best_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.8445325130994089,
            5.455941200256348
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal)\n    # Here, we select a solution that is not the best in either objective\n    objectives = [obj for _, obj in archive]\n    sorted_obj1 = sorted(objectives, key=lambda x: x[0])\n    sorted_obj2 = sorted(objectives, key=lambda x: x[1])\n\n    # Find solutions that are not the best in either objective\n    candidates = []\n    for sol, obj in archive:\n        if obj not in sorted_obj1[:1] and obj not in sorted_obj2[:1]:\n            candidates.append(sol)\n\n    if not candidates:\n        # If no such solutions, select the worst in one objective\n        worst_sol1 = archive[np.argmax([obj[0] for _, obj in archive])][0]\n        worst_sol2 = archive[np.argmax([obj[1] for _, obj in archive])][0]\n        candidates = [worst_sol1, worst_sol2]\n\n    # Randomly select a candidate solution\n    base_solution = random.choice(candidates).copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge insertion heuristic\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Step 1: Perform a 3-opt move to explore new neighborhoods\n    i, j, k = sorted(random.sample(range(1, n), 3))\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Reconstruct the tour with 3-opt\n    new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Step 2: Novel edge insertion heuristic - insert a random node in a promising position\n    if n > 3:\n        # Select a random node to relocate\n        node_to_move = random.choice(new_solution[1:-1])  # Exclude start/end nodes\n        idx = np.where(new_solution == node_to_move)[0][0]\n\n        # Remove the node\n        new_solution = np.concatenate([new_solution[:idx], new_solution[idx+1:]])\n\n        # Find the best insertion position based on both objectives\n        best_pos = 1\n        min_cost = float('inf')\n\n        for pos in range(1, len(new_solution)):\n            # Insert the node temporarily\n            temp_solution = np.insert(new_solution, pos, node_to_move)\n\n            # Calculate the change in both objectives\n            cost1 = distance_matrix_1[temp_solution[pos-1], temp_solution[pos]] + \\\n                   distance_matrix_1[temp_solution[pos], temp_solution[(pos+1)%n]] - \\\n                   distance_matrix_1[temp_solution[pos-1], temp_solution[(pos+1)%n]]\n\n            cost2 = distance_matrix_2[temp_solution[pos-1], temp_solution[pos]] + \\\n                   distance_matrix_2[temp_solution[pos], temp_solution[(pos+1)%n]] - \\\n                   distance_matrix_2[temp_solution[pos-1], temp_solution[(pos+1)%n]]\n\n            total_cost = cost1 + cost2  # Simple combination (could be weighted)\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        # Insert the node in the best position\n        new_solution = np.insert(new_solution, best_pos, node_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 9,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    weights = [1.0 / (1.0 + obj[0] + obj[1]) for _, obj in archive]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of 2-opt and edge insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Randomly select two segments to operate on\n    i, j = sorted(random.sample(range(1, n), 2))\n    k, l = sorted(random.sample(range(1, n), 2))\n\n    # Apply 2-opt between i and j\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply edge insertion between k and l\n    if k != l:\n        node = new_solution[l]\n        new_solution = np.concatenate([new_solution[:k], [node], new_solution[k:l], new_solution[l+1:]])\n\n    # Ensure feasibility (no duplicates and all nodes included)\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(len(instance)), unique_nodes)\n    for node in missing_nodes:\n        # Insert missing nodes at random positions\n        pos = random.randint(1, n-1)\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Remove duplicates while preserving order\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    return new_solution\n\n",
        "score": [
            -0.8611010900158328,
            2.6280577778816223
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    weights = [1.0 / (1.0 + obj[0] + obj[1]) for _, obj in archive]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of 2-opt and edge insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Randomly select two segments to operate on\n    i, j = sorted(random.sample(range(1, n), 2))\n    k, l = sorted(random.sample(range(1, n), 2))\n\n    # Apply 2-opt between i and j\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply edge insertion between k and l\n    if k != l:\n        node = new_solution[l]\n        new_solution = np.concatenate([new_solution[:k], [node], new_solution[k:l], new_solution[l+1:]])\n\n    # Ensure feasibility (no duplicates and all nodes included)\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(len(instance)), unique_nodes)\n    for node in missing_nodes:\n        # Insert missing nodes at random positions\n        pos = random.randint(1, n-1)\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Remove duplicates while preserving order\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 10,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement based on objective values\n    # Here, we prioritize solutions with higher combined objective values (worse solutions)\n    archive_sorted = sorted(archive, key=lambda x: -sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge-swap based on both objectives\n    n = len(new_solution)\n    for _ in range(3):  # Perform multiple iterations for better exploration\n        # Randomly select three distinct edges to modify\n        i, j, k = np.random.choice(range(1, n-1), size=3, replace=False)\n        i, j, k = sorted([i, j, k])\n\n        # Create a candidate solution by reversing the segment between i and j, then swapping j and k\n        candidate = new_solution.copy()\n        candidate[i:j+1] = np.flip(candidate[i:j+1])\n        candidate[j], candidate[k] = candidate[k], candidate[j]\n\n        # Calculate the cost difference for both objectives\n        def calculate_cost_diff(solution):\n            cost1 = sum(distance_matrix_1[solution[i-1], solution[i]] for i in range(n))\n            cost2 = sum(distance_matrix_2[solution[i-1], solution[i]] for i in range(n))\n            return (cost1, cost2)\n\n        current_cost = calculate_cost_diff(new_solution)\n        candidate_cost = calculate_cost_diff(candidate)\n\n        # Accept the candidate if it improves either objective\n        if (candidate_cost[0] < current_cost[0]) or (candidate_cost[1] < current_cost[1]):\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8430755644023338,
            3.7868784070014954
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement based on objective values\n    # Here, we prioritize solutions with higher combined objective values (worse solutions)\n    archive_sorted = sorted(archive, key=lambda x: -sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge-swap based on both objectives\n    n = len(new_solution)\n    for _ in range(3):  # Perform multiple iterations for better exploration\n        # Randomly select three distinct edges to modify\n        i, j, k = np.random.choice(range(1, n-1), size=3, replace=False)\n        i, j, k = sorted([i, j, k])\n\n        # Create a candidate solution by reversing the segment between i and j, then swapping j and k\n        candidate = new_solution.copy()\n        candidate[i:j+1] = np.flip(candidate[i:j+1])\n        candidate[j], candidate[k] = candidate[k], candidate[j]\n\n        # Calculate the cost difference for both objectives\n        def calculate_cost_diff(solution):\n            cost1 = sum(distance_matrix_1[solution[i-1], solution[i]] for i in range(n))\n            cost2 = sum(distance_matrix_2[solution[i-1], solution[i]] for i in range(n))\n            return (cost1, cost2)\n\n        current_cost = calculate_cost_diff(new_solution)\n        candidate_cost = calculate_cost_diff(candidate)\n\n        # Accept the candidate if it improves either objective\n        if (candidate_cost[0] < current_cost[0]) or (candidate_cost[1] < current_cost[1]):\n            new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 11,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    total_costs = [sum(obj) for obj in objectives]\n    if not total_costs:\n        return archive[0][0].copy()\n\n    min_cost = min(total_costs)\n    max_cost = max(total_costs)\n    normalized_costs = [(max_cost - cost + 1) / (max_cost - min_cost + 1) for cost in total_costs]\n    probabilities = [cost / sum(normalized_costs) for cost in normalized_costs]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 3-opt with a randomized edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select 3 distinct nodes\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply a randomized 3-opt move\n    if random.random() < 0.5:\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8680435691635797,
            2.581058442592621
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    total_costs = [sum(obj) for obj in objectives]\n    if not total_costs:\n        return archive[0][0].copy()\n\n    min_cost = min(total_costs)\n    max_cost = max(total_costs)\n    normalized_costs = [(max_cost - cost + 1) / (max_cost - min_cost + 1) for cost in total_costs]\n    probabilities = [cost / sum(normalized_costs) for cost in normalized_costs]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 3-opt with a randomized edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select 3 distinct nodes\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply a randomized 3-opt move\n    if random.random() < 0.5:\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 12,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on a combination of objective values and diversity\n    # Here, we prioritize solutions with lower total cost (sum of both objectives)\n    archive.sort(key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a randomized swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices\n    indices = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted(indices)\n\n    # Apply 3-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]  # Reverse segment\n    new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]  # Reverse segment\n\n    # Add a randomized swap to escape local optima\n    if np.random.random() < 0.3:  # 30% chance of additional swap\n        swap_indices = np.random.choice(n, size=2, replace=False)\n        new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n\n    return new_solution\n\n",
        "score": [
            -0.8671914927980067,
            2.6719207763671875
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on a combination of objective values and diversity\n    # Here, we prioritize solutions with lower total cost (sum of both objectives)\n    archive.sort(key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a randomized swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices\n    indices = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted(indices)\n\n    # Apply 3-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]  # Reverse segment\n    new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]  # Reverse segment\n\n    # Add a randomized swap to escape local optima\n    if np.random.random() < 0.3:  # 30% chance of additional swap\n        swap_indices = np.random.choice(n, size=2, replace=False)\n        new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 13,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value (potential for improvement)\n    selected = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge insertion strategy\n    n = len(base_solution)\n    i, j = np.random.randint(0, n, size=2)\n    if i > j:\n        i, j = j, i\n\n    # Apply 2-opt swap\n    new_solution[i:j+1] = base_solution[i:j+1][::-1]\n\n    # Novel edge insertion: try to improve by inserting a node in a different position\n    if n > 3:\n        k = np.random.randint(0, n)\n        while k == i or k == j:\n            k = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7986219372930237,
            2.328272521495819
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value (potential for improvement)\n    selected = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge insertion strategy\n    n = len(base_solution)\n    i, j = np.random.randint(0, n, size=2)\n    if i > j:\n        i, j = j, i\n\n    # Apply 2-opt swap\n    new_solution[i:j+1] = base_solution[i:j+1][::-1]\n\n    # Novel edge insertion: try to improve by inserting a node in a different position\n    if n > 3:\n        k = np.random.randint(0, n)\n        while k == i or k == j:\n            k = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 14,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_solution = random.choice(archive)[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    if random.random() < 0.3:  # 30% chance for edge insertion\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution = np.concatenate([new_solution[:i+1], new_solution[j:], new_solution[i+1:j]])\n    elif random.random() < 0.5:  # 20% chance for segment reversal\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:  # 50% chance for random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n, \"Invalid tour generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.9025989787956034,
            2.2405760288238525
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_solution = random.choice(archive)[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    if random.random() < 0.3:  # 30% chance for edge insertion\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution = np.concatenate([new_solution[:i+1], new_solution[j:], new_solution[i+1:j]])\n    elif random.random() < 0.5:  # 20% chance for segment reversal\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:  # 50% chance for random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n, \"Invalid tour generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 15,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_objectives = [(i, (obj[0] / distance_matrix_1.max(), obj[1] / distance_matrix_2.max())) for i, (_, obj) in enumerate(archive)]\n    selected_idx = min(normalized_objectives, key=lambda x: sum(x[1]))[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge exchange + segment relocation\n    n = len(base_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Edge exchange: swap edges (i, i+1) and (j, j+1) with (i, j) and (i+1, j+1)\n    if j - i > 1:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment relocation: move a random segment to a new position\n    seg_start, seg_end = sorted(np.random.choice(n, 2, replace=False))\n    seg_length = min(3, seg_end - seg_start)  # Limit segment length for efficiency\n    segment = new_solution[seg_start:seg_start + seg_length]\n    new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_start + seg_length:], segment])\n\n    return new_solution\n\n",
        "score": [
            -0.9083703114031084,
            2.353114068508148
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_objectives = [(i, (obj[0] / distance_matrix_1.max(), obj[1] / distance_matrix_2.max())) for i, (_, obj) in enumerate(archive)]\n    selected_idx = min(normalized_objectives, key=lambda x: sum(x[1]))[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge exchange + segment relocation\n    n = len(base_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Edge exchange: swap edges (i, i+1) and (j, j+1) with (i, j) and (i+1, j+1)\n    if j - i > 1:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment relocation: move a random segment to a new position\n    seg_start, seg_end = sorted(np.random.choice(n, 2, replace=False))\n    seg_length = min(3, seg_end - seg_start)  # Limit segment length for efficiency\n    segment = new_solution[seg_start:seg_start + seg_length]\n    new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_start + seg_length:], segment])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 16,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its total cost\n    costs = [sum(obj) for _, obj in archive]\n    if all(c == 0 for c in costs):\n        probs = [1/len(archive)] * len(archive)\n    else:\n        probs = [1/c if c != 0 else max(costs) for c in costs]\n        total = sum(probs)\n        probs = [p/total for p in probs]\n\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of edge exchange and segment reinsertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to reinsert\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n\n    # Step 2: Remove the segment and find the best insertion point\n    remaining = np.concatenate([new_solution[:a], new_solution[b+1:]])\n    best_pos = -1\n    best_gain = 0\n\n    # Evaluate insertion points considering both objectives\n    for i in range(len(remaining)):\n        # Insert segment after position i\n        candidate = np.concatenate([remaining[:i+1], segment, remaining[i+1:]])\n\n        # Calculate cost difference for both objectives\n        cost_diff1 = (distance_matrix_1[remaining[i], segment[0]] +\n                      distance_matrix_1[segment[-1], remaining[(i+1)%len(remaining)]] -\n                      distance_matrix_1[remaining[i], remaining[(i+1)%len(remaining)]])\n\n        cost_diff2 = (distance_matrix_2[remaining[i], segment[0]] +\n                      distance_matrix_2[segment[-1], remaining[(i+1)%len(remaining)]] -\n                      distance_matrix_2[remaining[i], remaining[(i+1)%len(remaining)]])\n\n        # Weighted gain (could be adjusted)\n        gain = - (0.5 * cost_diff1 + 0.5 * cost_diff2)\n\n        if gain < best_gain:\n            best_gain = gain\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([remaining[:best_pos+1], segment, remaining[best_pos+1:]])\n\n    # Step 3: With some probability, perform an edge exchange\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j and (j - i) > 1:\n            # Exchange edges between i and j\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.699320132981708,
            2.7212430834770203
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its total cost\n    costs = [sum(obj) for _, obj in archive]\n    if all(c == 0 for c in costs):\n        probs = [1/len(archive)] * len(archive)\n    else:\n        probs = [1/c if c != 0 else max(costs) for c in costs]\n        total = sum(probs)\n        probs = [p/total for p in probs]\n\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of edge exchange and segment reinsertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to reinsert\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n\n    # Step 2: Remove the segment and find the best insertion point\n    remaining = np.concatenate([new_solution[:a], new_solution[b+1:]])\n    best_pos = -1\n    best_gain = 0\n\n    # Evaluate insertion points considering both objectives\n    for i in range(len(remaining)):\n        # Insert segment after position i\n        candidate = np.concatenate([remaining[:i+1], segment, remaining[i+1:]])\n\n        # Calculate cost difference for both objectives\n        cost_diff1 = (distance_matrix_1[remaining[i], segment[0]] +\n                      distance_matrix_1[segment[-1], remaining[(i+1)%len(remaining)]] -\n                      distance_matrix_1[remaining[i], remaining[(i+1)%len(remaining)]])\n\n        cost_diff2 = (distance_matrix_2[remaining[i], segment[0]] +\n                      distance_matrix_2[segment[-1], remaining[(i+1)%len(remaining)]] -\n                      distance_matrix_2[remaining[i], remaining[(i+1)%len(remaining)]])\n\n        # Weighted gain (could be adjusted)\n        gain = - (0.5 * cost_diff1 + 0.5 * cost_diff2)\n\n        if gain < best_gain:\n            best_gain = gain\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([remaining[:best_pos+1], segment, remaining[best_pos+1:]])\n\n    # Step 3: With some probability, perform an edge exchange\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j and (j - i) > 1:\n            # Exchange edges between i and j\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 17,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best but not the worst)\n    archive_solutions = [sol for sol, _ in archive]\n    if len(archive_solutions) > 2:\n        # Select a middle solution to avoid local optima\n        idx = len(archive_solutions) // 2\n        base_solution = archive_solutions[idx].copy()\n    else:\n        base_solution = archive_solutions[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt with biased random walk\n    if n >= 4:\n        # Select 3 random edges to perform 3-opt\n        i, j, k = sorted(np.random.choice(range(1, n-1), 3, replace=False))\n\n        # Perform 3-opt by reconnecting the edges\n        new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n        new_solution[j:k+1] = np.flip(new_solution[j:k+1])\n\n        # With some probability, perform a biased random walk to escape local optima\n        if np.random.rand() < 0.3:\n            # Randomly select a segment and reverse it\n            a, b = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n            new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        # If the solution is invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5671518178821888,
            1.6742216348648071
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best but not the worst)\n    archive_solutions = [sol for sol, _ in archive]\n    if len(archive_solutions) > 2:\n        # Select a middle solution to avoid local optima\n        idx = len(archive_solutions) // 2\n        base_solution = archive_solutions[idx].copy()\n    else:\n        base_solution = archive_solutions[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt with biased random walk\n    if n >= 4:\n        # Select 3 random edges to perform 3-opt\n        i, j, k = sorted(np.random.choice(range(1, n-1), 3, replace=False))\n\n        # Perform 3-opt by reconnecting the edges\n        new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n        new_solution[j:k+1] = np.flip(new_solution[j:k+1])\n\n        # With some probability, perform a biased random walk to escape local optima\n        if np.random.rand() < 0.3:\n            # Randomly select a segment and reverse it\n            a, b = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n            new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        # If the solution is invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 17,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best but not the worst)\n    archive_solutions = [sol for sol, _ in archive]\n    if len(archive_solutions) > 2:\n        # Select a middle solution to avoid local optima\n        idx = len(archive_solutions) // 2\n        base_solution = archive_solutions[idx].copy()\n    else:\n        base_solution = archive_solutions[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt with biased random walk\n    if n >= 4:\n        # Select 3 random edges to perform 3-opt\n        i, j, k = sorted(np.random.choice(range(1, n-1), 3, replace=False))\n\n        # Perform 3-opt by reconnecting the edges\n        new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n        new_solution[j:k+1] = np.flip(new_solution[j:k+1])\n\n        # With some probability, perform a biased random walk to escape local optima\n        if np.random.rand() < 0.3:\n            # Randomly select a segment and reverse it\n            a, b = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n            new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        # If the solution is invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5671518178821888,
            1.6742216348648071
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best but not the worst)\n    archive_solutions = [sol for sol, _ in archive]\n    if len(archive_solutions) > 2:\n        # Select a middle solution to avoid local optima\n        idx = len(archive_solutions) // 2\n        base_solution = archive_solutions[idx].copy()\n    else:\n        base_solution = archive_solutions[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt with biased random walk\n    if n >= 4:\n        # Select 3 random edges to perform 3-opt\n        i, j, k = sorted(np.random.choice(range(1, n-1), 3, replace=False))\n\n        # Perform 3-opt by reconnecting the edges\n        new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n        new_solution[j:k+1] = np.flip(new_solution[j:k+1])\n\n        # With some probability, perform a biased random walk to escape local optima\n        if np.random.rand() < 0.3:\n            # Randomly select a segment and reverse it\n            a, b = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n            new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        # If the solution is invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 18,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others in the archive)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(base_solution)\n\n    # Step 1: Edge insertion (distance-aware)\n    i, j = random.sample(range(n), 2)\n    if abs(i - j) > 1:\n        # Calculate cost difference for both objectives\n        old_cost1 = distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[j-1], base_solution[j]]\n        new_cost1 = distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j-1], base_solution[i]]\n        old_cost2 = distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[j-1], base_solution[j]]\n        new_cost2 = distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j-1], base_solution[i]]\n\n        # Apply if it improves at least one objective\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment reversal (distance-aware)\n    a, b = sorted(random.sample(range(n), 2))\n    if b - a > 2:\n        # Calculate cost difference for both objectives\n        old_cost1 = distance_matrix_1[base_solution[a-1], base_solution[a]] + distance_matrix_1[base_solution[b-1], base_solution[b]]\n        new_cost1 = distance_matrix_1[base_solution[a-1], base_solution[b]] + distance_matrix_1[base_solution[a], base_solution[b-1]]\n        old_cost2 = distance_matrix_2[base_solution[a-1], base_solution[a]] + distance_matrix_2[base_solution[b-1], base_solution[b]]\n        new_cost2 = distance_matrix_2[base_solution[a-1], base_solution[b]] + distance_matrix_2[base_solution[a], base_solution[b-1]]\n\n        # Apply if it improves at least one objective\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Novel perturbation (distance-aware swap)\n    k, l = random.sample(range(n), 2)\n    if abs(k - l) > 1:\n        # Calculate cost difference for both objectives\n        old_cost1 = distance_matrix_1[base_solution[k-1], base_solution[k]] + distance_matrix_1[base_solution[l-1], base_solution[l]]\n        new_cost1 = distance_matrix_1[base_solution[k-1], base_solution[l]] + distance_matrix_1[base_solution[l-1], base_solution[k]]\n        old_cost2 = distance_matrix_2[base_solution[k-1], base_solution[k]] + distance_matrix_2[base_solution[l-1], base_solution[l]]\n        new_cost2 = distance_matrix_2[base_solution[k-1], base_solution[l]] + distance_matrix_2[base_solution[l-1], base_solution[k]]\n\n        # Apply if it improves at least one objective\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.9170114315955715,
            2.475582480430603
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others in the archive)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(base_solution)\n\n    # Step 1: Edge insertion (distance-aware)\n    i, j = random.sample(range(n), 2)\n    if abs(i - j) > 1:\n        # Calculate cost difference for both objectives\n        old_cost1 = distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[j-1], base_solution[j]]\n        new_cost1 = distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j-1], base_solution[i]]\n        old_cost2 = distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[j-1], base_solution[j]]\n        new_cost2 = distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j-1], base_solution[i]]\n\n        # Apply if it improves at least one objective\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment reversal (distance-aware)\n    a, b = sorted(random.sample(range(n), 2))\n    if b - a > 2:\n        # Calculate cost difference for both objectives\n        old_cost1 = distance_matrix_1[base_solution[a-1], base_solution[a]] + distance_matrix_1[base_solution[b-1], base_solution[b]]\n        new_cost1 = distance_matrix_1[base_solution[a-1], base_solution[b]] + distance_matrix_1[base_solution[a], base_solution[b-1]]\n        old_cost2 = distance_matrix_2[base_solution[a-1], base_solution[a]] + distance_matrix_2[base_solution[b-1], base_solution[b]]\n        new_cost2 = distance_matrix_2[base_solution[a-1], base_solution[b]] + distance_matrix_2[base_solution[a], base_solution[b-1]]\n\n        # Apply if it improves at least one objective\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Novel perturbation (distance-aware swap)\n    k, l = random.sample(range(n), 2)\n    if abs(k - l) > 1:\n        # Calculate cost difference for both objectives\n        old_cost1 = distance_matrix_1[base_solution[k-1], base_solution[k]] + distance_matrix_1[base_solution[l-1], base_solution[l]]\n        new_cost1 = distance_matrix_1[base_solution[k-1], base_solution[l]] + distance_matrix_1[base_solution[l-1], base_solution[k]]\n        old_cost2 = distance_matrix_2[base_solution[k-1], base_solution[k]] + distance_matrix_2[base_solution[l-1], base_solution[l]]\n        new_cost2 = distance_matrix_2[base_solution[k-1], base_solution[l]] + distance_matrix_2[base_solution[l-1], base_solution[k]]\n\n        # Apply if it improves at least one objective\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 19,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best but not the worst)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    candidate_solutions = sorted_archive[len(sorted_archive)//3 : -len(sorted_archive)//3]\n    if not candidate_solutions:\n        candidate_solutions = archive\n    base_solution = random.choice(candidate_solutions)[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    if n < 5:\n        # For small tours, use a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # For larger tours, use a combination of 3-opt and segment inversion\n        if random.random() < 0.7:\n            # 3-opt move\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j]\n            segment2 = new_solution[j:k]\n            new_solution[i:k] = np.concatenate([segment2, segment1])\n        else:\n            # Segment inversion with adaptive length\n            segment_length = min(5, n-1)\n            start = random.randint(0, n - segment_length - 1)\n            end = start + segment_length\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure the solution remains feasible\n    assert len(set(new_solution)) == n, \"Generated solution is not a valid tour\"\n    assert len(new_solution) == n, \"Generated solution has incorrect length\"\n\n    return new_solution\n\n",
        "score": [
            -0.5275659293187844,
            2.0573960542678833
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best but not the worst)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    candidate_solutions = sorted_archive[len(sorted_archive)//3 : -len(sorted_archive)//3]\n    if not candidate_solutions:\n        candidate_solutions = archive\n    base_solution = random.choice(candidate_solutions)[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    if n < 5:\n        # For small tours, use a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # For larger tours, use a combination of 3-opt and segment inversion\n        if random.random() < 0.7:\n            # 3-opt move\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j]\n            segment2 = new_solution[j:k]\n            new_solution[i:k] = np.concatenate([segment2, segment1])\n        else:\n            # Segment inversion with adaptive length\n            segment_length = min(5, n-1)\n            start = random.randint(0, n - segment_length - 1)\n            end = start + segment_length\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure the solution remains feasible\n    assert len(set(new_solution)) == n, \"Generated solution is not a valid tour\"\n    assert len(new_solution) == n, \"Generated solution has incorrect length\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 20,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high diversity)\n    selected_idx = random.choices(range(len(archive)), k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose segments to modify\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse a segment and reinsert it\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Custom operator: rotate a segment by a random amount\n    if random.random() < 0.5:\n        rotation = random.randint(1, len(segment)-1)\n        segment = np.roll(segment, rotation)\n        new_solution[a:b+1] = segment\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8933471650719378,
            1.5011838674545288
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high diversity)\n    selected_idx = random.choices(range(len(archive)), k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose segments to modify\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse a segment and reinsert it\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Custom operator: rotate a segment by a random amount\n    if random.random() < 0.5:\n        rotation = random.randint(1, len(segment)-1)\n        segment = np.roll(segment, rotation)\n        new_solution[a:b+1] = segment\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 20,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high diversity)\n    selected_idx = random.choices(range(len(archive)), k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose segments to modify\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse a segment and reinsert it\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Custom operator: rotate a segment by a random amount\n    if random.random() < 0.5:\n        rotation = random.randint(1, len(segment)-1)\n        segment = np.roll(segment, rotation)\n        new_solution[a:b+1] = segment\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8933471650719378,
            1.5011838674545288
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high diversity)\n    selected_idx = random.choices(range(len(archive)), k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose segments to modify\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse a segment and reinsert it\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Custom operator: rotate a segment by a random amount\n    if random.random() < 0.5:\n        rotation = random.randint(1, len(segment)-1)\n        segment = np.roll(segment, rotation)\n        new_solution[a:b+1] = segment\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 21,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine edge insertion and segment reversal\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select a segment to reverse\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select a node to reinsert elsewhere\n    node_to_move = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node_to_move))\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure the solution remains feasible (no duplicates, all nodes present)\n    assert len(new_solution) == len(np.unique(new_solution)), \"Invalid solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.904676864327354,
            2.126172661781311
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine edge insertion and segment reversal\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select a segment to reverse\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select a node to reinsert elsewhere\n    node_to_move = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node_to_move))\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure the solution remains feasible (no duplicates, all nodes present)\n    assert len(new_solution) == len(np.unique(new_solution)), \"Invalid solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 22,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    import numpy as np\n\n    # Select a solution with high potential for improvement (e.g., not already optimal in both objectives)\n    candidates = []\n    for sol, (cost1, cost2) in archive:\n        # Simple heuristic: select solutions that are not Pareto-optimal in the archive\n        dominated = False\n        for _, (other_cost1, other_cost2) in archive:\n            if (other_cost1 <= cost1 and other_cost2 < cost2) or (other_cost1 < cost1 and other_cost2 <= cost2):\n                dominated = True\n                break\n        if not dominated:\n            candidates.append(sol)\n\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n\n    base_solution = random.choice(candidates).copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine 3-opt with a custom operator\n    if n >= 4:\n        # Randomly select three distinct edges to perform a 3-opt move\n        a, b, c = sorted(random.sample(range(n), 3))\n        # Perform a 3-opt move (reverse the middle segment)\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n        # Custom operator: swap nodes in a way that reduces both objectives\n        if n >= 6:\n            i, j = sorted(random.sample(range(n), 2))\n            # Check if swapping these nodes improves both objectives\n            current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n            current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or random.random() < 0.3:  # Allow some randomness\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7845224910663043,
            2.5768445134162903
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    import numpy as np\n\n    # Select a solution with high potential for improvement (e.g., not already optimal in both objectives)\n    candidates = []\n    for sol, (cost1, cost2) in archive:\n        # Simple heuristic: select solutions that are not Pareto-optimal in the archive\n        dominated = False\n        for _, (other_cost1, other_cost2) in archive:\n            if (other_cost1 <= cost1 and other_cost2 < cost2) or (other_cost1 < cost1 and other_cost2 <= cost2):\n                dominated = True\n                break\n        if not dominated:\n            candidates.append(sol)\n\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n\n    base_solution = random.choice(candidates).copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine 3-opt with a custom operator\n    if n >= 4:\n        # Randomly select three distinct edges to perform a 3-opt move\n        a, b, c = sorted(random.sample(range(n), 3))\n        # Perform a 3-opt move (reverse the middle segment)\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n        # Custom operator: swap nodes in a way that reduces both objectives\n        if n >= 6:\n            i, j = sorted(random.sample(range(n), 2))\n            # Check if swapping these nodes improves both objectives\n            current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n            current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or random.random() < 0.3:  # Allow some randomness\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 23,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a probability inversely proportional to its cost\n    costs = np.array([sum(obj) for _, obj in archive])\n    if np.all(costs == costs[0]):\n        # All solutions have the same cost, select uniformly\n        selected_idx = np.random.randint(len(archive))\n    else:\n        # Normalize costs to probabilities\n        probabilities = 1 / (costs + 1e-10)  # Avoid division by zero\n        probabilities = probabilities / np.sum(probabilities)\n        selected_idx = np.random.choice(len(archive), p=probabilities)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(base_solution)\n\n    # Step 1: Edge swapping (similar to 2-opt but more flexible)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Probabilistic node insertion to avoid local optima\n    if np.random.rand() < 0.5:  # 50% chance to apply insertion\n        k = np.random.randint(n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = np.random.randint(n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility by checking for duplicates and missing nodes\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or not np.array_equal(sorted(unique_nodes), sorted(base_solution)):\n        # Fallback to a simple swap if the solution is invalid\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.860128040063725,
            2.6283907890319824
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a probability inversely proportional to its cost\n    costs = np.array([sum(obj) for _, obj in archive])\n    if np.all(costs == costs[0]):\n        # All solutions have the same cost, select uniformly\n        selected_idx = np.random.randint(len(archive))\n    else:\n        # Normalize costs to probabilities\n        probabilities = 1 / (costs + 1e-10)  # Avoid division by zero\n        probabilities = probabilities / np.sum(probabilities)\n        selected_idx = np.random.choice(len(archive), p=probabilities)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(base_solution)\n\n    # Step 1: Edge swapping (similar to 2-opt but more flexible)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Probabilistic node insertion to avoid local optima\n    if np.random.rand() < 0.5:  # 50% chance to apply insertion\n        k = np.random.randint(n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = np.random.randint(n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility by checking for duplicates and missing nodes\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or not np.array_equal(sorted(unique_nodes), sorted(base_solution)):\n        # Fallback to a simple swap if the solution is invalid\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 24,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a probability inversely proportional to its total cost\n    total_costs = [obj[0] + obj[1] for _, obj in archive]\n    if all(c == 0 for c in total_costs):\n        probabilities = [1.0 / len(archive)] * len(archive)\n    else:\n        probabilities = [1.0 / (c + 1e-6) for c in total_costs]\n    probabilities = [p / sum(probabilities) for p in probabilities]\n\n    base_solution = random.choices(archive, weights=probabilities, k=1)[0][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel edge insertion heuristic\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, apply a novel edge insertion heuristic\n    # Select a random segment and insert it elsewhere\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b].copy()\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure the solution remains a valid tour\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if the operation fails\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8242362616450246,
            2.495037257671356
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a probability inversely proportional to its total cost\n    total_costs = [obj[0] + obj[1] for _, obj in archive]\n    if all(c == 0 for c in total_costs):\n        probabilities = [1.0 / len(archive)] * len(archive)\n    else:\n        probabilities = [1.0 / (c + 1e-6) for c in total_costs]\n    probabilities = [p / sum(probabilities) for p in probabilities]\n\n    base_solution = random.choices(archive, weights=probabilities, k=1)[0][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel edge insertion heuristic\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, apply a novel edge insertion heuristic\n    # Select a random segment and insert it elsewhere\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b].copy()\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure the solution remains a valid tour\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if the operation fails\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 25,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on the sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    fitness = normalized_obj.sum(axis=1)\n    selected_idx = np.argmin(fitness)  # Prefer solutions with lower combined objective values\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combination of edge swapping and segment relocation\n    for _ in range(2):  # Perform a few iterations of the hybrid operator\n        # Edge swapping (2-opt variant)\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Segment relocation (novel operator)\n        if n > 3:\n            k = np.random.randint(1, n-1)\n            segment = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], new_solution[k+2:], segment])\n\n    # Ensure the solution remains a valid tour\n    assert len(set(new_solution)) == n, \"Invalid tour: duplicate nodes or missing nodes\"\n\n    return new_solution\n\n",
        "score": [
            -0.7609410597505082,
            2.0865862369537354
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on the sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    fitness = normalized_obj.sum(axis=1)\n    selected_idx = np.argmin(fitness)  # Prefer solutions with lower combined objective values\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combination of edge swapping and segment relocation\n    for _ in range(2):  # Perform a few iterations of the hybrid operator\n        # Edge swapping (2-opt variant)\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Segment relocation (novel operator)\n        if n > 3:\n            k = np.random.randint(1, n-1)\n            segment = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], new_solution[k+2:], segment])\n\n    # Ensure the solution remains a valid tour\n    assert len(set(new_solution)) == n, \"Invalid tour: duplicate nodes or missing nodes\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 26,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    import numpy as np\n\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    dominated = [False] * len(archive)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and archive[j][1][0] <= archive[i][1][0] and archive[j][1][1] <= archive[i][1][1] and (archive[j][1][0] < archive[i][1][0] or archive[j][1][1] < archive[i][1][1]):\n                dominated[i] = True\n                break\n\n    non_dominated_indices = [i for i in range(len(archive)) if not dominated[i]]\n    if not non_dominated_indices:\n        non_dominated_indices = list(range(len(archive)))\n\n    selected_idx = random.choice(non_dominated_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n\n    # Apply a novel edge swap strategy within the segment\n    if len(segment) > 2:\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(len(segment)), 2))\n        # Swap the nodes at these positions\n        segment[i], segment[j] = segment[j], segment[i]\n\n    # Reinsert the modified segment back into the solution\n    new_solution[a:b+1] = segment\n\n    # Ensure the solution remains a valid tour\n    if len(set(new_solution)) != len(base_solution):\n        # If invalid, revert to a simple swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8688293467370063,
            2.5540924072265625
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    import numpy as np\n\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    dominated = [False] * len(archive)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and archive[j][1][0] <= archive[i][1][0] and archive[j][1][1] <= archive[i][1][1] and (archive[j][1][0] < archive[i][1][0] or archive[j][1][1] < archive[i][1][1]):\n                dominated[i] = True\n                break\n\n    non_dominated_indices = [i for i in range(len(archive)) if not dominated[i]]\n    if not non_dominated_indices:\n        non_dominated_indices = list(range(len(archive)))\n\n    selected_idx = random.choice(non_dominated_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n\n    # Apply a novel edge swap strategy within the segment\n    if len(segment) > 2:\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(len(segment)), 2))\n        # Swap the nodes at these positions\n        segment[i], segment[j] = segment[j], segment[i]\n\n    # Reinsert the modified segment back into the solution\n    new_solution[a:b+1] = segment\n\n    # Ensure the solution remains a valid tour\n    if len(set(new_solution)) != len(base_solution):\n        # If invalid, revert to a simple swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 27,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    weights = 1 / (normalized_objectives.sum(axis=1) + 1e-10)\n    weights = weights / weights.sum()  # Normalize to probabilities\n\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: combination of edge swaps and segment reversals\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between two local search strategies\n    if random.random() < 0.5:\n        # Edge swap: swap two edges by choosing two non-adjacent nodes and reversing the segment between them\n        i, j = sorted(random.sample(range(n), 2))\n        if i + 1 < j:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n    else:\n        # Segment reversal: reverse a randomly selected segment of the tour\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            -0.7597948899678956,
            2.4033520221710205
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    weights = 1 / (normalized_objectives.sum(axis=1) + 1e-10)\n    weights = weights / weights.sum()  # Normalize to probabilities\n\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: combination of edge swaps and segment reversals\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between two local search strategies\n    if random.random() < 0.5:\n        # Edge swap: swap two edges by choosing two non-adjacent nodes and reversing the segment between them\n        i, j = sorted(random.sample(range(n), 2))\n        if i + 1 < j:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n    else:\n        # Segment reversal: reverse a randomly selected segment of the tour\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 28,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its dominance\n    # Solutions with higher costs are more likely to be selected for improvement\n    costs = np.array([obj[0] + obj[1] for _, obj in archive])\n    if len(costs) > 1:\n        normalized_costs = (costs - np.min(costs)) / (np.max(costs) - np.min(costs))\n        probabilities = 1 - normalized_costs\n        probabilities /= np.sum(probabilities)\n        selected_idx = np.random.choice(len(archive), p=probabilities)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a custom edge exchange\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # 3-opt move: select three random edges and reconnect them in a new way\n        a, b, c = sorted(random.sample(range(n), 3))\n        # Create three possible 3-opt moves and select the best one\n        candidates = [\n            np.concatenate([new_solution[:a], new_solution[b:c][::-1], new_solution[a:b], new_solution[c:]]),\n            np.concatenate([new_solution[:a], new_solution[b:c], new_solution[a:b][::-1], new_solution[c:]]),\n            np.concatenate([new_solution[:a], new_solution[b:c][::-1], new_solution[a:b][::-1], new_solution[c:]])\n        ]\n\n        # Evaluate each candidate based on both objectives\n        best_candidate = None\n        best_score = float('inf')\n\n        for candidate in candidates:\n            # Calculate total distance for both objectives\n            total_dist1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            total_dist2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            score = total_dist1 + total_dist2  # Combined score\n\n            if score < best_score:\n                best_score = score\n                best_candidate = candidate\n\n        if best_candidate is not None:\n            new_solution = best_candidate\n\n        # Additional edge exchange based on objective diversity\n        # Find the most \"dominated\" edge (highest combined distance in both objectives)\n        max_edge_cost = -1\n        max_edge_idx = 0\n\n        for i in range(n):\n            j = (i + 1) % n\n            cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            combined_cost = cost1 + cost2\n\n            if combined_cost > max_edge_cost:\n                max_edge_cost = combined_cost\n                max_edge_idx = i\n\n        # Replace the most dominated edge with a random better edge\n        if max_edge_cost > 0:\n            # Find all possible edges that could replace this one\n            possible_edges = []\n            for i in range(n):\n                for j in range(n):\n                    if i != j and not ((i == max_edge_idx and j == (max_edge_idx + 1) % n) or\n                                      (j == max_edge_idx and i == (max_edge_idx + 1) % n)):\n                        cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n                        cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n                        possible_edges.append((i, j, cost1 + cost2))\n\n            if possible_edges:\n                # Select the best possible replacement edge\n                possible_edges.sort(key=lambda x: x[2])\n                best_replacement = possible_edges[0]\n\n                # Perform the edge exchange\n                i, j, _ = best_replacement\n                new_solution[max_edge_idx], new_solution[(max_edge_idx + 1) % n] = new_solution[i], new_solution[j]\n\n    return new_solution\n\n",
        "score": [
            -0.9675480841228934,
            14.31111890077591
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its dominance\n    # Solutions with higher costs are more likely to be selected for improvement\n    costs = np.array([obj[0] + obj[1] for _, obj in archive])\n    if len(costs) > 1:\n        normalized_costs = (costs - np.min(costs)) / (np.max(costs) - np.min(costs))\n        probabilities = 1 - normalized_costs\n        probabilities /= np.sum(probabilities)\n        selected_idx = np.random.choice(len(archive), p=probabilities)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a custom edge exchange\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # 3-opt move: select three random edges and reconnect them in a new way\n        a, b, c = sorted(random.sample(range(n), 3))\n        # Create three possible 3-opt moves and select the best one\n        candidates = [\n            np.concatenate([new_solution[:a], new_solution[b:c][::-1], new_solution[a:b], new_solution[c:]]),\n            np.concatenate([new_solution[:a], new_solution[b:c], new_solution[a:b][::-1], new_solution[c:]]),\n            np.concatenate([new_solution[:a], new_solution[b:c][::-1], new_solution[a:b][::-1], new_solution[c:]])\n        ]\n\n        # Evaluate each candidate based on both objectives\n        best_candidate = None\n        best_score = float('inf')\n\n        for candidate in candidates:\n            # Calculate total distance for both objectives\n            total_dist1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            total_dist2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            score = total_dist1 + total_dist2  # Combined score\n\n            if score < best_score:\n                best_score = score\n                best_candidate = candidate\n\n        if best_candidate is not None:\n            new_solution = best_candidate\n\n        # Additional edge exchange based on objective diversity\n        # Find the most \"dominated\" edge (highest combined distance in both objectives)\n        max_edge_cost = -1\n        max_edge_idx = 0\n\n        for i in range(n):\n            j = (i + 1) % n\n            cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            combined_cost = cost1 + cost2\n\n            if combined_cost > max_edge_cost:\n                max_edge_cost = combined_cost\n                max_edge_idx = i\n\n        # Replace the most dominated edge with a random better edge\n        if max_edge_cost > 0:\n            # Find all possible edges that could replace this one\n            possible_edges = []\n            for i in range(n):\n                for j in range(n):\n                    if i != j and not ((i == max_edge_idx and j == (max_edge_idx + 1) % n) or\n                                      (j == max_edge_idx and i == (max_edge_idx + 1) % n)):\n                        cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n                        cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n                        possible_edges.append((i, j, cost1 + cost2))\n\n            if possible_edges:\n                # Select the best possible replacement edge\n                possible_edges.sort(key=lambda x: x[2])\n                best_replacement = possible_edges[0]\n\n                # Perform the edge exchange\n                i, j, _ = best_replacement\n                new_solution[max_edge_idx], new_solution[(max_edge_idx + 1) % n] = new_solution[i], new_solution[j]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 29,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Calculate potential improvement scores (inverse of current costs)\n        scores = [1 / (obj[0] + obj[1]) for _, obj in archive]\n        total_score = sum(scores)\n        probabilities = [score / total_score for score in scores]\n        selected_idx = random.choices(range(len(archive)), weights=probabilities, k=1)[0]\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal\n    if n >= 4:\n        # Select three distinct random indices\n        i, j, k = sorted(random.sample(range(n), 3))\n\n        # Apply 3-opt move (reverse segments between i-j, j-k, and k-i)\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n        new_solution[k:] = new_solution[k:][::-1]\n\n        # Novel segment reversal: reverse a random segment between i and k\n        seg_start = random.randint(i, k)\n        seg_end = random.randint(seg_start, k)\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.724220425779237,
            2.3388583660125732
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Calculate potential improvement scores (inverse of current costs)\n        scores = [1 / (obj[0] + obj[1]) for _, obj in archive]\n        total_score = sum(scores)\n        probabilities = [score / total_score for score in scores]\n        selected_idx = random.choices(range(len(archive)), weights=probabilities, k=1)[0]\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal\n    if n >= 4:\n        # Select three distinct random indices\n        i, j, k = sorted(random.sample(range(n), 3))\n\n        # Apply 3-opt move (reverse segments between i-j, j-k, and k-i)\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n        new_solution[k:] = new_solution[k:][::-1]\n\n        # Novel segment reversal: reverse a random segment between i and k\n        seg_start = random.randint(i, k)\n        seg_end = random.randint(seg_start, k)\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 30,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest total cost)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: apply a combination of edge exchange and node insertion\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Step 1: Edge exchange (swap two non-adjacent edges)\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Node insertion (move a node to a different position)\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    insert_pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure validity (no duplicates and all nodes visited)\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.6502197884647222,
            2.4082486033439636
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest total cost)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: apply a combination of edge exchange and node insertion\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Step 1: Edge exchange (swap two non-adjacent edges)\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Node insertion (move a node to a different position)\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    insert_pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure validity (no duplicates and all nodes visited)\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 31,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with worst objectives)\n    archive_solutions = [sol_obj[0] for sol_obj in archive]\n    objectives = [sol_obj[1] for sol_obj in archive]\n\n    # Normalize objectives to identify promising candidates\n    obj1 = np.array([obj[0] for obj in objectives])\n    obj2 = np.array([obj[1] for obj in objectives])\n\n    # Select solutions in the Pareto front or with high potential\n    pareto_front = []\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and (obj1[j] <= obj1[i] and obj2[j] <= obj2[i] and (obj1[j] < obj1[i] or obj2[j] < obj2[i])):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    # If no Pareto front, select the worst solution (highest sum of objectives)\n    if not pareto_front:\n        selected_idx = np.argmax(obj1 + obj2)\n    else:\n        # Randomly select from Pareto front\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operations\n\n    # Step 1: Random edge exchange (similar to 2-opt but more flexible)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Step 2: Segment inversion with a twist (novel operation)\n    k = np.random.randint(i, j)\n    new_solution[i:k+1] = base_solution[i:k+1][::-1]  # Invert segment\n    new_solution[k+1:j+1] = base_solution[k+1:j+1][::-1]  # Invert remaining segment\n\n    # Ensure feasibility: check for duplicates and repair if necessary\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if inversion causes duplicates\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9095630314133527,
            2.8047528862953186
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with worst objectives)\n    archive_solutions = [sol_obj[0] for sol_obj in archive]\n    objectives = [sol_obj[1] for sol_obj in archive]\n\n    # Normalize objectives to identify promising candidates\n    obj1 = np.array([obj[0] for obj in objectives])\n    obj2 = np.array([obj[1] for obj in objectives])\n\n    # Select solutions in the Pareto front or with high potential\n    pareto_front = []\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and (obj1[j] <= obj1[i] and obj2[j] <= obj2[i] and (obj1[j] < obj1[i] or obj2[j] < obj2[i])):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    # If no Pareto front, select the worst solution (highest sum of objectives)\n    if not pareto_front:\n        selected_idx = np.argmax(obj1 + obj2)\n    else:\n        # Randomly select from Pareto front\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operations\n\n    # Step 1: Random edge exchange (similar to 2-opt but more flexible)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Step 2: Segment inversion with a twist (novel operation)\n    k = np.random.randint(i, j)\n    new_solution[i:k+1] = base_solution[i:k+1][::-1]  # Invert segment\n    new_solution[k+1:j+1] = base_solution[k+1:j+1][::-1]  # Invert remaining segment\n\n    # Ensure feasibility: check for duplicates and repair if necessary\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if inversion causes duplicates\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 32,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value to encourage improvement\n    selected_idx = np.argmax([sum(obj) for (_, obj) in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combination of 2-opt and node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and node insertion\n    if np.random.rand() < 0.5:\n        # 2-opt move: select two edges and reverse the segment between them\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Node insertion: remove a random node and insert it in a new position\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.93132915948248,
            2.6659398078918457
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value to encourage improvement\n    selected_idx = np.argmax([sum(obj) for (_, obj) in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combination of 2-opt and node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and node insertion\n    if np.random.rand() < 0.5:\n        # 2-opt move: select two edges and reverse the segment between them\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Node insertion: remove a random node and insert it in a new position\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 33,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a novel segment inversion strategy\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Randomly select 3 distinct edges to perform 3-opt\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment1 = base_solution[a:b+1]\n    segment2 = base_solution[b+1:c+1]\n    segment3 = np.concatenate([base_solution[c+1:], base_solution[:a]])\n\n    # Step 2: Reconnect segments in a novel way to create a new tour\n    # Option 1: Reverse segment2 and connect in order\n    new_segments = [segment1, segment2[::-1], segment3]\n    candidate1 = np.concatenate(new_segments)\n\n    # Option 2: Invert a random segment within segment2\n    if len(segment2) > 1:\n        inv_start, inv_end = sorted(random.sample(range(len(segment2)), 2))\n        segment2[inv_start:inv_end+1] = segment2[inv_start:inv_end+1][::-1]\n        new_segments = [segment1, segment2, segment3]\n        candidate2 = np.concatenate(new_segments)\n    else:\n        candidate2 = candidate1\n\n    # Step 3: Select the best candidate based on both objectives\n    def evaluate(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1))\n        cost1 += distance_matrix_1[solution[-1], solution[0]]  # Complete the tour\n        cost2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1))\n        cost2 += distance_matrix_2[solution[-1], solution[0]]\n        return (cost1, cost2)\n\n    base_cost = evaluate(base_solution)\n    cost1 = evaluate(candidate1)\n    cost2 = evaluate(candidate2)\n\n    # Select the candidate that improves both objectives or the one with the best trade-off\n    if (cost1[0] <= base_cost[0] and cost1[1] <= base_cost[1]) or (cost2[0] <= base_cost[0] and cost2[1] <= base_cost[1]):\n        new_solution = candidate1 if (cost1[0] + cost1[1]) <= (cost2[0] + cost2[1]) else candidate2\n    else:\n        # If no improvement, randomly select one to maintain diversity\n        new_solution = random.choice([candidate1, candidate2])\n\n    return new_solution\n\n",
        "score": [
            -0.8327874222028786,
            2.424137592315674
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a novel segment inversion strategy\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Randomly select 3 distinct edges to perform 3-opt\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment1 = base_solution[a:b+1]\n    segment2 = base_solution[b+1:c+1]\n    segment3 = np.concatenate([base_solution[c+1:], base_solution[:a]])\n\n    # Step 2: Reconnect segments in a novel way to create a new tour\n    # Option 1: Reverse segment2 and connect in order\n    new_segments = [segment1, segment2[::-1], segment3]\n    candidate1 = np.concatenate(new_segments)\n\n    # Option 2: Invert a random segment within segment2\n    if len(segment2) > 1:\n        inv_start, inv_end = sorted(random.sample(range(len(segment2)), 2))\n        segment2[inv_start:inv_end+1] = segment2[inv_start:inv_end+1][::-1]\n        new_segments = [segment1, segment2, segment3]\n        candidate2 = np.concatenate(new_segments)\n    else:\n        candidate2 = candidate1\n\n    # Step 3: Select the best candidate based on both objectives\n    def evaluate(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1))\n        cost1 += distance_matrix_1[solution[-1], solution[0]]  # Complete the tour\n        cost2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1))\n        cost2 += distance_matrix_2[solution[-1], solution[0]]\n        return (cost1, cost2)\n\n    base_cost = evaluate(base_solution)\n    cost1 = evaluate(candidate1)\n    cost2 = evaluate(candidate2)\n\n    # Select the candidate that improves both objectives or the one with the best trade-off\n    if (cost1[0] <= base_cost[0] and cost1[1] <= base_cost[1]) or (cost2[0] <= base_cost[0] and cost2[1] <= base_cost[1]):\n        new_solution = candidate1 if (cost1[0] + cost1[1]) <= (cost2[0] + cost2[1]) else candidate2\n    else:\n        # If no improvement, randomly select one to maintain diversity\n        new_solution = random.choice([candidate1, candidate2])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 34,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate potential improvement scores (inverse of current cost)\n    objectives = np.array([obj for _, obj in archive])\n    inv_costs = 1.0 / (objectives.sum(axis=1) + 1e-6)  # Avoid division by zero\n    probabilities = inv_costs / inv_costs.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: 3-opt + node swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose a segment to modify\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    c = random.randint(0, n - 1)\n    a, b, c = sorted([a, b, c])\n\n    # Apply 3-opt move\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    new_solution[a:c] = np.concatenate([segment2, segment1])\n\n    # Apply node swap with probability 0.5\n    if random.random() < 0.5 and n > 2:\n        swap1, swap2 = random.sample(range(n), 2)\n        new_solution[swap1], new_solution[swap2] = new_solution[swap2], new_solution[swap1]\n\n    # Ensure the solution remains feasible\n    if not np.array_equal(np.unique(new_solution), np.unique(base_solution)):\n        new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.7921640702163769,
            2.2256610989570618
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate potential improvement scores (inverse of current cost)\n    objectives = np.array([obj for _, obj in archive])\n    inv_costs = 1.0 / (objectives.sum(axis=1) + 1e-6)  # Avoid division by zero\n    probabilities = inv_costs / inv_costs.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: 3-opt + node swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose a segment to modify\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    c = random.randint(0, n - 1)\n    a, b, c = sorted([a, b, c])\n\n    # Apply 3-opt move\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    new_solution[a:c] = np.concatenate([segment2, segment1])\n\n    # Apply node swap with probability 0.5\n    if random.random() < 0.5 and n > 2:\n        swap1, swap2 = random.sample(range(n), 2)\n        new_solution[swap1], new_solution[swap2] = new_solution[swap2], new_solution[swap1]\n\n    # Ensure the solution remains feasible\n    if not np.array_equal(np.unique(new_solution), np.unique(base_solution)):\n        new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 35,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability of being non-dominated or with high diversity\n    candidates = [sol for sol, _ in archive]\n    if len(candidates) > 1:\n        # Randomly select a solution with a bias towards those with lower costs\n        weights = [1.0 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]  # Avoid division by zero\n        selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = candidates[0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 3-opt and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Choose a segment to modify\n        seg_start = random.randint(0, n - 4)\n        seg_length = random.randint(2, min(4, n - seg_start - 1))\n\n        # Extract the segment and reverse it\n        segment = new_solution[seg_start:seg_start + seg_length]\n        new_solution[seg_start:seg_start + seg_length] = segment[::-1]\n\n        # With some probability, apply a 3-opt move\n        if random.random() < 0.5 and n >= 6:\n            # Select three non-overlapping edges to reconnect\n            a, b, c = sorted(random.sample(range(n), 3))\n            # Reconnect the edges in a different order\n            new_solution[a:b] = new_solution[a:b][::-1]\n            new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == len(base_solution), \"Invalid solution length\"\n    assert len(np.unique(new_solution)) == len(new_solution), \"Duplicate nodes in solution\"\n\n    return new_solution\n\n",
        "score": [
            -0.8204817127373423,
            2.183180570602417
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability of being non-dominated or with high diversity\n    candidates = [sol for sol, _ in archive]\n    if len(candidates) > 1:\n        # Randomly select a solution with a bias towards those with lower costs\n        weights = [1.0 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]  # Avoid division by zero\n        selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = candidates[0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 3-opt and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Choose a segment to modify\n        seg_start = random.randint(0, n - 4)\n        seg_length = random.randint(2, min(4, n - seg_start - 1))\n\n        # Extract the segment and reverse it\n        segment = new_solution[seg_start:seg_start + seg_length]\n        new_solution[seg_start:seg_start + seg_length] = segment[::-1]\n\n        # With some probability, apply a 3-opt move\n        if random.random() < 0.5 and n >= 6:\n            # Select three non-overlapping edges to reconnect\n            a, b, c = sorted(random.sample(range(n), 3))\n            # Reconnect the edges in a different order\n            new_solution[a:b] = new_solution[a:b][::-1]\n            new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == len(base_solution), \"Invalid solution length\"\n    assert len(np.unique(new_solution)) == len(new_solution), \"Duplicate nodes in solution\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 36,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with high variance in objectives)\n    objectives = [obj for _, obj in archive]\n    objective_variance = [np.var(obj) for obj in objectives]\n    selected_index = np.argmax(objective_variance)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply operators\n\n    # Step 1: Edge exchange with multi-objective consideration\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n\n    # Evaluate edge exchange in both objectives\n    def edge_exchange_cost(sol, i, j):\n        n = len(sol)\n        prev_i = (i - 1) % n\n        next_i = (i + 1) % n\n        prev_j = (j - 1) % n\n        next_j = (j + 1) % n\n\n        # Current cost\n        cost1 = (distance_matrix_1[sol[prev_i], sol[i]] + distance_matrix_1[sol[i], sol[next_i]] +\n                 distance_matrix_1[sol[prev_j], sol[j]] + distance_matrix_1[sol[j], sol[next_j]])\n        cost2 = (distance_matrix_2[sol[prev_i], sol[i]] + distance_matrix_2[sol[i], sol[next_i]] +\n                 distance_matrix_2[sol[prev_j], sol[j]] + distance_matrix_2[sol[j], sol[next_j]])\n\n        # Proposed cost\n        new_cost1 = (distance_matrix_1[sol[prev_i], sol[j]] + distance_matrix_1[sol[j], sol[next_i]] +\n                     distance_matrix_1[sol[prev_j], sol[i]] + distance_matrix_1[sol[i], sol[next_j]])\n        new_cost2 = (distance_matrix_2[sol[prev_i], sol[j]] + distance_matrix_2[sol[j], sol[next_i]] +\n                     distance_matrix_2[sol[prev_j], sol[i]] + distance_matrix_2[sol[i], sol[next_j]])\n\n        return (new_cost1 - cost1, new_cost2 - cost2)\n\n    delta_cost1, delta_cost2 = edge_exchange_cost(new_solution, i, j)\n\n    # Accept if both objectives improve or one improves significantly while the other doesn't worsen too much\n    if (delta_cost1 < 0 and delta_cost2 < 0) or (delta_cost1 < 0 and delta_cost2 < 0.1 * abs(delta_cost1)) or (delta_cost2 < 0 and delta_cost1 < 0.1 * abs(delta_cost2)):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment relocation with multi-objective consideration\n    if n >= 6:\n        # Select a random segment\n        seg_start = random.randint(0, n - 3)\n        seg_end = random.randint(seg_start + 2, min(seg_start + 5, n - 1))\n\n        # Select a random insertion point\n        insert_pos = random.randint(0, n - 1)\n        while insert_pos >= seg_start and insert_pos <= seg_end:\n            insert_pos = random.randint(0, n - 1)\n\n        # Extract the segment\n        segment = new_solution[seg_start:seg_end+1]\n        remaining = np.concatenate([new_solution[:seg_start], new_solution[seg_end+1:]])\n\n        # Insert the segment\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.3515736858612881,
            3.83267605304718
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with high variance in objectives)\n    objectives = [obj for _, obj in archive]\n    objective_variance = [np.var(obj) for obj in objectives]\n    selected_index = np.argmax(objective_variance)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply operators\n\n    # Step 1: Edge exchange with multi-objective consideration\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n\n    # Evaluate edge exchange in both objectives\n    def edge_exchange_cost(sol, i, j):\n        n = len(sol)\n        prev_i = (i - 1) % n\n        next_i = (i + 1) % n\n        prev_j = (j - 1) % n\n        next_j = (j + 1) % n\n\n        # Current cost\n        cost1 = (distance_matrix_1[sol[prev_i], sol[i]] + distance_matrix_1[sol[i], sol[next_i]] +\n                 distance_matrix_1[sol[prev_j], sol[j]] + distance_matrix_1[sol[j], sol[next_j]])\n        cost2 = (distance_matrix_2[sol[prev_i], sol[i]] + distance_matrix_2[sol[i], sol[next_i]] +\n                 distance_matrix_2[sol[prev_j], sol[j]] + distance_matrix_2[sol[j], sol[next_j]])\n\n        # Proposed cost\n        new_cost1 = (distance_matrix_1[sol[prev_i], sol[j]] + distance_matrix_1[sol[j], sol[next_i]] +\n                     distance_matrix_1[sol[prev_j], sol[i]] + distance_matrix_1[sol[i], sol[next_j]])\n        new_cost2 = (distance_matrix_2[sol[prev_i], sol[j]] + distance_matrix_2[sol[j], sol[next_i]] +\n                     distance_matrix_2[sol[prev_j], sol[i]] + distance_matrix_2[sol[i], sol[next_j]])\n\n        return (new_cost1 - cost1, new_cost2 - cost2)\n\n    delta_cost1, delta_cost2 = edge_exchange_cost(new_solution, i, j)\n\n    # Accept if both objectives improve or one improves significantly while the other doesn't worsen too much\n    if (delta_cost1 < 0 and delta_cost2 < 0) or (delta_cost1 < 0 and delta_cost2 < 0.1 * abs(delta_cost1)) or (delta_cost2 < 0 and delta_cost1 < 0.1 * abs(delta_cost2)):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment relocation with multi-objective consideration\n    if n >= 6:\n        # Select a random segment\n        seg_start = random.randint(0, n - 3)\n        seg_end = random.randint(seg_start + 2, min(seg_start + 5, n - 1))\n\n        # Select a random insertion point\n        insert_pos = random.randint(0, n - 1)\n        while insert_pos >= seg_start and insert_pos <= seg_end:\n            insert_pos = random.randint(0, n - 1)\n\n        # Extract the segment\n        segment = new_solution[seg_start:seg_end+1]\n        remaining = np.concatenate([new_solution[:seg_start], new_solution[seg_end+1:]])\n\n        # Insert the segment\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 37,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    total_costs = objectives.sum(axis=1)\n    probabilities = 1 / (total_costs + 1e-6)  # Avoid division by zero\n    probabilities = probabilities / probabilities.sum()\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of segment inversion and node swap\n    n = len(new_solution)\n    if n < 4:\n        # For very small instances, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # With 70% probability, perform a segment inversion\n        if random.random() < 0.7:\n            start, end = sorted(random.sample(range(n), 2))\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n        else:\n            # With 30% probability, perform a node swap between two segments\n            split = random.randint(2, n-2)\n            first_part = new_solution[:split]\n            second_part = new_solution[split:]\n            i, j = random.randint(0, len(first_part)-1), random.randint(0, len(second_part)-1)\n            first_part[i], second_part[j] = second_part[j], first_part[i]\n            new_solution = np.concatenate([first_part, second_part])\n\n    return new_solution\n\n",
        "score": [
            -0.9066607431195499,
            2.125530421733856
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    total_costs = objectives.sum(axis=1)\n    probabilities = 1 / (total_costs + 1e-6)  # Avoid division by zero\n    probabilities = probabilities / probabilities.sum()\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of segment inversion and node swap\n    n = len(new_solution)\n    if n < 4:\n        # For very small instances, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # With 70% probability, perform a segment inversion\n        if random.random() < 0.7:\n            start, end = sorted(random.sample(range(n), 2))\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n        else:\n            # With 30% probability, perform a node swap between two segments\n            split = random.randint(2, n-2)\n            first_part = new_solution[:split]\n            second_part = new_solution[split:]\n            i, j = random.randint(0, len(first_part)-1), random.randint(0, len(second_part)-1)\n            first_part[i], second_part[j] = second_part[j], first_part[i]\n            new_solution = np.concatenate([first_part, second_part])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 38,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    import numpy as np\n\n    # Select a solution with a probability proportional to its potential for improvement\n    if len(archive) > 1:\n        # Calculate the \"potential\" for each solution (e.g., based on objective values)\n        potentials = [sum(obj) for (sol, obj) in archive]\n        min_potential = min(potentials)\n        max_potential = max(potentials)\n        if max_potential == min_potential:\n            probabilities = [1.0 / len(archive)] * len(archive)\n        else:\n            normalized = [(p - min_potential) / (max_potential - min_potential) for p in potentials]\n            probabilities = [1 - n for n in normalized]  # Higher potential -> higher selection probability\n            total = sum(probabilities)\n            probabilities = [p / total for p in probabilities]\n\n        # Select a solution based on the calculated probabilities\n        selected_idx = random.choices(range(len(archive)), weights=probabilities, k=1)[0]\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with a custom move\n    n = len(new_solution)\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n\n    # Apply a custom move: reverse a segment and then insert a random segment elsewhere\n    segment = new_solution[i:j+1]\n    remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n    new_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:new_pos], segment[::-1], remaining[new_pos:]])\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to a simple swap if the custom move fails\n        k, l = random.sample(range(n), 2)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.8311527348805703,
            2.0113943815231323
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    import numpy as np\n\n    # Select a solution with a probability proportional to its potential for improvement\n    if len(archive) > 1:\n        # Calculate the \"potential\" for each solution (e.g., based on objective values)\n        potentials = [sum(obj) for (sol, obj) in archive]\n        min_potential = min(potentials)\n        max_potential = max(potentials)\n        if max_potential == min_potential:\n            probabilities = [1.0 / len(archive)] * len(archive)\n        else:\n            normalized = [(p - min_potential) / (max_potential - min_potential) for p in potentials]\n            probabilities = [1 - n for n in normalized]  # Higher potential -> higher selection probability\n            total = sum(probabilities)\n            probabilities = [p / total for p in probabilities]\n\n        # Select a solution based on the calculated probabilities\n        selected_idx = random.choices(range(len(archive)), weights=probabilities, k=1)[0]\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with a custom move\n    n = len(new_solution)\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n\n    # Apply a custom move: reverse a segment and then insert a random segment elsewhere\n    segment = new_solution[i:j+1]\n    remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n    new_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:new_pos], segment[::-1], remaining[new_pos:]])\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to a simple swap if the custom move fails\n        k, l = random.sample(range(n), 2)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 39,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high diversity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine edge-swap and segment-reversal\n    n = len(base_solution)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Edge-swap: swap two edges (a, b) and (c, d) with (a, c) and (b, d)\n    if a != c and b != d:\n        new_solution = np.concatenate([\n            base_solution[:a], base_solution[c:d+1], base_solution[b:c], base_solution[a:b], base_solution[d+1:]\n        ])\n\n    # Segment-reversal: reverse a segment between two random nodes\n    if np.random.random() < 0.5:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility (no duplicates or skips)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7951079967660358,
            1.0035297870635986
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high diversity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine edge-swap and segment-reversal\n    n = len(base_solution)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Edge-swap: swap two edges (a, b) and (c, d) with (a, c) and (b, d)\n    if a != c and b != d:\n        new_solution = np.concatenate([\n            base_solution[:a], base_solution[c:d+1], base_solution[b:c], base_solution[a:b], base_solution[d+1:]\n        ])\n\n    # Segment-reversal: reverse a segment between two random nodes\n    if np.random.random() < 0.5:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility (no duplicates or skips)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 39,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high diversity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine edge-swap and segment-reversal\n    n = len(base_solution)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Edge-swap: swap two edges (a, b) and (c, d) with (a, c) and (b, d)\n    if a != c and b != d:\n        new_solution = np.concatenate([\n            base_solution[:a], base_solution[c:d+1], base_solution[b:c], base_solution[a:b], base_solution[d+1:]\n        ])\n\n    # Segment-reversal: reverse a segment between two random nodes\n    if np.random.random() < 0.5:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility (no duplicates or skips)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7951079967660358,
            1.0035297870635986
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high diversity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine edge-swap and segment-reversal\n    n = len(base_solution)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Edge-swap: swap two edges (a, b) and (c, d) with (a, c) and (b, d)\n    if a != c and b != d:\n        new_solution = np.concatenate([\n            base_solution[:a], base_solution[c:d+1], base_solution[b:c], base_solution[a:b], base_solution[d+1:]\n        ])\n\n    # Segment-reversal: reverse a segment between two random nodes\n    if np.random.random() < 0.5:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility (no duplicates or skips)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 40,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on a combination of objective values and diversity\n    def selection_criterion(solution_obj):\n        # Prefer solutions with lower combined objective values but also ensure diversity\n        return solution_obj[0] + solution_obj[1] + random.uniform(-0.1, 0.1) * (solution_obj[0] + solution_obj[1])\n\n    selected_solution = min(archive, key=lambda x: selection_criterion(x[1]))[0].copy()\n\n    # Hybrid local search strategy\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment and reverse it (segment reversal)\n    if n > 3:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 2: Randomly insert a node into a different position (edge insertion)\n    if n > 2:\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            insert_pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 3: Randomly swap two segments (crossover-like operation)\n    if n > 4:\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([\n            new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n        ])\n\n    # Ensure the solution is valid (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9353622289382217,
            2.2776222825050354
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on a combination of objective values and diversity\n    def selection_criterion(solution_obj):\n        # Prefer solutions with lower combined objective values but also ensure diversity\n        return solution_obj[0] + solution_obj[1] + random.uniform(-0.1, 0.1) * (solution_obj[0] + solution_obj[1])\n\n    selected_solution = min(archive, key=lambda x: selection_criterion(x[1]))[0].copy()\n\n    # Hybrid local search strategy\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment and reverse it (segment reversal)\n    if n > 3:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 2: Randomly insert a node into a different position (edge insertion)\n    if n > 2:\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            insert_pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 3: Randomly swap two segments (crossover-like operation)\n    if n > 4:\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([\n            new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n        ])\n\n    # Ensure the solution is valid (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 41,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a bias towards those with lower total cost\n    objectives = np.array([obj for _, obj in archive])\n    total_costs = objectives.sum(axis=1)\n    probabilities = 1 / (total_costs + 1e-6)  # Avoid division by zero\n    probabilities /= probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion with biased random walk\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful local search\n\n    # Step 1: Select a segment to remove (biased towards longer segments)\n    segment_length = min(3, n // 4)\n    if n > 4:\n        segment_length = np.random.randint(2, min(5, n // 2))\n\n    start = np.random.randint(0, n - segment_length)\n    segment = new_solution[start:start + segment_length]\n\n    # Step 2: Remove the segment and reinsert it at a new position\n    remaining = np.concatenate([new_solution[:start], new_solution[start + segment_length:]])\n\n    # Step 3: Find the best insertion point considering both objectives\n    best_insert_pos = 0\n    best_cost = float('inf')\n\n    for i in range(len(remaining)):\n        # Insert segment at position i\n        candidate = np.concatenate([remaining[:i], segment, remaining[i:]])\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert_pos = i\n\n    # Apply the best insertion\n    new_solution = np.concatenate([remaining[:best_insert_pos], segment, remaining[best_insert_pos:]])\n\n    # Step 4: Apply a biased random walk to escape local optima\n    if np.random.random() < 0.3:  # 30% chance of applying the walk\n        walk_length = np.random.randint(1, min(3, n // 3))\n        for _ in range(walk_length):\n            i, j = np.random.choice(n, 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7932293981869661,
            13.617588222026825
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a bias towards those with lower total cost\n    objectives = np.array([obj for _, obj in archive])\n    total_costs = objectives.sum(axis=1)\n    probabilities = 1 / (total_costs + 1e-6)  # Avoid division by zero\n    probabilities /= probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion with biased random walk\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful local search\n\n    # Step 1: Select a segment to remove (biased towards longer segments)\n    segment_length = min(3, n // 4)\n    if n > 4:\n        segment_length = np.random.randint(2, min(5, n // 2))\n\n    start = np.random.randint(0, n - segment_length)\n    segment = new_solution[start:start + segment_length]\n\n    # Step 2: Remove the segment and reinsert it at a new position\n    remaining = np.concatenate([new_solution[:start], new_solution[start + segment_length:]])\n\n    # Step 3: Find the best insertion point considering both objectives\n    best_insert_pos = 0\n    best_cost = float('inf')\n\n    for i in range(len(remaining)):\n        # Insert segment at position i\n        candidate = np.concatenate([remaining[:i], segment, remaining[i:]])\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert_pos = i\n\n    # Apply the best insertion\n    new_solution = np.concatenate([remaining[:best_insert_pos], segment, remaining[best_insert_pos:]])\n\n    # Step 4: Apply a biased random walk to escape local optima\n    if np.random.random() < 0.3:  # 30% chance of applying the walk\n        walk_length = np.random.randint(1, min(3, n // 3))\n        for _ in range(walk_length):\n            i, j = np.random.choice(n, 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 42,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty. Cannot select a neighbor.\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    norm_objectives = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    weights = 1 / (norm_objectives.sum(axis=1) + 1e-10)  # Higher weight for better solutions\n    weights = weights / weights.sum()  # Normalize weights\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: Edge Insertion + Node Swap\n    if n < 4:\n        # For small instances, perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Edge Insertion: Remove a random edge and reinsert it\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:i+1], [node], new_solution[i+1:j], new_solution[j+1:]])\n        # Ensure the solution remains a valid tour\n        if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n            new_solution = base_solution.copy()\n\n        # Node Swap: Swap two nodes if it improves the total distance in either objective space\n        i, j = random.sample(range(n), 2)\n        # Calculate the change in total distance for both objectives\n        delta_1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]\n                   - distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[j], new_solution[j]])\n        delta_2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]\n                   - distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[j], new_solution[j]])\n        if delta_1 < 0 or delta_2 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9079602300702847,
            2.3169315457344055
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty. Cannot select a neighbor.\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    norm_objectives = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    weights = 1 / (norm_objectives.sum(axis=1) + 1e-10)  # Higher weight for better solutions\n    weights = weights / weights.sum()  # Normalize weights\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: Edge Insertion + Node Swap\n    if n < 4:\n        # For small instances, perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Edge Insertion: Remove a random edge and reinsert it\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:i+1], [node], new_solution[i+1:j], new_solution[j+1:]])\n        # Ensure the solution remains a valid tour\n        if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n            new_solution = base_solution.copy()\n\n        # Node Swap: Swap two nodes if it improves the total distance in either objective space\n        i, j = random.sample(range(n), 2)\n        # Calculate the change in total distance for both objectives\n        delta_1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]\n                   - distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[j], new_solution[j]])\n        delta_2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]\n                   - distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[j], new_solution[j]])\n        if delta_1 < 0 or delta_2 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 43,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest sum of objectives)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Step 1: 3-opt move (select 3 random non-adjacent edges and reconnect)\n    a, b, c = sorted(random.sample(range(n), 3))\n    while (b - a) == 1 or (c - b) == 1:  # Ensure edges are not adjacent\n        a, b, c = sorted(random.sample(range(n), 3))\n\n    # Reconnect the edges in a different way to create a new tour\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]  # Reverse segment\n    new_solution[b:c+1] = new_solution[b:c+1][::-1]  # Reverse another segment\n\n    # Step 2: Segment inversion with objective-aware decision\n    # Choose a segment to invert based on which objective would benefit more\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j+1]\n\n    # Calculate improvement potential for both objectives\n    def calculate_improvement(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        return cost1, cost2\n\n    original_cost1, original_cost2 = calculate_improvement(new_solution)\n    inverted_segment = segment[::-1]\n    temp_solution = new_solution.copy()\n    temp_solution[i:j+1] = inverted_segment\n    inverted_cost1, inverted_cost2 = calculate_improvement(temp_solution)\n\n    # Accept inversion if it improves at least one objective\n    if (inverted_cost1 < original_cost1) or (inverted_cost2 < original_cost2):\n        new_solution = temp_solution\n\n    # Step 3: Swap-based perturbation for diversification\n    if random.random() < 0.3:  # 30% chance of swap perturbation\n        k, l = random.sample(range(n), 2)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.725671944527985,
            1.7834753394126892
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest sum of objectives)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Step 1: 3-opt move (select 3 random non-adjacent edges and reconnect)\n    a, b, c = sorted(random.sample(range(n), 3))\n    while (b - a) == 1 or (c - b) == 1:  # Ensure edges are not adjacent\n        a, b, c = sorted(random.sample(range(n), 3))\n\n    # Reconnect the edges in a different way to create a new tour\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]  # Reverse segment\n    new_solution[b:c+1] = new_solution[b:c+1][::-1]  # Reverse another segment\n\n    # Step 2: Segment inversion with objective-aware decision\n    # Choose a segment to invert based on which objective would benefit more\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j+1]\n\n    # Calculate improvement potential for both objectives\n    def calculate_improvement(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        return cost1, cost2\n\n    original_cost1, original_cost2 = calculate_improvement(new_solution)\n    inverted_segment = segment[::-1]\n    temp_solution = new_solution.copy()\n    temp_solution[i:j+1] = inverted_segment\n    inverted_cost1, inverted_cost2 = calculate_improvement(temp_solution)\n\n    # Accept inversion if it improves at least one objective\n    if (inverted_cost1 < original_cost1) or (inverted_cost2 < original_cost2):\n        new_solution = temp_solution\n\n    # Step 3: Swap-based perturbation for diversification\n    if random.random() < 0.3:  # 30% chance of swap perturbation\n        k, l = random.sample(range(n), 2)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 44,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best combined objective (weighted sum)\n    weights = [0.5, 0.5]  # Equal weights for both objectives\n    best_idx = 0\n    best_score = np.inf\n    for i, (sol, obj) in enumerate(archive):\n        score = weights[0] * obj[0] + weights[1] * obj[1]\n        if score < best_score:\n            best_score = score\n            best_idx = i\n\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine edge insertion and segment reversal\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # No possible improvement for small tours\n\n    # Randomly select a segment to modify\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Edge insertion: move segment [a, b] to a random position\n    segment = new_solution[a:b+1]\n    remaining = np.concatenate([new_solution[:a], new_solution[b+1:]])\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Segment reversal: reverse a random segment to explore different configurations\n    c = random.randint(0, n - 1)\n    d = random.randint(0, n - 1)\n    if c > d:\n        c, d = d, c\n    new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Ensure the solution remains valid (visits each node exactly once)\n    assert len(new_solution) == len(base_solution) and len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.7217465426664548,
            2.273533523082733
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best combined objective (weighted sum)\n    weights = [0.5, 0.5]  # Equal weights for both objectives\n    best_idx = 0\n    best_score = np.inf\n    for i, (sol, obj) in enumerate(archive):\n        score = weights[0] * obj[0] + weights[1] * obj[1]\n        if score < best_score:\n            best_score = score\n            best_idx = i\n\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine edge insertion and segment reversal\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # No possible improvement for small tours\n\n    # Randomly select a segment to modify\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Edge insertion: move segment [a, b] to a random position\n    segment = new_solution[a:b+1]\n    remaining = np.concatenate([new_solution[:a], new_solution[b+1:]])\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Segment reversal: reverse a random segment to explore different configurations\n    c = random.randint(0, n - 1)\n    d = random.randint(0, n - 1)\n    if c > d:\n        c, d = d, c\n    new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Ensure the solution remains valid (visits each node exactly once)\n    assert len(new_solution) == len(base_solution) and len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 45,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., high cost or dominated by others)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_costs = [cost for _, cost in archive]\n\n    # Calculate dominance counts to identify promising solutions\n    dominance_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (archive_costs[i][0] <= archive_costs[j][0] and archive_costs[i][1] <= archive_costs[j][1]) and (archive_costs[i][0] < archive_costs[j][0] or archive_costs[i][1] < archive_costs[j][1]):\n                    dominance_counts[i] += 1\n\n    # Select the solution with the highest dominance count (most promising for improvement)\n    selected_idx = np.argmax(dominance_counts)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-swap based on objective diversity\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform a 3-opt move (select three random edges and reconnect them)\n    i, j, k = sorted(np.random.choice(np.arange(1, n-1), 3, replace=False))\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Reconnect segments in a new order to explore diverse solutions\n    new_order = [segment1, segment2[::-1], segment3, segment4[::-1]]\n    new_solution = np.concatenate(new_order)\n\n    # Apply an edge-swap based on objective diversity (swap edges that are diverse in both objectives)\n    for _ in range(2):  # Perform a few swaps\n        a, b = np.random.choice(np.arange(1, n-1), 2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Calculate the cost difference in both objectives\n        old_edges = [(new_solution[a-1], new_solution[a]), (new_solution[b-1], new_solution[b])]\n        new_edges = [(new_solution[a-1], new_solution[b]), (new_solution[a], new_solution[b-1])]\n\n        cost_diff1 = (distance_matrix_1[old_edges[0][0], old_edges[0][1]] + distance_matrix_1[old_edges[1][0], old_edges[1][1]]) - \\\n                     (distance_matrix_1[new_edges[0][0], new_edges[0][1]] + distance_matrix_1[new_edges[1][0], new_edges[1][1]])\n\n        cost_diff2 = (distance_matrix_2[old_edges[0][0], old_edges[0][1]] + distance_matrix_2[old_edges[1][0], old_edges[1][1]]) - \\\n                     (distance_matrix_2[new_edges[0][0], new_edges[0][1]] + distance_matrix_2[new_edges[1][0], new_edges[1][1]])\n\n        # If the swap improves both objectives, accept it\n        if cost_diff1 < 0 and cost_diff2 < 0:\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.752722180711643,
            2.725514769554138
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., high cost or dominated by others)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_costs = [cost for _, cost in archive]\n\n    # Calculate dominance counts to identify promising solutions\n    dominance_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (archive_costs[i][0] <= archive_costs[j][0] and archive_costs[i][1] <= archive_costs[j][1]) and (archive_costs[i][0] < archive_costs[j][0] or archive_costs[i][1] < archive_costs[j][1]):\n                    dominance_counts[i] += 1\n\n    # Select the solution with the highest dominance count (most promising for improvement)\n    selected_idx = np.argmax(dominance_counts)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-swap based on objective diversity\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform a 3-opt move (select three random edges and reconnect them)\n    i, j, k = sorted(np.random.choice(np.arange(1, n-1), 3, replace=False))\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Reconnect segments in a new order to explore diverse solutions\n    new_order = [segment1, segment2[::-1], segment3, segment4[::-1]]\n    new_solution = np.concatenate(new_order)\n\n    # Apply an edge-swap based on objective diversity (swap edges that are diverse in both objectives)\n    for _ in range(2):  # Perform a few swaps\n        a, b = np.random.choice(np.arange(1, n-1), 2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Calculate the cost difference in both objectives\n        old_edges = [(new_solution[a-1], new_solution[a]), (new_solution[b-1], new_solution[b])]\n        new_edges = [(new_solution[a-1], new_solution[b]), (new_solution[a], new_solution[b-1])]\n\n        cost_diff1 = (distance_matrix_1[old_edges[0][0], old_edges[0][1]] + distance_matrix_1[old_edges[1][0], old_edges[1][1]]) - \\\n                     (distance_matrix_1[new_edges[0][0], new_edges[0][1]] + distance_matrix_1[new_edges[1][0], new_edges[1][1]])\n\n        cost_diff2 = (distance_matrix_2[old_edges[0][0], old_edges[0][1]] + distance_matrix_2[old_edges[1][0], old_edges[1][1]]) - \\\n                     (distance_matrix_2[new_edges[0][0], new_edges[0][1]] + distance_matrix_2[new_edges[1][0], new_edges[1][1]])\n\n        # If the swap improves both objectives, accept it\n        if cost_diff1 < 0 and cost_diff2 < 0:\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 46,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their combined objective values (weighted sum)\n        archive_sorted = sorted(archive, key=lambda x: 0.5 * x[1][0] + 0.5 * x[1][1])\n        # Select a solution with high probability from the top 30% of the archive\n        top_n = max(1, int(0.3 * len(archive_sorted)))\n        selected_solution = random.choice(archive_sorted[:top_n])[0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: Combination of edge insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Choose between edge insertion or segment reversal with equal probability\n        if random.random() < 0.5:\n            # Edge insertion (similar to Lin-Kernighan but simplified)\n            a, b, c = random.sample(range(n), 3)\n            if a > b:\n                a, b = b, a\n            if b > c:\n                b, c = c, b\n            if a > b:\n                a, b = b, a\n            # Remove edges (a,b) and (b,c), insert (a,c) and (b,b) (which is invalid, so we need to adjust)\n            segment = new_solution[a:b+1]\n            new_solution = np.concatenate([new_solution[:a], segment[::-1], new_solution[b+1:]])\n        else:\n            # Segment reversal (similar to 2-opt but with variable segment lengths)\n            i, j = sorted(random.sample(range(n), 2))\n            # Ensure the segment length is reasonable (at least 2 nodes)\n            if j - i >= 2:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8017966558686477,
            1.921028196811676
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their combined objective values (weighted sum)\n        archive_sorted = sorted(archive, key=lambda x: 0.5 * x[1][0] + 0.5 * x[1][1])\n        # Select a solution with high probability from the top 30% of the archive\n        top_n = max(1, int(0.3 * len(archive_sorted)))\n        selected_solution = random.choice(archive_sorted[:top_n])[0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: Combination of edge insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Choose between edge insertion or segment reversal with equal probability\n        if random.random() < 0.5:\n            # Edge insertion (similar to Lin-Kernighan but simplified)\n            a, b, c = random.sample(range(n), 3)\n            if a > b:\n                a, b = b, a\n            if b > c:\n                b, c = c, b\n            if a > b:\n                a, b = b, a\n            # Remove edges (a,b) and (b,c), insert (a,c) and (b,b) (which is invalid, so we need to adjust)\n            segment = new_solution[a:b+1]\n            new_solution = np.concatenate([new_solution[:a], segment[::-1], new_solution[b+1:]])\n        else:\n            # Segment reversal (similar to 2-opt but with variable segment lengths)\n            i, j = sorted(random.sample(range(n), 2))\n            # Ensure the segment length is reasonable (at least 2 nodes)\n            if j - i >= 2:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 47,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest combined cost)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(len(archive_sorted) // 4, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combination of edge insertion and segment reversal\n    for _ in range(2):  # Perform multiple perturbations\n        # Randomly select a segment to reverse (3-opt like operation)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        new_solution[a:b+1] = reversed_segment\n\n        # Randomly insert a node elsewhere (edge insertion)\n        if n > 2:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.concatenate([new_solution[:j], [node], new_solution[j:i], new_solution[i+1:]])\n\n    # Ensure the solution remains valid (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or not np.array_equal(np.sort(unique_nodes), np.arange(n)):\n        # If invalid, revert to nearest valid solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8008390654833768,
            0.9309478998184204
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest combined cost)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(len(archive_sorted) // 4, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combination of edge insertion and segment reversal\n    for _ in range(2):  # Perform multiple perturbations\n        # Randomly select a segment to reverse (3-opt like operation)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        new_solution[a:b+1] = reversed_segment\n\n        # Randomly insert a node elsewhere (edge insertion)\n        if n > 2:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.concatenate([new_solution[:j], [node], new_solution[j:i], new_solution[i+1:]])\n\n    # Ensure the solution remains valid (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or not np.array_equal(np.sort(unique_nodes), np.arange(n)):\n        # If invalid, revert to nearest valid solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 47,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest combined cost)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(len(archive_sorted) // 4, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combination of edge insertion and segment reversal\n    for _ in range(2):  # Perform multiple perturbations\n        # Randomly select a segment to reverse (3-opt like operation)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        new_solution[a:b+1] = reversed_segment\n\n        # Randomly insert a node elsewhere (edge insertion)\n        if n > 2:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.concatenate([new_solution[:j], [node], new_solution[j:i], new_solution[i+1:]])\n\n    # Ensure the solution remains valid (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or not np.array_equal(np.sort(unique_nodes), np.arange(n)):\n        # If invalid, revert to nearest valid solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8008390654833768,
            0.9309478998184204
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest combined cost)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(len(archive_sorted) // 4, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combination of edge insertion and segment reversal\n    for _ in range(2):  # Perform multiple perturbations\n        # Randomly select a segment to reverse (3-opt like operation)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        new_solution[a:b+1] = reversed_segment\n\n        # Randomly insert a node elsewhere (edge insertion)\n        if n > 2:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.concatenate([new_solution[:j], [node], new_solution[j:i], new_solution[i+1:]])\n\n    # Ensure the solution remains valid (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or not np.array_equal(np.sort(unique_nodes), np.arange(n)):\n        # If invalid, revert to nearest valid solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 48,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best but not the worst)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    candidate_solutions = sorted_archive[len(sorted_archive)//4 : 3*len(sorted_archive)//4]\n    if not candidate_solutions:\n        candidate_solutions = archive\n    selected = random.choice(candidate_solutions)[0].copy()\n\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge insertion + segment relocation\n    for _ in range(3):  # Perform multiple iterations for better exploration\n        # Edge insertion\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            segment = new_solution[i+1:j]\n            new_solution = np.concatenate([new_solution[:i+1], new_solution[j:], segment])\n\n        # Segment relocation\n        k, l = sorted(random.sample(range(n), 2))\n        if l - k > 1:\n            segment = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:k], new_solution[l:], segment])\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.7340280484734093,
            1.8546615242958069
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best but not the worst)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    candidate_solutions = sorted_archive[len(sorted_archive)//4 : 3*len(sorted_archive)//4]\n    if not candidate_solutions:\n        candidate_solutions = archive\n    selected = random.choice(candidate_solutions)[0].copy()\n\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge insertion + segment relocation\n    for _ in range(3):  # Perform multiple iterations for better exploration\n        # Edge insertion\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            segment = new_solution[i+1:j]\n            new_solution = np.concatenate([new_solution[:i+1], new_solution[j:], segment])\n\n        # Segment relocation\n        k, l = sorted(random.sample(range(n), 2))\n        if l - k > 1:\n            segment = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:k], new_solution[l:], segment])\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 49,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives to find less optimal ones\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select from the middle 60% to balance exploration and exploitation\n        selection_pool = sorted_archive[int(len(archive)*0.2):int(len(archive)*0.8)]\n        selected = random.choice(selection_pool)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    if random.random() < 0.7:  # 70% chance for edge swap (2-opt variant)\n        # Select two random edges to swap\n        i, j = sorted(random.sample(range(1, len(new_solution)), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:  # 30% chance for node insertion\n        # Select a random node and insert it in a new position\n        node_idx = random.randint(0, len(new_solution)-1)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != len(new_solution):\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6687038773358841,
            1.975519061088562
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives to find less optimal ones\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select from the middle 60% to balance exploration and exploitation\n        selection_pool = sorted_archive[int(len(archive)*0.2):int(len(archive)*0.8)]\n        selected = random.choice(selection_pool)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    if random.random() < 0.7:  # 70% chance for edge swap (2-opt variant)\n        # Select two random edges to swap\n        i, j = sorted(random.sample(range(1, len(new_solution)), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:  # 30% chance for node insertion\n        # Select a random node and insert it in a new position\n        node_idx = random.randint(0, len(new_solution)-1)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != len(new_solution):\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 50,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weights = np.array([0.5, 0.5])  # Equal weights for both objectives\n    objectives = np.array([obj for _, obj in archive])\n    scores = np.dot(objectives, weights)\n    best_idx = np.argmin(scores)\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, use a simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # 3-opt with segment-wise perturbation\n        # Select three random segments and reverse them\n        segments = sorted(np.random.choice(np.arange(1, n-1), 3, replace=False))\n        for i in range(3):\n            start = segments[i]\n            end = segments[(i+1) % 3] if i < 2 else n\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Additional segment-wise perturbation for diversity\n        if np.random.rand() < 0.3:\n            seg_size = np.random.randint(2, min(5, n//2))\n            seg_start = np.random.randint(0, n - seg_size)\n            seg_end = seg_start + seg_size\n            new_solution[seg_start:seg_end] = np.roll(new_solution[seg_start:seg_end], shift=1)\n\n    return new_solution\n\n",
        "score": [
            -0.656726444729449,
            1.9402549266815186
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weights = np.array([0.5, 0.5])  # Equal weights for both objectives\n    objectives = np.array([obj for _, obj in archive])\n    scores = np.dot(objectives, weights)\n    best_idx = np.argmin(scores)\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, use a simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # 3-opt with segment-wise perturbation\n        # Select three random segments and reverse them\n        segments = sorted(np.random.choice(np.arange(1, n-1), 3, replace=False))\n        for i in range(3):\n            start = segments[i]\n            end = segments[(i+1) % 3] if i < 2 else n\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Additional segment-wise perturbation for diversity\n        if np.random.rand() < 0.3:\n            seg_size = np.random.randint(2, min(5, n//2))\n            seg_start = np.random.randint(0, n - seg_size)\n            seg_end = seg_start + seg_size\n            new_solution[seg_start:seg_end] = np.roll(new_solution[seg_start:seg_end], shift=1)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 51,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_solution = None\n    selected_obj = None\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if other_obj[0] < obj[0] and other_obj[1] < obj[1]:\n                dominated = True\n                break\n        if not dominated:\n            selected_solution = sol.copy()\n            selected_obj = obj\n            break\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n_nodes = len(new_solution)\n\n    # Hybrid local search: combine 3-opt with a novel segment-based improvement\n    for _ in range(10):  # Limit the number of attempts to avoid excessive computation\n        # Randomly select three distinct segments\n        a, b, c, d = sorted(random.sample(range(1, n_nodes), 4))\n\n        # Apply 3-opt-like move\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        segment3 = new_solution[c:d]\n\n        # Reverse segments with probability 0.5\n        if random.random() < 0.5:\n            segment1 = segment1[::-1]\n        if random.random() < 0.5:\n            segment2 = segment2[::-1]\n        if random.random() < 0.5:\n            segment3 = segment3[::-1]\n\n        # Reconstruct the tour\n        temp_solution = np.concatenate([\n            new_solution[:a],\n            segment1,\n            segment2,\n            segment3,\n            new_solution[d:]\n        ])\n\n        # Check if the new solution is valid (no duplicates, all nodes present)\n        if len(np.unique(temp_solution)) == n_nodes:\n            new_solution = temp_solution\n\n    # Novel segment-based improvement: swap two non-adjacent segments\n    for _ in range(5):\n        a, b, c, d = sorted(random.sample(range(1, n_nodes), 4))\n        if a >= b or c >= d:\n            continue\n\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[c:d]\n\n        # Swap segments\n        temp_solution = np.concatenate([\n            new_solution[:a],\n            segment2,\n            new_solution[b:c],\n            segment1,\n            new_solution[d:]\n        ])\n\n        if len(np.unique(temp_solution)) == n_nodes:\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7329910035490844,
            2.581971526145935
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_solution = None\n    selected_obj = None\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if other_obj[0] < obj[0] and other_obj[1] < obj[1]:\n                dominated = True\n                break\n        if not dominated:\n            selected_solution = sol.copy()\n            selected_obj = obj\n            break\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n_nodes = len(new_solution)\n\n    # Hybrid local search: combine 3-opt with a novel segment-based improvement\n    for _ in range(10):  # Limit the number of attempts to avoid excessive computation\n        # Randomly select three distinct segments\n        a, b, c, d = sorted(random.sample(range(1, n_nodes), 4))\n\n        # Apply 3-opt-like move\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        segment3 = new_solution[c:d]\n\n        # Reverse segments with probability 0.5\n        if random.random() < 0.5:\n            segment1 = segment1[::-1]\n        if random.random() < 0.5:\n            segment2 = segment2[::-1]\n        if random.random() < 0.5:\n            segment3 = segment3[::-1]\n\n        # Reconstruct the tour\n        temp_solution = np.concatenate([\n            new_solution[:a],\n            segment1,\n            segment2,\n            segment3,\n            new_solution[d:]\n        ])\n\n        # Check if the new solution is valid (no duplicates, all nodes present)\n        if len(np.unique(temp_solution)) == n_nodes:\n            new_solution = temp_solution\n\n    # Novel segment-based improvement: swap two non-adjacent segments\n    for _ in range(5):\n        a, b, c, d = sorted(random.sample(range(1, n_nodes), 4))\n        if a >= b or c >= d:\n            continue\n\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[c:d]\n\n        # Swap segments\n        temp_solution = np.concatenate([\n            new_solution[:a],\n            segment2,\n            new_solution[b:c],\n            segment1,\n            new_solution[d:]\n        ])\n\n        if len(np.unique(temp_solution)) == n_nodes:\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 52,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-dominated or high variance)\n    selected_idx = np.argmax([(obj[0] + obj[1]) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of edge swaps and node insertions\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful improvement possible\n\n    # Randomly choose between edge swap and node insertion\n    if random.random() < 0.5:\n        # Edge swap (similar to 2-opt but with a twist)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = base_solution[i:j][::-1]\n    else:\n        # Node insertion with multiple swaps\n        i, j = sorted(random.sample(range(n), 2))\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Additional swap to increase diversity\n        if n > 4 and random.random() < 0.3:\n            k, l = sorted(random.sample(range(n-1), 2))\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.8860504277849555,
            2.370650827884674
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-dominated or high variance)\n    selected_idx = np.argmax([(obj[0] + obj[1]) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of edge swaps and node insertions\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful improvement possible\n\n    # Randomly choose between edge swap and node insertion\n    if random.random() < 0.5:\n        # Edge swap (similar to 2-opt but with a twist)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = base_solution[i:j][::-1]\n    else:\n        # Node insertion with multiple swaps\n        i, j = sorted(random.sample(range(n), 2))\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Additional swap to increase diversity\n        if n > 4 and random.random() < 0.3:\n            k, l = sorted(random.sample(range(n-1), 2))\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 53,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: 3-opt with adaptive move selection\n    n = len(new_solution)\n    i, j, k = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Evaluate all possible 3-opt moves and select the best one\n    moves = [\n        (new_solution[i:j], new_solution[j:k], new_solution[k:]),\n        (new_solution[i:j][::-1], new_solution[j:k], new_solution[k:]),\n        (new_solution[i:j], new_solution[j:k][::-1], new_solution[k:]),\n        (new_solution[i:j][::-1], new_solution[j:k][::-1], new_solution[k:]),\n        (new_solution[i:j], new_solution[k:j:-1], new_solution[j:k]),\n        (new_solution[i:j][::-1], new_solution[k:j:-1], new_solution[j:k])\n    ]\n\n    best_move = None\n    best_score = float('inf')\n\n    for move in moves:\n        candidate = np.concatenate(move)\n        if len(np.unique(candidate)) == n:  # Ensure feasibility\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            score = cost1 + cost2  # Combined objective\n\n            if score < best_score:\n                best_score = score\n                best_move = candidate\n\n    if best_move is not None:\n        new_solution = best_move\n\n    # Additional perturbation to escape local optima\n    if np.random.random() < 0.3:\n        l, m = np.random.choice(n, size=2, replace=False)\n        new_solution[l], new_solution[m] = new_solution[m], new_solution[l]\n\n    return new_solution\n\n",
        "score": [
            -0.8533110861889401,
            2.685224413871765
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: 3-opt with adaptive move selection\n    n = len(new_solution)\n    i, j, k = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Evaluate all possible 3-opt moves and select the best one\n    moves = [\n        (new_solution[i:j], new_solution[j:k], new_solution[k:]),\n        (new_solution[i:j][::-1], new_solution[j:k], new_solution[k:]),\n        (new_solution[i:j], new_solution[j:k][::-1], new_solution[k:]),\n        (new_solution[i:j][::-1], new_solution[j:k][::-1], new_solution[k:]),\n        (new_solution[i:j], new_solution[k:j:-1], new_solution[j:k]),\n        (new_solution[i:j][::-1], new_solution[k:j:-1], new_solution[j:k])\n    ]\n\n    best_move = None\n    best_score = float('inf')\n\n    for move in moves:\n        candidate = np.concatenate(move)\n        if len(np.unique(candidate)) == n:  # Ensure feasibility\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            score = cost1 + cost2  # Combined objective\n\n            if score < best_score:\n                best_score = score\n                best_move = candidate\n\n    if best_move is not None:\n        new_solution = best_move\n\n    # Additional perturbation to escape local optima\n    if np.random.random() < 0.3:\n        l, m = np.random.choice(n, size=2, replace=False)\n        new_solution[l], new_solution[m] = new_solution[m], new_solution[l]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 54,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: choose a solution with high potential for improvement\n    # Here, we select a solution that is not already in the archive (simplified for this example)\n    # In practice, you might use more sophisticated criteria (e.g., non-dominated solutions, diversity, etc.)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct nodes to perform a 3-opt move\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Perform 3-opt: reverse the segment between a and c\n    new_solution[a:c+1] = np.flip(new_solution[a:c+1])\n\n    # Custom edge swap: swap edges between b and c if it improves both objectives\n    # This is a simplified version; in practice, you'd need to evaluate the impact\n    if np.random.rand() > 0.5:  # Randomly decide to perform the swap\n        temp = new_solution[b].copy()\n        new_solution[b] = new_solution[c]\n        new_solution[c] = temp\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if 3-opt causes duplicates (shouldn't happen with proper selection)\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    return new_solution\n\n",
        "score": [
            -0.9346969712174921,
            2.517700493335724
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: choose a solution with high potential for improvement\n    # Here, we select a solution that is not already in the archive (simplified for this example)\n    # In practice, you might use more sophisticated criteria (e.g., non-dominated solutions, diversity, etc.)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct nodes to perform a 3-opt move\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Perform 3-opt: reverse the segment between a and c\n    new_solution[a:c+1] = np.flip(new_solution[a:c+1])\n\n    # Custom edge swap: swap edges between b and c if it improves both objectives\n    # This is a simplified version; in practice, you'd need to evaluate the impact\n    if np.random.rand() > 0.5:  # Randomly decide to perform the swap\n        temp = new_solution[b].copy()\n        new_solution[b] = new_solution[c]\n        new_solution[c] = temp\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if 3-opt causes duplicates (shouldn't happen with proper selection)\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 55,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest total cost to prioritize improvement\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    if random.random() < 0.5:\n        # Edge insertion: randomly select two edges and insert one between the other\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:i+1], [new_solution[k]], new_solution[i+1:]])\n    else:\n        # Segment reversal: reverse a random segment of the tour\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, fall back to a simple 2-swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.4688512149714399,
            1.2558743357658386
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest total cost to prioritize improvement\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    if random.random() < 0.5:\n        # Edge insertion: randomly select two edges and insert one between the other\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:i+1], [new_solution[k]], new_solution[i+1:]])\n    else:\n        # Segment reversal: reverse a random segment of the tour\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, fall back to a simple 2-swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 56,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment inversion\n    n = len(base_solution)\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    c, d = sorted(np.random.choice(n, size=2, replace=False))\n\n    # Apply 2-opt between segments [a, b] and [c, d]\n    if a < c and b < d and c - b > 1:\n        new_solution[b+1:c] = base_solution[b+1:c][::-1]\n\n    # Apply segment inversion for the other objective\n    if a < b and b < n:\n        new_solution[a:b+1] = base_solution[a:b+1][::-1]\n\n    # Ensure feasibility: check if all nodes are visited exactly once\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.8045501837642572,
            2.6341822743415833
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment inversion\n    n = len(base_solution)\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    c, d = sorted(np.random.choice(n, size=2, replace=False))\n\n    # Apply 2-opt between segments [a, b] and [c, d]\n    if a < c and b < d and c - b > 1:\n        new_solution[b+1:c] = base_solution[b+1:c][::-1]\n\n    # Apply segment inversion for the other objective\n    if a < b and b < n:\n        new_solution[a:b+1] = base_solution[a:b+1][::-1]\n\n    # Ensure feasibility: check if all nodes are visited exactly once\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 57,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    total_cost = sum(cost1 + cost2 for _, (cost1, cost2) in archive)\n    weights = [(cost1 + cost2) / total_cost for _, (cost1, cost2) in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange with a novel segment relocation\n    n = len(new_solution)\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n\n    # Ensure i and j are distinct\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    # Perform edge exchange (2-opt-like but more flexible)\n    if i > j:\n        i, j = j, i\n\n    # Reverse the segment between i and j (novel segment relocation)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Optional: Apply a second local search operator for diversity\n    if random.random() < 0.3:  # 30% chance of additional perturbation\n        k = random.randint(0, n - 1)\n        l = random.randint(0, n - 1)\n        if k != l:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7979370962806585,
            1.810675024986267
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    total_cost = sum(cost1 + cost2 for _, (cost1, cost2) in archive)\n    weights = [(cost1 + cost2) / total_cost for _, (cost1, cost2) in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange with a novel segment relocation\n    n = len(new_solution)\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n\n    # Ensure i and j are distinct\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    # Perform edge exchange (2-opt-like but more flexible)\n    if i > j:\n        i, j = j, i\n\n    # Reverse the segment between i and j (novel segment relocation)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Optional: Apply a second local search operator for diversity\n    if random.random() < 0.3:  # 30% chance of additional perturbation\n        k = random.randint(0, n - 1)\n        l = random.randint(0, n - 1)\n        if k != l:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 58,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        # For very small instances, just swap two random edges\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Hybrid local search strategy: 3-opt + edge-swap\n    # First perform 3-opt\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Then perform edge-swap based on both distance matrices\n    for _ in range(3):  # Limit the number of swaps for efficiency\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n\n        # Calculate current and potential costs\n        current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n        potential_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                          distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                          distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                          distance_matrix_2[new_solution[j-1], new_solution[i]])\n\n        if potential_cost < current_cost:\n            # Perform the swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7853629980872175,
            2.5950194597244263
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        # For very small instances, just swap two random edges\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Hybrid local search strategy: 3-opt + edge-swap\n    # First perform 3-opt\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Then perform edge-swap based on both distance matrices\n    for _ in range(3):  # Limit the number of swaps for efficiency\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n\n        # Calculate current and potential costs\n        current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n        potential_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                          distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                          distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                          distance_matrix_2[new_solution[j-1], new_solution[i]])\n\n        if potential_cost < current_cost:\n            # Perform the swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 59,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its cost\n    costs = np.array([obj[0] + obj[1] for _, obj in archive])\n    probs = 1 / (costs + 1e-6)  # Avoid division by zero\n    probs = probs / probs.sum()\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge-swap operator\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # First, perform a random 3-opt move\n    a, b, c = sorted(random.sample(range(n), 3))\n    new_solution[a:b] = base_solution[a:b][::-1]\n    new_solution[b:c] = base_solution[b:c][::-1]\n\n    # Then, perform a novel edge-swap operator that considers both objectives\n    for _ in range(2):  # Number of swaps to perform\n        i, j = sorted(random.sample(range(n), 2))\n        # Calculate the change in both objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n                 (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                  distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n                 (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                  distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        # Only perform the swap if it improves at least one objective\n        if delta1 < 0 or delta2 < 0:\n            temp = new_solution[i:j+1].copy()\n            new_solution[i:j+1] = temp[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8111498012950593,
            2.5802212357521057
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its cost\n    costs = np.array([obj[0] + obj[1] for _, obj in archive])\n    probs = 1 / (costs + 1e-6)  # Avoid division by zero\n    probs = probs / probs.sum()\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge-swap operator\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # First, perform a random 3-opt move\n    a, b, c = sorted(random.sample(range(n), 3))\n    new_solution[a:b] = base_solution[a:b][::-1]\n    new_solution[b:c] = base_solution[b:c][::-1]\n\n    # Then, perform a novel edge-swap operator that considers both objectives\n    for _ in range(2):  # Number of swaps to perform\n        i, j = sorted(random.sample(range(n), 2))\n        # Calculate the change in both objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n                 (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                  distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n                 (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                  distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        # Only perform the swap if it improves at least one objective\n        if delta1 < 0 or delta2 < 0:\n            temp = new_solution[i:j+1].copy()\n            new_solution[i:j+1] = temp[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 60,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the best solution from the archive based on a weighted sum of objectives\n    weights = np.random.uniform(0.3, 0.7)  # Random weights for bi-objective selection\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    best_idx = np.argmin(scores)\n    base_solution = archive[best_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search strategy\n    for _ in range(3):  # Number of local search iterations\n        # Randomly select a local search operator\n        operator = np.random.choice(['edge_insertion', 'node_swap', 'segment_relocation'])\n\n        if operator == 'edge_insertion':\n            # Randomly select two edges to insert\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            # Insert the segment between i and j at a random position\n            k = np.random.randint(0, n)\n            if k > i and k < j:\n                continue  # Invalid insertion\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k], segment, new_solution[k:]])\n\n        elif operator == 'node_swap':\n            # Randomly select two nodes to swap\n            i, j = np.random.choice(n, 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        elif operator == 'segment_relocation':\n            # Randomly select a segment and relocate it\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            segment = new_solution[i:j+1]\n            k = np.random.randint(0, n)\n            if k > i and k < j:\n                continue  # Invalid relocation\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k], segment, new_solution[k:]])\n\n    return new_solution\n\n",
        "score": [
            -0.7679335583642831,
            1.3785584568977356
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the best solution from the archive based on a weighted sum of objectives\n    weights = np.random.uniform(0.3, 0.7)  # Random weights for bi-objective selection\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    best_idx = np.argmin(scores)\n    base_solution = archive[best_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search strategy\n    for _ in range(3):  # Number of local search iterations\n        # Randomly select a local search operator\n        operator = np.random.choice(['edge_insertion', 'node_swap', 'segment_relocation'])\n\n        if operator == 'edge_insertion':\n            # Randomly select two edges to insert\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            # Insert the segment between i and j at a random position\n            k = np.random.randint(0, n)\n            if k > i and k < j:\n                continue  # Invalid insertion\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k], segment, new_solution[k:]])\n\n        elif operator == 'node_swap':\n            # Randomly select two nodes to swap\n            i, j = np.random.choice(n, 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        elif operator == 'segment_relocation':\n            # Randomly select a segment and relocate it\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            segment = new_solution[i:j+1]\n            k = np.random.randint(0, n)\n            if k > i and k < j:\n                continue  # Invalid relocation\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k], segment, new_solution[k:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 61,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Assign ranks to solutions based on their dominance\n    ranked_solutions = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))  # Simple sum-based ranking for this example\n    selected_idx = random.choices(range(len(ranked_solutions)), weights=[1/(i+1) for i in range(len(ranked_solutions))], k=1)[0]\n    base_solution = ranked_solutions[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 3-opt with a novel segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct edges to modify\n    a, b, c = sorted(random.sample(range(1, n-1), 3))\n\n    # Apply 3-opt move\n    new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    # Novel segment inversion: invert a random segment not overlapping with the previous one\n    segment_start = random.randint(0, n-2)\n    segment_end = random.randint(segment_start+1, n-1)\n    if not (segment_start <= a <= segment_end or segment_start <= c <= segment_end):\n        new_solution[segment_start:segment_end+1] = new_solution[segment_start:segment_end+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9094359648592606,
            2.3161011338233948
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Assign ranks to solutions based on their dominance\n    ranked_solutions = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))  # Simple sum-based ranking for this example\n    selected_idx = random.choices(range(len(ranked_solutions)), weights=[1/(i+1) for i in range(len(ranked_solutions))], k=1)[0]\n    base_solution = ranked_solutions[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 3-opt with a novel segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct edges to modify\n    a, b, c = sorted(random.sample(range(1, n-1), 3))\n\n    # Apply 3-opt move\n    new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    # Novel segment inversion: invert a random segment not overlapping with the previous one\n    segment_start = random.randint(0, n-2)\n    segment_end = random.randint(segment_start+1, n-1)\n    if not (segment_start <= a <= segment_end or segment_start <= c <= segment_end):\n        new_solution[segment_start:segment_end+1] = new_solution[segment_start:segment_end+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 62,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Hybrid local search operator: combine edge swaps and node insertions\n    new_solution = base_solution.copy()\n\n    # Step 1: Random edge swap (2-opt-like but with a twist)\n    a, b = np.random.choice(n, size=2, replace=False)\n    if a > b:\n        a, b = b, a\n    new_solution[a:b] = new_solution[a:b][::-1]  # Reverse segment\n\n    # Step 2: Random node insertion (to diversify)\n    if n > 3:\n        c, d = np.random.choice(n, size=2, replace=False)\n        node = new_solution[d]\n        new_solution = np.delete(new_solution, d)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility (no duplicates and all nodes present)\n    assert len(new_solution) == len(base_solution)\n    assert len(set(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.8837178674703003,
            2.6582157015800476
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Hybrid local search operator: combine edge swaps and node insertions\n    new_solution = base_solution.copy()\n\n    # Step 1: Random edge swap (2-opt-like but with a twist)\n    a, b = np.random.choice(n, size=2, replace=False)\n    if a > b:\n        a, b = b, a\n    new_solution[a:b] = new_solution[a:b][::-1]  # Reverse segment\n\n    # Step 2: Random node insertion (to diversify)\n    if n > 3:\n        c, d = np.random.choice(n, size=2, replace=False)\n        node = new_solution[d]\n        new_solution = np.delete(new_solution, d)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility (no duplicates and all nodes present)\n    assert len(new_solution) == len(base_solution)\n    assert len(set(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 63,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with lower total cost\n    total_costs = [sum(obj) for _, obj in archive]\n    probabilities = np.array(total_costs) / sum(total_costs)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Modified Lin-Kernighan with biased random walk\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    segment_length = max(3, min(10, n // 5))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Extract the segment and reverse it (similar to a partial 2-opt but more flexible)\n    segment = new_solution[start:end]\n    reversed_segment = segment[::-1]\n\n    # Replace the segment with its reversed version\n    new_solution[start:end] = reversed_segment\n\n    # Additional perturbation: randomly swap two nodes if the segment is too short\n    if segment_length <= 5:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution: Duplicate nodes or missing nodes\"\n\n    return new_solution\n\n",
        "score": [
            -0.8062702873926514,
            2.478083312511444
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with lower total cost\n    total_costs = [sum(obj) for _, obj in archive]\n    probabilities = np.array(total_costs) / sum(total_costs)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Modified Lin-Kernighan with biased random walk\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    segment_length = max(3, min(10, n // 5))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Extract the segment and reverse it (similar to a partial 2-opt but more flexible)\n    segment = new_solution[start:end]\n    reversed_segment = segment[::-1]\n\n    # Replace the segment with its reversed version\n    new_solution[start:end] = reversed_segment\n\n    # Additional perturbation: randomly swap two nodes if the segment is too short\n    if segment_length <= 5:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution: Duplicate nodes or missing nodes\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 64,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal)\n    # Here, we select a solution that is not the best in either objective\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = [i for i in range(len(sorted_archive)) if i != 0]  # Exclude the best solution\n    if not candidate_indices:\n        candidate_indices = [0]  # Fallback to the best solution if no other candidates\n\n    selected_idx = random.choice(candidate_indices)\n    base_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Combine edge swapping with path relinking\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small instances\n\n    # Step 1: Edge swapping (similar to 2-opt but more flexible)\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Ensure valid indices and no overlap\n    if a == c and b == d:\n        return new_solution  # No change\n\n    # Perform edge swap\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Step 2: Path relinking (intelligent segment exchange)\n    # Select two random segments and exchange them\n    seg1_start, seg1_end = sorted(random.sample(range(n), 2))\n    seg2_start, seg2_end = sorted(random.sample(range(n), 2))\n\n    # Ensure segments are of similar length\n    seg1_len = seg1_end - seg1_start\n    seg2_len = seg2_end - seg2_start\n\n    if seg1_len == seg2_len:\n        # Exchange segments\n        temp = new_solution[seg1_start:seg1_end+1].copy()\n        new_solution[seg1_start:seg1_end+1] = new_solution[seg2_start:seg2_end+1]\n        new_solution[seg2_start:seg2_end+1] = temp\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to original solution if invalid\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7410446225071274,
            2.0430057048797607
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal)\n    # Here, we select a solution that is not the best in either objective\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = [i for i in range(len(sorted_archive)) if i != 0]  # Exclude the best solution\n    if not candidate_indices:\n        candidate_indices = [0]  # Fallback to the best solution if no other candidates\n\n    selected_idx = random.choice(candidate_indices)\n    base_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Combine edge swapping with path relinking\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small instances\n\n    # Step 1: Edge swapping (similar to 2-opt but more flexible)\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Ensure valid indices and no overlap\n    if a == c and b == d:\n        return new_solution  # No change\n\n    # Perform edge swap\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Step 2: Path relinking (intelligent segment exchange)\n    # Select two random segments and exchange them\n    seg1_start, seg1_end = sorted(random.sample(range(n), 2))\n    seg2_start, seg2_end = sorted(random.sample(range(n), 2))\n\n    # Ensure segments are of similar length\n    seg1_len = seg1_end - seg1_start\n    seg2_len = seg2_end - seg2_start\n\n    if seg1_len == seg2_len:\n        # Exchange segments\n        temp = new_solution[seg1_start:seg1_end+1].copy()\n        new_solution[seg1_start:seg1_end+1] = new_solution[seg2_start:seg2_end+1]\n        new_solution[seg2_start:seg2_end+1] = temp\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to original solution if invalid\n        return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 65,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def potential_score(solution, obj1, obj2):\n        # Higher potential if the solution is non-dominated and has high diversity\n        non_dominated = True\n        for (_, (o1, o2)) in archive:\n            if (o1 < obj1 and o2 < obj2) or (o1 <= obj1 and o2 < obj2) or (o1 < obj1 and o2 <= obj2):\n                non_dominated = False\n                break\n        if non_dominated:\n            return obj1 + obj2  # Higher score for non-dominated solutions\n        return 0.5 * (obj1 + obj2)  # Lower score for dominated solutions\n\n    scored_solutions = [(solution, obj1, obj2, potential_score(solution, obj1, obj2))\n                        for (solution, (obj1, obj2)) in archive]\n\n    # Sort by potential score in descending order\n    scored_solutions.sort(key=lambda x: -x[3])\n    selected_solution = scored_solutions[0][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select segments for 3-opt\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Perform 3-opt move\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Novel edge swap: swap two edges in a way that preserves feasibility\n    if n > 3:\n        a, b = sorted(random.sample(range(n), 2))\n        if a != b and abs(a - b) != 1:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if the solution becomes invalid\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7638686591169837,
            2.363346517086029
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def potential_score(solution, obj1, obj2):\n        # Higher potential if the solution is non-dominated and has high diversity\n        non_dominated = True\n        for (_, (o1, o2)) in archive:\n            if (o1 < obj1 and o2 < obj2) or (o1 <= obj1 and o2 < obj2) or (o1 < obj1 and o2 <= obj2):\n                non_dominated = False\n                break\n        if non_dominated:\n            return obj1 + obj2  # Higher score for non-dominated solutions\n        return 0.5 * (obj1 + obj2)  # Lower score for dominated solutions\n\n    scored_solutions = [(solution, obj1, obj2, potential_score(solution, obj1, obj2))\n                        for (solution, (obj1, obj2)) in archive]\n\n    # Sort by potential score in descending order\n    scored_solutions.sort(key=lambda x: -x[3])\n    selected_solution = scored_solutions[0][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select segments for 3-opt\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Perform 3-opt move\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Novel edge swap: swap two edges in a way that preserves feasibility\n    if n > 3:\n        a, b = sorted(random.sample(range(n), 2))\n        if a != b and abs(a - b) != 1:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if the solution becomes invalid\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 66,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    archive.sort(key=lambda x: min(x[1]))\n    selected_solution = archive[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge insertion strategy\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible with small instances\n\n    # Randomly select 4 distinct indices for 3-opt\n    indices = np.random.choice(n, size=4, replace=False)\n    i, j, k, l = sorted(indices)\n\n    # Apply 3-opt move\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n    new_solution[j:k+1] = np.flip(new_solution[j:k+1])\n    new_solution[k:l+1] = np.flip(new_solution[k:l+1])\n\n    # Novel edge insertion: try to improve by inserting a random edge\n    if np.random.random() < 0.3:  # 30% chance to apply edge insertion\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n        # Remove edges (a,b) and (b+1,a-1) if they exist\n        if b - a > 1:\n            new_solution[a:b+1] = np.concatenate([new_solution[a:a+1], new_solution[b:b+1], new_solution[a+1:b]])\n\n    return new_solution\n\n",
        "score": [
            -0.42873663294043796,
            1.3840349316596985
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    archive.sort(key=lambda x: min(x[1]))\n    selected_solution = archive[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge insertion strategy\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible with small instances\n\n    # Randomly select 4 distinct indices for 3-opt\n    indices = np.random.choice(n, size=4, replace=False)\n    i, j, k, l = sorted(indices)\n\n    # Apply 3-opt move\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n    new_solution[j:k+1] = np.flip(new_solution[j:k+1])\n    new_solution[k:l+1] = np.flip(new_solution[k:l+1])\n\n    # Novel edge insertion: try to improve by inserting a random edge\n    if np.random.random() < 0.3:  # 30% chance to apply edge insertion\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n        # Remove edges (a,b) and (b+1,a-1) if they exist\n        if b - a > 1:\n            new_solution[a:b+1] = np.concatenate([new_solution[a:a+1], new_solution[b:b+1], new_solution[a+1:b]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 67,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 0:\n        # Sort solutions by Pareto dominance (simplified by sum of objectives)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        top_solutions = archive_sorted[:max(1, int(0.3 * len(archive_sorted)))]\n        selected_solution = random.choice(top_solutions)[0].copy()\n    else:\n        selected_solution = np.random.permutation(len(instance))\n\n    # Step 2: Apply segmented 3-opt local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three segments to operate on\n    points = sorted(random.sample(range(1, n), 3))\n    i, j, k = points[0], points[1], points[2]\n\n    # Reconnect the segments in a new configuration\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Create 6 possible new configurations\n    configs = [\n        np.concatenate([segment1, segment2[::-1], segment3, segment4]),\n        np.concatenate([segment1, segment3, segment2, segment4]),\n        np.concatenate([segment1, segment2, segment3[::-1], segment4]),\n        np.concatenate([segment1, segment3[::-1], segment2, segment4]),\n        np.concatenate([segment1, segment2, segment4, segment3[::-1]]),\n        np.concatenate([segment1, segment3, segment4, segment2[::-1]])\n    ]\n\n    # Evaluate all configurations\n    best_config = None\n    best_cost = float('inf')\n\n    for config in configs:\n        cost1 = sum(distance_matrix_1[config[i-1], config[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[config[i-1], config[i]] for i in range(n))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_config = config.copy()\n\n    # With 20% probability, accept a worse solution to escape local optima\n    if random.random() < 0.2 and len(configs) > 1:\n        new_solution = random.choice([c for c in configs if not np.array_equal(c, best_config)])\n    else:\n        new_solution = best_config\n\n    return new_solution\n\n",
        "score": [
            -0.9114167329896636,
            3.168970465660095
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 0:\n        # Sort solutions by Pareto dominance (simplified by sum of objectives)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        top_solutions = archive_sorted[:max(1, int(0.3 * len(archive_sorted)))]\n        selected_solution = random.choice(top_solutions)[0].copy()\n    else:\n        selected_solution = np.random.permutation(len(instance))\n\n    # Step 2: Apply segmented 3-opt local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three segments to operate on\n    points = sorted(random.sample(range(1, n), 3))\n    i, j, k = points[0], points[1], points[2]\n\n    # Reconnect the segments in a new configuration\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Create 6 possible new configurations\n    configs = [\n        np.concatenate([segment1, segment2[::-1], segment3, segment4]),\n        np.concatenate([segment1, segment3, segment2, segment4]),\n        np.concatenate([segment1, segment2, segment3[::-1], segment4]),\n        np.concatenate([segment1, segment3[::-1], segment2, segment4]),\n        np.concatenate([segment1, segment2, segment4, segment3[::-1]]),\n        np.concatenate([segment1, segment3, segment4, segment2[::-1]])\n    ]\n\n    # Evaluate all configurations\n    best_config = None\n    best_cost = float('inf')\n\n    for config in configs:\n        cost1 = sum(distance_matrix_1[config[i-1], config[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[config[i-1], config[i]] for i in range(n))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_config = config.copy()\n\n    # With 20% probability, accept a worse solution to escape local optima\n    if random.random() < 0.2 and len(configs) > 1:\n        new_solution = random.choice([c for c in configs if not np.array_equal(c, best_config)])\n    else:\n        new_solution = best_config\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 68,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    objectives = [obj for _, obj in archive]\n    total_cost = sum(sum(obj) for obj in objectives)\n    probabilities = [sum(obj) / total_cost for obj in objectives]\n    selected_idx = random.choices(range(len(archive)), weights=probabilities, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-based perturbation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct edges to perform 3-opt\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[:i+1]\n    segment2 = new_solution[i+1:j+1]\n    segment3 = new_solution[j+1:k+1]\n    segment4 = new_solution[k+1:]\n\n    # Reconnect the segments in a different order\n    new_solution = np.concatenate([segment1, segment3[::-1], segment2[::-1], segment4])\n\n    # Novel edge-based perturbation: swap edges between two random nodes\n    if n > 3:\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.8381791539626098,
            2.452669382095337
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    objectives = [obj for _, obj in archive]\n    total_cost = sum(sum(obj) for obj in objectives)\n    probabilities = [sum(obj) / total_cost for obj in objectives]\n    selected_idx = random.choices(range(len(archive)), weights=probabilities, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-based perturbation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct edges to perform 3-opt\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[:i+1]\n    segment2 = new_solution[i+1:j+1]\n    segment3 = new_solution[j+1:k+1]\n    segment4 = new_solution[k+1:]\n\n    # Reconnect the segments in a different order\n    new_solution = np.concatenate([segment1, segment3[::-1], segment2[::-1], segment4])\n\n    # Novel edge-based perturbation: swap edges between two random nodes\n    if n > 3:\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 69,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution from the archive with probability proportional to its potential for improvement\n    # Here, we use a simple heuristic: solutions with higher total cost are more likely to be selected\n    total_costs = [obj[0] + obj[1] for _, obj in archive]\n    max_cost = max(total_costs)\n    if max_cost == 0:\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        probabilities = [cost / max_cost for cost in total_costs]\n        selected_idx = random.choices(range(len(archive)), weights=probabilities, k=1)[0]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of 3-opt and a novel edge swap\n    n = len(new_solution)\n    if n < 4:\n        # If the tour is too small, just perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Choose between 3-opt or edge swap based on a random decision\n        if random.random() < 0.5:\n            # 3-opt move: select 3 random edges and reconnect them\n            i, j, k = sorted(random.sample(range(n), 3))\n            # Reconnect the edges in a different order\n            new_solution[i:j] = new_solution[i:j][::-1]\n            new_solution[j:k] = new_solution[j:k][::-1]\n        else:\n            # Novel edge swap: identify edges that are critical in both objectives\n            # Calculate edge costs in both objectives\n            edge_costs_1 = [distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)]\n            edge_costs_2 = [distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)]\n\n            # Find edges that are above average in both objectives\n            avg_cost_1 = np.mean(edge_costs_1)\n            avg_cost_2 = np.mean(edge_costs_2)\n            critical_edges = [i for i in range(n) if edge_costs_1[i] > avg_cost_1 and edge_costs_2[i] > avg_cost_2]\n\n            if critical_edges:\n                # Select a random critical edge and swap its endpoints\n                edge_idx = random.choice(critical_edges)\n                node1 = new_solution[edge_idx]\n                node2 = new_solution[(edge_idx + 1) % n]\n\n                # Find the positions of these nodes in the solution\n                pos1 = np.where(new_solution == node1)[0][0]\n                pos2 = np.where(new_solution == node2)[0][0]\n\n                # Perform a swap that maintains feasibility\n                if pos1 < pos2:\n                    new_solution[pos1:pos2] = new_solution[pos1:pos2][::-1]\n                else:\n                    new_solution[pos2:pos1] = new_solution[pos2:pos1][::-1]\n            else:\n                # If no critical edges found, perform a random 2-opt\n                i, j = sorted(random.sample(range(n), 2))\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.847395106074698,
            2.829624652862549
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution from the archive with probability proportional to its potential for improvement\n    # Here, we use a simple heuristic: solutions with higher total cost are more likely to be selected\n    total_costs = [obj[0] + obj[1] for _, obj in archive]\n    max_cost = max(total_costs)\n    if max_cost == 0:\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        probabilities = [cost / max_cost for cost in total_costs]\n        selected_idx = random.choices(range(len(archive)), weights=probabilities, k=1)[0]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of 3-opt and a novel edge swap\n    n = len(new_solution)\n    if n < 4:\n        # If the tour is too small, just perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Choose between 3-opt or edge swap based on a random decision\n        if random.random() < 0.5:\n            # 3-opt move: select 3 random edges and reconnect them\n            i, j, k = sorted(random.sample(range(n), 3))\n            # Reconnect the edges in a different order\n            new_solution[i:j] = new_solution[i:j][::-1]\n            new_solution[j:k] = new_solution[j:k][::-1]\n        else:\n            # Novel edge swap: identify edges that are critical in both objectives\n            # Calculate edge costs in both objectives\n            edge_costs_1 = [distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)]\n            edge_costs_2 = [distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)]\n\n            # Find edges that are above average in both objectives\n            avg_cost_1 = np.mean(edge_costs_1)\n            avg_cost_2 = np.mean(edge_costs_2)\n            critical_edges = [i for i in range(n) if edge_costs_1[i] > avg_cost_1 and edge_costs_2[i] > avg_cost_2]\n\n            if critical_edges:\n                # Select a random critical edge and swap its endpoints\n                edge_idx = random.choice(critical_edges)\n                node1 = new_solution[edge_idx]\n                node2 = new_solution[(edge_idx + 1) % n]\n\n                # Find the positions of these nodes in the solution\n                pos1 = np.where(new_solution == node1)[0][0]\n                pos2 = np.where(new_solution == node2)[0][0]\n\n                # Perform a swap that maintains feasibility\n                if pos1 < pos2:\n                    new_solution[pos1:pos2] = new_solution[pos1:pos2][::-1]\n                else:\n                    new_solution[pos2:pos1] = new_solution[pos2:pos1][::-1]\n            else:\n                # If no critical edges found, perform a random 2-opt\n                i, j = sorted(random.sample(range(n), 2))\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 70,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge insertion and partial reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Step 1: Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Randomly select two edges and insert one into the other\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if j - i > 1:  # Ensure there's space to insert\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    # Ensure feasibility: check for duplicates and missing nodes\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8755484806272633,
            2.0290626883506775
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge insertion and partial reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Step 1: Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Randomly select two edges and insert one into the other\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if j - i > 1:  # Ensure there's space to insert\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    # Ensure feasibility: check for duplicates and missing nodes\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 71,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with the highest potential for improvement (e.g., highest objective values)\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel edge insertion heuristic\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Apply a modified 2-opt to improve the solution\n    for _ in range(10):  # Limit the number of iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == j:\n            continue\n        # Reverse the segment between i and j\n        new_segment = np.concatenate((new_solution[i:j+1][::-1], new_solution[j+1:]))\n        candidate = np.concatenate((new_solution[:i], new_segment))\n        # Evaluate the candidate in both objective spaces\n        cost1 = sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        # Accept if both objectives are improved or one is improved while the other is not worsened significantly\n        if (cost1 < sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]) or \\\n           (cost2 < sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]):\n            new_solution = candidate\n\n    # Step 2: Apply a novel edge insertion heuristic to further improve the solution\n    for _ in range(5):  # Limit the number of iterations\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i == j:\n            continue\n        # Remove node at position i and reinsert it after position j\n        node = new_solution[i]\n        candidate = np.concatenate((new_solution[:i], new_solution[i+1:]))\n        candidate = np.insert(candidate, j, node)\n        # Evaluate the candidate in both objective spaces\n        cost1 = sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        # Accept if both objectives are improved or one is improved while the other is not worsened significantly\n        if (cost1 < sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]) or \\\n           (cost2 < sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]):\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7038839478924652,
            8.215842545032501
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with the highest potential for improvement (e.g., highest objective values)\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel edge insertion heuristic\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Apply a modified 2-opt to improve the solution\n    for _ in range(10):  # Limit the number of iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == j:\n            continue\n        # Reverse the segment between i and j\n        new_segment = np.concatenate((new_solution[i:j+1][::-1], new_solution[j+1:]))\n        candidate = np.concatenate((new_solution[:i], new_segment))\n        # Evaluate the candidate in both objective spaces\n        cost1 = sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        # Accept if both objectives are improved or one is improved while the other is not worsened significantly\n        if (cost1 < sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]) or \\\n           (cost2 < sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]):\n            new_solution = candidate\n\n    # Step 2: Apply a novel edge insertion heuristic to further improve the solution\n    for _ in range(5):  # Limit the number of iterations\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i == j:\n            continue\n        # Remove node at position i and reinsert it after position j\n        node = new_solution[i]\n        candidate = np.concatenate((new_solution[:i], new_solution[i+1:]))\n        candidate = np.insert(candidate, j, node)\n        # Evaluate the candidate in both objective spaces\n        cost1 = sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        # Accept if both objectives are improved or one is improved while the other is not worsened significantly\n        if (cost1 < sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]) or \\\n           (cost2 < sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]):\n            new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 72,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weights = [0.5, 0.5]  # Equal weights for both objectives\n    best_solution = max(archive, key=lambda x: -(weights[0] * x[1][0] + weights[1] * x[1][1]))[0]\n    new_solution = best_solution.copy()\n\n    # Hybrid local search: combine edge exchange and node relocation\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    k = np.random.randint(n)\n\n    # Edge exchange (similar to 3-opt but more flexible)\n    if i > j:\n        i, j = j, i\n    segment = new_solution[i:j]\n    new_segment = np.concatenate([segment[:k-i], segment[k-i:][::-1]])\n    new_solution[i:j] = new_segment\n\n    # Node relocation with objective-aware selection\n    l = np.random.randint(n)\n    if l != i and l != j:\n        # Evaluate potential moves based on both objectives\n        original_cost = (distance_matrix_1[new_solution[l-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[l]] +\n                          distance_matrix_1[new_solution[l], new_solution[(l+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[l-1], new_solution[i]] + distance_matrix_2[new_solution[l-1], new_solution[i]] +\n                    distance_matrix_1[new_solution[i], new_solution[(l+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(l+1)%n]])\n\n        if new_cost < original_cost:\n            new_solution[l] = new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.694739963008655,
            1.6291077733039856
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weights = [0.5, 0.5]  # Equal weights for both objectives\n    best_solution = max(archive, key=lambda x: -(weights[0] * x[1][0] + weights[1] * x[1][1]))[0]\n    new_solution = best_solution.copy()\n\n    # Hybrid local search: combine edge exchange and node relocation\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    k = np.random.randint(n)\n\n    # Edge exchange (similar to 3-opt but more flexible)\n    if i > j:\n        i, j = j, i\n    segment = new_solution[i:j]\n    new_segment = np.concatenate([segment[:k-i], segment[k-i:][::-1]])\n    new_solution[i:j] = new_segment\n\n    # Node relocation with objective-aware selection\n    l = np.random.randint(n)\n    if l != i and l != j:\n        # Evaluate potential moves based on both objectives\n        original_cost = (distance_matrix_1[new_solution[l-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[l]] +\n                          distance_matrix_1[new_solution[l], new_solution[(l+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[l-1], new_solution[i]] + distance_matrix_2[new_solution[l-1], new_solution[i]] +\n                    distance_matrix_1[new_solution[i], new_solution[(l+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(l+1)%n]])\n\n        if new_cost < original_cost:\n            new_solution[l] = new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 73,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a probability inversely proportional to its dominance (better solutions are less likely to be selected)\n    total_costs = np.array([sum(obj) for _, obj in archive])\n    if len(total_costs) > 1:\n        selection_probs = 1 / (total_costs - np.min(total_costs) + 1e-6)  # Avoid division by zero\n        selection_probs = selection_probs / np.sum(selection_probs)\n        selected_idx = np.random.choice(len(archive), p=selection_probs)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: Edge Insertion + Segment Reversal\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # No improvement possible\n\n    # Step 1: Edge Insertion\n    i, j = sorted(random.sample(range(1, n), 2))  # Select two random edges\n    if j - i > 1:  # Ensure there's a segment to move\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    # Step 2: Segment Reversal (for both objectives)\n    # Evaluate the current cost\n    def calculate_cost(solution, distance_matrix):\n        cost = 0\n        for k in range(len(solution) - 1):\n            cost += distance_matrix[solution[k], solution[k+1]]\n        cost += distance_matrix[solution[-1], solution[0]]  # Return to start\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Try reversing a random segment\n    i, j = sorted(random.sample(range(1, n), 2))\n    reversed_solution = new_solution.copy()\n    reversed_solution[i:j] = reversed_solution[i:j]\n\n    new_cost1 = calculate_cost(reversed_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(reversed_solution, distance_matrix_2)\n\n    # Accept the reversal if it improves both objectives\n    if (new_cost1 <= current_cost1 and new_cost2 <= current_cost2):\n        new_solution = reversed_solution\n\n    # Step 3: Edge Swap (for diversification)\n    i, j = sorted(random.sample(range(1, n), 2))\n    if i != j:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7770246830882244,
            2.6506338715553284
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a probability inversely proportional to its dominance (better solutions are less likely to be selected)\n    total_costs = np.array([sum(obj) for _, obj in archive])\n    if len(total_costs) > 1:\n        selection_probs = 1 / (total_costs - np.min(total_costs) + 1e-6)  # Avoid division by zero\n        selection_probs = selection_probs / np.sum(selection_probs)\n        selected_idx = np.random.choice(len(archive), p=selection_probs)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: Edge Insertion + Segment Reversal\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # No improvement possible\n\n    # Step 1: Edge Insertion\n    i, j = sorted(random.sample(range(1, n), 2))  # Select two random edges\n    if j - i > 1:  # Ensure there's a segment to move\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    # Step 2: Segment Reversal (for both objectives)\n    # Evaluate the current cost\n    def calculate_cost(solution, distance_matrix):\n        cost = 0\n        for k in range(len(solution) - 1):\n            cost += distance_matrix[solution[k], solution[k+1]]\n        cost += distance_matrix[solution[-1], solution[0]]  # Return to start\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Try reversing a random segment\n    i, j = sorted(random.sample(range(1, n), 2))\n    reversed_solution = new_solution.copy()\n    reversed_solution[i:j] = reversed_solution[i:j]\n\n    new_cost1 = calculate_cost(reversed_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(reversed_solution, distance_matrix_2)\n\n    # Accept the reversal if it improves both objectives\n    if (new_cost1 <= current_cost1 and new_cost2 <= current_cost2):\n        new_solution = reversed_solution\n\n    # Step 3: Edge Swap (for diversification)\n    i, j = sorted(random.sample(range(1, n), 2))\n    if i != j:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 74,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its dominance rank\n    # (simplified here by selecting randomly among the top 30% of solutions)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    top_k = max(1, int(0.3 * len(sorted_archive)))\n    selected_solution = random.choice(sorted_archive[:top_k])[0].copy()\n\n    # Hybrid local search operator: combine edge insertion with a biased random walk\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge insertion (select a random segment and insert it in reverse)\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], segment[::-1], new_solution[j:]])\n\n    # Step 2: Biased random walk (move nodes based on distance in both objective spaces)\n    for _ in range(3):  # Perform 3 biased moves\n        # Select two nodes with high distance in either objective space\n        node1, node2 = random.sample(range(n), 2)\n        dist1 = distance_matrix_1[new_solution[node1], new_solution[node2]]\n        dist2 = distance_matrix_2[new_solution[node1], new_solution[node2]]\n\n        if dist1 > np.mean(distance_matrix_1) or dist2 > np.mean(distance_matrix_2):\n            # Swap these nodes if they are far apart in either space\n            new_solution[node1], new_solution[node2] = new_solution[node2], new_solution[node1]\n\n    return new_solution\n\n",
        "score": [
            -0.8612278023059429,
            3.149359941482544
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its dominance rank\n    # (simplified here by selecting randomly among the top 30% of solutions)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    top_k = max(1, int(0.3 * len(sorted_archive)))\n    selected_solution = random.choice(sorted_archive[:top_k])[0].copy()\n\n    # Hybrid local search operator: combine edge insertion with a biased random walk\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge insertion (select a random segment and insert it in reverse)\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], segment[::-1], new_solution[j:]])\n\n    # Step 2: Biased random walk (move nodes based on distance in both objective spaces)\n    for _ in range(3):  # Perform 3 biased moves\n        # Select two nodes with high distance in either objective space\n        node1, node2 = random.sample(range(n), 2)\n        dist1 = distance_matrix_1[new_solution[node1], new_solution[node2]]\n        dist2 = distance_matrix_2[new_solution[node1], new_solution[node2]]\n\n        if dist1 > np.mean(distance_matrix_1) or dist2 > np.mean(distance_matrix_2):\n            # Swap these nodes if they are far apart in either space\n            new_solution[node1], new_solution[node2] = new_solution[node2], new_solution[node1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 75,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weights = [0.5, 0.5]  # Equal weights for both objectives\n    best_idx = 0\n    best_score = float('inf')\n\n    for i, (sol, obj) in enumerate(archive):\n        score = weights[0] * obj[0] + weights[1] * obj[1]\n        if score < best_score:\n            best_score = score\n            best_idx = i\n\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel move\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # No improvement possible\n\n    # Randomly select 3 distinct positions\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move (reverse the middle segment)\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Novel move: if the segment length is 2, also swap the nodes\n    if b - a == 1:\n        new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n\n    # Ensure the solution remains valid\n    assert len(np.unique(new_solution)) == len(base_solution), \"Invalid solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.6676564716359321,
            2.4241195917129517
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weights = [0.5, 0.5]  # Equal weights for both objectives\n    best_idx = 0\n    best_score = float('inf')\n\n    for i, (sol, obj) in enumerate(archive):\n        score = weights[0] * obj[0] + weights[1] * obj[1]\n        if score < best_score:\n            best_score = score\n            best_idx = i\n\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel move\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # No improvement possible\n\n    # Randomly select 3 distinct positions\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move (reverse the middle segment)\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Novel move: if the segment length is 2, also swap the nodes\n    if b - a == 1:\n        new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n\n    # Ensure the solution remains valid\n    assert len(np.unique(new_solution)) == len(base_solution), \"Invalid solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 76,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Sort solutions by Pareto dominance (simplified for this example)\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        # Select a solution from the top 30% of the archive\n        top_k = max(1, len(archive_sorted) // 3)\n        selected_idx = random.randint(0, top_k - 1)\n        base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt with edge exchange\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Perform 3-opt move\n    temp_solution = new_solution.copy()\n    temp_solution[i:j] = np.flip(temp_solution[i:j])\n    temp_solution[j:k] = np.flip(temp_solution[j:k])\n\n    # Evaluate the move in both objectives\n    def calculate_cost(solution, distance_matrix):\n        cost = 0\n        for a, b in zip(solution, np.roll(solution, -1)):\n            cost += distance_matrix[a, b]\n        return cost\n\n    original_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    original_cost2 = calculate_cost(new_solution, distance_matrix_2)\n    temp_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    temp_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    # Accept if both objectives improve or if one improves significantly\n    if (temp_cost1 < original_cost1 and temp_cost2 < original_cost2) or \\\n       (temp_cost1 < original_cost1 * 0.95 or temp_cost2 < original_cost2 * 0.95):\n        new_solution = temp_solution.copy()\n\n    # Additional edge exchange heuristic\n    for _ in range(2):  # Limit the number of exchanges to maintain efficiency\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n        # Swap edges (a,b) and (c,d) with (a,c) and (b,d)\n        temp_solution = new_solution.copy()\n        temp_solution[a], temp_solution[b], temp_solution[c], temp_solution[d] = \\\n            new_solution[c], new_solution[d], new_solution[a], new_solution[b]\n\n        temp_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n        temp_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n        if (temp_cost1 < original_cost1 and temp_cost2 < original_cost2) or \\\n           (temp_cost1 < original_cost1 * 0.98 or temp_cost2 < original_cost2 * 0.98):\n            new_solution = temp_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9193627569956953,
            5.5077216029167175
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Sort solutions by Pareto dominance (simplified for this example)\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        # Select a solution from the top 30% of the archive\n        top_k = max(1, len(archive_sorted) // 3)\n        selected_idx = random.randint(0, top_k - 1)\n        base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt with edge exchange\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Perform 3-opt move\n    temp_solution = new_solution.copy()\n    temp_solution[i:j] = np.flip(temp_solution[i:j])\n    temp_solution[j:k] = np.flip(temp_solution[j:k])\n\n    # Evaluate the move in both objectives\n    def calculate_cost(solution, distance_matrix):\n        cost = 0\n        for a, b in zip(solution, np.roll(solution, -1)):\n            cost += distance_matrix[a, b]\n        return cost\n\n    original_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    original_cost2 = calculate_cost(new_solution, distance_matrix_2)\n    temp_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    temp_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    # Accept if both objectives improve or if one improves significantly\n    if (temp_cost1 < original_cost1 and temp_cost2 < original_cost2) or \\\n       (temp_cost1 < original_cost1 * 0.95 or temp_cost2 < original_cost2 * 0.95):\n        new_solution = temp_solution.copy()\n\n    # Additional edge exchange heuristic\n    for _ in range(2):  # Limit the number of exchanges to maintain efficiency\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n        # Swap edges (a,b) and (c,d) with (a,c) and (b,d)\n        temp_solution = new_solution.copy()\n        temp_solution[a], temp_solution[b], temp_solution[c], temp_solution[d] = \\\n            new_solution[c], new_solution[d], new_solution[a], new_solution[b]\n\n        temp_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n        temp_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n        if (temp_cost1 < original_cost1 and temp_cost2 < original_cost2) or \\\n           (temp_cost1 < original_cost1 * 0.98 or temp_cost2 < original_cost2 * 0.98):\n            new_solution = temp_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 77,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a probability inversely proportional to its rank in the Pareto front\n    weights = [1.0 / (i + 1) for i in range(len(archive))]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights]\n    selected_idx = random.choices(range(len(archive)), weights=probabilities, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge-swapping strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 segments to perform 3-opt\n    if n >= 3:\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[:i+1]\n        segment2 = new_solution[i+1:j+1]\n        segment3 = new_solution[j+1:k+1]\n        segment4 = new_solution[k+1:]\n\n        # Try all possible combinations of these segments\n        combinations = [\n            np.concatenate([segment1, segment2, segment3, segment4]),\n            np.concatenate([segment1, segment3, segment2, segment4]),\n            np.concatenate([segment2, segment1, segment3, segment4]),\n            np.concatenate([segment2, segment3, segment1, segment4]),\n            np.concatenate([segment3, segment1, segment2, segment4]),\n            np.concatenate([segment3, segment2, segment1, segment4])\n        ]\n\n        # Evaluate all combinations based on both objectives\n        best_combination = combinations[0]\n        best_score = np.sum(distance_matrix_1[best_combination[:-1], best_combination[1:]]) + np.sum(distance_matrix_2[best_combination[:-1], best_combination[1:]])\n\n        for comb in combinations[1:]:\n            current_score = np.sum(distance_matrix_1[comb[:-1], comb[1:]]) + np.sum(distance_matrix_2[comb[:-1], comb[1:]])\n            if current_score < best_score:\n                best_score = current_score\n                best_combination = comb\n\n        new_solution = best_combination\n\n    # Additional edge-swapping strategy based on distance matrices\n    for _ in range(min(5, n // 2)):\n        a, b = random.sample(range(n), 2)\n        if a > b:\n            a, b = b, a\n\n        # Calculate the change in both objectives\n        delta1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                 distance_matrix_1[new_solution[b-1], new_solution[a]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]]) - \\\n                (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                 distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                 distance_matrix_2[new_solution[b-1], new_solution[a]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]]) - \\\n                (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                 distance_matrix_2[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n\n        # Accept the swap if it improves at least one objective\n        if delta1 < 0 or delta2 < 0:\n            # Perform the swap\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.930172920082005,
            3.1194502115249634
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a probability inversely proportional to its rank in the Pareto front\n    weights = [1.0 / (i + 1) for i in range(len(archive))]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights]\n    selected_idx = random.choices(range(len(archive)), weights=probabilities, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge-swapping strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 segments to perform 3-opt\n    if n >= 3:\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[:i+1]\n        segment2 = new_solution[i+1:j+1]\n        segment3 = new_solution[j+1:k+1]\n        segment4 = new_solution[k+1:]\n\n        # Try all possible combinations of these segments\n        combinations = [\n            np.concatenate([segment1, segment2, segment3, segment4]),\n            np.concatenate([segment1, segment3, segment2, segment4]),\n            np.concatenate([segment2, segment1, segment3, segment4]),\n            np.concatenate([segment2, segment3, segment1, segment4]),\n            np.concatenate([segment3, segment1, segment2, segment4]),\n            np.concatenate([segment3, segment2, segment1, segment4])\n        ]\n\n        # Evaluate all combinations based on both objectives\n        best_combination = combinations[0]\n        best_score = np.sum(distance_matrix_1[best_combination[:-1], best_combination[1:]]) + np.sum(distance_matrix_2[best_combination[:-1], best_combination[1:]])\n\n        for comb in combinations[1:]:\n            current_score = np.sum(distance_matrix_1[comb[:-1], comb[1:]]) + np.sum(distance_matrix_2[comb[:-1], comb[1:]])\n            if current_score < best_score:\n                best_score = current_score\n                best_combination = comb\n\n        new_solution = best_combination\n\n    # Additional edge-swapping strategy based on distance matrices\n    for _ in range(min(5, n // 2)):\n        a, b = random.sample(range(n), 2)\n        if a > b:\n            a, b = b, a\n\n        # Calculate the change in both objectives\n        delta1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                 distance_matrix_1[new_solution[b-1], new_solution[a]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]]) - \\\n                (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                 distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                 distance_matrix_2[new_solution[b-1], new_solution[a]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]]) - \\\n                (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                 distance_matrix_2[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n\n        # Accept the swap if it improves at least one objective\n        if delta1 < 0 or delta2 < 0:\n            # Perform the swap\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 78,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high potential for improvement (e.g., among the top 20% non-dominated solutions)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selection_pool = sorted_archive[:max(1, len(archive) // 5)]\n    selected_solution = random.choice(selection_pool)[0].copy()\n\n    # Hybrid local search operator: 3-opt with probabilistic edge swaps\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct edges to perform a 3-opt move\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Generate all possible 3-opt moves (6 possible neighbors)\n    candidates = [\n        new_solution.copy(),\n        new_solution.copy(),\n        new_solution.copy(),\n        new_solution.copy(),\n        new_solution.copy(),\n        new_solution.copy()\n    ]\n\n    # Apply 3-opt moves\n    candidates[0][i:j] = new_solution[i:j][::-1]  # Reverse segment i to j\n    candidates[1][j:k] = new_solution[j:k][::-1]  # Reverse segment j to k\n    candidates[2][i:k] = new_solution[i:k][::-1]  # Reverse entire segment i to k\n\n    # Additional probabilistic edge swaps\n    if random.random() < 0.3:\n        l, m = sorted(random.sample(range(1, n), 2))\n        candidates[3][l], candidates[3][m] = candidates[3][m], candidates[3][l]  # Swap two nodes\n\n    if random.random() < 0.3:\n        l, m = sorted(random.sample(range(1, n), 2))\n        candidates[4][l:m] = candidates[4][m-1:l-1:-1]  # Reverse a random segment\n\n    if random.random() < 0.3:\n        l, m = sorted(random.sample(range(1, n), 2))\n        candidates[5][l:m] = np.roll(candidates[5][l:m], 1)  # Rotate a segment\n\n    # Evaluate all candidates based on both objectives\n    best_candidate = None\n    best_score = float('inf')\n\n    for candidate in candidates:\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_score:\n            best_score = total_cost\n            best_candidate = candidate\n\n    return best_candidate if best_candidate is not None else selected_solution\n\n",
        "score": [
            -0.8344871571660468,
            4.498749911785126
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high potential for improvement (e.g., among the top 20% non-dominated solutions)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selection_pool = sorted_archive[:max(1, len(archive) // 5)]\n    selected_solution = random.choice(selection_pool)[0].copy()\n\n    # Hybrid local search operator: 3-opt with probabilistic edge swaps\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct edges to perform a 3-opt move\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Generate all possible 3-opt moves (6 possible neighbors)\n    candidates = [\n        new_solution.copy(),\n        new_solution.copy(),\n        new_solution.copy(),\n        new_solution.copy(),\n        new_solution.copy(),\n        new_solution.copy()\n    ]\n\n    # Apply 3-opt moves\n    candidates[0][i:j] = new_solution[i:j][::-1]  # Reverse segment i to j\n    candidates[1][j:k] = new_solution[j:k][::-1]  # Reverse segment j to k\n    candidates[2][i:k] = new_solution[i:k][::-1]  # Reverse entire segment i to k\n\n    # Additional probabilistic edge swaps\n    if random.random() < 0.3:\n        l, m = sorted(random.sample(range(1, n), 2))\n        candidates[3][l], candidates[3][m] = candidates[3][m], candidates[3][l]  # Swap two nodes\n\n    if random.random() < 0.3:\n        l, m = sorted(random.sample(range(1, n), 2))\n        candidates[4][l:m] = candidates[4][m-1:l-1:-1]  # Reverse a random segment\n\n    if random.random() < 0.3:\n        l, m = sorted(random.sample(range(1, n), 2))\n        candidates[5][l:m] = np.roll(candidates[5][l:m], 1)  # Rotate a segment\n\n    # Evaluate all candidates based on both objectives\n    best_candidate = None\n    best_score = float('inf')\n\n    for candidate in candidates:\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_score:\n            best_score = total_cost\n            best_candidate = candidate\n\n    return best_candidate if best_candidate is not None else selected_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 79,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    weights = [1 / (1 + obj[0] + obj[1]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom move\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 3-opt move\n    if n >= 6:\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        segment3 = new_solution[k:]\n        new_order = np.concatenate([segment1, segment2[::-1], segment3])\n        new_solution = np.concatenate([new_solution[:i], new_order])\n\n    # Then apply a custom move: swap segments of varying lengths\n    if n >= 4:\n        a, b = sorted(random.sample(range(n), 2))\n        segment_length = random.randint(1, min(3, n - max(a, b)))\n        new_solution[a:a+segment_length], new_solution[b:b+segment_length] = new_solution[b:b+segment_length], new_solution[a:a+segment_length]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.771297762497948,
            10.758442997932434
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    weights = [1 / (1 + obj[0] + obj[1]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom move\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 3-opt move\n    if n >= 6:\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        segment3 = new_solution[k:]\n        new_order = np.concatenate([segment1, segment2[::-1], segment3])\n        new_solution = np.concatenate([new_solution[:i], new_order])\n\n    # Then apply a custom move: swap segments of varying lengths\n    if n >= 4:\n        a, b = sorted(random.sample(range(n), 2))\n        segment_length = random.randint(1, min(3, n - max(a, b)))\n        new_solution[a:a+segment_length], new_solution[b:b+segment_length] = new_solution[b:b+segment_length], new_solution[a:a+segment_length]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 80,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Intelligently select a solution with potential for improvement\n    # Prefer solutions that are non-dominated or have high diversity\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    # 1. Randomly select a segment and reverse it (similar to 2-opt but with segment reversal)\n    n = len(base_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = base_solution[j:i-1 if i > 0 else None:-1]\n\n    # 2. Apply edge insertion to further improve the solution\n    if len(new_solution) > 3:\n        k = random.randint(0, n - 1)\n        l = random.randint(0, n - 1)\n        if k != l:\n            temp = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, l, temp)\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == len(base_solution), \"Invalid solution generated.\"\n\n    return new_solution\n\n",
        "score": [
            -0.8030800735906,
            2.416933834552765
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Intelligently select a solution with potential for improvement\n    # Prefer solutions that are non-dominated or have high diversity\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    # 1. Randomly select a segment and reverse it (similar to 2-opt but with segment reversal)\n    n = len(base_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = base_solution[j:i-1 if i > 0 else None:-1]\n\n    # 2. Apply edge insertion to further improve the solution\n    if len(new_solution) > 3:\n        k = random.randint(0, n - 1)\n        l = random.randint(0, n - 1)\n        if k != l:\n            temp = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, l, temp)\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == len(base_solution), \"Invalid solution generated.\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 81,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a custom move to explore both objectives\n    n = len(base_solution)\n    if n < 3:\n        return new_solution  # Too small for meaningful changes\n\n    # Step 1: Randomly select three distinct edges to modify\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Step 2: Apply a custom 3-opt-like move that considers both objectives\n    # This move replaces three edges with three new edges, balancing both distance matrices\n    new_solution[a:b] = base_solution[a:b][::-1]  # Reverse segment a to b\n    new_solution[b:c] = base_solution[b:c][::-1]  # Reverse segment b to c\n\n    # Step 3: Evaluate the move's impact on both objectives\n    # If the move improves both objectives, accept it; otherwise, try another move\n    def evaluate_move(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n        cost2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n        return (cost1, cost2)\n\n    original_costs = evaluate_move(base_solution)\n    new_costs = evaluate_move(new_solution)\n\n    # If the move doesn't improve both objectives, try a different move\n    if not (new_costs[0] <= original_costs[0] and new_costs[1] <= original_costs[1]):\n        # Alternative move: swap two non-adjacent segments\n        d, e = sorted(random.sample(range(n), 2))\n        new_solution[d:e] = base_solution[d:e][::-1]\n        new_costs = evaluate_move(new_solution)\n        if not (new_costs[0] <= original_costs[0] and new_costs[1] <= original_costs[1]):\n            # If still no improvement, revert to original\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.4774213380958221,
            3.773048520088196
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a custom move to explore both objectives\n    n = len(base_solution)\n    if n < 3:\n        return new_solution  # Too small for meaningful changes\n\n    # Step 1: Randomly select three distinct edges to modify\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Step 2: Apply a custom 3-opt-like move that considers both objectives\n    # This move replaces three edges with three new edges, balancing both distance matrices\n    new_solution[a:b] = base_solution[a:b][::-1]  # Reverse segment a to b\n    new_solution[b:c] = base_solution[b:c][::-1]  # Reverse segment b to c\n\n    # Step 3: Evaluate the move's impact on both objectives\n    # If the move improves both objectives, accept it; otherwise, try another move\n    def evaluate_move(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n        cost2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n        return (cost1, cost2)\n\n    original_costs = evaluate_move(base_solution)\n    new_costs = evaluate_move(new_solution)\n\n    # If the move doesn't improve both objectives, try a different move\n    if not (new_costs[0] <= original_costs[0] and new_costs[1] <= original_costs[1]):\n        # Alternative move: swap two non-adjacent segments\n        d, e = sorted(random.sample(range(n), 2))\n        new_solution[d:e] = base_solution[d:e][::-1]\n        new_costs = evaluate_move(new_solution)\n        if not (new_costs[0] <= original_costs[0] and new_costs[1] <= original_costs[1]):\n            # If still no improvement, revert to original\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 82,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability of being non-dominated or with lower costs\n    weights = [1.0 / (1 + i) for i in range(len(archive))]  # Prefer earlier solutions\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a biased edge selection\n    n = len(base_solution)\n    if n < 3:\n        return base_solution  # No improvement possible\n\n    # Select three distinct positions with bias toward edges with high cost in either objective\n    def get_biased_indices():\n        # Calculate edge costs in both objectives\n        costs = []\n        for i in range(n):\n            u, v = base_solution[i], base_solution[(i + 1) % n]\n            cost1 = distance_matrix_1[u, v]\n            cost2 = distance_matrix_2[u, v]\n            costs.append(cost1 + cost2)\n\n        # Select indices with probability proportional to their edge costs\n        probs = np.array(costs) / sum(costs)\n        return sorted(random.choices(range(n), weights=probs, k=3))\n\n    i, j, k = get_biased_indices()\n\n    # Apply a modified 3-opt move\n    if i < j < k:\n        # Reverse the segment between j and k\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n    else:\n        # Handle circular cases\n        if i > j:\n            j, i = i, j\n        if j > k:\n            k, j = j, k\n        if i > j:\n            j, i = i, j\n\n        # Apply a more complex rearrangement\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n        new_solution[i:k+1] = np.concatenate([segment2, segment1])\n\n    return new_solution\n\n",
        "score": [
            -0.827294837699905,
            2.5768274664878845
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability of being non-dominated or with lower costs\n    weights = [1.0 / (1 + i) for i in range(len(archive))]  # Prefer earlier solutions\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a biased edge selection\n    n = len(base_solution)\n    if n < 3:\n        return base_solution  # No improvement possible\n\n    # Select three distinct positions with bias toward edges with high cost in either objective\n    def get_biased_indices():\n        # Calculate edge costs in both objectives\n        costs = []\n        for i in range(n):\n            u, v = base_solution[i], base_solution[(i + 1) % n]\n            cost1 = distance_matrix_1[u, v]\n            cost2 = distance_matrix_2[u, v]\n            costs.append(cost1 + cost2)\n\n        # Select indices with probability proportional to their edge costs\n        probs = np.array(costs) / sum(costs)\n        return sorted(random.choices(range(n), weights=probs, k=3))\n\n    i, j, k = get_biased_indices()\n\n    # Apply a modified 3-opt move\n    if i < j < k:\n        # Reverse the segment between j and k\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n    else:\n        # Handle circular cases\n        if i > j:\n            j, i = i, j\n        if j > k:\n            k, j = j, k\n        if i > j:\n            j, i = i, j\n\n        # Apply a more complex rearrangement\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n        new_solution[i:k+1] = np.concatenate([segment2, segment1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 83,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto front solutions or high-cost solutions)\n    selected = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge insertion strategy\n    n = len(selected)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # 2-opt move\n    new_solution = selected.copy()\n    new_solution[i:j+1] = selected[i:j+1][::-1]\n\n    # Novel edge insertion: randomly insert a node from a random segment\n    if n > 3:\n        k = np.random.randint(0, n)\n        if k != i and k != j:\n            # Remove node k and reinsert it at a random position\n            node_k = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, pos, node_k)\n\n    return new_solution\n\n",
        "score": [
            -0.9600475152185918,
            2.41612708568573
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto front solutions or high-cost solutions)\n    selected = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge insertion strategy\n    n = len(selected)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # 2-opt move\n    new_solution = selected.copy()\n    new_solution[i:j+1] = selected[i:j+1][::-1]\n\n    # Novel edge insertion: randomly insert a node from a random segment\n    if n > 3:\n        k = np.random.randint(0, n)\n        if k != i and k != j:\n            # Remove node k and reinsert it at a random position\n            node_k = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, pos, node_k)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 84,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weights = np.array([0.5, 0.5])  # Equal weights for both objectives\n    objectives = np.array([obj for _, obj in archive])\n    scores = np.dot(objectives, weights)\n    best_idx = np.argmin(scores)\n    base_solution = archive[best_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of edge insertion and edge reversal\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Edge insertion: remove a segment and reinsert it in reverse order\n    segment = new_solution[i:j+1][::-1]\n    new_solution = np.concatenate([new_solution[:i], segment, new_solution[j+1:]])\n\n    # Edge reversal: reverse a random segment to explore different sub-tours\n    k, l = np.random.choice(n, size=2, replace=False)\n    k, l = min(k, l), max(k, l)\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8280160028016683,
            2.4441051483154297
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weights = np.array([0.5, 0.5])  # Equal weights for both objectives\n    objectives = np.array([obj for _, obj in archive])\n    scores = np.dot(objectives, weights)\n    best_idx = np.argmin(scores)\n    base_solution = archive[best_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of edge insertion and edge reversal\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Edge insertion: remove a segment and reinsert it in reverse order\n    segment = new_solution[i:j+1][::-1]\n    new_solution = np.concatenate([new_solution[:i], segment, new_solution[j+1:]])\n\n    # Edge reversal: reverse a random segment to explore different sub-tours\n    k, l = np.random.choice(n, size=2, replace=False)\n    k, l = min(k, l), max(k, l)\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 85,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (low cost) and good diversity\n    selected_idx = 0\n    min_cost = float('inf')\n    for i, (sol, (cost1, cost2)) in enumerate(archive):\n        # Combine costs for selection (could use weighted sum or Pareto dominance)\n        combined_cost = cost1 + cost2\n        if combined_cost < min_cost:\n            min_cost = combined_cost\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with segment reversal\n    n = len(new_solution)\n    if n < 4:\n        # For very small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select three random segments\n        a, b, c = sorted(random.sample(range(1, n), 3))\n        segment1 = new_solution[:a]\n        segment2 = new_solution[a:b]\n        segment3 = new_solution[b:c]\n        segment4 = new_solution[c:]\n\n        # Recombine segments in a different order\n        # This creates a 3-opt like move with additional segment reversal\n        new_order = [segment1, segment2[::-1], segment3, segment4[::-1]]\n        new_solution = np.concatenate(new_order)\n\n    # Ensure the solution remains a valid tour (no duplicates)\n    assert len(np.unique(new_solution)) == len(new_solution), \"Invalid tour generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.6935296772486335,
            2.1401599049568176
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (low cost) and good diversity\n    selected_idx = 0\n    min_cost = float('inf')\n    for i, (sol, (cost1, cost2)) in enumerate(archive):\n        # Combine costs for selection (could use weighted sum or Pareto dominance)\n        combined_cost = cost1 + cost2\n        if combined_cost < min_cost:\n            min_cost = combined_cost\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with segment reversal\n    n = len(new_solution)\n    if n < 4:\n        # For very small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select three random segments\n        a, b, c = sorted(random.sample(range(1, n), 3))\n        segment1 = new_solution[:a]\n        segment2 = new_solution[a:b]\n        segment3 = new_solution[b:c]\n        segment4 = new_solution[c:]\n\n        # Recombine segments in a different order\n        # This creates a 3-opt like move with additional segment reversal\n        new_order = [segment1, segment2[::-1], segment3, segment4[::-1]]\n        new_solution = np.concatenate(new_order)\n\n    # Ensure the solution remains a valid tour (no duplicates)\n    assert len(np.unique(new_solution)) == len(new_solution), \"Invalid tour generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 86,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / np.max(objectives, axis=0)\n    weights = 1 / (normalized_objectives.sum(axis=1) + 1e-6)\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combination of edge insertion and swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n\n    # Apply edge insertion: move a random node to a new position\n    if len(segment) > 2:\n        node_to_move = random.choice(segment)\n        new_pos = random.randint(0, n-1)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n    # Apply swap: swap two random nodes\n    if n > 1:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (visits all nodes exactly once)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.8197827314881602,
            2.5510144233703613
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / np.max(objectives, axis=0)\n    weights = 1 / (normalized_objectives.sum(axis=1) + 1e-6)\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combination of edge insertion and swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n\n    # Apply edge insertion: move a random node to a new position\n    if len(segment) > 2:\n        node_to_move = random.choice(segment)\n        new_pos = random.randint(0, n-1)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n    # Apply swap: swap two random nodes\n    if n > 1:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (visits all nodes exactly once)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 87,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high variance)\n    selected_idx = np.random.choice(len(archive), p=[1.0 / len(archive) for _ in range(len(archive))])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment inversion strategy\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Choose three random segments to modify\n    a, b, c = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n\n    # Apply 3-opt-like operation\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[b:c] = np.flip(new_solution[b:c])\n\n    # Novel segment inversion: invert a segment based on distance improvement\n    for _ in range(2):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(range(1, n), size=2, replace=False))\n        segment = new_solution[i:j]\n        original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]])\n        inverted_cost = (distance_matrix_1[new_solution[i-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[j]] +\n                          distance_matrix_2[new_solution[i-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[j]])\n\n        if inverted_cost < original_cost:\n            new_solution[i:j] = np.flip(segment)\n\n    return new_solution\n\n",
        "score": [
            -0.8207463624285266,
            2.1694487929344177
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high variance)\n    selected_idx = np.random.choice(len(archive), p=[1.0 / len(archive) for _ in range(len(archive))])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment inversion strategy\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Choose three random segments to modify\n    a, b, c = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n\n    # Apply 3-opt-like operation\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[b:c] = np.flip(new_solution[b:c])\n\n    # Novel segment inversion: invert a segment based on distance improvement\n    for _ in range(2):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(range(1, n), size=2, replace=False))\n        segment = new_solution[i:j]\n        original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]])\n        inverted_cost = (distance_matrix_1[new_solution[i-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[j]] +\n                          distance_matrix_2[new_solution[i-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[j]])\n\n        if inverted_cost < original_cost:\n            new_solution[i:j] = np.flip(segment)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 88,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already on the Pareto front)\n    # Here, we randomly select a solution with a high combined cost\n    costs = np.array([obj[0] + obj[1] for _, obj in archive])\n    probabilities = costs / np.sum(costs)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a multi-objective aware move\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select 3 distinct positions to modify\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply a 3-opt move (reverses segments between i-j and j-k)\n    new_solution[i:j] = np.flip(new_solution[i:j])\n    new_solution[j:k] = np.flip(new_solution[j:k])\n\n    # Multi-objective aware move: swap nodes if it improves both objectives\n    for _ in range(3):  # Try a few times\n        a, b = random.sample(range(n), 2)\n        if a == b:\n            continue\n\n        # Calculate current and new costs for both objectives\n        current_cost1 = distance_matrix_1[base_solution[a-1], base_solution[a]] + distance_matrix_1[base_solution[b-1], base_solution[b]]\n        new_cost1 = distance_matrix_1[base_solution[a-1], base_solution[b]] + distance_matrix_1[base_solution[b-1], base_solution[a]]\n\n        current_cost2 = distance_matrix_2[base_solution[a-1], base_solution[a]] + distance_matrix_2[base_solution[b-1], base_solution[b]]\n        new_cost2 = distance_matrix_2[base_solution[a-1], base_solution[b]] + distance_matrix_2[base_solution[b-1], base_solution[a]]\n\n        # Accept if both objectives improve\n        if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7920897219202836,
            2.4824143052101135
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already on the Pareto front)\n    # Here, we randomly select a solution with a high combined cost\n    costs = np.array([obj[0] + obj[1] for _, obj in archive])\n    probabilities = costs / np.sum(costs)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a multi-objective aware move\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select 3 distinct positions to modify\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply a 3-opt move (reverses segments between i-j and j-k)\n    new_solution[i:j] = np.flip(new_solution[i:j])\n    new_solution[j:k] = np.flip(new_solution[j:k])\n\n    # Multi-objective aware move: swap nodes if it improves both objectives\n    for _ in range(3):  # Try a few times\n        a, b = random.sample(range(n), 2)\n        if a == b:\n            continue\n\n        # Calculate current and new costs for both objectives\n        current_cost1 = distance_matrix_1[base_solution[a-1], base_solution[a]] + distance_matrix_1[base_solution[b-1], base_solution[b]]\n        new_cost1 = distance_matrix_1[base_solution[a-1], base_solution[b]] + distance_matrix_1[base_solution[b-1], base_solution[a]]\n\n        current_cost2 = distance_matrix_2[base_solution[a-1], base_solution[a]] + distance_matrix_2[base_solution[b-1], base_solution[b]]\n        new_cost2 = distance_matrix_2[base_solution[a-1], base_solution[b]] + distance_matrix_2[base_solution[b-1], base_solution[a]]\n\n        # Accept if both objectives improve\n        if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 89,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if not non_dominated:\n        non_dominated = [sol for sol, _ in archive]\n\n    base_solution = random.choice(non_dominated).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge swap strategy\n    n = len(new_solution)\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # 3-opt move: reverse segments between i, j, k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Novel edge swap: swap edges between non-adjacent nodes to improve both objectives\n    if random.random() < 0.5:  # 50% chance to apply edge swap\n        a, b = sorted(random.sample(range(n), 2))\n        if a + 1 != b and b + 1 != a:  # Ensure they're not adjacent\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure solution remains feasible (valid TSP tour)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.841772276724843,
            1.6028541922569275
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if not non_dominated:\n        non_dominated = [sol for sol, _ in archive]\n\n    base_solution = random.choice(non_dominated).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge swap strategy\n    n = len(new_solution)\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # 3-opt move: reverse segments between i, j, k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Novel edge swap: swap edges between non-adjacent nodes to improve both objectives\n    if random.random() < 0.5:  # 50% chance to apply edge swap\n        a, b = sorted(random.sample(range(n), 2))\n        if a + 1 != b and b + 1 != a:  # Ensure they're not adjacent\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure solution remains feasible (valid TSP tour)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 90,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best but not the worst)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    if len(sorted_archive) > 2:\n        selected_idx = random.randint(1, len(sorted_archive) - 2)\n    else:\n        selected_idx = 0\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: combine 3-opt with a custom edge-swap\n    # Step 1: Randomly select three non-consecutive edges\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    k = random.randint(0, n - 1)\n    while j == (i + 1) % n or k == (j + 1) % n or k == (i + 1) % n:\n        j = random.randint(0, n - 1)\n        k = random.randint(0, n - 1)\n\n    # Ensure i < j < k (for simplicity)\n    indices = sorted([i, j, k])\n    i, j, k = indices[0], indices[1], indices[2]\n\n    # Step 2: Apply 3-opt move\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_segment = np.concatenate([segment2, segment1])\n    new_solution[i:k] = new_segment\n\n    # Step 3: Apply custom edge-swap (swap two random edges)\n    if random.random() < 0.5:  # 50% chance to apply edge-swap\n        a = random.randint(0, n - 1)\n        b = random.randint(0, n - 1)\n        while b == (a + 1) % n:\n            b = random.randint(0, n - 1)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.8545468246712792,
            2.3387932181358337
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best but not the worst)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    if len(sorted_archive) > 2:\n        selected_idx = random.randint(1, len(sorted_archive) - 2)\n    else:\n        selected_idx = 0\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: combine 3-opt with a custom edge-swap\n    # Step 1: Randomly select three non-consecutive edges\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    k = random.randint(0, n - 1)\n    while j == (i + 1) % n or k == (j + 1) % n or k == (i + 1) % n:\n        j = random.randint(0, n - 1)\n        k = random.randint(0, n - 1)\n\n    # Ensure i < j < k (for simplicity)\n    indices = sorted([i, j, k])\n    i, j, k = indices[0], indices[1], indices[2]\n\n    # Step 2: Apply 3-opt move\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_segment = np.concatenate([segment2, segment1])\n    new_solution[i:k] = new_segment\n\n    # Step 3: Apply custom edge-swap (swap two random edges)\n    if random.random() < 0.5:  # 50% chance to apply edge-swap\n        a = random.randint(0, n - 1)\n        b = random.randint(0, n - 1)\n        while b == (a + 1) % n:\n            b = random.randint(0, n - 1)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 91,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the lowest total cost (sum of both objectives)\n    best_idx = np.argmin([obj1 + obj2 for (sol, (obj1, obj2)) in archive])\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-swap operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct positions to perform 3-opt\n    if n >= 3:\n        i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n        # Perform 3-opt: reverse segments between i-j and j-k\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Novel edge-swap operator: swap two non-adjacent edges if it improves both objectives\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        # Ensure a and b are not adjacent\n        if abs(a - b) > 1:\n            # Calculate current and new costs\n            current_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_1[new_solution[b-1], new_solution[a]])\n\n            current_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            # Apply swap if both objectives improve\n            if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.795357527967486,
            1.811201274394989
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the lowest total cost (sum of both objectives)\n    best_idx = np.argmin([obj1 + obj2 for (sol, (obj1, obj2)) in archive])\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-swap operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct positions to perform 3-opt\n    if n >= 3:\n        i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n        # Perform 3-opt: reverse segments between i-j and j-k\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Novel edge-swap operator: swap two non-adjacent edges if it improves both objectives\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        # Ensure a and b are not adjacent\n        if abs(a - b) > 1:\n            # Calculate current and new costs\n            current_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_1[new_solution[b-1], new_solution[a]])\n\n            current_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            # Apply swap if both objectives improve\n            if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 92,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high diversity)\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (1 + i) for i in range(len(archive))], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a novel edge-swapping strategy\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small tours\n\n    # Randomly select 4 distinct positions to perform 3-opt\n    a, b, c, d = sorted(random.sample(range(n), 4))\n\n    # Apply 3-opt move (preserves feasibility)\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[b+1:c+1]\n    segment3 = new_solution[c+1:d+1]\n\n    # Try different combinations of segments\n    options = [\n        np.concatenate([new_solution[:a], segment1, segment2, segment3, new_solution[d+1:]]),\n        np.concatenate([new_solution[:a], segment1, np.flip(segment2), segment3, new_solution[d+1:]]),\n        np.concatenate([new_solution[:a], np.flip(segment1), segment2, segment3, new_solution[d+1:]]),\n        np.concatenate([new_solution[:a], segment1, segment2, np.flip(segment3), new_solution[d+1:]]),\n    ]\n\n    # Evaluate all options based on both objectives\n    best_option = new_solution\n    best_score = np.inf\n\n    for option in options:\n        cost1 = sum(distance_matrix_1[option[i], option[i+1]] for i in range(n-1)) + distance_matrix_1[option[-1], option[0]]\n        cost2 = sum(distance_matrix_2[option[i], option[i+1]] for i in range(n-1)) + distance_matrix_2[option[-1], option[0]]\n        total_cost = cost1 + cost2\n\n        if total_cost < best_score:\n            best_score = total_cost\n            best_option = option\n\n    new_solution = best_option\n\n    # Additional edge-swapping strategy for further improvement\n    for _ in range(2):  # Limit iterations for efficiency\n        i, j = sorted(random.sample(range(n), 2))\n        # Swap edges (i, i+1) and (j, j+1) with (i, j) and (i+1, j+1)\n        if abs(i - j) > 1:  # Ensure valid swap\n            new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    return new_solution\n\n",
        "score": [
            -0.8184579742538091,
            2.083359658718109
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high diversity)\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (1 + i) for i in range(len(archive))], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a novel edge-swapping strategy\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small tours\n\n    # Randomly select 4 distinct positions to perform 3-opt\n    a, b, c, d = sorted(random.sample(range(n), 4))\n\n    # Apply 3-opt move (preserves feasibility)\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[b+1:c+1]\n    segment3 = new_solution[c+1:d+1]\n\n    # Try different combinations of segments\n    options = [\n        np.concatenate([new_solution[:a], segment1, segment2, segment3, new_solution[d+1:]]),\n        np.concatenate([new_solution[:a], segment1, np.flip(segment2), segment3, new_solution[d+1:]]),\n        np.concatenate([new_solution[:a], np.flip(segment1), segment2, segment3, new_solution[d+1:]]),\n        np.concatenate([new_solution[:a], segment1, segment2, np.flip(segment3), new_solution[d+1:]]),\n    ]\n\n    # Evaluate all options based on both objectives\n    best_option = new_solution\n    best_score = np.inf\n\n    for option in options:\n        cost1 = sum(distance_matrix_1[option[i], option[i+1]] for i in range(n-1)) + distance_matrix_1[option[-1], option[0]]\n        cost2 = sum(distance_matrix_2[option[i], option[i+1]] for i in range(n-1)) + distance_matrix_2[option[-1], option[0]]\n        total_cost = cost1 + cost2\n\n        if total_cost < best_score:\n            best_score = total_cost\n            best_option = option\n\n    new_solution = best_option\n\n    # Additional edge-swapping strategy for further improvement\n    for _ in range(2):  # Limit iterations for efficiency\n        i, j = sorted(random.sample(range(n), 2))\n        # Swap edges (i, i+1) and (j, j+1) with (i, j) and (i+1, j+1)\n        if abs(i - j) > 1:  # Ensure valid swap\n            new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 93,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Hybrid local search strategy: combine edge exchange with segment inversion\n    for _ in range(2):  # Perform a few iterations\n        # Randomly select two non-adjacent edges to exchange\n        i = random.randint(0, n - 4)\n        j = random.randint(i + 2, n - 2)\n\n        # Edge exchange (similar to 2-opt but more flexible)\n        new_solution[i+1:j+1] = base_solution[i+1:j+1][::-1]\n\n        # Novel segment inversion: invert a random segment with probability 0.5\n        if random.random() < 0.5:\n            k = random.randint(0, n - 3)\n            l = random.randint(k + 1, min(k + 5, n - 1))\n            new_solution[k:l+1] = base_solution[k:l+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, fall back to a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7043116918929941,
            1.0180739760398865
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Hybrid local search strategy: combine edge exchange with segment inversion\n    for _ in range(2):  # Perform a few iterations\n        # Randomly select two non-adjacent edges to exchange\n        i = random.randint(0, n - 4)\n        j = random.randint(i + 2, n - 2)\n\n        # Edge exchange (similar to 2-opt but more flexible)\n        new_solution[i+1:j+1] = base_solution[i+1:j+1][::-1]\n\n        # Novel segment inversion: invert a random segment with probability 0.5\n        if random.random() < 0.5:\n            k = random.randint(0, n - 3)\n            l = random.randint(k + 1, min(k + 5, n - 1))\n            new_solution[k:l+1] = base_solution[k:l+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, fall back to a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 94,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by the sum of objectives (can be replaced with other selection criteria)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = sorted_archive[0][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge insertion strategy\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on a random segment\n    i = np.random.randint(0, n - 1)\n    j = np.random.randint(i + 1, n)\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Edge insertion: insert a random edge from another solution in the archive\n    if len(archive) > 1:\n        other_solution = archive[1][0]\n        # Find an edge in the other solution not present in the current solution\n        for a in range(len(other_solution) - 1):\n            edge = (other_solution[a], other_solution[a + 1])\n            if not ((edge in zip(new_solution, new_solution[1:] + new_solution[:1])) or\n                    (edge[::-1] in zip(new_solution, new_solution[1:] + new_solution[:1]))):\n                # Find positions to insert the edge\n                u, v = edge\n                # Remove one occurrence of u and v from the current solution\n                mask = np.ones(n, dtype=bool)\n                mask[np.where(new_solution == u)[0][0]] = False\n                mask[np.where(new_solution == v)[0][0]] = False\n                reduced_solution = new_solution[mask]\n                # Insert the edge\n                insert_pos = np.random.randint(0, len(reduced_solution) + 1)\n                new_solution = np.concatenate([reduced_solution[:insert_pos], [u, v], reduced_solution[insert_pos:]])\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.610622110859409,
            1.8402239680290222
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by the sum of objectives (can be replaced with other selection criteria)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = sorted_archive[0][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge insertion strategy\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on a random segment\n    i = np.random.randint(0, n - 1)\n    j = np.random.randint(i + 1, n)\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Edge insertion: insert a random edge from another solution in the archive\n    if len(archive) > 1:\n        other_solution = archive[1][0]\n        # Find an edge in the other solution not present in the current solution\n        for a in range(len(other_solution) - 1):\n            edge = (other_solution[a], other_solution[a + 1])\n            if not ((edge in zip(new_solution, new_solution[1:] + new_solution[:1])) or\n                    (edge[::-1] in zip(new_solution, new_solution[1:] + new_solution[:1]))):\n                # Find positions to insert the edge\n                u, v = edge\n                # Remove one occurrence of u and v from the current solution\n                mask = np.ones(n, dtype=bool)\n                mask[np.where(new_solution == u)[0][0]] = False\n                mask[np.where(new_solution == v)[0][0]] = False\n                reduced_solution = new_solution[mask]\n                # Insert the edge\n                insert_pos = np.random.randint(0, len(reduced_solution) + 1)\n                new_solution = np.concatenate([reduced_solution[:insert_pos], [u, v], reduced_solution[insert_pos:]])\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 95,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high potential for improvement (e.g., not dominated by others)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_cost1, current_cost2 = archive[selected_idx][1]\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge-swap heuristic\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select 3 distinct edges to modify\n    i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Step 2: Perform a 3-opt move\n    # This is a generalized 3-opt that can handle both 2-opt and more complex rearrangements\n    segment1 = new_solution[:i+1]\n    segment2 = new_solution[i+1:j+1]\n    segment3 = new_solution[j+1:k+1]\n    segment4 = new_solution[k+1:]\n\n    # Reconstruct the tour with the segments reversed or reordered\n    new_solution = np.concatenate([segment1, segment3[::-1], segment2[::-1], segment4])\n\n    # Step 3: Apply a novel edge-swap heuristic to further improve the solution\n    # Select two random nodes and swap their positions if it improves the solution\n    a, b = np.random.choice(n, size=2, replace=False)\n    if a > b:\n        a, b = b, a\n\n    # Calculate the change in cost for both objectives\n    delta_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                    distance_matrix_1[new_solution[b], new_solution[a]] +\n                    distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                    distance_matrix_1[new_solution[a], new_solution[b+1 if b+1 < n else 0]]) - \\\n                   (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                    distance_matrix_1[new_solution[a], new_solution[a+1 if a+1 < n else 0]] +\n                    distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                    distance_matrix_1[new_solution[b], new_solution[b+1 if b+1 < n else 0]])\n\n    delta_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                    distance_matrix_2[new_solution[b], new_solution[a]] +\n                    distance_matrix_2[new_solution[b-1], new_solution[a]] +\n                    distance_matrix_2[new_solution[a], new_solution[b+1 if b+1 < n else 0]]) - \\\n                   (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                    distance_matrix_2[new_solution[a], new_solution[a+1 if a+1 < n else 0]] +\n                    distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                    distance_matrix_2[new_solution[b], new_solution[b+1 if b+1 < n else 0]])\n\n    # Only perform the swap if it improves at least one objective\n    if delta_cost1 < 0 or delta_cost2 < 0:\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7995178864421535,
            2.209903657436371
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high potential for improvement (e.g., not dominated by others)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_cost1, current_cost2 = archive[selected_idx][1]\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge-swap heuristic\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select 3 distinct edges to modify\n    i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Step 2: Perform a 3-opt move\n    # This is a generalized 3-opt that can handle both 2-opt and more complex rearrangements\n    segment1 = new_solution[:i+1]\n    segment2 = new_solution[i+1:j+1]\n    segment3 = new_solution[j+1:k+1]\n    segment4 = new_solution[k+1:]\n\n    # Reconstruct the tour with the segments reversed or reordered\n    new_solution = np.concatenate([segment1, segment3[::-1], segment2[::-1], segment4])\n\n    # Step 3: Apply a novel edge-swap heuristic to further improve the solution\n    # Select two random nodes and swap their positions if it improves the solution\n    a, b = np.random.choice(n, size=2, replace=False)\n    if a > b:\n        a, b = b, a\n\n    # Calculate the change in cost for both objectives\n    delta_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                    distance_matrix_1[new_solution[b], new_solution[a]] +\n                    distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                    distance_matrix_1[new_solution[a], new_solution[b+1 if b+1 < n else 0]]) - \\\n                   (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                    distance_matrix_1[new_solution[a], new_solution[a+1 if a+1 < n else 0]] +\n                    distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                    distance_matrix_1[new_solution[b], new_solution[b+1 if b+1 < n else 0]])\n\n    delta_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                    distance_matrix_2[new_solution[b], new_solution[a]] +\n                    distance_matrix_2[new_solution[b-1], new_solution[a]] +\n                    distance_matrix_2[new_solution[a], new_solution[b+1 if b+1 < n else 0]]) - \\\n                   (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                    distance_matrix_2[new_solution[a], new_solution[a+1 if a+1 < n else 0]] +\n                    distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                    distance_matrix_2[new_solution[b], new_solution[b+1 if b+1 < n else 0]])\n\n    # Only perform the swap if it improves at least one objective\n    if delta_cost1 < 0 or delta_cost2 < 0:\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 96,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly biased towards non-dominated solutions)\n    selected = random.choices(\n        archive,\n        weights=[1.0 / (1 + idx) for idx in range(len(archive))],\n        k=1\n    )[0][0].copy()\n\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine edge swaps with segment inversion\n    for _ in range(2):  # Perform multiple iterations\n        # Randomly choose between edge swap and segment inversion\n        if random.random() < 0.5:\n            # Edge swap\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Segment inversion (novel approach)\n            i, j = sorted(random.sample(range(n), 2))\n            segment = new_solution[i:j+1]\n            new_solution[i:j+1] = segment[::-1]\n\n        # Ensure the solution remains valid (no duplicates, all nodes present)\n        if len(np.unique(new_solution)) != n:\n            # If invalid, revert to previous state\n            new_solution = selected.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8291350243705592,
            2.2944539189338684
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly biased towards non-dominated solutions)\n    selected = random.choices(\n        archive,\n        weights=[1.0 / (1 + idx) for idx in range(len(archive))],\n        k=1\n    )[0][0].copy()\n\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine edge swaps with segment inversion\n    for _ in range(2):  # Perform multiple iterations\n        # Randomly choose between edge swap and segment inversion\n        if random.random() < 0.5:\n            # Edge swap\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Segment inversion (novel approach)\n            i, j = sorted(random.sample(range(n), 2))\n            segment = new_solution[i:j+1]\n            new_solution[i:j+1] = segment[::-1]\n\n        # Ensure the solution remains valid (no duplicates, all nodes present)\n        if len(np.unique(new_solution)) != n:\n            # If invalid, revert to previous state\n            new_solution = selected.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 97,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., one with the best trade-off between objectives)\n    archive_solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Normalize objectives to compare trade-offs\n    normalized_objectives = objectives / np.max(objectives, axis=0)\n    scores = np.sum(normalized_objectives, axis=1)  # Sum of normalized objectives as a simple score\n    best_idx = np.argmin(scores)  # Select the solution with the best trade-off\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search operator: combination of edge insertion and swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify (edge insertion)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b]\n\n    # Remove the segment and reinsert it in a different position\n    remaining = np.concatenate([new_solution[:a], new_solution[b:]])\n    insert_pos = np.random.randint(0, len(remaining) + 1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Apply a swap to further improve the solution\n    if n > 2:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is a valid tour (no duplicates or missing nodes)\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.7057159698322599,
            2.5611549019813538
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., one with the best trade-off between objectives)\n    archive_solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Normalize objectives to compare trade-offs\n    normalized_objectives = objectives / np.max(objectives, axis=0)\n    scores = np.sum(normalized_objectives, axis=1)  # Sum of normalized objectives as a simple score\n    best_idx = np.argmin(scores)  # Select the solution with the best trade-off\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search operator: combination of edge insertion and swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify (edge insertion)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b]\n\n    # Remove the segment and reinsert it in a different position\n    remaining = np.concatenate([new_solution[:a], new_solution[b:]])\n    insert_pos = np.random.randint(0, len(remaining) + 1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Apply a swap to further improve the solution\n    if n > 2:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is a valid tour (no duplicates or missing nodes)\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 98,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weights = [0.5, 0.5]  # Equal weight for both objectives\n    best_solution = max(archive, key=lambda x: -(weights[0] * x[1][0] + weights[1] * x[1][1]))[0]\n    new_solution = best_solution.copy()\n\n    # Apply hybrid local search: 3-opt + segment-based relocation\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # 3-opt move (select three random non-consecutive edges and reconnect them)\n    i, j, k = sorted(random.sample(range(1, n-1), 3))\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Reconnect segments in a new order\n    new_order = [segment1, segment2, segment3, segment4]\n    random.shuffle(new_order)\n    new_solution = np.concatenate(new_order)\n\n    # Segment-based relocation: move a random segment to a new position\n    segment_size = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_size)\n    segment = new_solution[start:start+segment_size]\n    remaining = np.concatenate([new_solution[:start], new_solution[start+segment_size:]])\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure feasibility (no node is skipped or revisited)\n    if len(np.unique(new_solution)) != len(new_solution):\n        # If invalid, revert to the original solution\n        new_solution = best_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6760859476488,
            1.9285533428192139
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weights = [0.5, 0.5]  # Equal weight for both objectives\n    best_solution = max(archive, key=lambda x: -(weights[0] * x[1][0] + weights[1] * x[1][1]))[0]\n    new_solution = best_solution.copy()\n\n    # Apply hybrid local search: 3-opt + segment-based relocation\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # 3-opt move (select three random non-consecutive edges and reconnect them)\n    i, j, k = sorted(random.sample(range(1, n-1), 3))\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Reconnect segments in a new order\n    new_order = [segment1, segment2, segment3, segment4]\n    random.shuffle(new_order)\n    new_solution = np.concatenate(new_order)\n\n    # Segment-based relocation: move a random segment to a new position\n    segment_size = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_size)\n    segment = new_solution[start:start+segment_size]\n    remaining = np.concatenate([new_solution[:start], new_solution[start+segment_size:]])\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure feasibility (no node is skipped or revisited)\n    if len(np.unique(new_solution)) != len(new_solution):\n        # If invalid, revert to the original solution\n        new_solution = best_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 99,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high variance in objectives)\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator: Edge exchange with segment inversion\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Perform edge exchange\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Perform segment inversion (novel operator)\n    segment = new_solution[k:l+1]\n    new_solution[k:l+1] = segment[::-1]\n\n    # Ensure feasibility: check for duplicates and fix if needed\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, perform a repair operation (swap missing nodes)\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for m in missing_nodes:\n            idx = np.where(new_solution == random.choice(unique_nodes))[0][0]\n            new_solution[idx] = m\n\n    return new_solution\n\n",
        "score": [
            -0.9482578888004229,
            1.3355233669281006
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high variance in objectives)\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator: Edge exchange with segment inversion\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Perform edge exchange\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Perform segment inversion (novel operator)\n    segment = new_solution[k:l+1]\n    new_solution[k:l+1] = segment[::-1]\n\n    # Ensure feasibility: check for duplicates and fix if needed\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, perform a repair operation (swap missing nodes)\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for m in missing_nodes:\n            idx = np.where(new_solution == random.choice(unique_nodes))[0][0]\n            new_solution[idx] = m\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 100,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its rank (higher rank = more promising)\n    ranks = np.argsort([obj[0] + obj[1] for _, obj in archive])[::-1]  # Sort by sum of objectives in descending order\n    selected_idx = random.choices(range(len(archive)), weights=[1/(i+1) for i in ranks])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation with edge insertion\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select a segment to relocate (3-5 nodes)\n    segment_length = random.randint(3, min(5, n-2))\n    segment_start = random.randint(0, n - segment_length - 1)\n    segment = new_solution[segment_start:segment_start + segment_length]\n\n    # Step 2: Remove the segment from the solution\n    new_solution = np.concatenate([new_solution[:segment_start], new_solution[segment_start + segment_length:]])\n\n    # Step 3: Find the best insertion point for the segment in both objective spaces\n    best_insert_pos = 0\n    min_total_cost = float('inf')\n\n    for i in range(len(new_solution)):\n        # Temporarily insert the segment at position i\n        candidate = np.insert(new_solution, i, segment)\n\n        # Calculate the cost for the candidate solution in both spaces\n        cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(len(candidate)))\n        cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(len(candidate)))\n\n        # Weighted sum of costs (can be adjusted for different preferences)\n        total_cost = cost1 + cost2\n\n        if total_cost < min_total_cost:\n            min_total_cost = total_cost\n            best_insert_pos = i\n\n    # Insert the segment at the best position\n    new_solution = np.insert(new_solution, best_insert_pos, segment)\n\n    # Step 4: Apply edge insertion to further improve the solution\n    for _ in range(min(3, n // 2)):  # Limit the number of edge insertions\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) < 2:\n            continue  # Skip if too close\n\n        # Perform edge insertion\n        a, b = min(i, j), max(i, j)\n        new_solution[b], new_solution[a+1] = new_solution[a+1], new_solution[b]\n\n        # Check if the move improves both objectives\n        original_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b-1]] + distance_matrix_1[new_solution[a], new_solution[b]]\n\n        original_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b-1]] + distance_matrix_2[new_solution[a], new_solution[b]]\n\n        if new_cost1 > original_cost1 or new_cost2 > original_cost2:\n            # Revert if the move worsens either objective\n            new_solution[b], new_solution[a+1] = new_solution[a+1], new_solution[b]\n\n    return new_solution\n\n",
        "score": [
            -0.8689243490480109,
            13.319243729114532
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its rank (higher rank = more promising)\n    ranks = np.argsort([obj[0] + obj[1] for _, obj in archive])[::-1]  # Sort by sum of objectives in descending order\n    selected_idx = random.choices(range(len(archive)), weights=[1/(i+1) for i in ranks])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation with edge insertion\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select a segment to relocate (3-5 nodes)\n    segment_length = random.randint(3, min(5, n-2))\n    segment_start = random.randint(0, n - segment_length - 1)\n    segment = new_solution[segment_start:segment_start + segment_length]\n\n    # Step 2: Remove the segment from the solution\n    new_solution = np.concatenate([new_solution[:segment_start], new_solution[segment_start + segment_length:]])\n\n    # Step 3: Find the best insertion point for the segment in both objective spaces\n    best_insert_pos = 0\n    min_total_cost = float('inf')\n\n    for i in range(len(new_solution)):\n        # Temporarily insert the segment at position i\n        candidate = np.insert(new_solution, i, segment)\n\n        # Calculate the cost for the candidate solution in both spaces\n        cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(len(candidate)))\n        cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(len(candidate)))\n\n        # Weighted sum of costs (can be adjusted for different preferences)\n        total_cost = cost1 + cost2\n\n        if total_cost < min_total_cost:\n            min_total_cost = total_cost\n            best_insert_pos = i\n\n    # Insert the segment at the best position\n    new_solution = np.insert(new_solution, best_insert_pos, segment)\n\n    # Step 4: Apply edge insertion to further improve the solution\n    for _ in range(min(3, n // 2)):  # Limit the number of edge insertions\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) < 2:\n            continue  # Skip if too close\n\n        # Perform edge insertion\n        a, b = min(i, j), max(i, j)\n        new_solution[b], new_solution[a+1] = new_solution[a+1], new_solution[b]\n\n        # Check if the move improves both objectives\n        original_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b-1]] + distance_matrix_1[new_solution[a], new_solution[b]]\n\n        original_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b-1]] + distance_matrix_2[new_solution[a], new_solution[b]]\n\n        if new_cost1 > original_cost1 or new_cost2 > original_cost2:\n            # Revert if the move worsens either objective\n            new_solution[b], new_solution[a+1] = new_solution[a+1], new_solution[b]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 101,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    weights = 1 / (normalized_obj.sum(axis=1) + 1e-10)\n    weights = weights / weights.sum()  # Normalize weights\n\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: edge insertion with biased random walk\n    n_nodes = len(base_solution)\n    if n_nodes < 3:\n        return new_solution  # No improvement possible\n\n    # Step 1: Select a random segment to remove (3 to 5 nodes)\n    segment_length = np.random.randint(3, min(6, n_nodes - 2))\n    start = np.random.randint(0, n_nodes - segment_length)\n    segment = new_solution[start:start + segment_length]\n\n    # Step 2: Remove the segment and insert it at a new position with bias towards lower cost edges\n    remaining = np.concatenate([new_solution[:start], new_solution[start + segment_length:]])\n    insertion_pos = np.random.randint(0, len(remaining) + 1)\n\n    # Step 3: Calculate insertion cost for each possible position\n    insertion_costs = []\n    for i in range(len(remaining) + 1):\n        if i == 0:\n            prev_node = remaining[-1]\n            next_node = remaining[0]\n        elif i == len(remaining):\n            prev_node = remaining[-1]\n            next_node = remaining[0]\n        else:\n            prev_node = remaining[i - 1]\n            next_node = remaining[i]\n\n        # Cost is the sum of distances before and after insertion\n        cost = (distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node] +\n                distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node])\n        insertion_costs.append(cost)\n\n    # Step 4: Bias insertion position selection towards lower cost\n    insertion_costs = np.array(insertion_costs)\n    insertion_probs = np.exp(-insertion_costs / insertion_costs.max())  # Exponential bias\n    insertion_probs = insertion_probs / insertion_probs.sum()\n    insertion_pos = np.random.choice(len(insertion_costs), p=insertion_probs)\n\n    # Step 5: Insert the segment at the selected position\n    new_solution = np.concatenate([\n        remaining[:insertion_pos],\n        segment,\n        remaining[insertion_pos:]\n    ])\n\n    # Step 6: Optional: Apply a small random walk to escape local optima\n    if np.random.random() < 0.3:\n        swap_pos1, swap_pos2 = np.random.choice(len(new_solution), 2, replace=False)\n        new_solution[swap_pos1], new_solution[swap_pos2] = new_solution[swap_pos2], new_solution[swap_pos1]\n\n    return new_solution\n\n",
        "score": [
            -0.8658086477643325,
            3.264209568500519
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    weights = 1 / (normalized_obj.sum(axis=1) + 1e-10)\n    weights = weights / weights.sum()  # Normalize weights\n\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: edge insertion with biased random walk\n    n_nodes = len(base_solution)\n    if n_nodes < 3:\n        return new_solution  # No improvement possible\n\n    # Step 1: Select a random segment to remove (3 to 5 nodes)\n    segment_length = np.random.randint(3, min(6, n_nodes - 2))\n    start = np.random.randint(0, n_nodes - segment_length)\n    segment = new_solution[start:start + segment_length]\n\n    # Step 2: Remove the segment and insert it at a new position with bias towards lower cost edges\n    remaining = np.concatenate([new_solution[:start], new_solution[start + segment_length:]])\n    insertion_pos = np.random.randint(0, len(remaining) + 1)\n\n    # Step 3: Calculate insertion cost for each possible position\n    insertion_costs = []\n    for i in range(len(remaining) + 1):\n        if i == 0:\n            prev_node = remaining[-1]\n            next_node = remaining[0]\n        elif i == len(remaining):\n            prev_node = remaining[-1]\n            next_node = remaining[0]\n        else:\n            prev_node = remaining[i - 1]\n            next_node = remaining[i]\n\n        # Cost is the sum of distances before and after insertion\n        cost = (distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node] +\n                distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node])\n        insertion_costs.append(cost)\n\n    # Step 4: Bias insertion position selection towards lower cost\n    insertion_costs = np.array(insertion_costs)\n    insertion_probs = np.exp(-insertion_costs / insertion_costs.max())  # Exponential bias\n    insertion_probs = insertion_probs / insertion_probs.sum()\n    insertion_pos = np.random.choice(len(insertion_costs), p=insertion_probs)\n\n    # Step 5: Insert the segment at the selected position\n    new_solution = np.concatenate([\n        remaining[:insertion_pos],\n        segment,\n        remaining[insertion_pos:]\n    ])\n\n    # Step 6: Optional: Apply a small random walk to escape local optima\n    if np.random.random() < 0.3:\n        swap_pos1, swap_pos2 = np.random.choice(len(new_solution), 2, replace=False)\n        new_solution[swap_pos1], new_solution[swap_pos2] = new_solution[swap_pos2], new_solution[swap_pos1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 102,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # We prioritize solutions that are not dominated by others in the archive\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        # If all solutions are dominated, select the one with the best combined cost\n        base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    else:\n        # Select a non-dominated solution with high diversity (randomly chosen)\n        base_solution, _ = random.choice(non_dominated)\n\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # For larger instances, perform a more complex operator\n        # 1. Select a segment of the tour (3-5 nodes)\n        seg_length = min(5, n // 2)\n        start = random.randint(0, n - seg_length)\n        end = start + seg_length\n\n        # 2. Extract the segment and reverse it (similar to 2-opt but more flexible)\n        segment = new_solution[start:end]\n        reversed_segment = segment[::-1]\n\n        # 3. Optionally perform a random walk within the segment\n        if random.random() < 0.3:\n            # Randomly shuffle a portion of the segment\n            sub_start = random.randint(0, len(segment)-2)\n            sub_end = random.randint(sub_start+1, len(segment)-1)\n            segment[sub_start:sub_end] = np.random.permutation(segment[sub_start:sub_end])\n\n        # 4. Insert the modified segment back\n        new_solution[start:end] = segment\n\n        # 5. With some probability, perform an additional edge exchange\n        if random.random() < 0.5:\n            # Select two random edges and swap their connections\n            i, j = sorted(random.sample(range(n), 2))\n            if i+1 < j:\n                # Only perform the swap if it maintains feasibility\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7382361511598032,
            3.113748550415039
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # We prioritize solutions that are not dominated by others in the archive\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        # If all solutions are dominated, select the one with the best combined cost\n        base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    else:\n        # Select a non-dominated solution with high diversity (randomly chosen)\n        base_solution, _ = random.choice(non_dominated)\n\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # For larger instances, perform a more complex operator\n        # 1. Select a segment of the tour (3-5 nodes)\n        seg_length = min(5, n // 2)\n        start = random.randint(0, n - seg_length)\n        end = start + seg_length\n\n        # 2. Extract the segment and reverse it (similar to 2-opt but more flexible)\n        segment = new_solution[start:end]\n        reversed_segment = segment[::-1]\n\n        # 3. Optionally perform a random walk within the segment\n        if random.random() < 0.3:\n            # Randomly shuffle a portion of the segment\n            sub_start = random.randint(0, len(segment)-2)\n            sub_end = random.randint(sub_start+1, len(segment)-1)\n            segment[sub_start:sub_end] = np.random.permutation(segment[sub_start:sub_end])\n\n        # 4. Insert the modified segment back\n        new_solution[start:end] = segment\n\n        # 5. With some probability, perform an additional edge exchange\n        if random.random() < 0.5:\n            # Select two random edges and swap their connections\n            i, j = sorted(random.sample(range(n), 2))\n            if i+1 < j:\n                # Only perform the swap if it maintains feasibility\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 103,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge swap\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Apply 3-opt: reverse segments between i, j, k\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Custom edge swap: swap edges (i, i+1) and (j, j+1) if it improves both objectives\n    if i + 1 < j and j + 1 < n:\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[j+1]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n\n        # Propose new edges\n        proposed_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[j+1]]\n        proposed_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]]\n\n        if (proposed_cost1 < current_cost1 and proposed_cost2 < current_cost2):\n            # Perform the swap\n            new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n    return new_solution\n\n",
        "score": [
            -0.8102085886706931,
            2.039758861064911
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge swap\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Apply 3-opt: reverse segments between i, j, k\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Custom edge swap: swap edges (i, i+1) and (j, j+1) if it improves both objectives\n    if i + 1 < j and j + 1 < n:\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[j+1]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n\n        # Propose new edges\n        proposed_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[j+1]]\n        proposed_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]]\n\n        if (proposed_cost1 < current_cost1 and proposed_cost2 < current_cost2):\n            # Perform the swap\n            new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 104,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its objective values (higher cost, lower probability)\n    objectives = [obj for (sol, obj) in archive]\n    costs = np.array([sum(obj) for obj in objectives])\n    if np.all(costs == costs[0]):\n        # If all costs are equal, select randomly\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        # Normalize costs to probabilities (lower cost, higher probability)\n        probs = 1 / (costs + 1e-6)  # Avoid division by zero\n        probs = probs / np.sum(probs)\n        selected_idx = np.random.choice(len(archive), p=probs)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a custom operator\n    n = len(new_solution)\n    if n < 4:\n        # If the tour is too small, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Choose between 3-opt or custom operator with 50% probability\n        if random.random() < 0.5:\n            # 3-opt: select 3 random edges and reconnect them\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j]\n            segment2 = new_solution[j:k]\n            new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n        else:\n            # Custom operator: relocate a segment of nodes to a different position\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment = new_solution[i:j]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9251992192796855,
            2.4558298587799072
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its objective values (higher cost, lower probability)\n    objectives = [obj for (sol, obj) in archive]\n    costs = np.array([sum(obj) for obj in objectives])\n    if np.all(costs == costs[0]):\n        # If all costs are equal, select randomly\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        # Normalize costs to probabilities (lower cost, higher probability)\n        probs = 1 / (costs + 1e-6)  # Avoid division by zero\n        probs = probs / np.sum(probs)\n        selected_idx = np.random.choice(len(archive), p=probs)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a custom operator\n    n = len(new_solution)\n    if n < 4:\n        # If the tour is too small, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Choose between 3-opt or custom operator with 50% probability\n        if random.random() < 0.5:\n            # 3-opt: select 3 random edges and reconnect them\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j]\n            segment2 = new_solution[j:k]\n            new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n        else:\n            # Custom operator: relocate a segment of nodes to a different position\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment = new_solution[i:j]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 105,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high diversity)\n    candidates = [sol for sol, _ in archive]\n    selected_idx = np.random.choice(len(candidates))\n    base_solution = candidates[selected_idx].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select three non-consecutive edges to perform a 3-opt move\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    while j == i + 1 or k == j + 1:  # Ensure non-consecutive edges\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Perform 3-opt move\n    new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n    new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n\n    # Step 2: Novel edge-swap strategy: swap edges between two randomly selected nodes\n    a, b = np.random.choice(n, 2, replace=False)\n    if a > b:\n        a, b = b, a\n\n    # Ensure the swap maintains feasibility\n    if b - a > 1:\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution is a valid tour (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Invalid tour generated.\"\n\n    return new_solution\n\n",
        "score": [
            -0.8466376271995935,
            1.8535394668579102
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high diversity)\n    candidates = [sol for sol, _ in archive]\n    selected_idx = np.random.choice(len(candidates))\n    base_solution = candidates[selected_idx].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select three non-consecutive edges to perform a 3-opt move\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    while j == i + 1 or k == j + 1:  # Ensure non-consecutive edges\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Perform 3-opt move\n    new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n    new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n\n    # Step 2: Novel edge-swap strategy: swap edges between two randomly selected nodes\n    a, b = np.random.choice(n, 2, replace=False)\n    if a > b:\n        a, b = b, a\n\n    # Ensure the swap maintains feasibility\n    if b - a > 1:\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution is a valid tour (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Invalid tour generated.\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 106,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for (sol, obj) in archive]\n    costs1 = np.array([obj[0] for obj in objectives])\n    costs2 = np.array([obj[1] for obj in objectives])\n\n    # Normalize costs to avoid bias towards any single objective\n    norm_costs1 = (costs1 - np.min(costs1)) / (np.max(costs1) - np.min(costs1) + 1e-10)\n    norm_costs2 = (costs2 - np.min(costs2)) / (np.max(costs2) - np.min(costs2) + 1e-10)\n\n    # Calculate combined score (lower is better)\n    combined_score = norm_costs1 + norm_costs2\n    probabilities = 1.0 / (combined_score + 1e-10)\n    probabilities /= np.sum(probabilities)\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of edge exchange and segment relocation\n    n = len(new_solution)\n    if n <= 3:\n        # For small tours, just reverse the order\n        new_solution = new_solution[::-1]\n    else:\n        # Choose a random segment to relocate\n        segment_size = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - segment_size)\n        segment = new_solution[start:start + segment_size]\n\n        # Choose a new position for the segment\n        new_pos = random.randint(0, n - segment_size)\n        while new_pos >= start and new_pos <= start + segment_size:\n            new_pos = random.randint(0, n - segment_size)\n\n        # Create new solution by removing the segment and inserting it at the new position\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[start + segment_size:]\n        ])\n        new_solution = np.insert(new_solution, new_pos, segment)\n\n        # Optionally, perform a random edge exchange\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7839558542106614,
            2.8812222480773926
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for (sol, obj) in archive]\n    costs1 = np.array([obj[0] for obj in objectives])\n    costs2 = np.array([obj[1] for obj in objectives])\n\n    # Normalize costs to avoid bias towards any single objective\n    norm_costs1 = (costs1 - np.min(costs1)) / (np.max(costs1) - np.min(costs1) + 1e-10)\n    norm_costs2 = (costs2 - np.min(costs2)) / (np.max(costs2) - np.min(costs2) + 1e-10)\n\n    # Calculate combined score (lower is better)\n    combined_score = norm_costs1 + norm_costs2\n    probabilities = 1.0 / (combined_score + 1e-10)\n    probabilities /= np.sum(probabilities)\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of edge exchange and segment relocation\n    n = len(new_solution)\n    if n <= 3:\n        # For small tours, just reverse the order\n        new_solution = new_solution[::-1]\n    else:\n        # Choose a random segment to relocate\n        segment_size = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - segment_size)\n        segment = new_solution[start:start + segment_size]\n\n        # Choose a new position for the segment\n        new_pos = random.randint(0, n - segment_size)\n        while new_pos >= start and new_pos <= start + segment_size:\n            new_pos = random.randint(0, n - segment_size)\n\n        # Create new solution by removing the segment and inserting it at the new position\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[start + segment_size:]\n        ])\n        new_solution = np.insert(new_solution, new_pos, segment)\n\n        # Optionally, perform a random edge exchange\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 107,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (top 20% of the archive)\n    archive_size = len(archive)\n    top_k = max(1, int(0.2 * archive_size))\n    selected_indices = sorted(random.sample(range(archive_size), top_k), key=lambda i: sum(archive[i][1]))\n    selected_idx = random.choice(selected_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search\n    n = len(new_solution)\n    operator = random.choice(['3-opt', 'segment_reversal', 'node_insertion'])\n\n    if operator == '3-opt' and n >= 3:\n        # Select 3 random non-adjacent edges\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Rearrange the edges to form a new tour\n        new_solution = np.concatenate([\n            new_solution[:i+1],\n            new_solution[j:k+1][::-1],\n            new_solution[i+1:j],\n            new_solution[k+1:]\n        ])\n    elif operator == 'segment_reversal' and n >= 2:\n        # Reverse a random segment\n        start, end = sorted(random.sample(range(n), 2))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n    elif operator == 'node_insertion' and n >= 2:\n        # Move a random node to a different position\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        new_solution = np.concatenate([\n            new_solution[:node_idx],\n            new_solution[node_idx+1:]\n        ])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            [node],\n            new_solution[insert_pos:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -0.804649729891618,
            2.3347217440605164
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (top 20% of the archive)\n    archive_size = len(archive)\n    top_k = max(1, int(0.2 * archive_size))\n    selected_indices = sorted(random.sample(range(archive_size), top_k), key=lambda i: sum(archive[i][1]))\n    selected_idx = random.choice(selected_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search\n    n = len(new_solution)\n    operator = random.choice(['3-opt', 'segment_reversal', 'node_insertion'])\n\n    if operator == '3-opt' and n >= 3:\n        # Select 3 random non-adjacent edges\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Rearrange the edges to form a new tour\n        new_solution = np.concatenate([\n            new_solution[:i+1],\n            new_solution[j:k+1][::-1],\n            new_solution[i+1:j],\n            new_solution[k+1:]\n        ])\n    elif operator == 'segment_reversal' and n >= 2:\n        # Reverse a random segment\n        start, end = sorted(random.sample(range(n), 2))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n    elif operator == 'node_insertion' and n >= 2:\n        # Move a random node to a different position\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        new_solution = np.concatenate([\n            new_solution[:node_idx],\n            new_solution[node_idx+1:]\n        ])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            [node],\n            new_solution[insert_pos:]\n        ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 108,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their total distance (sum of both objectives)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select from top 30% of solutions\n        candidate_indices = range(min(3, len(sorted_archive)))\n        selected_idx = random.choice(candidate_indices)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    if n > 3:\n        # Step 1: Randomly select a segment to reverse\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))  # Limit segment size for efficiency\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Step 2: Randomly insert a node from another position\n        if n > 4:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                # Ensure we're not creating duplicates\n                temp = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                insert_pos = random.randint(0, n-2)\n                new_solution = np.insert(new_solution, insert_pos, temp)\n\n    # Ensure the solution remains feasible (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If duplicates exist, revert to original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8237909059904389,
            2.3772298097610474
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their total distance (sum of both objectives)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select from top 30% of solutions\n        candidate_indices = range(min(3, len(sorted_archive)))\n        selected_idx = random.choice(candidate_indices)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    if n > 3:\n        # Step 1: Randomly select a segment to reverse\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))  # Limit segment size for efficiency\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Step 2: Randomly insert a node from another position\n        if n > 4:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                # Ensure we're not creating duplicates\n                temp = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                insert_pos = random.randint(0, n-2)\n                new_solution = np.insert(new_solution, insert_pos, temp)\n\n    # Ensure the solution remains feasible (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If duplicates exist, revert to original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 109,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., with high variance in objectives)\n    def potential_score(solution, objective):\n        # Simple heuristic: higher potential if the solution has high variance in objectives\n        return abs(objective[0] - objective[1])\n\n    # Sort solutions by potential score (descending)\n    sorted_archive = sorted(archive, key=lambda x: -potential_score(x[0], x[1]))\n    selected_solution = sorted_archive[0][0].copy()\n\n    # Hybrid local search: combine 3-opt with random swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose a segment to modify\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # 3-opt move: reverse a segment or rotate it\n    if random.random() < 0.5:\n        # Reverse segment\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    else:\n        # Rotate segment\n        segment = new_solution[a:b+1]\n        shift = random.randint(1, len(segment)-1)\n        new_solution[a:b+1] = np.roll(segment, shift)\n\n    # Random swap to ensure diversity\n    if random.random() < 0.3:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing them with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes[0]\n            missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.3720340742679311,
            1.849069595336914
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., with high variance in objectives)\n    def potential_score(solution, objective):\n        # Simple heuristic: higher potential if the solution has high variance in objectives\n        return abs(objective[0] - objective[1])\n\n    # Sort solutions by potential score (descending)\n    sorted_archive = sorted(archive, key=lambda x: -potential_score(x[0], x[1]))\n    selected_solution = sorted_archive[0][0].copy()\n\n    # Hybrid local search: combine 3-opt with random swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose a segment to modify\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # 3-opt move: reverse a segment or rotate it\n    if random.random() < 0.5:\n        # Reverse segment\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    else:\n        # Rotate segment\n        segment = new_solution[a:b+1]\n        shift = random.randint(1, len(segment)-1)\n        new_solution[a:b+1] = np.roll(segment, shift)\n\n    # Random swap to ensure diversity\n    if random.random() < 0.3:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing them with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes[0]\n            missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 110,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest cost but not already optimal)\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))  # Sort by sum of objectives\n    candidate_solutions = [sol for sol in archive if not (sol[1][0] == 0 and sol[1][1] == 0)]  # Exclude optimal solutions\n\n    if not candidate_solutions:\n        base_solution = archive[0][0].copy()\n    else:\n        # Select a solution with high diversity (not too similar to others)\n        base_solution = candidate_solutions[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of 2-opt and node insertion\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # No improvement possible for very small tours\n\n    # Step 1: Apply 2-opt with distance matrix selection based on current objective\n    obj1, obj2 = archive[0][1]  # Using first solution's objective for decision\n    if obj1 > obj2:\n        dist_matrix = distance_matrix_1\n    else:\n        dist_matrix = distance_matrix_2\n\n    i, j = np.random.randint(0, n, size=2)\n    if i > j:\n        i, j = j, i\n\n    # Ensure i and j are not adjacent\n    if j - i == 1:\n        j = (j + 1) % n\n\n    # Reverse the segment between i and j\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Apply node insertion with the other distance matrix\n    other_dist_matrix = distance_matrix_2 if dist_matrix is distance_matrix_1 else distance_matrix_1\n\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n\n    # Find the best insertion point using the other distance matrix\n    best_pos = 0\n    min_cost = float('inf')\n    for pos in range(n - 1):\n        temp_solution = np.insert(new_solution, pos, node)\n        cost = (dist_matrix[temp_solution[-1], temp_solution[0]] +\n                other_dist_matrix[temp_solution[-1], temp_solution[0]])\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = pos\n\n    new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure the solution is a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution  # Fallback to original if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.8858508211289167,
            4.58718603849411
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest cost but not already optimal)\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))  # Sort by sum of objectives\n    candidate_solutions = [sol for sol in archive if not (sol[1][0] == 0 and sol[1][1] == 0)]  # Exclude optimal solutions\n\n    if not candidate_solutions:\n        base_solution = archive[0][0].copy()\n    else:\n        # Select a solution with high diversity (not too similar to others)\n        base_solution = candidate_solutions[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of 2-opt and node insertion\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # No improvement possible for very small tours\n\n    # Step 1: Apply 2-opt with distance matrix selection based on current objective\n    obj1, obj2 = archive[0][1]  # Using first solution's objective for decision\n    if obj1 > obj2:\n        dist_matrix = distance_matrix_1\n    else:\n        dist_matrix = distance_matrix_2\n\n    i, j = np.random.randint(0, n, size=2)\n    if i > j:\n        i, j = j, i\n\n    # Ensure i and j are not adjacent\n    if j - i == 1:\n        j = (j + 1) % n\n\n    # Reverse the segment between i and j\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Apply node insertion with the other distance matrix\n    other_dist_matrix = distance_matrix_2 if dist_matrix is distance_matrix_1 else distance_matrix_1\n\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n\n    # Find the best insertion point using the other distance matrix\n    best_pos = 0\n    min_cost = float('inf')\n    for pos in range(n - 1):\n        temp_solution = np.insert(new_solution, pos, node)\n        cost = (dist_matrix[temp_solution[-1], temp_solution[0]] +\n                other_dist_matrix[temp_solution[-1], temp_solution[0]])\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = pos\n\n    new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure the solution is a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution  # Fallback to original if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 111,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / (objectives.sum(axis=0) + 1e-10)\n    selection_probs = 1 - normalized_objectives.mean(axis=1)\n    selection_probs = selection_probs / selection_probs.sum()\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion with a novel segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select two random segments to operate on\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Edge insertion: move segment [a:b] to position c\n    segment = new_solution[a:b]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n    new_solution = np.concatenate([new_solution[:c], segment, new_solution[c:]])\n\n    # Novel segment reversal: reverse segment [c:d] with probability 0.5\n    if random.random() < 0.5:\n        segment = new_solution[c:d]\n        new_solution[c:d] = segment[::-1]\n\n    # Ensure the solution remains valid (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or not np.all(counts == 1):\n        # Fallback to a simple swap if the operation fails\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.843110012096046,
            2.7134631872177124
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / (objectives.sum(axis=0) + 1e-10)\n    selection_probs = 1 - normalized_objectives.mean(axis=1)\n    selection_probs = selection_probs / selection_probs.sum()\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion with a novel segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select two random segments to operate on\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Edge insertion: move segment [a:b] to position c\n    segment = new_solution[a:b]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n    new_solution = np.concatenate([new_solution[:c], segment, new_solution[c:]])\n\n    # Novel segment reversal: reverse segment [c:d] with probability 0.5\n    if random.random() < 0.5:\n        segment = new_solution[c:d]\n        new_solution[c:d] = segment[::-1]\n\n    # Ensure the solution remains valid (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or not np.all(counts == 1):\n        # Fallback to a simple swap if the operation fails\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 112,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / np.sum(objectives, axis=0, keepdims=True)\n    weights = 1 / (normalized_objectives[:, 0] + normalized_objectives[:, 1] + 1e-6)\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge exchange\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select segments for 3-opt\n    i, j, k = sorted(random.sample(range(1, n-1), 3))\n\n    # Apply 3-opt\n    if random.random() < 0.5:\n        new_solution[i:j] = new_solution[i:j][::-1]\n    if random.random() < 0.5:\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Custom edge exchange: swap two edges if it improves both objectives\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[b+1]]\n    current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[b+1]]\n    new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[b+1]]\n    new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[b+1]]\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or random.random() < 0.2:\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7823466178954273,
            2.6549412608146667
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / np.sum(objectives, axis=0, keepdims=True)\n    weights = 1 / (normalized_objectives[:, 0] + normalized_objectives[:, 1] + 1e-6)\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge exchange\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select segments for 3-opt\n    i, j, k = sorted(random.sample(range(1, n-1), 3))\n\n    # Apply 3-opt\n    if random.random() < 0.5:\n        new_solution[i:j] = new_solution[i:j][::-1]\n    if random.random() < 0.5:\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Custom edge exchange: swap two edges if it improves both objectives\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[b+1]]\n    current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[b+1]]\n    new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[b+1]]\n    new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[b+1]]\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or random.random() < 0.2:\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 113,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on Pareto dominance or diversity\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel edge insertion\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations for better exploration\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n        # Apply a novel edge insertion: move a segment and insert it elsewhere\n        segment = new_solution[i:j]\n        remaining = np.concatenate([new_solution[:i], new_solution[j:]])\n        insert_pos = random.randint(0, len(remaining) - 1)\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n        # Apply 2-opt within the segment to improve local structure\n        if len(segment) > 2:\n            a, b = sorted(random.sample(range(len(segment)), 2))\n            segment[a:b] = segment[a:b][::-1]\n            new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure the solution remains valid (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        extra = set(unique_nodes) - set(range(n))\n        for m in missing:\n            pos = random.randint(0, n - 1)\n            new_solution[pos] = m\n        for e in extra:\n            pos = np.where(new_solution == e)[0][0]\n            new_solution[pos] = random.choice(list(set(range(n)) - set(new_solution)))\n\n    return new_solution\n\n",
        "score": [
            -0.757224967981406,
            2.8438620567321777
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on Pareto dominance or diversity\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel edge insertion\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations for better exploration\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n        # Apply a novel edge insertion: move a segment and insert it elsewhere\n        segment = new_solution[i:j]\n        remaining = np.concatenate([new_solution[:i], new_solution[j:]])\n        insert_pos = random.randint(0, len(remaining) - 1)\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n        # Apply 2-opt within the segment to improve local structure\n        if len(segment) > 2:\n            a, b = sorted(random.sample(range(len(segment)), 2))\n            segment[a:b] = segment[a:b][::-1]\n            new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure the solution remains valid (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        extra = set(unique_nodes) - set(range(n))\n        for m in missing:\n            pos = random.randint(0, n - 1)\n            new_solution[pos] = m\n        for e in extra:\n            pos = np.where(new_solution == e)[0][0]\n            new_solution[pos] = random.choice(list(set(range(n)) - set(new_solution)))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 114,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its Pareto dominance\n    # or random selection if no dominance information is available\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal operator\n    # First, perform a random 3-opt move\n    n = len(selected_solution)\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Create a new solution by reversing segments between i, j, and k\n    new_solution = selected_solution.copy()\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n    new_solution[j:k+1] = np.flip(new_solution[j:k+1])\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, fall back to a simpler 2-opt move\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution = selected_solution.copy()\n        new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    return new_solution\n\n",
        "score": [
            -0.9377728648618688,
            2.1395994424819946
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its Pareto dominance\n    # or random selection if no dominance information is available\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal operator\n    # First, perform a random 3-opt move\n    n = len(selected_solution)\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Create a new solution by reversing segments between i, j, and k\n    new_solution = selected_solution.copy()\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n    new_solution[j:k+1] = np.flip(new_solution[j:k+1])\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, fall back to a simpler 2-opt move\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution = selected_solution.copy()\n        new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 115,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest cost in either objective)\n    archive.sort(key=lambda x: x[1][0] + x[1][1])  # Sort by sum of objectives\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a novel edge swap\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Randomly select three segments to modify\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Novel edge swap: swap three edges in a way that maintains feasibility\n    # This creates a more complex reconfiguration than 2-opt\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Reconstruct the solution with swapped segments\n    new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Verify the solution is still a valid tour (no duplicates)\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        # If invalid, fall back to a simpler swap\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        return new_solution\n\n",
        "score": [
            -0.8013863859811157,
            1.6300206780433655
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest cost in either objective)\n    archive.sort(key=lambda x: x[1][0] + x[1][1])  # Sort by sum of objectives\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a novel edge swap\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Randomly select three segments to modify\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Novel edge swap: swap three edges in a way that maintains feasibility\n    # This creates a more complex reconfiguration than 2-opt\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Reconstruct the solution with swapped segments\n    new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Verify the solution is still a valid tour (no duplicates)\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        # If invalid, fall back to a simpler swap\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 116,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest sum of normalized objectives (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct positions (ensuring feasibility)\n    a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Apply 3-opt move (reverse a segment)\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply custom edge swap (swap edges between segments)\n    if np.random.rand() < 0.5:  # 50% chance to apply the swap\n        new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n\n    # Ensure the solution remains a valid tour\n    assert len(np.unique(new_solution)) == n, \"Invalid tour generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.911933757724246,
            2.1638532280921936
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest sum of normalized objectives (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct positions (ensuring feasibility)\n    a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Apply 3-opt move (reverse a segment)\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply custom edge swap (swap edges between segments)\n    if np.random.rand() < 0.5:  # 50% chance to apply the swap\n        new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n\n    # Ensure the solution remains a valid tour\n    assert len(np.unique(new_solution)) == n, \"Invalid tour generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 117,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        return archive[0][0].copy()\n\n    # Select a solution with high diversity (not too similar to others)\n    selected_solution = archive_solutions[0]\n    if len(archive_solutions) > 1:\n        # Compare solutions based on hamming distance\n        hamming_distances = [np.sum(selected_solution != other) for other in archive_solutions[1:]]\n        selected_solution = archive_solutions[np.argmax(hamming_distances)]\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n\n    # Step 1: Random segment reordering (novel heuristic)\n    if n > 3:\n        segment_length = random.randint(2, min(5, n // 3))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        # Extract the segment and reverse it\n        segment = new_solution[start:end]\n        new_segment = segment[::-1]\n\n        # Calculate the change in both objectives\n        old_cost1 = distance_matrix_1[new_solution[start-1], new_solution[start]] + distance_matrix_1[new_solution[end-1], new_solution[end % n]]\n        new_cost1 = distance_matrix_1[new_solution[start-1], new_segment[0]] + distance_matrix_1[new_segment[-1], new_solution[end % n]]\n\n        old_cost2 = distance_matrix_2[new_solution[start-1], new_solution[start]] + distance_matrix_2[new_solution[end-1], new_solution[end % n]]\n        new_cost2 = distance_matrix_2[new_solution[start-1], new_segment[0]] + distance_matrix_2[new_segment[-1], new_solution[end % n]]\n\n        # Accept if at least one objective improves\n        if new_cost1 < old_cost1 or new_cost2 < old_cost2:\n            new_solution[start:end] = new_segment\n\n    # Step 2: Edge exchange (2.5-opt style)\n    if n > 3:\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Try different edge exchanges\n        exchanges = [\n            (i, j, k), (i, k, j),\n            (j, i, k), (j, k, i),\n            (k, i, j), (k, j, i)\n        ]\n\n        best_new_solution = new_solution.copy()\n        best_improvement = 0\n\n        for a, b, c in exchanges:\n            temp_solution = new_solution.copy()\n            temp_solution[a:b] = temp_solution[a:b][::-1]\n            temp_solution[b:c] = temp_solution[b:c][::-1]\n\n            # Calculate change in both objectives\n            old_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_1[new_solution[c-1], new_solution[c % n]]\n            new_cost1 = distance_matrix_1[temp_solution[a-1], temp_solution[a]] + distance_matrix_1[temp_solution[b-1], temp_solution[b]] + distance_matrix_1[temp_solution[c-1], temp_solution[c % n]]\n\n            old_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[c-1], new_solution[c % n]]\n            new_cost2 = distance_matrix_2[temp_solution[a-1], temp_solution[a]] + distance_matrix_2[temp_solution[b-1], temp_solution[b]] + distance_matrix_2[temp_solution[c-1], temp_solution[c % n]]\n\n            improvement = (old_cost1 - new_cost1) + (old_cost2 - new_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_new_solution = temp_solution.copy()\n\n        new_solution = best_new_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8681285416642386,
            3.612916111946106
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        return archive[0][0].copy()\n\n    # Select a solution with high diversity (not too similar to others)\n    selected_solution = archive_solutions[0]\n    if len(archive_solutions) > 1:\n        # Compare solutions based on hamming distance\n        hamming_distances = [np.sum(selected_solution != other) for other in archive_solutions[1:]]\n        selected_solution = archive_solutions[np.argmax(hamming_distances)]\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n\n    # Step 1: Random segment reordering (novel heuristic)\n    if n > 3:\n        segment_length = random.randint(2, min(5, n // 3))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        # Extract the segment and reverse it\n        segment = new_solution[start:end]\n        new_segment = segment[::-1]\n\n        # Calculate the change in both objectives\n        old_cost1 = distance_matrix_1[new_solution[start-1], new_solution[start]] + distance_matrix_1[new_solution[end-1], new_solution[end % n]]\n        new_cost1 = distance_matrix_1[new_solution[start-1], new_segment[0]] + distance_matrix_1[new_segment[-1], new_solution[end % n]]\n\n        old_cost2 = distance_matrix_2[new_solution[start-1], new_solution[start]] + distance_matrix_2[new_solution[end-1], new_solution[end % n]]\n        new_cost2 = distance_matrix_2[new_solution[start-1], new_segment[0]] + distance_matrix_2[new_segment[-1], new_solution[end % n]]\n\n        # Accept if at least one objective improves\n        if new_cost1 < old_cost1 or new_cost2 < old_cost2:\n            new_solution[start:end] = new_segment\n\n    # Step 2: Edge exchange (2.5-opt style)\n    if n > 3:\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Try different edge exchanges\n        exchanges = [\n            (i, j, k), (i, k, j),\n            (j, i, k), (j, k, i),\n            (k, i, j), (k, j, i)\n        ]\n\n        best_new_solution = new_solution.copy()\n        best_improvement = 0\n\n        for a, b, c in exchanges:\n            temp_solution = new_solution.copy()\n            temp_solution[a:b] = temp_solution[a:b][::-1]\n            temp_solution[b:c] = temp_solution[b:c][::-1]\n\n            # Calculate change in both objectives\n            old_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_1[new_solution[c-1], new_solution[c % n]]\n            new_cost1 = distance_matrix_1[temp_solution[a-1], temp_solution[a]] + distance_matrix_1[temp_solution[b-1], temp_solution[b]] + distance_matrix_1[temp_solution[c-1], temp_solution[c % n]]\n\n            old_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[c-1], new_solution[c % n]]\n            new_cost2 = distance_matrix_2[temp_solution[a-1], temp_solution[a]] + distance_matrix_2[temp_solution[b-1], temp_solution[b]] + distance_matrix_2[temp_solution[c-1], temp_solution[c % n]]\n\n            improvement = (old_cost1 - new_cost1) + (old_cost2 - new_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_new_solution = temp_solution.copy()\n\n        new_solution = best_new_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 118,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a high probability of being non-dominated or having high diversity\n    selected_idx = random.choices(range(len(archive)), weights=[1/(i+1) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy\n    n = len(new_solution)\n    operator = random.choice(['edge_insertion', 'node_swap', 'segment_relocation'])\n\n    if operator == 'edge_insertion':\n        # Randomly select two edges and insert one between the other's nodes\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    elif operator == 'node_swap':\n        # Swap two randomly selected nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    elif operator == 'segment_relocation':\n        # Relocate a random segment of nodes to a new position\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n        insert_pos = random.randint(0, len(remaining))\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if the operator causes duplicates\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8471791747479207,
            1.7437555193901062
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a high probability of being non-dominated or having high diversity\n    selected_idx = random.choices(range(len(archive)), weights=[1/(i+1) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy\n    n = len(new_solution)\n    operator = random.choice(['edge_insertion', 'node_swap', 'segment_relocation'])\n\n    if operator == 'edge_insertion':\n        # Randomly select two edges and insert one between the other's nodes\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    elif operator == 'node_swap':\n        # Swap two randomly selected nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    elif operator == 'segment_relocation':\n        # Relocate a random segment of nodes to a new position\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n        insert_pos = random.randint(0, len(remaining))\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if the operator causes duplicates\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 119,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability biased towards better solutions\n    weights = [1.0 / (i + 1) for i in range(len(archive))]  # Higher weight for earlier solutions\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine edge insertion with 3-opt-like moves\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Choose a random segment to modify\n    start = random.randint(0, n - 4)\n    end = random.randint(start + 3, min(start + 6, n - 1))\n\n    # Extract the segment and remaining nodes\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n\n    # Determine the best insertion point for the segment in both objective spaces\n    best_pos = 0\n    best_cost = float('inf')\n\n    for pos in range(len(remaining)):\n        # Insert the segment at position pos\n        candidate = np.insert(remaining, pos, segment)\n\n        # Calculate total cost in both objective spaces\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(len(candidate)))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(len(candidate)))\n\n        # Use a weighted sum of both costs to guide selection\n        total_cost = 0.5 * cost1 + 0.5 * cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = pos\n\n    # Insert the segment at the best position\n    new_solution = np.insert(remaining, best_pos, segment)\n\n    # Apply a 3-opt-like move on a random subset of nodes\n    if n >= 5:\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Try different configurations of the 3 nodes\n        options = [\n            new_solution.copy(),\n            np.concatenate([new_solution[:i], new_solution[j:k+1], new_solution[i:j], new_solution[k+1:]]),\n            np.concatenate([new_solution[:i], new_solution[k:j-1:-1], new_solution[i:j], new_solution[k+1:]]),\n            np.concatenate([new_solution[:i], new_solution[j:k+1], new_solution[i:j][::-1], new_solution[k+1:]])\n        ]\n\n        # Evaluate all options and keep the best one\n        best_option = min(options, key=lambda x: 0.5 * sum(distance_matrix_1[x[i-1], x[i]] for i in range(len(x))) +\n                                              0.5 * sum(distance_matrix_2[x[i-1], x[i]] for i in range(len(x))))\n\n        new_solution = best_option\n\n    return new_solution\n\n",
        "score": [
            -0.8450206030120291,
            14.486622393131256
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability biased towards better solutions\n    weights = [1.0 / (i + 1) for i in range(len(archive))]  # Higher weight for earlier solutions\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine edge insertion with 3-opt-like moves\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Choose a random segment to modify\n    start = random.randint(0, n - 4)\n    end = random.randint(start + 3, min(start + 6, n - 1))\n\n    # Extract the segment and remaining nodes\n    segment = new_solution[start:end+1]\n    remaining = np.concatenate([new_solution[:start], new_solution[end+1:]])\n\n    # Determine the best insertion point for the segment in both objective spaces\n    best_pos = 0\n    best_cost = float('inf')\n\n    for pos in range(len(remaining)):\n        # Insert the segment at position pos\n        candidate = np.insert(remaining, pos, segment)\n\n        # Calculate total cost in both objective spaces\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(len(candidate)))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(len(candidate)))\n\n        # Use a weighted sum of both costs to guide selection\n        total_cost = 0.5 * cost1 + 0.5 * cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = pos\n\n    # Insert the segment at the best position\n    new_solution = np.insert(remaining, best_pos, segment)\n\n    # Apply a 3-opt-like move on a random subset of nodes\n    if n >= 5:\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Try different configurations of the 3 nodes\n        options = [\n            new_solution.copy(),\n            np.concatenate([new_solution[:i], new_solution[j:k+1], new_solution[i:j], new_solution[k+1:]]),\n            np.concatenate([new_solution[:i], new_solution[k:j-1:-1], new_solution[i:j], new_solution[k+1:]]),\n            np.concatenate([new_solution[:i], new_solution[j:k+1], new_solution[i:j][::-1], new_solution[k+1:]])\n        ]\n\n        # Evaluate all options and keep the best one\n        best_option = min(options, key=lambda x: 0.5 * sum(distance_matrix_1[x[i-1], x[i]] for i in range(len(x))) +\n                                              0.5 * sum(distance_matrix_2[x[i-1], x[i]] for i in range(len(x))))\n\n        new_solution = best_option\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 120,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        # If all solutions are dominated, select randomly\n        selected_sol, _ = random.choice(archive)\n    else:\n        # Select the solution with the highest combined cost (potential for improvement)\n        selected_sol, _ = max(non_dominated, key=lambda x: sum(x[1]))\n\n    new_solution = selected_sol.copy()\n\n    # Hybrid local search operator: combination of edge exchange and segment reversal\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Edge exchange (swap two edges)\n    if j - i > 1:\n        new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment\n    else:\n        # If segment is too small, perform a simple swap\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6551732747807495,
            2.1610042452812195
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        # If all solutions are dominated, select randomly\n        selected_sol, _ = random.choice(archive)\n    else:\n        # Select the solution with the highest combined cost (potential for improvement)\n        selected_sol, _ = max(non_dominated, key=lambda x: sum(x[1]))\n\n    new_solution = selected_sol.copy()\n\n    # Hybrid local search operator: combination of edge exchange and segment reversal\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Edge exchange (swap two edges)\n    if j - i > 1:\n        new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment\n    else:\n        # If segment is too small, perform a simple swap\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 121,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    archive_solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Prioritize solutions with lower costs in either objective\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for obj in objectives]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive_solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search operator\n    operator = random.choice(['edge_insertion', 'segment_reversal', 'non_adjacent_swap'])\n\n    if operator == 'edge_insertion':\n        # Randomly select two edges and reinsert nodes\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], new_solution[i:j]])\n\n    elif operator == 'segment_reversal':\n        # Reverse a random segment of the tour\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'non_adjacent_swap':\n        # Swap two non-adjacent edges (novel operator)\n        a, b, c, d = sorted(random.sample(range(1, n), 4))\n        if a == b or c == d:\n            # Ensure distinct edges\n            a, b = sorted(random.sample(range(1, n), 2))\n            c, d = sorted(random.sample(range(1, n), 2))\n        # Perform the swap\n        new_solution[a], new_solution[b], new_solution[c], new_solution[d] = new_solution[b], new_solution[a], new_solution[d], new_solution[c]\n\n    return new_solution\n\n",
        "score": [
            -0.8408344384042716,
            2.3518311977386475
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    archive_solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Prioritize solutions with lower costs in either objective\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for obj in objectives]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive_solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search operator\n    operator = random.choice(['edge_insertion', 'segment_reversal', 'non_adjacent_swap'])\n\n    if operator == 'edge_insertion':\n        # Randomly select two edges and reinsert nodes\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], new_solution[i:j]])\n\n    elif operator == 'segment_reversal':\n        # Reverse a random segment of the tour\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'non_adjacent_swap':\n        # Swap two non-adjacent edges (novel operator)\n        a, b, c, d = sorted(random.sample(range(1, n), 4))\n        if a == b or c == d:\n            # Ensure distinct edges\n            a, b = sorted(random.sample(range(1, n), 2))\n            c, d = sorted(random.sample(range(1, n), 2))\n        # Perform the swap\n        new_solution[a], new_solution[b], new_solution[c], new_solution[d] = new_solution[b], new_solution[a], new_solution[d], new_solution[c]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 122,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_obj.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt to the first objective space\n    i, j = sorted(random.sample(range(1, n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply edge insertion to the second objective space\n    if random.random() < 0.5:  # 50% chance to apply edge insertion\n        k, l = sorted(random.sample(range(1, n), 2))\n        if k < l:\n            new_solution = np.concatenate([new_solution[:k], new_solution[l:], new_solution[k:l]])\n\n    # Ensure the solution is valid (no duplicates and all nodes are visited)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    # If the solution is incomplete, repair by adding missing nodes at random positions\n    missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n    if len(missing_nodes) > 0:\n        insert_positions = random.sample(range(1, len(new_solution)), len(missing_nodes))\n        for pos, node in zip(sorted(insert_positions), missing_nodes):\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.876204485313607,
            2.5769320130348206
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_obj.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt to the first objective space\n    i, j = sorted(random.sample(range(1, n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply edge insertion to the second objective space\n    if random.random() < 0.5:  # 50% chance to apply edge insertion\n        k, l = sorted(random.sample(range(1, n), 2))\n        if k < l:\n            new_solution = np.concatenate([new_solution[:k], new_solution[l:], new_solution[k:l]])\n\n    # Ensure the solution is valid (no duplicates and all nodes are visited)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    # If the solution is incomplete, repair by adding missing nodes at random positions\n    missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n    if len(missing_nodes) > 0:\n        insert_positions = random.sample(range(1, len(new_solution)), len(missing_nodes))\n        for pos, node in zip(sorted(insert_positions), missing_nodes):\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 123,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with better combined objective values\n    objectives = np.array([obj for _, obj in archive])\n    scores = objectives[:, 0] + objectives[:, 1]  # Combined score for selection\n    probabilities = np.exp(-scores / np.sum(scores))  # Higher scores get lower probability\n    probabilities /= np.sum(probabilities)  # Normalize to form a probability distribution\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    if n < 5:\n        # For small instances, perform a full segment reversal\n        i, j = np.random.choice(n, 2, replace=False)\n        i, j = min(i, j), max(i, j)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # For larger instances, perform a combination of edge insertions and segment reversals\n        # Step 1: Randomly select a segment and reverse it\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Step 2: Randomly select two edges and perform an insertion\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        if k < l:\n            # Insert the segment [k, l] after position m\n            m = np.random.randint(0, n)\n            if m >= k and m < l:\n                m = (m + 1) % n\n            segment = new_solution[k:l+1]\n            new_solution = np.concatenate([new_solution[:k], new_solution[l+1:m+1], segment, new_solution[m+1:]])\n\n    # Ensure the solution remains valid (no duplicates and all nodes are visited)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.7984674679994088,
            1.3397327065467834
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with better combined objective values\n    objectives = np.array([obj for _, obj in archive])\n    scores = objectives[:, 0] + objectives[:, 1]  # Combined score for selection\n    probabilities = np.exp(-scores / np.sum(scores))  # Higher scores get lower probability\n    probabilities /= np.sum(probabilities)  # Normalize to form a probability distribution\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    if n < 5:\n        # For small instances, perform a full segment reversal\n        i, j = np.random.choice(n, 2, replace=False)\n        i, j = min(i, j), max(i, j)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # For larger instances, perform a combination of edge insertions and segment reversals\n        # Step 1: Randomly select a segment and reverse it\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Step 2: Randomly select two edges and perform an insertion\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        if k < l:\n            # Insert the segment [k, l] after position m\n            m = np.random.randint(0, n)\n            if m >= k and m < l:\n                m = (m + 1) % n\n            segment = new_solution[k:l+1]\n            new_solution = np.concatenate([new_solution[:k], new_solution[l+1:m+1], segment, new_solution[m+1:]])\n\n    # Ensure the solution remains valid (no duplicates and all nodes are visited)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 124,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_solution = None\n    selected_objective = None\n\n    # Simple selection strategy: pick a solution that is not dominated by any other in the archive\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            selected_solution = sol.copy()\n            selected_objective = obj\n            break\n\n    if selected_solution is None:\n        # Fallback: pick a random solution if no non-dominated solution is found\n        selected_solution = archive[np.random.randint(len(archive))][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine edge swaps with a novel move\n    # Step 1: Randomly select a segment to reverse (similar to 2-opt but more flexible)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 2: Novel move - swap a random edge with another edge considering both objectives\n    if n > 3:\n        i = np.random.randint(n)\n        j = np.random.randint(n)\n        while j == i or j == (i + 1) % n:\n            j = np.random.randint(n)\n\n        # Calculate potential improvement in both objectives\n        old_edges = [\n            (new_solution[i-1], new_solution[i]),\n            (new_solution[i], new_solution[i+1] if i+1 < n else new_solution[0]),\n            (new_solution[j-1], new_solution[j]),\n            (new_solution[j], new_solution[j+1] if j+1 < n else new_solution[0])\n        ]\n\n        new_edges = [\n            (new_solution[i-1], new_solution[j]),\n            (new_solution[j], new_solution[i+1] if i+1 < n else new_solution[0]),\n            (new_solution[j-1], new_solution[i]),\n            (new_solution[i], new_solution[j+1] if j+1 < n else new_solution[0])\n        ]\n\n        old_cost1 = sum(distance_matrix_1[e[0], e[1]] for e in old_edges)\n        new_cost1 = sum(distance_matrix_1[e[0], e[1]] for e in new_edges)\n\n        old_cost2 = sum(distance_matrix_2[e[0], e[1]] for e in old_edges)\n        new_cost2 = sum(distance_matrix_2[e[0], e[1]] for e in new_edges)\n\n        # Only accept the swap if it improves at least one objective\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7679613528537279,
            2.109393537044525
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_solution = None\n    selected_objective = None\n\n    # Simple selection strategy: pick a solution that is not dominated by any other in the archive\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            selected_solution = sol.copy()\n            selected_objective = obj\n            break\n\n    if selected_solution is None:\n        # Fallback: pick a random solution if no non-dominated solution is found\n        selected_solution = archive[np.random.randint(len(archive))][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine edge swaps with a novel move\n    # Step 1: Randomly select a segment to reverse (similar to 2-opt but more flexible)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 2: Novel move - swap a random edge with another edge considering both objectives\n    if n > 3:\n        i = np.random.randint(n)\n        j = np.random.randint(n)\n        while j == i or j == (i + 1) % n:\n            j = np.random.randint(n)\n\n        # Calculate potential improvement in both objectives\n        old_edges = [\n            (new_solution[i-1], new_solution[i]),\n            (new_solution[i], new_solution[i+1] if i+1 < n else new_solution[0]),\n            (new_solution[j-1], new_solution[j]),\n            (new_solution[j], new_solution[j+1] if j+1 < n else new_solution[0])\n        ]\n\n        new_edges = [\n            (new_solution[i-1], new_solution[j]),\n            (new_solution[j], new_solution[i+1] if i+1 < n else new_solution[0]),\n            (new_solution[j-1], new_solution[i]),\n            (new_solution[i], new_solution[j+1] if j+1 < n else new_solution[0])\n        ]\n\n        old_cost1 = sum(distance_matrix_1[e[0], e[1]] for e in old_edges)\n        new_cost1 = sum(distance_matrix_1[e[0], e[1]] for e in new_edges)\n\n        old_cost2 = sum(distance_matrix_2[e[0], e[1]] for e in old_edges)\n        new_cost2 = sum(distance_matrix_2[e[0], e[1]] for e in new_edges)\n\n        # Only accept the swap if it improves at least one objective\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 125,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in any objective)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selection_pool = archive_sorted[:max(1, len(archive) // 5)]\n    selected = random.choice(selection_pool)\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: combination of 3-opt and edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct positions to perform 3-opt\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Perform 3-opt: reverse segments between a-b, b-c, and c-a\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n    new_solution[c:] = new_solution[c:][::-1]\n\n    # Randomly select a node to reinsert elsewhere (edge insertion)\n    node_to_move = random.randint(0, n-1)\n    node_value = new_solution[node_to_move]\n\n    # Remove the node and reinsert at a random position\n    new_solution = np.delete(new_solution, node_to_move)\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, insert_pos, node_value)\n\n    # Ensure the solution remains a valid tour\n    if len(set(new_solution)) != n:\n        raise ValueError(\"Invalid tour generated - duplicate nodes\")\n\n    return new_solution\n\n",
        "score": [
            -0.7662932881973984,
            2.281886577606201
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in any objective)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selection_pool = archive_sorted[:max(1, len(archive) // 5)]\n    selected = random.choice(selection_pool)\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: combination of 3-opt and edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct positions to perform 3-opt\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Perform 3-opt: reverse segments between a-b, b-c, and c-a\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n    new_solution[c:] = new_solution[c:][::-1]\n\n    # Randomly select a node to reinsert elsewhere (edge insertion)\n    node_to_move = random.randint(0, n-1)\n    node_value = new_solution[node_to_move]\n\n    # Remove the node and reinsert at a random position\n    new_solution = np.delete(new_solution, node_to_move)\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, insert_pos, node_value)\n\n    # Ensure the solution remains a valid tour\n    if len(set(new_solution)) != n:\n        raise ValueError(\"Invalid tour generated - duplicate nodes\")\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 126,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge-swap strategy\n    n = len(base_solution)\n    if n < 3:\n        return new_solution  # No improvement possible\n\n    # Randomly select segments for modification\n    a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Perform a 3-opt move (reverse a segment)\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Custom edge-swap strategy: swap edges based on both objectives\n    if np.random.rand() < 0.5:  # 50% chance to apply edge-swap\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        # Check if swap improves both objectives\n        old_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n        if new_cost < old_cost:\n            new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    return new_solution\n\n",
        "score": [
            -0.7215944543456735,
            2.2401830554008484
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge-swap strategy\n    n = len(base_solution)\n    if n < 3:\n        return new_solution  # No improvement possible\n\n    # Randomly select segments for modification\n    a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Perform a 3-opt move (reverse a segment)\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Custom edge-swap strategy: swap edges based on both objectives\n    if np.random.rand() < 0.5:  # 50% chance to apply edge-swap\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        # Check if swap improves both objectives\n        old_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n        if new_cost < old_cost:\n            new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 127,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a probability inversely proportional to its objective values (favoring non-dominated solutions)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / np.max(objectives, axis=0)\n    crowding_distances = 1 / (normalized_objectives[:, 0] + normalized_objectives[:, 1] + 1e-10)\n    selection_probs = crowding_distances / np.sum(crowding_distances)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Edge insertion followed by a novel swap-based operator\n    new_solution = base_solution.copy()\n\n    # Edge insertion: Randomly select two non-adjacent edges and reconnect them\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    while (j == i + 1) or (j == 0 and i == n - 1):  # Ensure edges are not adjacent\n        i, j = sorted(random.sample(range(n), 2))\n\n    # Reconnect the edges\n    if i == 0 and j == n - 1:\n        new_solution = np.roll(new_solution, 1)\n    else:\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[j:], new_solution[i+1:j]])\n\n    # Novel swap-based operator: Swap two nodes that are not adjacent and improve both objectives\n    for _ in range(10):  # Limit the number of attempts to avoid excessive computation\n        a, b = random.sample(range(n), 2)\n        if abs(a - b) <= 1 or abs(a - b) >= n - 1:\n            continue  # Skip adjacent or nearly adjacent nodes\n\n        # Calculate current and new distances for both objectives\n        current_dist1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        current_dist2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n        new_dist1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n        new_dist2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n        if (new_dist1 < current_dist1 and new_dist2 < current_dist2) or \\\n           (random.random() < 0.3):  # Allow some non-improving swaps for diversity\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8082690953931346,
            2.4063300490379333
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a probability inversely proportional to its objective values (favoring non-dominated solutions)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / np.max(objectives, axis=0)\n    crowding_distances = 1 / (normalized_objectives[:, 0] + normalized_objectives[:, 1] + 1e-10)\n    selection_probs = crowding_distances / np.sum(crowding_distances)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Edge insertion followed by a novel swap-based operator\n    new_solution = base_solution.copy()\n\n    # Edge insertion: Randomly select two non-adjacent edges and reconnect them\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    while (j == i + 1) or (j == 0 and i == n - 1):  # Ensure edges are not adjacent\n        i, j = sorted(random.sample(range(n), 2))\n\n    # Reconnect the edges\n    if i == 0 and j == n - 1:\n        new_solution = np.roll(new_solution, 1)\n    else:\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[j:], new_solution[i+1:j]])\n\n    # Novel swap-based operator: Swap two nodes that are not adjacent and improve both objectives\n    for _ in range(10):  # Limit the number of attempts to avoid excessive computation\n        a, b = random.sample(range(n), 2)\n        if abs(a - b) <= 1 or abs(a - b) >= n - 1:\n            continue  # Skip adjacent or nearly adjacent nodes\n\n        # Calculate current and new distances for both objectives\n        current_dist1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        current_dist2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n        new_dist1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n        new_dist2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n        if (new_dist1 < current_dist1 and new_dist2 < current_dist2) or \\\n           (random.random() < 0.3):  # Allow some non-improving swaps for diversity\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 128,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high potential for improvement (e.g., with high variance in objectives)\n    objectives = np.array([obj for (sol, obj) in archive])\n    objective_variance = np.var(objectives, axis=0)\n    weighted_scores = objective_variance[0] * objectives[:, 0] + objective_variance[1] * objectives[:, 1]\n    selected_idx = np.argmin(weighted_scores)  # Prefer solutions with lower objectives but high variance\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # Hybrid local search: combine 3-opt with a novel edge insertion\n    for _ in range(10):  # Number of attempts\n        i, j, k = np.random.choice(n_nodes, size=3, replace=False)\n        i, j, k = sorted([i, j, k])\n\n        # Apply 3-opt move\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_segment = np.concatenate([segment2, segment1])\n\n        temp_solution = np.concatenate([new_solution[:i], new_segment, new_solution[k:]])\n        temp_solution = np.concatenate([temp_solution, [temp_solution[0]]])  # Ensure circularity\n\n        # Novel edge insertion: try to insert a random edge at a random position\n        if np.random.rand() < 0.3:  # 30% chance to apply edge insertion\n            a, b = np.random.choice(n_nodes, size=2, replace=False)\n            temp_solution = np.insert(temp_solution, a, temp_solution[b])\n            temp_solution = np.unique(temp_solution, return_index=True)[1]  # Remove duplicates\n            temp_solution = np.sort(temp_solution)  # Reorder to maintain feasibility\n\n        # Ensure the solution is valid (visits each node exactly once)\n        if len(np.unique(temp_solution)) == n_nodes:\n            new_solution = temp_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9133393601253335,
            3.1903051137924194
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high potential for improvement (e.g., with high variance in objectives)\n    objectives = np.array([obj for (sol, obj) in archive])\n    objective_variance = np.var(objectives, axis=0)\n    weighted_scores = objective_variance[0] * objectives[:, 0] + objective_variance[1] * objectives[:, 1]\n    selected_idx = np.argmin(weighted_scores)  # Prefer solutions with lower objectives but high variance\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # Hybrid local search: combine 3-opt with a novel edge insertion\n    for _ in range(10):  # Number of attempts\n        i, j, k = np.random.choice(n_nodes, size=3, replace=False)\n        i, j, k = sorted([i, j, k])\n\n        # Apply 3-opt move\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_segment = np.concatenate([segment2, segment1])\n\n        temp_solution = np.concatenate([new_solution[:i], new_segment, new_solution[k:]])\n        temp_solution = np.concatenate([temp_solution, [temp_solution[0]]])  # Ensure circularity\n\n        # Novel edge insertion: try to insert a random edge at a random position\n        if np.random.rand() < 0.3:  # 30% chance to apply edge insertion\n            a, b = np.random.choice(n_nodes, size=2, replace=False)\n            temp_solution = np.insert(temp_solution, a, temp_solution[b])\n            temp_solution = np.unique(temp_solution, return_index=True)[1]  # Remove duplicates\n            temp_solution = np.sort(temp_solution)  # Reorder to maintain feasibility\n\n        # Ensure the solution is valid (visits each node exactly once)\n        if len(np.unique(temp_solution)) == n_nodes:\n            new_solution = temp_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 129,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    import numpy as np\n\n    # Select a solution with probability proportional to its potential for improvement\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate potential for improvement: solutions with lower costs are more likely to be selected\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    total_potential = np.sum(normalized_costs, axis=1)\n    probabilities = 1 / (total_potential + 1e-10)  # Higher potential -> higher probability\n    probabilities /= probabilities.sum()  # Normalize to sum to 1\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select 3 distinct edges to perform a 3-opt move\n    a, b, c = sorted(random.sample(range(n), 3))\n    i, j, k = new_solution[a], new_solution[b], new_solution[c]\n\n    # Generate all possible 3-opt neighbors and select the best one\n    candidates = []\n    for perm in [(i, j, k), (i, k, j)]:\n        candidate = new_solution.copy()\n        candidate[a:b] = perm[0]\n        candidate[b:c] = perm[1]\n        candidate[c:] = perm[2]\n        candidates.append(candidate)\n\n    # Evaluate candidates based on both objectives\n    best_candidate = None\n    best_score = float('inf')\n\n    for candidate in candidates:\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n        combined_score = cost1 + cost2  # Simple aggregation for selection\n\n        if combined_score < best_score:\n            best_score = combined_score\n            best_candidate = candidate\n\n    if best_candidate is not None:\n        new_solution = best_candidate\n\n    # Step 2: Apply a novel edge-swap strategy based on objective-specific distances\n    # Select two non-adjacent edges to swap\n    if n >= 4:\n        x, y = sorted(random.sample(range(n), 2))\n        if abs(x - y) > 1:  # Ensure edges are not adjacent\n            # Swap edges (x, x+1) and (y, y+1)\n            new_solution[x+1], new_solution[y] = new_solution[y], new_solution[x+1]\n\n    return new_solution\n\n",
        "score": [
            -0.9460144745715933,
            1.0529972910881042
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    import numpy as np\n\n    # Select a solution with probability proportional to its potential for improvement\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate potential for improvement: solutions with lower costs are more likely to be selected\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    total_potential = np.sum(normalized_costs, axis=1)\n    probabilities = 1 / (total_potential + 1e-10)  # Higher potential -> higher probability\n    probabilities /= probabilities.sum()  # Normalize to sum to 1\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select 3 distinct edges to perform a 3-opt move\n    a, b, c = sorted(random.sample(range(n), 3))\n    i, j, k = new_solution[a], new_solution[b], new_solution[c]\n\n    # Generate all possible 3-opt neighbors and select the best one\n    candidates = []\n    for perm in [(i, j, k), (i, k, j)]:\n        candidate = new_solution.copy()\n        candidate[a:b] = perm[0]\n        candidate[b:c] = perm[1]\n        candidate[c:] = perm[2]\n        candidates.append(candidate)\n\n    # Evaluate candidates based on both objectives\n    best_candidate = None\n    best_score = float('inf')\n\n    for candidate in candidates:\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n        combined_score = cost1 + cost2  # Simple aggregation for selection\n\n        if combined_score < best_score:\n            best_score = combined_score\n            best_candidate = candidate\n\n    if best_candidate is not None:\n        new_solution = best_candidate\n\n    # Step 2: Apply a novel edge-swap strategy based on objective-specific distances\n    # Select two non-adjacent edges to swap\n    if n >= 4:\n        x, y = sorted(random.sample(range(n), 2))\n        if abs(x - y) > 1:  # Ensure edges are not adjacent\n            # Swap edges (x, x+1) and (y, y+1)\n            new_solution[x+1], new_solution[y] = new_solution[y], new_solution[x+1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 130,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest cost in either objective)\n    archive.sort(key=lambda x: min(x[1]))\n    base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    # Step 1: Randomly select a segment and reverse it (novel segment reversal)\n    if n > 3:\n        start = np.random.randint(0, n - 2)\n        end = np.random.randint(start + 1, n - 1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Edge swapping with distance-based selection (avoids 2-opt)\n    if n > 4:\n        i = np.random.randint(0, n - 3)\n        j = np.random.randint(i + 2, n - 1)\n\n        # Calculate current and potential distances\n        current_dist1 = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[j+1]]\n        new_dist1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[j+1]]\n\n        current_dist2 = distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n        new_dist2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]]\n\n        # Accept if either objective improves\n        if (new_dist1 < current_dist1) or (new_dist2 < current_dist2):\n            new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n    # Step 3: Random insertion to escape local optima\n    if n > 2:\n        pos = np.random.randint(0, n)\n        val = new_solution[pos]\n        new_solution = np.delete(new_solution, pos)\n        new_pos = np.random.randint(0, n - 1)\n        new_solution = np.insert(new_solution, new_pos, val)\n\n    return new_solution\n\n",
        "score": [
            -0.487323270293276,
            2.2708678245544434
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest cost in either objective)\n    archive.sort(key=lambda x: min(x[1]))\n    base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    # Step 1: Randomly select a segment and reverse it (novel segment reversal)\n    if n > 3:\n        start = np.random.randint(0, n - 2)\n        end = np.random.randint(start + 1, n - 1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Edge swapping with distance-based selection (avoids 2-opt)\n    if n > 4:\n        i = np.random.randint(0, n - 3)\n        j = np.random.randint(i + 2, n - 1)\n\n        # Calculate current and potential distances\n        current_dist1 = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[j+1]]\n        new_dist1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[j+1]]\n\n        current_dist2 = distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n        new_dist2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]]\n\n        # Accept if either objective improves\n        if (new_dist1 < current_dist1) or (new_dist2 < current_dist2):\n            new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n    # Step 3: Random insertion to escape local optima\n    if n > 2:\n        pos = np.random.randint(0, n)\n        val = new_solution[pos]\n        new_solution = np.delete(new_solution, pos)\n        new_pos = np.random.randint(0, n - 1)\n        new_solution = np.insert(new_solution, new_pos, val)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 131,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 30% in the archive)\n    sorted_archive = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selection_size = max(1, len(sorted_archive) // 3)\n    selected_solutions = random.sample(sorted_archive[:selection_size], 1)\n    base_solution, _ = selected_solutions[0]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of edge exchange and node insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Step 1: Edge exchange (similar to 2-opt but with a twist)\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Ensure the exchange maintains feasibility\n    if a == c or b == d:\n        return new_solution\n\n    # Perform edge exchange\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n    new_solution[c:d+1] = np.flip(new_solution[c:d+1])\n\n    # Step 2: Node insertion (relocate a random node to a better position)\n    node_to_move = random.choice(new_solution)\n    current_pos = np.where(new_solution == node_to_move)[0][0]\n\n    # Evaluate possible insertion positions\n    best_pos = current_pos\n    best_cost = float('inf')\n\n    for pos in range(n):\n        if pos == current_pos:\n            continue\n\n        # Create a candidate solution\n        candidate = np.delete(new_solution, current_pos)\n        candidate = np.insert(candidate, pos, node_to_move)\n\n        # Calculate total cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n\n        # Combine costs (weighted sum)\n        combined_cost = cost1 + cost2\n\n        if combined_cost < best_cost:\n            best_cost = combined_cost\n            best_pos = pos\n\n    # Apply the best insertion\n    if best_pos != current_pos:\n        new_solution = np.delete(new_solution, current_pos)\n        new_solution = np.insert(new_solution, best_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.8116103721965766,
            14.46653550863266
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 30% in the archive)\n    sorted_archive = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selection_size = max(1, len(sorted_archive) // 3)\n    selected_solutions = random.sample(sorted_archive[:selection_size], 1)\n    base_solution, _ = selected_solutions[0]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of edge exchange and node insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Step 1: Edge exchange (similar to 2-opt but with a twist)\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Ensure the exchange maintains feasibility\n    if a == c or b == d:\n        return new_solution\n\n    # Perform edge exchange\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n    new_solution[c:d+1] = np.flip(new_solution[c:d+1])\n\n    # Step 2: Node insertion (relocate a random node to a better position)\n    node_to_move = random.choice(new_solution)\n    current_pos = np.where(new_solution == node_to_move)[0][0]\n\n    # Evaluate possible insertion positions\n    best_pos = current_pos\n    best_cost = float('inf')\n\n    for pos in range(n):\n        if pos == current_pos:\n            continue\n\n        # Create a candidate solution\n        candidate = np.delete(new_solution, current_pos)\n        candidate = np.insert(candidate, pos, node_to_move)\n\n        # Calculate total cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n\n        # Combine costs (weighted sum)\n        combined_cost = cost1 + cost2\n\n        if combined_cost < best_cost:\n            best_cost = combined_cost\n            best_pos = pos\n\n    # Apply the best insertion\n    if best_pos != current_pos:\n        new_solution = np.delete(new_solution, current_pos)\n        new_solution = np.insert(new_solution, best_pos, node_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 132,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on a combination of objectives and diversity\n    def selection_criteria(sol_obj_pair):\n        sol, (obj1, obj2) = sol_obj_pair\n        # Normalize objectives and combine with a small random factor for diversity\n        norm_obj1 = obj1 / (np.max(distance_matrix_1) * len(sol))\n        norm_obj2 = obj2 / (np.max(distance_matrix_2) * len(sol))\n        return norm_obj1 + norm_obj2 + random.uniform(0, 0.1)\n\n    # Sort solutions by selection criteria and pick the best one\n    archive_sorted = sorted(archive, key=selection_criteria)\n    base_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine 3-opt with a custom move\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct positions\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply a custom 3-opt-like move\n    if random.random() < 0.5:\n        # Reverse segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Shift segment between i and j to position k\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k], segment, new_solution[k:]])\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap\n        new_solution = base_solution.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.5708101837701957,
            3.4931640625
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on a combination of objectives and diversity\n    def selection_criteria(sol_obj_pair):\n        sol, (obj1, obj2) = sol_obj_pair\n        # Normalize objectives and combine with a small random factor for diversity\n        norm_obj1 = obj1 / (np.max(distance_matrix_1) * len(sol))\n        norm_obj2 = obj2 / (np.max(distance_matrix_2) * len(sol))\n        return norm_obj1 + norm_obj2 + random.uniform(0, 0.1)\n\n    # Sort solutions by selection criteria and pick the best one\n    archive_sorted = sorted(archive, key=selection_criteria)\n    base_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine 3-opt with a custom move\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct positions\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply a custom 3-opt-like move\n    if random.random() < 0.5:\n        # Reverse segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Shift segment between i and j to position k\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k], segment, new_solution[k:]])\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap\n        new_solution = base_solution.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 133,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    combined_cost = np.sum(normalized_costs, axis=1)\n    probabilities = 1.0 / (combined_cost + 1e-10)\n    probabilities /= np.sum(probabilities)\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: probabilistic edge swaps with a mix of 3-opt and random swaps\n    n = len(base_solution)\n    if n < 3:\n        return new_solution  # No improvement possible\n\n    # Randomly select a segment to perturb\n    start = np.random.randint(0, n - 2)\n    end = np.random.randint(start + 2, min(start + 5, n))\n\n    # Apply a 3-opt-like move with probability 0.7, otherwise random swap\n    if np.random.rand() < 0.7:\n        # 3-opt move: reverse a segment and adjust edges\n        segment = new_solution[start:end]\n        new_solution[start:end] = segment[::-1]\n    else:\n        # Random swap of two nodes in the segment\n        i, j = np.random.choice(np.arange(start, end), 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility by checking for duplicates and repairing if needed\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing = np.setdiff1d(np.arange(n), new_solution)\n        for i in range(n):\n            if counts[i] > 1:\n                new_solution[np.where(new_solution == unique[i])[0][1:]] = missing[:len(np.where(new_solution == unique[i])[0][1:])]\n                missing = missing[len(np.where(new_solution == unique[i])[0][1:]):]\n\n    return new_solution\n\n",
        "score": [
            -0.9063652614569727,
            4.054346323013306
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    combined_cost = np.sum(normalized_costs, axis=1)\n    probabilities = 1.0 / (combined_cost + 1e-10)\n    probabilities /= np.sum(probabilities)\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: probabilistic edge swaps with a mix of 3-opt and random swaps\n    n = len(base_solution)\n    if n < 3:\n        return new_solution  # No improvement possible\n\n    # Randomly select a segment to perturb\n    start = np.random.randint(0, n - 2)\n    end = np.random.randint(start + 2, min(start + 5, n))\n\n    # Apply a 3-opt-like move with probability 0.7, otherwise random swap\n    if np.random.rand() < 0.7:\n        # 3-opt move: reverse a segment and adjust edges\n        segment = new_solution[start:end]\n        new_solution[start:end] = segment[::-1]\n    else:\n        # Random swap of two nodes in the segment\n        i, j = np.random.choice(np.arange(start, end), 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility by checking for duplicates and repairing if needed\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing = np.setdiff1d(np.arange(n), new_solution)\n        for i in range(n):\n            if counts[i] > 1:\n                new_solution[np.where(new_solution == unique[i])[0][1:]] = missing[:len(np.where(new_solution == unique[i])[0][1:])]\n                missing = missing[len(np.where(new_solution == unique[i])[0][1:]):]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 134,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    # (here, we use inverse of the sum of objectives as a proxy for potential)\n    objectives = [obj for _, obj in archive]\n    total_cost = [sum(obj) for obj in objectives]\n    probabilities = [1 / (cost + 1e-10) for cost in total_cost]  # Avoid division by zero\n    probabilities = np.array(probabilities) / np.sum(probabilities)\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combination of edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Perform edge insertion and segment reversal\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    # Reverse one of the segments\n    if random.random() < 0.5:\n        segment1 = segment1[::-1]\n    else:\n        segment2 = segment2[::-1]\n\n    # Insert the segments at random positions\n    new_solution = np.concatenate([\n        new_solution[:a],\n        segment2,\n        new_solution[b+1:c],\n        segment1,\n        new_solution[d+1:]\n    ])\n\n    # Ensure the solution is a valid tour (no duplicates and all nodes present)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or np.any(counts > 1):\n        # If invalid, perform a simple swap to fix\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8109845961220984,
            0.6993626952171326
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    # (here, we use inverse of the sum of objectives as a proxy for potential)\n    objectives = [obj for _, obj in archive]\n    total_cost = [sum(obj) for obj in objectives]\n    probabilities = [1 / (cost + 1e-10) for cost in total_cost]  # Avoid division by zero\n    probabilities = np.array(probabilities) / np.sum(probabilities)\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combination of edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Perform edge insertion and segment reversal\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    # Reverse one of the segments\n    if random.random() < 0.5:\n        segment1 = segment1[::-1]\n    else:\n        segment2 = segment2[::-1]\n\n    # Insert the segments at random positions\n    new_solution = np.concatenate([\n        new_solution[:a],\n        segment2,\n        new_solution[b+1:c],\n        segment1,\n        new_solution[d+1:]\n    ])\n\n    # Ensure the solution is a valid tour (no duplicates and all nodes present)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or np.any(counts > 1):\n        # If invalid, perform a simple swap to fix\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 134,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    # (here, we use inverse of the sum of objectives as a proxy for potential)\n    objectives = [obj for _, obj in archive]\n    total_cost = [sum(obj) for obj in objectives]\n    probabilities = [1 / (cost + 1e-10) for cost in total_cost]  # Avoid division by zero\n    probabilities = np.array(probabilities) / np.sum(probabilities)\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combination of edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Perform edge insertion and segment reversal\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    # Reverse one of the segments\n    if random.random() < 0.5:\n        segment1 = segment1[::-1]\n    else:\n        segment2 = segment2[::-1]\n\n    # Insert the segments at random positions\n    new_solution = np.concatenate([\n        new_solution[:a],\n        segment2,\n        new_solution[b+1:c],\n        segment1,\n        new_solution[d+1:]\n    ])\n\n    # Ensure the solution is a valid tour (no duplicates and all nodes present)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or np.any(counts > 1):\n        # If invalid, perform a simple swap to fix\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8109845961220984,
            0.6993626952171326
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    # (here, we use inverse of the sum of objectives as a proxy for potential)\n    objectives = [obj for _, obj in archive]\n    total_cost = [sum(obj) for obj in objectives]\n    probabilities = [1 / (cost + 1e-10) for cost in total_cost]  # Avoid division by zero\n    probabilities = np.array(probabilities) / np.sum(probabilities)\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combination of edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Perform edge insertion and segment reversal\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    # Reverse one of the segments\n    if random.random() < 0.5:\n        segment1 = segment1[::-1]\n    else:\n        segment2 = segment2[::-1]\n\n    # Insert the segments at random positions\n    new_solution = np.concatenate([\n        new_solution[:a],\n        segment2,\n        new_solution[b+1:c],\n        segment1,\n        new_solution[d+1:]\n    ])\n\n    # Ensure the solution is a valid tour (no duplicates and all nodes present)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or np.any(counts > 1):\n        # If invalid, perform a simple swap to fix\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 135,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (low cost but possible to improve)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(3, len(archive_sorted) - 1) if len(archive_sorted) > 3 else 0\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: combination of segment inversion and node swap\n    if n > 4:\n        # Select a random segment to invert\n        start, end = sorted(random.sample(range(1, n-1), 2))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Apply a node swap with a different segment\n        swap_pos1, swap_pos2 = random.sample(range(1, n-1), 2)\n        new_solution[swap_pos1], new_solution[swap_pos2] = new_solution[swap_pos2], new_solution[swap_pos1]\n    else:\n        # For small instances, just perform a 2-opt swap\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution (though unlikely with our operators)\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8259156346979761,
            1.9804133176803589
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (low cost but possible to improve)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(3, len(archive_sorted) - 1) if len(archive_sorted) > 3 else 0\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: combination of segment inversion and node swap\n    if n > 4:\n        # Select a random segment to invert\n        start, end = sorted(random.sample(range(1, n-1), 2))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Apply a node swap with a different segment\n        swap_pos1, swap_pos2 = random.sample(range(1, n-1), 2)\n        new_solution[swap_pos1], new_solution[swap_pos2] = new_solution[swap_pos2], new_solution[swap_pos1]\n    else:\n        # For small instances, just perform a 2-opt swap\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution (though unlikely with our operators)\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 136,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-frontier solutions)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: 3-opt with edge-swap\n    n = len(selected_solution)\n    if n < 4:\n        return selected_solution  # No improvement possible for very small tours\n\n    # Randomly select three non-consecutive edges to modify\n    i, j, k = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n\n    # Create a new solution by reversing segments and swapping edges\n    new_solution = selected_solution.copy()\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]  # Reverse segment between i and j\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]  # Reverse segment between j and k\n\n    # Additional edge-swap to escape local optima\n    if np.random.rand() < 0.5:  # 50% chance to perform edge-swap\n        a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple 2-opt if the solution becomes invalid\n        a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8292348728339642,
            2.6480007767677307
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-frontier solutions)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: 3-opt with edge-swap\n    n = len(selected_solution)\n    if n < 4:\n        return selected_solution  # No improvement possible for very small tours\n\n    # Randomly select three non-consecutive edges to modify\n    i, j, k = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n\n    # Create a new solution by reversing segments and swapping edges\n    new_solution = selected_solution.copy()\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]  # Reverse segment between i and j\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]  # Reverse segment between j and k\n\n    # Additional edge-swap to escape local optima\n    if np.random.rand() < 0.5:  # 50% chance to perform edge-swap\n        a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple 2-opt if the solution becomes invalid\n        a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 137,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high variance in objectives)\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: edge insertion with node reordering\n    n = len(new_solution)\n    i, j = random.sample(range(n), 2)\n\n    # Edge insertion: remove node at i and reinsert it after j\n    node_to_move = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    insert_pos = (j + 1) % (n - 1)  # Ensure valid insertion position\n    new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Node reordering: reverse a random segment to improve both objectives\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Verify feasibility (ensures no duplicates and all nodes are visited)\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.8677017078289866,
            2.5404942631721497
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high variance in objectives)\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: edge insertion with node reordering\n    n = len(new_solution)\n    i, j = random.sample(range(n), 2)\n\n    # Edge insertion: remove node at i and reinsert it after j\n    node_to_move = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    insert_pos = (j + 1) % (n - 1)  # Ensure valid insertion position\n    new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Node reordering: reverse a random segment to improve both objectives\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Verify feasibility (ensures no duplicates and all nodes are visited)\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 138,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (simplified approach)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the top 50% that has the highest potential\n        candidates = archive_sorted[:max(1, len(archive_sorted) // 2)]\n        base_solution, _ = random.choice(candidates)\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps and segment reversals\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly choose between edge swap and segment reversal\n    if random.random() < 0.5:\n        # Edge swap: swap two edges\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal: reverse a segment of the tour\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8782586725004091,
            2.307974934577942
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (simplified approach)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the top 50% that has the highest potential\n        candidates = archive_sorted[:max(1, len(archive_sorted) // 2)]\n        base_solution, _ = random.choice(candidates)\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps and segment reversals\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly choose between edge swap and segment reversal\n    if random.random() < 0.5:\n        # Edge swap: swap two edges\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal: reverse a segment of the tour\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 139,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution with a bias towards lower objectives and higher diversity\n    def selection_score(solution_obj: Tuple[float, float]) -> float:\n        # Lower objectives are better, so we use negative values\n        # Add a small random factor to encourage diversity\n        return -(solution_obj[0] + solution_obj[1]) + random.uniform(0, 0.1)\n\n    # Sort solutions by their score and select the top 10% with a random choice\n    archive_sorted = sorted(archive, key=lambda x: selection_score(x[1]))\n    top_percent = max(1, len(archive_sorted) // 10)\n    selected_solution = random.choice(archive_sorted[:top_percent])[0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine edge swaps with segment reversal\n    if n > 3:\n        # Randomly choose between edge swap and segment reversal\n        if random.random() < 0.7:  # Higher chance for edge swap\n            # Edge swap: swap two non-adjacent edges\n            i, j = sorted(random.sample(range(1, n-1), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Segment reversal: reverse a segment of the tour\n            i, j = sorted(random.sample(range(1, n-1), 2))\n            new_solution[i:j+1] = new_solution[j:i-1:-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not feasible.\"\n\n    return new_solution\n\n",
        "score": [
            -0.9571525052600937,
            2.6348348259925842
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution with a bias towards lower objectives and higher diversity\n    def selection_score(solution_obj: Tuple[float, float]) -> float:\n        # Lower objectives are better, so we use negative values\n        # Add a small random factor to encourage diversity\n        return -(solution_obj[0] + solution_obj[1]) + random.uniform(0, 0.1)\n\n    # Sort solutions by their score and select the top 10% with a random choice\n    archive_sorted = sorted(archive, key=lambda x: selection_score(x[1]))\n    top_percent = max(1, len(archive_sorted) // 10)\n    selected_solution = random.choice(archive_sorted[:top_percent])[0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine edge swaps with segment reversal\n    if n > 3:\n        # Randomly choose between edge swap and segment reversal\n        if random.random() < 0.7:  # Higher chance for edge swap\n            # Edge swap: swap two non-adjacent edges\n            i, j = sorted(random.sample(range(1, n-1), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Segment reversal: reverse a segment of the tour\n            i, j = sorted(random.sample(range(1, n-1), 2))\n            new_solution[i:j+1] = new_solution[j:i-1:-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not feasible.\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 140,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not already Pareto-optimal)\n    # For simplicity, we select a random solution with a non-zero objective\n    candidates = [sol for sol, obj in archive if obj[0] > 0 or obj[1] > 0]\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n\n    base_solution = random.choice(candidates).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: apply a combination of edge insertion and node swap\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # For larger instances, perform a more sophisticated operation\n        # Step 1: Select a random segment to reverse (similar to 2-opt but more flexible)\n        start, end = sorted(random.sample(range(n), 2))\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Step 2: Perform a node insertion (move a node to a different position)\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.8583960502907624,
            2.4898946285247803
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not already Pareto-optimal)\n    # For simplicity, we select a random solution with a non-zero objective\n    candidates = [sol for sol, obj in archive if obj[0] > 0 or obj[1] > 0]\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n\n    base_solution = random.choice(candidates).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: apply a combination of edge insertion and node swap\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # For larger instances, perform a more sophisticated operation\n        # Step 1: Select a random segment to reverse (similar to 2-opt but more flexible)\n        start, end = sorted(random.sample(range(n), 2))\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Step 2: Perform a node insertion (move a node to a different position)\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 141,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low cost\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct edges to modify\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Perform 3-opt move\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Optionally, perform edge exchange between two random edges\n    if random.random() < 0.5:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if 3-opt fails\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.840212485097931,
            2.080157995223999
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low cost\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct edges to modify\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Perform 3-opt move\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Optionally, perform edge exchange between two random edges\n    if random.random() < 0.5:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if 3-opt fails\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 142,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (could be replaced with a more sophisticated metric)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select the top 20% of solutions\n        candidate_solutions = sorted_archive[:max(1, len(sorted_archive) // 5)]\n        # Randomly select one from the top candidates\n        selected = random.choice(candidate_solutions)[0].copy()\n    else:\n        selected = archive[0][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with a custom edge insertion\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt on a random segment\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply edge insertion: randomly select a node and reinsert it in a better position\n    if n > 3:\n        node_to_move = random.choice(new_solution[1:-1])  # Avoid start/end nodes\n        current_pos = np.where(new_solution == node_to_move)[0][0]\n        new_solution = np.delete(new_solution, current_pos)\n\n        # Find the best insertion position based on both objectives\n        best_pos = 0\n        best_cost = float('inf')\n\n        for pos in range(len(new_solution)):\n            temp_solution = np.insert(new_solution, pos, node_to_move)\n            # Calculate the cost in both objective spaces\n            cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n            cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n            total_cost = cost1 + cost2  # Simple combination, could be more sophisticated\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        new_solution = np.insert(new_solution, best_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.7045356265303,
            14.693124771118164
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (could be replaced with a more sophisticated metric)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select the top 20% of solutions\n        candidate_solutions = sorted_archive[:max(1, len(sorted_archive) // 5)]\n        # Randomly select one from the top candidates\n        selected = random.choice(candidate_solutions)[0].copy()\n    else:\n        selected = archive[0][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with a custom edge insertion\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt on a random segment\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply edge insertion: randomly select a node and reinsert it in a better position\n    if n > 3:\n        node_to_move = random.choice(new_solution[1:-1])  # Avoid start/end nodes\n        current_pos = np.where(new_solution == node_to_move)[0][0]\n        new_solution = np.delete(new_solution, current_pos)\n\n        # Find the best insertion position based on both objectives\n        best_pos = 0\n        best_cost = float('inf')\n\n        for pos in range(len(new_solution)):\n            temp_solution = np.insert(new_solution, pos, node_to_move)\n            # Calculate the cost in both objective spaces\n            cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n            cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n            total_cost = cost1 + cost2  # Simple combination, could be more sophisticated\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        new_solution = np.insert(new_solution, best_pos, node_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 143,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability weighted by its potential for improvement\n    weights = [1.0 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge-swap operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three distinct positions for 3-opt\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Apply 3-opt: reverse the segment between i and j, then reverse between j and k\n    new_solution[i:j] = np.flip(new_solution[i:j])\n    new_solution[j:k] = np.flip(new_solution[j:k])\n\n    # Novel edge-swap operator: swap edges between two random nodes\n    a, b = random.sample(range(n), 2)\n    if a > b:\n        a, b = b, a\n    # Ensure the swap maintains feasibility\n    if b - a > 1:\n        new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Ensure the solution is a valid tour\n    assert len(np.unique(new_solution)) == n, \"Invalid tour generated\"\n    assert np.all(new_solution[:-1] != new_solution[1:]), \"Duplicate nodes in tour\"\n\n    return new_solution\n\n",
        "score": [
            -0.79913859415817,
            2.527129650115967
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability weighted by its potential for improvement\n    weights = [1.0 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge-swap operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three distinct positions for 3-opt\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Apply 3-opt: reverse the segment between i and j, then reverse between j and k\n    new_solution[i:j] = np.flip(new_solution[i:j])\n    new_solution[j:k] = np.flip(new_solution[j:k])\n\n    # Novel edge-swap operator: swap edges between two random nodes\n    a, b = random.sample(range(n), 2)\n    if a > b:\n        a, b = b, a\n    # Ensure the swap maintains feasibility\n    if b - a > 1:\n        new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Ensure the solution is a valid tour\n    assert len(np.unique(new_solution)) == n, \"Invalid tour generated\"\n    assert np.all(new_solution[:-1] != new_solution[1:]), \"Duplicate nodes in tour\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 144,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # Here, we prioritize solutions with higher total cost in either objective\n    archive_sorted = sorted(archive, key=lambda x: max(x[1]), reverse=True)\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: combination of 2-opt and edge exchange\n    n = len(new_solution)\n    for _ in range(10):  # Limited iterations to balance exploration and exploitation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        # 2-opt move: reverse a segment\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Edge exchange: swap edges with potential for improvement\n        if np.random.rand() < 0.3:  # Probability of edge exchange\n            k, l = sorted(np.random.choice(n, 2, replace=False))\n            if k != i and l != j:\n                # Check if swap improves both objectives\n                original_cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n                new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[j], new_solution[l]]\n\n                original_cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n                new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[j], new_solution[l]]\n\n                if (new_cost1 < original_cost1) and (new_cost2 < original_cost2):\n                    # Perform the edge exchange\n                    new_solution[i+1], new_solution[k] = new_solution[k], new_solution[i+1]\n                    new_solution[j], new_solution[l] = new_solution[l], new_solution[j]\n\n    return new_solution\n\n",
        "score": [
            -0.6329000858294125,
            3.218333423137665
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # Here, we prioritize solutions with higher total cost in either objective\n    archive_sorted = sorted(archive, key=lambda x: max(x[1]), reverse=True)\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: combination of 2-opt and edge exchange\n    n = len(new_solution)\n    for _ in range(10):  # Limited iterations to balance exploration and exploitation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        # 2-opt move: reverse a segment\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Edge exchange: swap edges with potential for improvement\n        if np.random.rand() < 0.3:  # Probability of edge exchange\n            k, l = sorted(np.random.choice(n, 2, replace=False))\n            if k != i and l != j:\n                # Check if swap improves both objectives\n                original_cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n                new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[j], new_solution[l]]\n\n                original_cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n                new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[j], new_solution[l]]\n\n                if (new_cost1 < original_cost1) and (new_cost2 < original_cost2):\n                    # Perform the edge exchange\n                    new_solution[i+1], new_solution[k] = new_solution[k], new_solution[i+1]\n                    new_solution[j], new_solution[l] = new_solution[l], new_solution[j]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 145,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with the highest potential for improvement\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge swap\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select three distinct indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply a custom 3-opt-like move\n    new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment\n    new_solution[j:k] = new_solution[j:k][::-1]  # Reverse another segment\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple 2-opt if the move is invalid\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8887750705692845,
            1.8210866451263428
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with the highest potential for improvement\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge swap\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select three distinct indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply a custom 3-opt-like move\n    new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment\n    new_solution[j:k] = new_solution[j:k][::-1]  # Reverse another segment\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple 2-opt if the move is invalid\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 146,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select non-dominated solutions from the archive\n    non_dominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        # If no non-dominated solutions, select randomly\n        selected_sol = np.random.choice(archive)[0]\n    else:\n        # Select a solution with the lowest combined cost\n        selected_sol, _ = min(non_dominated, key=lambda x: sum(x[1]))\n\n    # Apply hybrid local search: combination of 3-opt and node insertion\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices for 3-opt\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt: reverse the middle segment\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply node insertion: move a random node to a new position\n    node_to_move = np.random.randint(n)\n    new_pos = np.random.randint(n)\n    if new_pos > node_to_move:\n        new_solution = np.concatenate([new_solution[:node_to_move], new_solution[node_to_move+1:new_pos+1], [new_solution[node_to_move]], new_solution[new_pos+1:]])\n    else:\n        new_solution = np.concatenate([new_solution[:new_pos], [new_solution[node_to_move]], new_solution[new_pos:node_to_move], new_solution[node_to_move+1:]])\n\n    # Ensure the solution remains valid (no duplicates)\n    assert len(np.unique(new_solution)) == len(new_solution), \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.657624419842926,
            2.4730001091957092
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select non-dominated solutions from the archive\n    non_dominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        # If no non-dominated solutions, select randomly\n        selected_sol = np.random.choice(archive)[0]\n    else:\n        # Select a solution with the lowest combined cost\n        selected_sol, _ = min(non_dominated, key=lambda x: sum(x[1]))\n\n    # Apply hybrid local search: combination of 3-opt and node insertion\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices for 3-opt\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt: reverse the middle segment\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply node insertion: move a random node to a new position\n    node_to_move = np.random.randint(n)\n    new_pos = np.random.randint(n)\n    if new_pos > node_to_move:\n        new_solution = np.concatenate([new_solution[:node_to_move], new_solution[node_to_move+1:new_pos+1], [new_solution[node_to_move]], new_solution[new_pos+1:]])\n    else:\n        new_solution = np.concatenate([new_solution[:new_pos], [new_solution[node_to_move]], new_solution[new_pos:node_to_move], new_solution[node_to_move+1:]])\n\n    # Ensure the solution remains valid (no duplicates)\n    assert len(np.unique(new_solution)) == len(new_solution), \"Generated solution is invalid\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 147,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    # Solutions with lower costs and higher diversity are preferred\n    costs = np.array([obj for _, obj in archive])\n    normalized_costs = (costs - costs.min(axis=0)) / (costs.max(axis=0) - costs.min(axis=0) + 1e-10)\n    diversity_scores = np.array([np.std(normalized_costs[i]) for i in range(len(archive))])\n    selection_prob = (1 - normalized_costs.mean(axis=1)) * diversity_scores\n    selection_prob = selection_prob / selection_prob.sum()\n\n    selected_idx = np.random.choice(len(archive), p=selection_prob)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge insertion\n    n = len(new_solution)\n    for _ in range(3):  # Number of perturbation attempts\n        # Randomly select three distinct edges to modify\n        i, j, k = sorted(random.sample(range(n), 3))\n\n        # Apply 3-opt move\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Novel edge insertion: insert a random edge from another part of the tour\n        if random.random() < 0.5:  # 50% chance to apply novel insertion\n            l = random.randint(0, n-1)\n            if l != i and l != j and l != k:\n                # Remove node l and reinsert it elsewhere\n                node_l = new_solution[l]\n                new_solution = np.concatenate([new_solution[:l], new_solution[l+1:]])\n                insert_pos = random.randint(0, len(new_solution)-1)\n                new_solution = np.insert(new_solution, insert_pos, node_l)\n\n    return new_solution\n\n",
        "score": [
            -0.8467360165528334,
            3.924002170562744
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    # Solutions with lower costs and higher diversity are preferred\n    costs = np.array([obj for _, obj in archive])\n    normalized_costs = (costs - costs.min(axis=0)) / (costs.max(axis=0) - costs.min(axis=0) + 1e-10)\n    diversity_scores = np.array([np.std(normalized_costs[i]) for i in range(len(archive))])\n    selection_prob = (1 - normalized_costs.mean(axis=1)) * diversity_scores\n    selection_prob = selection_prob / selection_prob.sum()\n\n    selected_idx = np.random.choice(len(archive), p=selection_prob)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge insertion\n    n = len(new_solution)\n    for _ in range(3):  # Number of perturbation attempts\n        # Randomly select three distinct edges to modify\n        i, j, k = sorted(random.sample(range(n), 3))\n\n        # Apply 3-opt move\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Novel edge insertion: insert a random edge from another part of the tour\n        if random.random() < 0.5:  # 50% chance to apply novel insertion\n            l = random.randint(0, n-1)\n            if l != i and l != j and l != k:\n                # Remove node l and reinsert it elsewhere\n                node_l = new_solution[l]\n                new_solution = np.concatenate([new_solution[:l], new_solution[l+1:]])\n                insert_pos = random.randint(0, len(new_solution)-1)\n                new_solution = np.insert(new_solution, insert_pos, node_l)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 148,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 30% in either objective)\n    sorted_archive = sorted(archive, key=lambda x: max(x[1]))\n    top_threshold = int(0.3 * len(sorted_archive))\n    candidate_solutions = sorted_archive[:top_threshold]\n    if not candidate_solutions:\n        candidate_solutions = archive\n    selected = random.choice(candidate_solutions)\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct indices to perform 3-opt\n    indices = random.sample(range(n), 3)\n    i, j, k = sorted(indices)\n\n    # Perform 3-opt (swap edges to form a new tour)\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Custom edge insertion: move a random segment to a new position\n    seg_start = random.randint(0, n-3)\n    seg_length = random.randint(2, min(4, n - seg_start - 1))\n    segment = new_solution[seg_start:seg_start+seg_length]\n\n    # Remove the segment and insert it at a random position\n    new_solution = np.concatenate([\n        new_solution[:seg_start],\n        new_solution[seg_start+seg_length:]\n    ])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == len(base_solution), \"Invalid solution length\"\n    assert len(np.unique(new_solution)) == len(base_solution), \"Duplicate nodes in solution\"\n\n    return new_solution\n\n",
        "score": [
            -0.7195499921074747,
            2.036851465702057
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 30% in either objective)\n    sorted_archive = sorted(archive, key=lambda x: max(x[1]))\n    top_threshold = int(0.3 * len(sorted_archive))\n    candidate_solutions = sorted_archive[:top_threshold]\n    if not candidate_solutions:\n        candidate_solutions = archive\n    selected = random.choice(candidate_solutions)\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct indices to perform 3-opt\n    indices = random.sample(range(n), 3)\n    i, j, k = sorted(indices)\n\n    # Perform 3-opt (swap edges to form a new tour)\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Custom edge insertion: move a random segment to a new position\n    seg_start = random.randint(0, n-3)\n    seg_length = random.randint(2, min(4, n - seg_start - 1))\n    segment = new_solution[seg_start:seg_start+seg_length]\n\n    # Remove the segment and insert it at a random position\n    new_solution = np.concatenate([\n        new_solution[:seg_start],\n        new_solution[seg_start+seg_length:]\n    ])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == len(base_solution), \"Invalid solution length\"\n    assert len(np.unique(new_solution)) == len(base_solution), \"Duplicate nodes in solution\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 149,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability of being non-dominated or having potential for improvement\n    selected_solution = None\n    max_potential = -1\n\n    for sol, obj in archive:\n        # Calculate potential for improvement: higher potential if the solution is non-dominated or has high variance in objectives\n        potential = (obj[0] + obj[1]) * random.uniform(0.8, 1.2)  # Add some randomness to avoid bias\n        if potential > max_potential:\n            max_potential = potential\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search operator: a combination of edge insertion and segment reversal\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Step 1: Randomly select a segment to reverse (similar to 2-opt but with a variable segment length)\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Randomly insert a node elsewhere in the tour (edge insertion)\n    insert_pos = random.randint(0, n - 1)\n    node_to_insert = new_solution[insert_pos]\n    new_solution = np.delete(new_solution, insert_pos)\n    new_insert_pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, new_insert_pos, node_to_insert)\n\n    return new_solution\n\n",
        "score": [
            -0.9358907735225628,
            2.049038052558899
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability of being non-dominated or having potential for improvement\n    selected_solution = None\n    max_potential = -1\n\n    for sol, obj in archive:\n        # Calculate potential for improvement: higher potential if the solution is non-dominated or has high variance in objectives\n        potential = (obj[0] + obj[1]) * random.uniform(0.8, 1.2)  # Add some randomness to avoid bias\n        if potential > max_potential:\n            max_potential = potential\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search operator: a combination of edge insertion and segment reversal\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Step 1: Randomly select a segment to reverse (similar to 2-opt but with a variable segment length)\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Randomly insert a node elsewhere in the tour (edge insertion)\n    insert_pos = random.randint(0, n - 1)\n    node_to_insert = new_solution[insert_pos]\n    new_solution = np.delete(new_solution, insert_pos)\n    new_insert_pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, new_insert_pos, node_to_insert)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 150,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a random solution from the archive (can be replaced with more sophisticated selection)\n    selected_solution = random.choice(archive)[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: Edge Insertion + Segment Reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Step 1: Edge Insertion (move a random edge to a new position)\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    while abs(i - j) < 2:  # Ensure enough distance between i and j\n        j = random.randint(0, n-1)\n\n    # Insert node at j after node at i\n    node = new_solution[j]\n    new_solution = np.concatenate([new_solution[:i+1], [node], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Step 2: Segment Reversal (reverse a random segment)\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, n-1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        new_solution = np.sort(new_solution)  # Fallback to a valid tour\n\n    return new_solution\n\n",
        "score": [
            -0.7893955854213269,
            1.1342257857322693
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a random solution from the archive (can be replaced with more sophisticated selection)\n    selected_solution = random.choice(archive)[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: Edge Insertion + Segment Reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Step 1: Edge Insertion (move a random edge to a new position)\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    while abs(i - j) < 2:  # Ensure enough distance between i and j\n        j = random.randint(0, n-1)\n\n    # Insert node at j after node at i\n    node = new_solution[j]\n    new_solution = np.concatenate([new_solution[:i+1], [node], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Step 2: Segment Reversal (reverse a random segment)\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, n-1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        new_solution = np.sort(new_solution)  # Fallback to a valid tour\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 151,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its rank in the archive\n    ranks = np.arange(1, len(archive) + 1)\n    probabilities = 1 / ranks\n    probabilities = probabilities / probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: edge insertion followed by dynamic segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge insertion: remove a random edge and reinsert it in a different position\n    if n > 3:\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n - 1)\n\n        # Remove edge between i and i+1\n        removed_node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n\n        # Reinsert at position j\n        new_solution = np.insert(new_solution, j, removed_node)\n\n    # Dynamic segment reversal: reverse a random segment of the tour\n    if n > 3:\n        seg_start = random.randint(0, n - 2)\n        seg_end = random.randint(seg_start + 1, n - 1)\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes included)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n    assert set(new_solution) == set(base_solution), \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -1.0178354022212868,
            1.972780168056488
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its rank in the archive\n    ranks = np.arange(1, len(archive) + 1)\n    probabilities = 1 / ranks\n    probabilities = probabilities / probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: edge insertion followed by dynamic segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge insertion: remove a random edge and reinsert it in a different position\n    if n > 3:\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n - 1)\n\n        # Remove edge between i and i+1\n        removed_node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n\n        # Reinsert at position j\n        new_solution = np.insert(new_solution, j, removed_node)\n\n    # Dynamic segment reversal: reverse a random segment of the tour\n    if n > 3:\n        seg_start = random.randint(0, n - 2)\n        seg_end = random.randint(seg_start + 1, n - 1)\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes included)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n    assert set(new_solution) == set(base_solution), \"Generated solution is invalid\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 151,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its rank in the archive\n    ranks = np.arange(1, len(archive) + 1)\n    probabilities = 1 / ranks\n    probabilities = probabilities / probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: edge insertion followed by dynamic segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge insertion: remove a random edge and reinsert it in a different position\n    if n > 3:\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n - 1)\n\n        # Remove edge between i and i+1\n        removed_node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n\n        # Reinsert at position j\n        new_solution = np.insert(new_solution, j, removed_node)\n\n    # Dynamic segment reversal: reverse a random segment of the tour\n    if n > 3:\n        seg_start = random.randint(0, n - 2)\n        seg_end = random.randint(seg_start + 1, n - 1)\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes included)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n    assert set(new_solution) == set(base_solution), \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -1.0178354022212868,
            1.972780168056488
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its rank in the archive\n    ranks = np.arange(1, len(archive) + 1)\n    probabilities = 1 / ranks\n    probabilities = probabilities / probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: edge insertion followed by dynamic segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge insertion: remove a random edge and reinsert it in a different position\n    if n > 3:\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n - 1)\n\n        # Remove edge between i and i+1\n        removed_node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n\n        # Reinsert at position j\n        new_solution = np.insert(new_solution, j, removed_node)\n\n    # Dynamic segment reversal: reverse a random segment of the tour\n    if n > 3:\n        seg_start = random.randint(0, n - 2)\n        seg_end = random.randint(seg_start + 1, n - 1)\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes included)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n    assert set(new_solution) == set(base_solution), \"Generated solution is invalid\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 152,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by a combination of objective values (e.g., sum of normalized objectives)\n        objectives = np.array([obj for _, obj in archive])\n        normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n        scores = normalized_objectives.sum(axis=1)\n        selected_idx = np.argmin(scores)  # Select the solution with the lowest score (better overall performance)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: apply edge insertion and node swap\n    n = len(new_solution)\n    if n <= 2:\n        return new_solution  # No improvement possible\n\n    # Step 1: Edge insertion (move a random edge to a different position)\n    i, j = sorted(random.sample(range(n), 2))\n    edge = new_solution[i:j+1]\n\n    # Remove the edge and insert it at a random position\n    remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], edge, remaining[insert_pos:]])\n\n    # Step 2: Node swap (swap two nodes to potentially improve the tour)\n    if n > 2:\n        k, l = random.sample(range(n), 2)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains a valid tour (no duplicates and all nodes visited)\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n, \"Invalid tour generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.7854401140916389,
            2.135577976703644
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by a combination of objective values (e.g., sum of normalized objectives)\n        objectives = np.array([obj for _, obj in archive])\n        normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n        scores = normalized_objectives.sum(axis=1)\n        selected_idx = np.argmin(scores)  # Select the solution with the lowest score (better overall performance)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: apply edge insertion and node swap\n    n = len(new_solution)\n    if n <= 2:\n        return new_solution  # No improvement possible\n\n    # Step 1: Edge insertion (move a random edge to a different position)\n    i, j = sorted(random.sample(range(n), 2))\n    edge = new_solution[i:j+1]\n\n    # Remove the edge and insert it at a random position\n    remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], edge, remaining[insert_pos:]])\n\n    # Step 2: Node swap (swap two nodes to potentially improve the tour)\n    if n > 2:\n        k, l = random.sample(range(n), 2)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains a valid tour (no duplicates and all nodes visited)\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n, \"Invalid tour generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 153,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in either objective)\n    sorted_archive = sorted(archive, key=lambda x: max(x[1]))\n    selection_pool = sorted_archive[:max(1, len(sorted_archive) // 5)]\n    selected = random.choice(selection_pool)\n    base_solution = selected[0].copy()\n\n    # Hybrid local search operator: combine 3-opt with a custom edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct edges to perform 3-opt\n    i, j, k = sorted(random.sample(range(1, n), 3))\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Try all possible 3-opt configurations\n    candidates = [\n        np.concatenate([segment1, segment2[::-1], segment3[::-1], segment4]),\n        np.concatenate([segment1, segment3, segment2, segment4]),\n        np.concatenate([segment1, segment3[::-1], segment2, segment4]),\n        np.concatenate([segment1, segment2, segment3[::-1], segment4])\n    ]\n\n    # Evaluate all candidates based on both objectives\n    best_candidate = None\n    best_score = float('inf')\n\n    for candidate in candidates:\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        score = max(cost1, cost2)  # Using max to balance both objectives\n\n        if score < best_score:\n            best_score = score\n            best_candidate = candidate\n\n    if best_candidate is not None:\n        new_solution = best_candidate\n\n    # Additional custom edge swap for further improvement\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Verify the solution remains feasible\n    assert len(new_solution) == len(base_solution) and len(np.unique(new_solution)) == len(base_solution), \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.7029735843879343,
            2.7083520889282227
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in either objective)\n    sorted_archive = sorted(archive, key=lambda x: max(x[1]))\n    selection_pool = sorted_archive[:max(1, len(sorted_archive) // 5)]\n    selected = random.choice(selection_pool)\n    base_solution = selected[0].copy()\n\n    # Hybrid local search operator: combine 3-opt with a custom edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct edges to perform 3-opt\n    i, j, k = sorted(random.sample(range(1, n), 3))\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Try all possible 3-opt configurations\n    candidates = [\n        np.concatenate([segment1, segment2[::-1], segment3[::-1], segment4]),\n        np.concatenate([segment1, segment3, segment2, segment4]),\n        np.concatenate([segment1, segment3[::-1], segment2, segment4]),\n        np.concatenate([segment1, segment2, segment3[::-1], segment4])\n    ]\n\n    # Evaluate all candidates based on both objectives\n    best_candidate = None\n    best_score = float('inf')\n\n    for candidate in candidates:\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        score = max(cost1, cost2)  # Using max to balance both objectives\n\n        if score < best_score:\n            best_score = score\n            best_candidate = candidate\n\n    if best_candidate is not None:\n        new_solution = best_candidate\n\n    # Additional custom edge swap for further improvement\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Verify the solution remains feasible\n    assert len(new_solution) == len(base_solution) and len(np.unique(new_solution)) == len(base_solution), \"Generated solution is invalid\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 154,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest potential for improvement (lowest cost but not already optimal)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search operator: combine 3-opt with a custom move\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct positions\n    i, j, k = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Apply a 3-opt move (reverse a segment and reinsert)\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    # Custom move: swap two nodes that are far apart in both objective spaces\n    if np.random.rand() < 0.5:  # 50% chance to apply custom move\n        # Find the most distant pair in both spaces\n        max_dist = -1\n        x, y = 0, 0\n        for a in range(n):\n            for b in range(a+1, n):\n                dist1 = distance_matrix_1[new_solution[a], new_solution[b]]\n                dist2 = distance_matrix_2[new_solution[a], new_solution[b]]\n                if dist1 + dist2 > max_dist:\n                    max_dist = dist1 + dist2\n                    x, y = a, b\n        # Swap the most distant pair\n        new_solution[x], new_solution[y] = new_solution[y], new_solution[x]\n\n    return new_solution\n\n",
        "score": [
            -0.6967430299590716,
            3.508989155292511
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest potential for improvement (lowest cost but not already optimal)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search operator: combine 3-opt with a custom move\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct positions\n    i, j, k = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Apply a 3-opt move (reverse a segment and reinsert)\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    # Custom move: swap two nodes that are far apart in both objective spaces\n    if np.random.rand() < 0.5:  # 50% chance to apply custom move\n        # Find the most distant pair in both spaces\n        max_dist = -1\n        x, y = 0, 0\n        for a in range(n):\n            for b in range(a+1, n):\n                dist1 = distance_matrix_1[new_solution[a], new_solution[b]]\n                dist2 = distance_matrix_2[new_solution[a], new_solution[b]]\n                if dist1 + dist2 > max_dist:\n                    max_dist = dist1 + dist2\n                    x, y = a, b\n        # Swap the most distant pair\n        new_solution[x], new_solution[y] = new_solution[y], new_solution[x]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 155,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best but not the worst)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selection_pool = sorted_archive[len(archive)//4 : 3*len(archive)//4]  # Middle 50% of solutions\n    if not selection_pool:\n        selection_pool = archive\n    selected_idx = random.randint(0, len(selection_pool)-1)\n    base_solution = selection_pool[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Step 1: Edge exchange (similar to 2-opt but with more flexibility)\n    i, j = sorted(random.sample(range(n), 2))\n    if j - i > 1:  # Ensure we have at least one node in between\n        new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment\n\n    # Step 2: Segment relocation (novel approach)\n    if n >= 6:\n        a, b, c = sorted(random.sample(range(n), 3))\n        if b - a > 1 and c - b > 1:  # Ensure segments are meaningful\n            segment = new_solution[b:c]\n            new_solution = np.concatenate([new_solution[:b], new_solution[c:], segment])\n\n    # Ensure the solution remains valid\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6464409003617267,
            1.6264587044715881
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best but not the worst)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selection_pool = sorted_archive[len(archive)//4 : 3*len(archive)//4]  # Middle 50% of solutions\n    if not selection_pool:\n        selection_pool = archive\n    selected_idx = random.randint(0, len(selection_pool)-1)\n    base_solution = selection_pool[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Step 1: Edge exchange (similar to 2-opt but with more flexibility)\n    i, j = sorted(random.sample(range(n), 2))\n    if j - i > 1:  # Ensure we have at least one node in between\n        new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment\n\n    # Step 2: Segment relocation (novel approach)\n    if n >= 6:\n        a, b, c = sorted(random.sample(range(n), 3))\n        if b - a > 1 and c - b > 1:  # Ensure segments are meaningful\n            segment = new_solution[b:c]\n            new_solution = np.concatenate([new_solution[:b], new_solution[c:], segment])\n\n    # Ensure the solution remains valid\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 156,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    solutions = [s for s, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential for improvement (inverse of current cost)\n    potentials = [1.0 / (obj[0] + obj[1] + 1e-6) for obj in objectives]\n    total_potential = sum(potentials)\n    probabilities = [p / total_potential for p in potentials]\n\n    selected_idx = np.random.choice(len(solutions), p=probabilities)\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search operator: 3-opt with adaptive edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select three distinct edges to modify\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Perform 3-opt move (reconnects the three edges)\n    # This creates a new tour with potentially better cost in both objectives\n    new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment between i and j\n    new_solution[j:k] = new_solution[j:k][::-1]  # Reverse segment between j and k\n\n    # Ensure the tour remains valid (visits each node exactly once)\n    # Verify no duplicates and all nodes are present\n    if len(set(new_solution)) != n:\n        # If invalid, revert to original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7467484125293291,
            1.671017587184906
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    solutions = [s for s, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential for improvement (inverse of current cost)\n    potentials = [1.0 / (obj[0] + obj[1] + 1e-6) for obj in objectives]\n    total_potential = sum(potentials)\n    probabilities = [p / total_potential for p in potentials]\n\n    selected_idx = np.random.choice(len(solutions), p=probabilities)\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search operator: 3-opt with adaptive edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select three distinct edges to modify\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Perform 3-opt move (reconnects the three edges)\n    # This creates a new tour with potentially better cost in both objectives\n    new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment between i and j\n    new_solution[j:k] = new_solution[j:k][::-1]  # Reverse segment between j and k\n\n    # Ensure the tour remains valid (visits each node exactly once)\n    # Verify no duplicates and all nodes are present\n    if len(set(new_solution)) != n:\n        # If invalid, revert to original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 157,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of edge exchange and segment reversal\n    n = len(new_solution)\n    a, b, c, d = sorted(random.sample(range(n), 4))\n\n    # Perform edge exchange (swap two edges)\n    new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n\n    # Perform segment reversal (reverse a segment)\n    segment = new_solution[a:b]\n    new_solution[a:b] = segment[::-1]\n\n    # Ensure feasibility: check for duplicates or missing nodes\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.872040604088189,
            2.3965858221054077
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of edge exchange and segment reversal\n    n = len(new_solution)\n    a, b, c, d = sorted(random.sample(range(n), 4))\n\n    # Perform edge exchange (swap two edges)\n    new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n\n    # Perform segment reversal (reverse a segment)\n    segment = new_solution[a:b]\n    new_solution[a:b] = segment[::-1]\n\n    # Ensure feasibility: check for duplicates or missing nodes\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 158,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation with objective-aware selection\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Skip if too small\n\n    # Randomly select a segment to relocate\n    start = np.random.randint(0, n - 2)\n    end = np.random.randint(start + 1, min(start + 4, n - 1))  # Small segment (2-3 nodes)\n    segment = new_solution[start:end+1]\n\n    # Find best insertion point considering both objectives\n    best_insert_pos = -1\n    min_total_cost = float('inf')\n\n    for i in range(n - len(segment) + 1):\n        if i == start:\n            continue  # Skip original position\n\n        # Create candidate solution\n        candidate = np.concatenate([\n            new_solution[:start],\n            new_solution[end+1:i],\n            segment,\n            new_solution[i:]\n        ])\n\n        # Calculate total cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[j], candidate[(j+1)%n]] for j in range(n))\n        cost2 = sum(distance_matrix_2[candidate[j], candidate[(j+1)%n]] for j in range(n))\n        total_cost = cost1 + cost2  # Simple aggregation (could be weighted)\n\n        if total_cost < min_total_cost:\n            min_total_cost = total_cost\n            best_insert_pos = i\n\n    if best_insert_pos != -1:\n        # Apply the best relocation\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[end+1:best_insert_pos],\n            segment,\n            new_solution[best_insert_pos:]\n        ])\n\n    # Additional improvement: 2-opt on the relocated segment\n    if len(segment) > 1:\n        # Select two edges in the segment to reverse\n        i = np.random.randint(0, len(segment) - 1)\n        j = np.random.randint(i + 1, len(segment))\n\n        # Find positions in full solution\n        pos_i = np.where(new_solution == segment[i])[0][0]\n        pos_j = np.where(new_solution == segment[j])[0][0]\n\n        # Reverse the segment between i and j\n        new_solution[pos_i:pos_j+1] = new_solution[pos_i:pos_j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.4570920144929224,
            10.10216909646988
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation with objective-aware selection\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Skip if too small\n\n    # Randomly select a segment to relocate\n    start = np.random.randint(0, n - 2)\n    end = np.random.randint(start + 1, min(start + 4, n - 1))  # Small segment (2-3 nodes)\n    segment = new_solution[start:end+1]\n\n    # Find best insertion point considering both objectives\n    best_insert_pos = -1\n    min_total_cost = float('inf')\n\n    for i in range(n - len(segment) + 1):\n        if i == start:\n            continue  # Skip original position\n\n        # Create candidate solution\n        candidate = np.concatenate([\n            new_solution[:start],\n            new_solution[end+1:i],\n            segment,\n            new_solution[i:]\n        ])\n\n        # Calculate total cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[j], candidate[(j+1)%n]] for j in range(n))\n        cost2 = sum(distance_matrix_2[candidate[j], candidate[(j+1)%n]] for j in range(n))\n        total_cost = cost1 + cost2  # Simple aggregation (could be weighted)\n\n        if total_cost < min_total_cost:\n            min_total_cost = total_cost\n            best_insert_pos = i\n\n    if best_insert_pos != -1:\n        # Apply the best relocation\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[end+1:best_insert_pos],\n            segment,\n            new_solution[best_insert_pos:]\n        ])\n\n    # Additional improvement: 2-opt on the relocated segment\n    if len(segment) > 1:\n        # Select two edges in the segment to reverse\n        i = np.random.randint(0, len(segment) - 1)\n        j = np.random.randint(i + 1, len(segment))\n\n        # Find positions in full solution\n        pos_i = np.where(new_solution == segment[i])[0][0]\n        pos_j = np.where(new_solution == segment[j])[0][0]\n\n        # Reverse the segment between i and j\n        new_solution[pos_i:pos_j+1] = new_solution[pos_i:pos_j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 159,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a higher probability if it has lower costs\n    costs = np.array([obj for _, obj in archive])\n    normalized_costs = np.sum(costs, axis=1)\n    probabilities = 1 / (normalized_costs + 1e-6)  # Avoid division by zero\n    probabilities = probabilities / np.sum(probabilities)\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of edge exchange and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operators\n\n    # Randomly choose a segment to reverse\n    a, b = sorted(random.sample(range(1, n - 1), 2))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Randomly exchange two edges\n    c, d = sorted(random.sample(range(1, n - 1), 2))\n    if c != d:\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Ensure feasibility by checking for duplicates and missing nodes\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If infeasible, revert to a 2-opt move as fallback\n        i, j = sorted(random.sample(range(1, n - 1), 2))\n        new_solution[i:j] = new_solution[j-1:i-1:-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8872117657460961,
            2.7221879959106445
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a higher probability if it has lower costs\n    costs = np.array([obj for _, obj in archive])\n    normalized_costs = np.sum(costs, axis=1)\n    probabilities = 1 / (normalized_costs + 1e-6)  # Avoid division by zero\n    probabilities = probabilities / np.sum(probabilities)\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of edge exchange and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operators\n\n    # Randomly choose a segment to reverse\n    a, b = sorted(random.sample(range(1, n - 1), 2))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Randomly exchange two edges\n    c, d = sorted(random.sample(range(1, n - 1), 2))\n    if c != d:\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Ensure feasibility by checking for duplicates and missing nodes\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If infeasible, revert to a 2-opt move as fallback\n        i, j = sorted(random.sample(range(1, n - 1), 2))\n        new_solution[i:j] = new_solution[j-1:i-1:-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 160,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate improvement potential: inverse of current cost (higher cost = higher potential)\n    objectives = np.array([obj for _, obj in archive])\n    costs = np.sum(objectives, axis=1)\n    probabilities = 1 / (costs + 1e-6)  # Avoid division by zero\n    probabilities = probabilities / probabilities.sum()\n\n    # Select a solution based on the calculated probabilities\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of edge swaps and segment inversion\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Randomly choose between edge swap or segment inversion\n    if random.random() < 0.5:\n        # Edge swap: select 4 distinct indices and perform a 2-opt-like swap\n        i, j, k, l = random.sample(range(n), 4)\n        i, j = min(i, j), max(i, j)\n        k, l = min(k, l), max(k, l)\n\n        if i < k < j < l:\n            # Perform a 2-opt swap\n            new_solution[i:k+1] = base_solution[i:k+1][::-1]\n            new_solution[k+1:j+1] = base_solution[k+1:j+1][::-1]\n        elif k < i < l < j:\n            # Perform a different 2-opt configuration\n            new_solution[k:i+1] = base_solution[k:i+1][::-1]\n            new_solution[i+1:l+1] = base_solution[i+1:l+1][::-1]\n    else:\n        # Segment inversion: select a segment and invert it\n        segment_length = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        new_solution[start:end] = base_solution[start:end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8815018877740842,
            2.6794837713241577
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate improvement potential: inverse of current cost (higher cost = higher potential)\n    objectives = np.array([obj for _, obj in archive])\n    costs = np.sum(objectives, axis=1)\n    probabilities = 1 / (costs + 1e-6)  # Avoid division by zero\n    probabilities = probabilities / probabilities.sum()\n\n    # Select a solution based on the calculated probabilities\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of edge swaps and segment inversion\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Randomly choose between edge swap or segment inversion\n    if random.random() < 0.5:\n        # Edge swap: select 4 distinct indices and perform a 2-opt-like swap\n        i, j, k, l = random.sample(range(n), 4)\n        i, j = min(i, j), max(i, j)\n        k, l = min(k, l), max(k, l)\n\n        if i < k < j < l:\n            # Perform a 2-opt swap\n            new_solution[i:k+1] = base_solution[i:k+1][::-1]\n            new_solution[k+1:j+1] = base_solution[k+1:j+1][::-1]\n        elif k < i < l < j:\n            # Perform a different 2-opt configuration\n            new_solution[k:i+1] = base_solution[k:i+1][::-1]\n            new_solution[i+1:l+1] = base_solution[i+1:l+1][::-1]\n    else:\n        # Segment inversion: select a segment and invert it\n        segment_length = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        new_solution[start:end] = base_solution[start:end][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 161,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 30% in either objective)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 30% or top 3, whichever is smaller\n    selected_idx = random.randint(0, candidate_indices - 1)\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct positions to modify\n    a, b, c = sorted(random.sample(range(1, n-1), 3))\n\n    # Apply a novel 3-opt-like swap that considers both distance matrices\n    def calculate_gain(sol, i, j, k):\n        # Original edges: (i-1, i), (j-1, j), (k-1, k)\n        # New edges: (i-1, j), (k, i), (j-1, k)\n        original_cost = (\n            distance_matrix_1[sol[i-1], sol[i]] + distance_matrix_1[sol[j-1], sol[j]] + distance_matrix_1[sol[k-1], sol[k]] +\n            distance_matrix_2[sol[i-1], sol[i]] + distance_matrix_2[sol[j-1], sol[j]] + distance_matrix_2[sol[k-1], sol[k]]\n        )\n        new_cost = (\n            distance_matrix_1[sol[i-1], sol[j]] + distance_matrix_1[sol[k], sol[i]] + distance_matrix_1[sol[j-1], sol[k]] +\n            distance_matrix_2[sol[i-1], sol[j]] + distance_matrix_2[sol[k], sol[i]] + distance_matrix_2[sol[j-1], sol[k]]\n        )\n        return original_cost - new_cost\n\n    # Try different permutations of the selected points\n    for perm in [(a, b, c), (a, c, b), (b, a, c), (b, c, a), (c, a, b), (c, b, a)]:\n        temp_sol = new_solution.copy()\n        temp_sol[perm[0]], temp_sol[perm[1]], temp_sol[perm[2]] = new_solution[perm[1]], new_solution[perm[2]], new_solution[perm[0]]\n\n        # Check if this permutation improves both objectives\n        gain1 = calculate_gain(new_solution, a, b, c)\n        gain2 = calculate_gain(new_solution, perm[0], perm[1], perm[2])\n\n        if gain1 > 0 or gain2 > 0:\n            new_solution = temp_sol\n            break\n\n    # Ensure solution remains valid (no duplicates, all nodes present)\n    if len(set(new_solution)) != n or len(new_solution) != n:\n        # Fallback: perform a simple swap if the above fails\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7913903886969247,
            3.8417863845825195
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 30% in either objective)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 30% or top 3, whichever is smaller\n    selected_idx = random.randint(0, candidate_indices - 1)\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct positions to modify\n    a, b, c = sorted(random.sample(range(1, n-1), 3))\n\n    # Apply a novel 3-opt-like swap that considers both distance matrices\n    def calculate_gain(sol, i, j, k):\n        # Original edges: (i-1, i), (j-1, j), (k-1, k)\n        # New edges: (i-1, j), (k, i), (j-1, k)\n        original_cost = (\n            distance_matrix_1[sol[i-1], sol[i]] + distance_matrix_1[sol[j-1], sol[j]] + distance_matrix_1[sol[k-1], sol[k]] +\n            distance_matrix_2[sol[i-1], sol[i]] + distance_matrix_2[sol[j-1], sol[j]] + distance_matrix_2[sol[k-1], sol[k]]\n        )\n        new_cost = (\n            distance_matrix_1[sol[i-1], sol[j]] + distance_matrix_1[sol[k], sol[i]] + distance_matrix_1[sol[j-1], sol[k]] +\n            distance_matrix_2[sol[i-1], sol[j]] + distance_matrix_2[sol[k], sol[i]] + distance_matrix_2[sol[j-1], sol[k]]\n        )\n        return original_cost - new_cost\n\n    # Try different permutations of the selected points\n    for perm in [(a, b, c), (a, c, b), (b, a, c), (b, c, a), (c, a, b), (c, b, a)]:\n        temp_sol = new_solution.copy()\n        temp_sol[perm[0]], temp_sol[perm[1]], temp_sol[perm[2]] = new_solution[perm[1]], new_solution[perm[2]], new_solution[perm[0]]\n\n        # Check if this permutation improves both objectives\n        gain1 = calculate_gain(new_solution, a, b, c)\n        gain2 = calculate_gain(new_solution, perm[0], perm[1], perm[2])\n\n        if gain1 > 0 or gain2 > 0:\n            new_solution = temp_sol\n            break\n\n    # Ensure solution remains valid (no duplicates, all nodes present)\n    if len(set(new_solution)) != n or len(new_solution) != n:\n        # Fallback: perform a simple swap if the above fails\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 162,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        # Prefer solutions with higher diversity or lower cost\n        base_solution = min(non_dominated, key=lambda x: (x[1][0] + x[1][1]) / np.mean([distance_matrix_1[x[0][i], x[0][i+1]] + distance_matrix_2[x[0][i], x[0][i+1]] for i in range(len(x[0])-1)]))[0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a custom move\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select segments for 3-opt\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Apply 3-opt move\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Custom move: swap two randomly selected edges if it improves both objectives\n    a, b = random.sample(range(n), 2)\n    if a > b:\n        a, b = b, a\n\n    # Check if swap improves both objectives\n    current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n    current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n    new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n    new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n    if new_cost1 < current_cost1 and new_cost2 < current_cost2:\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.6724023122511686,
            7.001531720161438
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        # Prefer solutions with higher diversity or lower cost\n        base_solution = min(non_dominated, key=lambda x: (x[1][0] + x[1][1]) / np.mean([distance_matrix_1[x[0][i], x[0][i+1]] + distance_matrix_2[x[0][i], x[0][i+1]] for i in range(len(x[0])-1)]))[0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a custom move\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select segments for 3-opt\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Apply 3-opt move\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Custom move: swap two randomly selected edges if it improves both objectives\n    a, b = random.sample(range(n), 2)\n    if a > b:\n        a, b = b, a\n\n    # Check if swap improves both objectives\n    current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n    current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n    new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n    new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n    if new_cost1 < current_cost1 and new_cost2 < current_cost2:\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 163,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-dominated or high variance in objectives)\n    selected_solution = archive[0][0].copy()\n    selected_obj = archive[0][1]\n\n    # Calculate the variance in objectives to identify promising solutions\n    obj_variance = np.var([obj for (_, obj) in archive], axis=0)\n    for sol, obj in archive:\n        if np.var(obj) > np.var(selected_obj):\n            selected_solution = sol.copy()\n            selected_obj = obj\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine edge relocation with segment inversion\n    for _ in range(2):  # Perform multiple passes for better exploration\n        # Edge relocation: move a random edge to a different position\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = np.roll(new_solution[i:j+1], shift=1)\n\n        # Segment inversion: invert a random segment to explore new configurations\n        a, b = np.random.choice(n, 2, replace=False)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure the solution remains feasible\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.44503028324884264,
            6.1680309772491455
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-dominated or high variance in objectives)\n    selected_solution = archive[0][0].copy()\n    selected_obj = archive[0][1]\n\n    # Calculate the variance in objectives to identify promising solutions\n    obj_variance = np.var([obj for (_, obj) in archive], axis=0)\n    for sol, obj in archive:\n        if np.var(obj) > np.var(selected_obj):\n            selected_solution = sol.copy()\n            selected_obj = obj\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine edge relocation with segment inversion\n    for _ in range(2):  # Perform multiple passes for better exploration\n        # Edge relocation: move a random edge to a different position\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = np.roll(new_solution[i:j+1], shift=1)\n\n        # Segment inversion: invert a random segment to explore new configurations\n        a, b = np.random.choice(n, 2, replace=False)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure the solution remains feasible\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 164,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel segment reversal\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small tours\n\n    # Step 1: Randomly select three non-adjacent edges to perform a 3-opt move\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n    while b - a < 2 or c - b < 2:  # Ensure non-adjacent edges\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Step 2: Apply a novel segment reversal between b and c\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Step 3: Check feasibility (should always be feasible for 3-opt)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Revert if infeasible\n\n    # Step 4: Apply a random swap between two non-adjacent nodes to further diversify\n    i, j = np.random.choice(n, 2, replace=False)\n    while abs(i - j) == 1:  # Ensure non-adjacent nodes\n        i, j = np.random.choice(n, 2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.872722878221422,
            2.1287357807159424
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel segment reversal\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small tours\n\n    # Step 1: Randomly select three non-adjacent edges to perform a 3-opt move\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n    while b - a < 2 or c - b < 2:  # Ensure non-adjacent edges\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Step 2: Apply a novel segment reversal between b and c\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Step 3: Check feasibility (should always be feasible for 3-opt)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Revert if infeasible\n\n    # Step 4: Apply a random swap between two non-adjacent nodes to further diversify\n    i, j = np.random.choice(n, 2, replace=False)\n    while abs(i - j) == 1:  # Ensure non-adjacent nodes\n        i, j = np.random.choice(n, 2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 165,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Sort solutions by non-dominated rank (simplified approach)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution with a probability inversely proportional to its rank\n        ranks = np.arange(len(archive_sorted))\n        probabilities = 1 / (ranks + 1)\n        probabilities /= probabilities.sum()\n        selected_idx = np.random.choice(len(archive_sorted), p=probabilities)\n        base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: Combine 3-opt with a novel segment inversion\n    if n >= 4:\n        # Randomly select 3 distinct edges to modify\n        a, b, c = sorted(random.sample(range(n), 3))\n\n        # Apply 3-opt move\n        if random.random() < 0.7:  # 70% chance for 3-opt\n            new_solution[a:b] = new_solution[a:b][::-1]\n            new_solution[b:c] = new_solution[b:c][::-1]\n        else:  # 30% chance for segment inversion\n            segment = new_solution[a:b]\n            new_solution[a:b] = segment[::-1]\n\n        # Additional local improvement with 2-opt on a random segment\n        if n >= 4:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9220831679414114,
            2.0584676861763
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Sort solutions by non-dominated rank (simplified approach)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution with a probability inversely proportional to its rank\n        ranks = np.arange(len(archive_sorted))\n        probabilities = 1 / (ranks + 1)\n        probabilities /= probabilities.sum()\n        selected_idx = np.random.choice(len(archive_sorted), p=probabilities)\n        base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: Combine 3-opt with a novel segment inversion\n    if n >= 4:\n        # Randomly select 3 distinct edges to modify\n        a, b, c = sorted(random.sample(range(n), 3))\n\n        # Apply 3-opt move\n        if random.random() < 0.7:  # 70% chance for 3-opt\n            new_solution[a:b] = new_solution[a:b][::-1]\n            new_solution[b:c] = new_solution[b:c][::-1]\n        else:  # 30% chance for segment inversion\n            segment = new_solution[a:b]\n            new_solution[a:b] = segment[::-1]\n\n        # Additional local improvement with 2-opt on a random segment\n        if n >= 4:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 166,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    archive_sorted = sorted(archive, key=lambda x: min(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search strategy\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge insertion (randomly select a segment and reinsert it)\n    if n > 3:\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n        remaining = np.concatenate([new_solution[:a], new_solution[b:]])\n        insert_pos = random.randint(0, len(remaining))\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Two-segment swap (novel operator)\n    if n > 4:\n        # Select two non-overlapping segments\n        split1 = random.randint(1, n-2)\n        split2 = random.randint(split1+1, n-1)\n        seg1 = new_solution[:split1]\n        seg2 = new_solution[split1:split2]\n        seg3 = new_solution[split2:]\n\n        # Recombine segments in a different order\n        new_order = random.sample([seg1, seg2, seg3], k=3)\n        new_solution = np.concatenate(new_order)\n\n    # Ensure the solution remains feasible (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.4202429655916412,
            2.008047878742218
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    archive_sorted = sorted(archive, key=lambda x: min(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search strategy\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge insertion (randomly select a segment and reinsert it)\n    if n > 3:\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n        remaining = np.concatenate([new_solution[:a], new_solution[b:]])\n        insert_pos = random.randint(0, len(remaining))\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Two-segment swap (novel operator)\n    if n > 4:\n        # Select two non-overlapping segments\n        split1 = random.randint(1, n-2)\n        split2 = random.randint(split1+1, n-1)\n        seg1 = new_solution[:split1]\n        seg2 = new_solution[split1:split2]\n        seg3 = new_solution[split2:]\n\n        # Recombine segments in a different order\n        new_order = random.sample([seg1, seg2, seg3], k=3)\n        new_solution = np.concatenate(new_order)\n\n    # Ensure the solution remains feasible (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 167,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto front solutions)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Edge exchange + novel node insertion\n    n = len(new_solution)\n\n    # Edge exchange (similar to 2-opt but with a twist)\n    i, j = sorted(random.sample(range(n), 2))\n    if j - i > 1:\n        # Reverse the segment between i and j\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Novel node insertion: Move a random node to a new position\n    if n > 3:\n        k = random.randint(0, n - 1)\n        l = random.randint(0, n - 1)\n        if k != l:\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, l, node)\n\n    # Ensure the solution remains a valid TSP tour\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.8262682381864903,
            1.6568682789802551
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto front solutions)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Edge exchange + novel node insertion\n    n = len(new_solution)\n\n    # Edge exchange (similar to 2-opt but with a twist)\n    i, j = sorted(random.sample(range(n), 2))\n    if j - i > 1:\n        # Reverse the segment between i and j\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Novel node insertion: Move a random node to a new position\n    if n > 3:\n        k = random.randint(0, n - 1)\n        l = random.randint(0, n - 1)\n        if k != l:\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, l, node)\n\n    # Ensure the solution remains a valid TSP tour\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 168,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = random.choice(archive)[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel segment reversal\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt between i and j\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Novel segment reversal: reverse a random segment within the reversed segment\n    if j - i > 2:\n        sub_i, sub_j = sorted(random.sample(range(i, j), 2))\n        new_solution[sub_i:sub_j] = new_solution[sub_i:sub_j][::-1]\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    assert len(np.unique(new_solution)) == len(selected_solution), \"Solution is invalid (duplicate nodes)\"\n    assert np.array_equal(np.sort(new_solution), np.sort(selected_solution)), \"Solution is invalid (missing nodes)\"\n\n    return new_solution\n\n",
        "score": [
            -0.8226363730581144,
            2.3874632120132446
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = random.choice(archive)[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel segment reversal\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt between i and j\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Novel segment reversal: reverse a random segment within the reversed segment\n    if j - i > 2:\n        sub_i, sub_j = sorted(random.sample(range(i, j), 2))\n        new_solution[sub_i:sub_j] = new_solution[sub_i:sub_j][::-1]\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    assert len(np.unique(new_solution)) == len(selected_solution), \"Solution is invalid (duplicate nodes)\"\n    assert np.array_equal(np.sort(new_solution), np.sort(selected_solution)), \"Solution is invalid (missing nodes)\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 169,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best but not the worst)\n    if len(archive) > 2:\n        # Exclude the best and worst solutions to focus on middle ground\n        candidates = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))[1:-1]\n        selected = random.choice(candidates)\n    else:\n        selected = random.choice(archive)\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(base_solution)\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n\n    # Ensure i and j are distinct\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    # Path-based operation: Reverse a segment between i and j\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Edge-based operation: Swap edges if it improves both objectives\n    if j < n - 1:\n        a, b = i, (i + 1) % n\n        c, d = j, (j + 1) % n\n        cost_before_1 = distance_matrix_1[base_solution[a], base_solution[b]] + distance_matrix_1[base_solution[c], base_solution[d]]\n        cost_after_1 = distance_matrix_1[base_solution[a], base_solution[c]] + distance_matrix_1[base_solution[b], base_solution[d]]\n        cost_before_2 = distance_matrix_2[base_solution[a], base_solution[b]] + distance_matrix_2[base_solution[c], base_solution[d]]\n        cost_after_2 = distance_matrix_2[base_solution[a], base_solution[c]] + distance_matrix_2[base_solution[b], base_solution[d]]\n\n        if (cost_after_1 < cost_before_1 and cost_after_2 < cost_before_2):\n            new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n\n    return new_solution\n\n",
        "score": [
            -0.7987833883940858,
            2.2766587138175964
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best but not the worst)\n    if len(archive) > 2:\n        # Exclude the best and worst solutions to focus on middle ground\n        candidates = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))[1:-1]\n        selected = random.choice(candidates)\n    else:\n        selected = random.choice(archive)\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(base_solution)\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n\n    # Ensure i and j are distinct\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    # Path-based operation: Reverse a segment between i and j\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Edge-based operation: Swap edges if it improves both objectives\n    if j < n - 1:\n        a, b = i, (i + 1) % n\n        c, d = j, (j + 1) % n\n        cost_before_1 = distance_matrix_1[base_solution[a], base_solution[b]] + distance_matrix_1[base_solution[c], base_solution[d]]\n        cost_after_1 = distance_matrix_1[base_solution[a], base_solution[c]] + distance_matrix_1[base_solution[b], base_solution[d]]\n        cost_before_2 = distance_matrix_2[base_solution[a], base_solution[b]] + distance_matrix_2[base_solution[c], base_solution[d]]\n        cost_after_2 = distance_matrix_2[base_solution[a], base_solution[c]] + distance_matrix_2[base_solution[b], base_solution[d]]\n\n        if (cost_after_1 < cost_before_1 and cost_after_2 < cost_before_2):\n            new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 170,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # Here, we prioritize solutions with high total distance (could be adjusted based on problem characteristics)\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of edge insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operations\n\n    # Randomly select a segment to modify\n    segment_start = random.randint(0, n - 4)\n    segment_end = random.randint(segment_start + 2, min(segment_start + 5, n - 1))\n\n    # Extract the segment and reverse it\n    segment = new_solution[segment_start:segment_end + 1]\n    reversed_segment = segment[::-1]\n\n    # Insert the reversed segment back\n    new_solution[segment_start:segment_end + 1] = reversed_segment\n\n    # Optionally, perform an edge insertion to further improve\n    if random.random() < 0.3:  # 30% chance to apply edge insertion\n        # Select two random edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        # Swap the nodes between these edges\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8758928432342574,
            2.2863323092460632
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # Here, we prioritize solutions with high total distance (could be adjusted based on problem characteristics)\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of edge insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operations\n\n    # Randomly select a segment to modify\n    segment_start = random.randint(0, n - 4)\n    segment_end = random.randint(segment_start + 2, min(segment_start + 5, n - 1))\n\n    # Extract the segment and reverse it\n    segment = new_solution[segment_start:segment_end + 1]\n    reversed_segment = segment[::-1]\n\n    # Insert the reversed segment back\n    new_solution[segment_start:segment_end + 1] = reversed_segment\n\n    # Optionally, perform an edge insertion to further improve\n    if random.random() < 0.3:  # 30% chance to apply edge insertion\n        # Select two random edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        # Swap the nodes between these edges\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 171,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate dominance ranks (simplified for this example)\n    dominance_scores = []\n    for sol, _ in archive:\n        # Calculate total cost in both spaces\n        cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(len(sol)-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(len(sol)-1)) + distance_matrix_2[sol[-1], sol[0]]\n        dominance_scores.append(cost1 + cost2)\n\n    # Normalize scores to get probabilities\n    min_score = min(dominance_scores)\n    max_score = max(dominance_scores)\n    if max_score == min_score:\n        probs = [1.0 / len(archive)] * len(archive)\n    else:\n        normalized_scores = [(max_score - score) / (max_score - min_score) for score in dominance_scores]\n        sum_scores = sum(normalized_scores)\n        probs = [score / sum_scores for score in normalized_scores]\n\n    # Select a base solution\n    selected_idx = random.choices(range(len(archive)), weights=probs, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of edge exchange and segment relocation\n    n = len(new_solution)\n    if n < 4:\n        # For very small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Choose between edge exchange (2-opt) and segment relocation\n        if random.random() < 0.7:  # 70% chance for edge exchange\n            # Edge exchange (2-opt)\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Segment relocation\n            seg_length = random.randint(2, min(5, n//2))\n            i = random.randint(0, n - seg_length - 1)\n            segment = new_solution[i:i+seg_length]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+seg_length:]])\n            insert_pos = random.randint(0, len(new_solution) - seg_length)\n            new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.6685073986747991,
            4.940587520599365
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate dominance ranks (simplified for this example)\n    dominance_scores = []\n    for sol, _ in archive:\n        # Calculate total cost in both spaces\n        cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(len(sol)-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(len(sol)-1)) + distance_matrix_2[sol[-1], sol[0]]\n        dominance_scores.append(cost1 + cost2)\n\n    # Normalize scores to get probabilities\n    min_score = min(dominance_scores)\n    max_score = max(dominance_scores)\n    if max_score == min_score:\n        probs = [1.0 / len(archive)] * len(archive)\n    else:\n        normalized_scores = [(max_score - score) / (max_score - min_score) for score in dominance_scores]\n        sum_scores = sum(normalized_scores)\n        probs = [score / sum_scores for score in normalized_scores]\n\n    # Select a base solution\n    selected_idx = random.choices(range(len(archive)), weights=probs, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of edge exchange and segment relocation\n    n = len(new_solution)\n    if n < 4:\n        # For very small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Choose between edge exchange (2-opt) and segment relocation\n        if random.random() < 0.7:  # 70% chance for edge exchange\n            # Edge exchange (2-opt)\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Segment relocation\n            seg_length = random.randint(2, min(5, n//2))\n            i = random.randint(0, n - seg_length - 1)\n            segment = new_solution[i:i+seg_length]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+seg_length:]])\n            insert_pos = random.randint(0, len(new_solution) - seg_length)\n            new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 172,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with better combined objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    combined_scores = normalized_obj[:, 0] + normalized_obj[:, 1]\n    probabilities = combined_scores / combined_scores.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: choose between edge insertion or segment reversal\n    if random.random() < 0.5:\n        # Edge insertion: remove a random edge and reinsert it in a better position\n        n = len(base_solution)\n        i = random.randint(0, n-1)\n        j = (i + 1) % n\n        node_i, node_j = base_solution[i], base_solution[j]\n\n        # Remove edge (i, j)\n        new_solution = np.concatenate([base_solution[:i], base_solution[j+1:]])\n\n        # Find best insertion point for node_j\n        best_pos = 0\n        min_cost = float('inf')\n        for pos in range(len(new_solution)):\n            temp_solution = np.insert(new_solution, pos, node_j)\n            cost1 = distance_matrix_1[temp_solution[-1], temp_solution[0]]\n            cost2 = distance_matrix_2[temp_solution[-1], temp_solution[0]]\n            for k in range(len(temp_solution)-1):\n                cost1 += distance_matrix_1[temp_solution[k], temp_solution[k+1]]\n                cost2 += distance_matrix_2[temp_solution[k], temp_solution[k+1]]\n            total_cost = cost1 + cost2\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        # Insert node_j at best position\n        new_solution = np.insert(new_solution, best_pos, node_j)\n    else:\n        # Segment reversal: reverse a random segment of the tour\n        n = len(base_solution)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution = base_solution.copy()\n        new_solution[i:j+1] = base_solution[j:i-1 if i > 0 else None:-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8089208676972208,
            7.051869034767151
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with better combined objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    combined_scores = normalized_obj[:, 0] + normalized_obj[:, 1]\n    probabilities = combined_scores / combined_scores.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: choose between edge insertion or segment reversal\n    if random.random() < 0.5:\n        # Edge insertion: remove a random edge and reinsert it in a better position\n        n = len(base_solution)\n        i = random.randint(0, n-1)\n        j = (i + 1) % n\n        node_i, node_j = base_solution[i], base_solution[j]\n\n        # Remove edge (i, j)\n        new_solution = np.concatenate([base_solution[:i], base_solution[j+1:]])\n\n        # Find best insertion point for node_j\n        best_pos = 0\n        min_cost = float('inf')\n        for pos in range(len(new_solution)):\n            temp_solution = np.insert(new_solution, pos, node_j)\n            cost1 = distance_matrix_1[temp_solution[-1], temp_solution[0]]\n            cost2 = distance_matrix_2[temp_solution[-1], temp_solution[0]]\n            for k in range(len(temp_solution)-1):\n                cost1 += distance_matrix_1[temp_solution[k], temp_solution[k+1]]\n                cost2 += distance_matrix_2[temp_solution[k], temp_solution[k+1]]\n            total_cost = cost1 + cost2\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        # Insert node_j at best position\n        new_solution = np.insert(new_solution, best_pos, node_j)\n    else:\n        # Segment reversal: reverse a random segment of the tour\n        n = len(base_solution)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution = base_solution.copy()\n        new_solution[i:j+1] = base_solution[j:i-1 if i > 0 else None:-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 173,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_index = np.random.choice(len(archive))\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment inversion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply segment inversion (novel operator)\n    segment = new_solution[i:j+1]\n    new_solution[i:j+1] = segment[::-1]\n\n    # Ensure feasibility: check for validity (no duplicates, all nodes present)\n    if len(np.unique(new_solution)) == len(base_solution):\n        return new_solution\n    else:\n        # Fallback to standard 2-opt if inversion fails\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n",
        "score": [
            -0.905724097375107,
            2.165993094444275
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_index = np.random.choice(len(archive))\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment inversion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply segment inversion (novel operator)\n    segment = new_solution[i:j+1]\n    new_solution[i:j+1] = segment[::-1]\n\n    # Ensure feasibility: check for validity (no duplicates, all nodes present)\n    if len(np.unique(new_solution)) == len(base_solution):\n        return new_solution\n    else:\n        # Fallback to standard 2-opt if inversion fails\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 174,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability of being non-dominated or having high potential for improvement\n    # Here, we use a simple selection strategy: pick a solution with a high objective value (for diversification)\n    # In practice, you might use more sophisticated criteria (e.g., crowding distance, dominance rank)\n    objectives = [obj for _, obj in archive]\n    max_obj = max(sum(obj) for obj in objectives)\n    candidates = [sol for sol, obj in archive if sum(obj) == max_obj]\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n\n    base_solution = random.choice(candidates).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Variable-length 2-opt (choose random segments of varying lengths)\n    # 2. Insertion heuristic (move a random segment to a different position)\n    # 3. Swap heuristic (swap two random segments)\n\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Choose a random local search operator\n        operator = random.choice(['variable_2opt', 'insertion', 'swap'])\n\n        if operator == 'variable_2opt':\n            # Variable-length 2-opt\n            length = random.randint(2, min(10, n // 2))\n            start = random.randint(0, n - 2 * length)\n            segment1 = new_solution[start:start+length]\n            segment2 = new_solution[start+length:start+2*length]\n            new_solution[start:start+2*length] = np.concatenate([np.flip(segment2), np.flip(segment1)])\n\n        elif operator == 'insertion':\n            # Insertion heuristic\n            length = random.randint(1, min(5, n // 2))\n            start = random.randint(0, n - length)\n            segment = new_solution[start:start+length]\n            # Remove the segment\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+length:]])\n            # Insert it at a random position\n            insert_pos = random.randint(0, len(new_solution) - length + 1)\n            new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n        elif operator == 'swap':\n            # Swap heuristic\n            length = random.randint(1, min(5, n // 3))\n            start1 = random.randint(0, n - 2 * length)\n            start2 = random.randint(start1 + length, n - length)\n            segment1 = new_solution[start1:start1+length]\n            segment2 = new_solution[start2:start2+length]\n            new_solution[start1:start1+length] = segment2\n            new_solution[start2:start2+length] = segment1\n\n    return new_solution\n\n",
        "score": [
            -0.8979703283116336,
            1.3089703917503357
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability of being non-dominated or having high potential for improvement\n    # Here, we use a simple selection strategy: pick a solution with a high objective value (for diversification)\n    # In practice, you might use more sophisticated criteria (e.g., crowding distance, dominance rank)\n    objectives = [obj for _, obj in archive]\n    max_obj = max(sum(obj) for obj in objectives)\n    candidates = [sol for sol, obj in archive if sum(obj) == max_obj]\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n\n    base_solution = random.choice(candidates).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Variable-length 2-opt (choose random segments of varying lengths)\n    # 2. Insertion heuristic (move a random segment to a different position)\n    # 3. Swap heuristic (swap two random segments)\n\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Choose a random local search operator\n        operator = random.choice(['variable_2opt', 'insertion', 'swap'])\n\n        if operator == 'variable_2opt':\n            # Variable-length 2-opt\n            length = random.randint(2, min(10, n // 2))\n            start = random.randint(0, n - 2 * length)\n            segment1 = new_solution[start:start+length]\n            segment2 = new_solution[start+length:start+2*length]\n            new_solution[start:start+2*length] = np.concatenate([np.flip(segment2), np.flip(segment1)])\n\n        elif operator == 'insertion':\n            # Insertion heuristic\n            length = random.randint(1, min(5, n // 2))\n            start = random.randint(0, n - length)\n            segment = new_solution[start:start+length]\n            # Remove the segment\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+length:]])\n            # Insert it at a random position\n            insert_pos = random.randint(0, len(new_solution) - length + 1)\n            new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n        elif operator == 'swap':\n            # Swap heuristic\n            length = random.randint(1, min(5, n // 3))\n            start1 = random.randint(0, n - 2 * length)\n            start2 = random.randint(start1 + length, n - length)\n            segment1 = new_solution[start1:start1+length]\n            segment2 = new_solution[start2:start2+length]\n            new_solution[start1:start1+length] = segment2\n            new_solution[start2:start2+length] = segment1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 175,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated solutions)\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search strategy: Edge-swap with biased randomness\n    n = len(selected_solution)\n    if n < 3:\n        return selected_solution\n\n    # Randomly select a segment to modify\n    start = np.random.randint(0, n - 2)\n    end = np.random.randint(start + 1, n - 1)\n\n    # Apply a novel edge-swap operation\n    new_solution = selected_solution.copy()\n    new_solution[start:end+1] = np.flip(new_solution[start:end+1])\n\n    # Introduce controlled randomness to escape local optima\n    if np.random.random() < 0.3:\n        i, j = np.random.choice(range(n), size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (valid TSP tour)\n    if not (len(np.unique(new_solution)) == n and np.all(np.isin(new_solution, np.arange(n)))):\n        new_solution = selected_solution.copy()  # Fallback to original if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.9138841724808475,
            2.5902181267738342
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated solutions)\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search strategy: Edge-swap with biased randomness\n    n = len(selected_solution)\n    if n < 3:\n        return selected_solution\n\n    # Randomly select a segment to modify\n    start = np.random.randint(0, n - 2)\n    end = np.random.randint(start + 1, n - 1)\n\n    # Apply a novel edge-swap operation\n    new_solution = selected_solution.copy()\n    new_solution[start:end+1] = np.flip(new_solution[start:end+1])\n\n    # Introduce controlled randomness to escape local optima\n    if np.random.random() < 0.3:\n        i, j = np.random.choice(range(n), size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (valid TSP tour)\n    if not (len(np.unique(new_solution)) == n and np.all(np.isin(new_solution, np.arange(n)))):\n        new_solution = selected_solution.copy()  # Fallback to original if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 176,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high cost or low diversity)\n    # Here, we select the solution with the highest combined cost\n    costs = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmax(costs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge-swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct positions to perform 3-opt\n    a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Perform 3-opt move\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[b:c] = np.flip(new_solution[b:c])\n\n    # Additional edge-swap to further improve the solution\n    # Select two random edges and swap their endpoints if it improves both objectives\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    if i + 1 == j:\n        # Swap adjacent nodes if it reduces both costs\n        node_i, node_j = new_solution[i], new_solution[j]\n        cost_before = (distance_matrix_1[new_solution[i-1], node_i] + distance_matrix_1[node_i, node_j] + distance_matrix_1[node_j, new_solution[(j+1)%n]] +\n                       distance_matrix_2[new_solution[i-1], node_i] + distance_matrix_2[node_i, node_j] + distance_matrix_2[node_j, new_solution[(j+1)%n]])\n        cost_after = (distance_matrix_1[new_solution[i-1], node_j] + distance_matrix_1[node_j, node_i] + distance_matrix_1[node_i, new_solution[(j+1)%n]] +\n                      distance_matrix_2[new_solution[i-1], node_j] + distance_matrix_2[node_j, node_i] + distance_matrix_2[node_i, new_solution[(j+1)%n]])\n\n        if cost_after < cost_before:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8828101379105067,
            2.7414721250534058
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high cost or low diversity)\n    # Here, we select the solution with the highest combined cost\n    costs = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmax(costs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge-swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct positions to perform 3-opt\n    a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Perform 3-opt move\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[b:c] = np.flip(new_solution[b:c])\n\n    # Additional edge-swap to further improve the solution\n    # Select two random edges and swap their endpoints if it improves both objectives\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    if i + 1 == j:\n        # Swap adjacent nodes if it reduces both costs\n        node_i, node_j = new_solution[i], new_solution[j]\n        cost_before = (distance_matrix_1[new_solution[i-1], node_i] + distance_matrix_1[node_i, node_j] + distance_matrix_1[node_j, new_solution[(j+1)%n]] +\n                       distance_matrix_2[new_solution[i-1], node_i] + distance_matrix_2[node_i, node_j] + distance_matrix_2[node_j, new_solution[(j+1)%n]])\n        cost_after = (distance_matrix_1[new_solution[i-1], node_j] + distance_matrix_1[node_j, node_i] + distance_matrix_1[node_i, new_solution[(j+1)%n]] +\n                      distance_matrix_2[new_solution[i-1], node_j] + distance_matrix_2[node_j, node_i] + distance_matrix_2[node_i, new_solution[(j+1)%n]])\n\n        if cost_after < cost_before:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 177,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    weights = 1 / (normalized_objectives.mean(axis=1) + 1e-10)  # Lower objectives get higher weight\n    weights = weights / weights.sum()  # Normalize to probabilities\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose a segment to invert (novel operator)\n    if n >= 3:\n        a = random.randint(0, n - 3)\n        b = random.randint(a + 1, n - 2)\n        c = random.randint(b + 1, n - 1)\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]  # Invert segment a-b\n        new_solution[b+1:c+1] = new_solution[b+1:c+1][::-1]  # Invert segment b+1-c\n\n    # Apply 3-opt if beneficial\n    if n >= 3:\n        i, j, k = sorted(random.sample(range(n), 3))\n        current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[k-1], new_solution[k]])\n        new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_1[new_solution[j-1], new_solution[k]] +\n                    distance_matrix_1[new_solution[k-1], new_solution[i]])\n        if new_cost < current_cost:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.689760439499022,
            2.091693937778473
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    weights = 1 / (normalized_objectives.mean(axis=1) + 1e-10)  # Lower objectives get higher weight\n    weights = weights / weights.sum()  # Normalize to probabilities\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose a segment to invert (novel operator)\n    if n >= 3:\n        a = random.randint(0, n - 3)\n        b = random.randint(a + 1, n - 2)\n        c = random.randint(b + 1, n - 1)\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]  # Invert segment a-b\n        new_solution[b+1:c+1] = new_solution[b+1:c+1][::-1]  # Invert segment b+1-c\n\n    # Apply 3-opt if beneficial\n    if n >= 3:\n        i, j, k = sorted(random.sample(range(n), 3))\n        current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[k-1], new_solution[k]])\n        new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_1[new_solution[j-1], new_solution[k]] +\n                    distance_matrix_1[new_solution[k-1], new_solution[i]])\n        if new_cost < current_cost:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 178,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a preference for those with high potential for improvement\n    # Here, we use a combination of random selection and diversity consideration\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, base_objective = archive[selected_idx]\n\n    # Calculate the total cost in both objectives for the base solution\n    total_cost_1 = sum(distance_matrix_1[base_solution[i], base_solution[i+1]] for i in range(len(base_solution)-1))\n    total_cost_1 += distance_matrix_1[base_solution[-1], base_solution[0]]  # Close the loop\n\n    total_cost_2 = sum(distance_matrix_2[base_solution[i], base_solution[i+1]] for i in range(len(base_solution)-1))\n    total_cost_2 += distance_matrix_2[base_solution[-1], base_solution[0]]  # Close the loop\n\n    # Hybrid local search strategy: a combination of 3-opt and edge exchange\n    new_solution = base_solution.copy()\n\n    # First, perform a 3-opt move\n    n = len(new_solution)\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Create all possible 3-opt configurations\n    configs = [\n        new_solution.copy(),  # Original\n        np.concatenate((new_solution[:i], new_solution[i:j][::-1], new_solution[j:])),  # Reverse i-j\n        np.concatenate((new_solution[:i], new_solution[j:k][::-1], new_solution[i:j], new_solution[k:])),  # Reverse j-k, swap i-j and j-k\n        np.concatenate((new_solution[:i], new_solution[j:k][::-1], new_solution[k:])),  # Reverse j-k\n        np.concatenate((new_solution[:i], new_solution[k:], new_solution[j:i-1:-1], new_solution[i:j])),  # Reverse i-j and k-i\n        np.concatenate((new_solution[:i], new_solution[k:j-1:-1], new_solution[j:k], new_solution[i:j])),  # Reverse j-k and i-j\n        np.concatenate((new_solution[:i], new_solution[k:j-1:-1], new_solution[i:j], new_solution[j:k])),  # Reverse j-k and i-k\n        np.concatenate((new_solution[:i], new_solution[k:j-1:-1], new_solution[j:k][::-1], new_solution[i:j]))  # Reverse j-k and i-j and k-j\n    ]\n\n    # Evaluate all configurations in both objectives\n    best_config = new_solution\n    best_cost_1 = total_cost_1\n    best_cost_2 = total_cost_2\n\n    for config in configs:\n        # Calculate cost for this configuration\n        cost_1 = sum(distance_matrix_1[config[i], config[i+1]] for i in range(len(config)-1))\n        cost_1 += distance_matrix_1[config[-1], config[0]]\n\n        cost_2 = sum(distance_matrix_2[config[i], config[i+1]] for i in range(len(config)-1))\n        cost_2 += distance_matrix_2[config[-1], config[0]]\n\n        # Use a simple weighted sum to compare multi-objective solutions\n        # Here we use equal weights, but could be adjusted\n        weighted_cost = 0.5 * cost_1 + 0.5 * cost_2\n\n        # Update best if this configuration is better\n        if weighted_cost < 0.5 * best_cost_1 + 0.5 * best_cost_2:\n            best_config = config\n            best_cost_1 = cost_1\n            best_cost_2 = cost_2\n\n    new_solution = best_config\n\n    # Then perform an edge exchange (similar to Or-opt)\n    if n > 3:\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i+1)%n or j == (i-1)%n:\n            j = random.randint(0, n-1)\n\n        # Store the original segment\n        original_segment = new_solution[i:j]\n\n        # Create a new solution with the segment moved\n        if i < j:\n            new_solution = np.concatenate((new_solution[:i], new_solution[j:], original_segment))\n        else:\n            new_solution = np.concatenate((new_solution[:j], original_segment, new_solution[i:]))\n\n    return new_solution\n\n",
        "score": [
            -0.940858109416699,
            1.820300579071045
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a preference for those with high potential for improvement\n    # Here, we use a combination of random selection and diversity consideration\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, base_objective = archive[selected_idx]\n\n    # Calculate the total cost in both objectives for the base solution\n    total_cost_1 = sum(distance_matrix_1[base_solution[i], base_solution[i+1]] for i in range(len(base_solution)-1))\n    total_cost_1 += distance_matrix_1[base_solution[-1], base_solution[0]]  # Close the loop\n\n    total_cost_2 = sum(distance_matrix_2[base_solution[i], base_solution[i+1]] for i in range(len(base_solution)-1))\n    total_cost_2 += distance_matrix_2[base_solution[-1], base_solution[0]]  # Close the loop\n\n    # Hybrid local search strategy: a combination of 3-opt and edge exchange\n    new_solution = base_solution.copy()\n\n    # First, perform a 3-opt move\n    n = len(new_solution)\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Create all possible 3-opt configurations\n    configs = [\n        new_solution.copy(),  # Original\n        np.concatenate((new_solution[:i], new_solution[i:j][::-1], new_solution[j:])),  # Reverse i-j\n        np.concatenate((new_solution[:i], new_solution[j:k][::-1], new_solution[i:j], new_solution[k:])),  # Reverse j-k, swap i-j and j-k\n        np.concatenate((new_solution[:i], new_solution[j:k][::-1], new_solution[k:])),  # Reverse j-k\n        np.concatenate((new_solution[:i], new_solution[k:], new_solution[j:i-1:-1], new_solution[i:j])),  # Reverse i-j and k-i\n        np.concatenate((new_solution[:i], new_solution[k:j-1:-1], new_solution[j:k], new_solution[i:j])),  # Reverse j-k and i-j\n        np.concatenate((new_solution[:i], new_solution[k:j-1:-1], new_solution[i:j], new_solution[j:k])),  # Reverse j-k and i-k\n        np.concatenate((new_solution[:i], new_solution[k:j-1:-1], new_solution[j:k][::-1], new_solution[i:j]))  # Reverse j-k and i-j and k-j\n    ]\n\n    # Evaluate all configurations in both objectives\n    best_config = new_solution\n    best_cost_1 = total_cost_1\n    best_cost_2 = total_cost_2\n\n    for config in configs:\n        # Calculate cost for this configuration\n        cost_1 = sum(distance_matrix_1[config[i], config[i+1]] for i in range(len(config)-1))\n        cost_1 += distance_matrix_1[config[-1], config[0]]\n\n        cost_2 = sum(distance_matrix_2[config[i], config[i+1]] for i in range(len(config)-1))\n        cost_2 += distance_matrix_2[config[-1], config[0]]\n\n        # Use a simple weighted sum to compare multi-objective solutions\n        # Here we use equal weights, but could be adjusted\n        weighted_cost = 0.5 * cost_1 + 0.5 * cost_2\n\n        # Update best if this configuration is better\n        if weighted_cost < 0.5 * best_cost_1 + 0.5 * best_cost_2:\n            best_config = config\n            best_cost_1 = cost_1\n            best_cost_2 = cost_2\n\n    new_solution = best_config\n\n    # Then perform an edge exchange (similar to Or-opt)\n    if n > 3:\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i+1)%n or j == (i-1)%n:\n            j = random.randint(0, n-1)\n\n        # Store the original segment\n        original_segment = new_solution[i:j]\n\n        # Create a new solution with the segment moved\n        if i < j:\n            new_solution = np.concatenate((new_solution[:i], new_solution[j:], original_segment))\n        else:\n            new_solution = np.concatenate((new_solution[:j], original_segment, new_solution[i:]))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 179,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # Here, we select the solution with the highest total cost (sum of both objectives)\n    archive_with_costs = [(sol, obj, sum(obj)) for sol, obj in archive]\n    archive_with_costs.sort(key=lambda x: -x[2])  # Sort by total cost in descending order\n    selected_solution = archive_with_costs[0][0].copy()\n\n    # Hybrid local search strategy: combine edge insertion with a novel segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse (novel segment reversal)\n    if n > 3:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 2, min(start + 5, n - 1))  # Keep segment length between 2 and 5\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Perform edge insertion for further improvement\n    if n > 2:\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = random.randint(0, n - 1)\n\n        # Insert node at j after position i\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        insert_pos = (i + 1) % n\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9283808226532074,
            2.662746548652649
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # Here, we select the solution with the highest total cost (sum of both objectives)\n    archive_with_costs = [(sol, obj, sum(obj)) for sol, obj in archive]\n    archive_with_costs.sort(key=lambda x: -x[2])  # Sort by total cost in descending order\n    selected_solution = archive_with_costs[0][0].copy()\n\n    # Hybrid local search strategy: combine edge insertion with a novel segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse (novel segment reversal)\n    if n > 3:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 2, min(start + 5, n - 1))  # Keep segment length between 2 and 5\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Perform edge insertion for further improvement\n    if n > 2:\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = random.randint(0, n - 1)\n\n        # Insert node at j after position i\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        insert_pos = (i + 1) % n\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 180,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with a bias towards lower costs\n    costs = np.array([obj for _, obj in archive])\n    normalized_costs = (costs - costs.min(axis=0)) / (costs.max(axis=0) - costs.min(axis=0) + 1e-8)\n    total_costs = normalized_costs.sum(axis=1)\n    probabilities = 1 / (1 + total_costs)\n    probabilities /= probabilities.sum()\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a custom edge-swapping heuristic\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Randomly select 3 distinct positions\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Step 2: Apply 3-opt move (try all possible combinations)\n    candidates = [\n        new_solution.copy(),\n        np.concatenate([new_solution[:a], new_solution[a:b][::-1], new_solution[b:]]),\n        np.concatenate([new_solution[:a], new_solution[b:c], new_solution[a:b], new_solution[c:]]),\n        np.concatenate([new_solution[:a], new_solution[b:c][::-1], new_solution[a:b], new_solution[c:]]),\n        np.concatenate([new_solution[:a], new_solution[b:c], new_solution[a:b][::-1], new_solution[c:]]),\n        np.concatenate([new_solution[:a], new_solution[b:c][::-1], new_solution[a:b][::-1], new_solution[c:]])\n    ]\n\n    # Evaluate all candidates using both distance matrices\n    def evaluate(sol):\n        total_1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n        total_2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n        return (total_1, total_2)\n\n    best_candidate = min(candidates, key=lambda x: sum(evaluate(x)))\n\n    # Step 3: Apply custom edge-swapping heuristic\n    # Find the worst edge in both objectives\n    current_costs = evaluate(best_candidate)\n    worst_edge = None\n    worst_edge_value = 0\n\n    for i in range(n):\n        edge_cost = (distance_matrix_1[best_candidate[i], best_candidate[(i+1)%n]],\n                     distance_matrix_2[best_candidate[i], best_candidate[(i+1)%n]])\n        edge_score = (edge_cost[0] / current_costs[0] + edge_cost[1] / current_costs[1])\n\n        if edge_score > worst_edge_value:\n            worst_edge_value = edge_score\n            worst_edge = i\n\n    if worst_edge is not None:\n        # Try to replace the worst edge with a better one\n        i = worst_edge\n        j = random.randint(0, n-1)\n        while j == i or j == (i-1)%n or j == (i+1)%n:\n            j = random.randint(0, n-1)\n\n        # Create a new candidate by swapping edges\n        new_candidate = best_candidate.copy()\n        new_candidate[i], new_candidate[j] = new_candidate[j], new_candidate[i]\n\n        # Check if this improves both objectives\n        new_costs = evaluate(new_candidate)\n        if (new_costs[0] < current_costs[0] and new_costs[1] < current_costs[1]):\n            best_candidate = new_candidate\n\n    return best_candidate\n\n",
        "score": [
            -0.7348354923337562,
            4.821815490722656
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with a bias towards lower costs\n    costs = np.array([obj for _, obj in archive])\n    normalized_costs = (costs - costs.min(axis=0)) / (costs.max(axis=0) - costs.min(axis=0) + 1e-8)\n    total_costs = normalized_costs.sum(axis=1)\n    probabilities = 1 / (1 + total_costs)\n    probabilities /= probabilities.sum()\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a custom edge-swapping heuristic\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Randomly select 3 distinct positions\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Step 2: Apply 3-opt move (try all possible combinations)\n    candidates = [\n        new_solution.copy(),\n        np.concatenate([new_solution[:a], new_solution[a:b][::-1], new_solution[b:]]),\n        np.concatenate([new_solution[:a], new_solution[b:c], new_solution[a:b], new_solution[c:]]),\n        np.concatenate([new_solution[:a], new_solution[b:c][::-1], new_solution[a:b], new_solution[c:]]),\n        np.concatenate([new_solution[:a], new_solution[b:c], new_solution[a:b][::-1], new_solution[c:]]),\n        np.concatenate([new_solution[:a], new_solution[b:c][::-1], new_solution[a:b][::-1], new_solution[c:]])\n    ]\n\n    # Evaluate all candidates using both distance matrices\n    def evaluate(sol):\n        total_1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n        total_2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n        return (total_1, total_2)\n\n    best_candidate = min(candidates, key=lambda x: sum(evaluate(x)))\n\n    # Step 3: Apply custom edge-swapping heuristic\n    # Find the worst edge in both objectives\n    current_costs = evaluate(best_candidate)\n    worst_edge = None\n    worst_edge_value = 0\n\n    for i in range(n):\n        edge_cost = (distance_matrix_1[best_candidate[i], best_candidate[(i+1)%n]],\n                     distance_matrix_2[best_candidate[i], best_candidate[(i+1)%n]])\n        edge_score = (edge_cost[0] / current_costs[0] + edge_cost[1] / current_costs[1])\n\n        if edge_score > worst_edge_value:\n            worst_edge_value = edge_score\n            worst_edge = i\n\n    if worst_edge is not None:\n        # Try to replace the worst edge with a better one\n        i = worst_edge\n        j = random.randint(0, n-1)\n        while j == i or j == (i-1)%n or j == (i+1)%n:\n            j = random.randint(0, n-1)\n\n        # Create a new candidate by swapping edges\n        new_candidate = best_candidate.copy()\n        new_candidate[i], new_candidate[j] = new_candidate[j], new_candidate[i]\n\n        # Check if this improves both objectives\n        new_costs = evaluate(new_candidate)\n        if (new_costs[0] < current_costs[0] and new_costs[1] < current_costs[1]):\n            best_candidate = new_candidate\n\n    return best_candidate\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 181,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a base solution with a probability weighted by its potential for improvement\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]  # Inverse of total cost as weight\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: a combination of edge exchange and partial reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operations\n\n    # Step 1: Randomly select a segment to reverse\n    segment_start = random.randint(0, n - 4)\n    segment_end = random.randint(segment_start + 2, min(segment_start + 5, n - 1))  # Limit segment size\n    new_solution[segment_start:segment_end] = new_solution[segment_start:segment_end][::-1]\n\n    # Step 2: Randomly swap two edges to break and reconnect the tour\n    swap_pos1, swap_pos2 = random.sample(range(n), 2)\n    new_solution[swap_pos1], new_solution[swap_pos2] = new_solution[swap_pos2], new_solution[swap_pos1]\n\n    # Step 3: Check if the new solution is feasible (no duplicates, all nodes present)\n    if len(set(new_solution)) != n or not set(new_solution).issubset(set(base_solution)):\n        # If infeasible, revert to the original segment reversal\n        new_solution = base_solution.copy()\n        new_solution[segment_start:segment_end] = new_solution[segment_start:segment_end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9317328930288526,
            2.427910089492798
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a base solution with a probability weighted by its potential for improvement\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]  # Inverse of total cost as weight\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: a combination of edge exchange and partial reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operations\n\n    # Step 1: Randomly select a segment to reverse\n    segment_start = random.randint(0, n - 4)\n    segment_end = random.randint(segment_start + 2, min(segment_start + 5, n - 1))  # Limit segment size\n    new_solution[segment_start:segment_end] = new_solution[segment_start:segment_end][::-1]\n\n    # Step 2: Randomly swap two edges to break and reconnect the tour\n    swap_pos1, swap_pos2 = random.sample(range(n), 2)\n    new_solution[swap_pos1], new_solution[swap_pos2] = new_solution[swap_pos2], new_solution[swap_pos1]\n\n    # Step 3: Check if the new solution is feasible (no duplicates, all nodes present)\n    if len(set(new_solution)) != n or not set(new_solution).issubset(set(base_solution)):\n        # If infeasible, revert to the original segment reversal\n        new_solution = base_solution.copy()\n        new_solution[segment_start:segment_end] = new_solution[segment_start:segment_end][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 182,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a probability inversely proportional to its rank (better solutions more likely)\n    weights = [1.0 / (i + 1) for i in range(len(archive))]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly choose between 3 operators: 2-opt, segment inversion, or swap\n    operator = random.choice(['2opt', 'inversion', 'swap'])\n\n    if operator == '2opt':\n        # 2-opt: Reverse a segment between two random indices\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'inversion':\n        # Segment inversion: Reverse a random segment and shift the rest\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], segment[::-1], new_solution[j:]])\n\n    elif operator == 'swap':\n        # Swap two random segments of equal length\n        segment_length = random.randint(2, max(2, n // 4))\n        a, b = sorted(random.sample(range(n - segment_length + 1), 2))\n        new_solution[a:a+segment_length], new_solution[b:b+segment_length] = (\n            new_solution[b:b+segment_length].copy(), new_solution[a:a+segment_length].copy()\n        )\n\n    # Ensure the solution remains feasible (no duplicate nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8279228284855485,
            1.3186228275299072
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a probability inversely proportional to its rank (better solutions more likely)\n    weights = [1.0 / (i + 1) for i in range(len(archive))]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly choose between 3 operators: 2-opt, segment inversion, or swap\n    operator = random.choice(['2opt', 'inversion', 'swap'])\n\n    if operator == '2opt':\n        # 2-opt: Reverse a segment between two random indices\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'inversion':\n        # Segment inversion: Reverse a random segment and shift the rest\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], segment[::-1], new_solution[j:]])\n\n    elif operator == 'swap':\n        # Swap two random segments of equal length\n        segment_length = random.randint(2, max(2, n // 4))\n        a, b = sorted(random.sample(range(n - segment_length + 1), 2))\n        new_solution[a:a+segment_length], new_solution[b:b+segment_length] = (\n            new_solution[b:b+segment_length].copy(), new_solution[a:a+segment_length].copy()\n        )\n\n    # Ensure the solution remains feasible (no duplicate nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 183,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a bias towards those with higher potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement score (simplified: higher score for solutions with higher total distance)\n    improvement_scores = [sum(obj) for obj in archive_objectives]\n    total_score = sum(improvement_scores)\n    if total_score == 0:\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        probabilities = [score / total_score for score in improvement_scores]\n        selected_idx = np.random.choice(len(archive), p=probabilities)\n\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: edge insertion + biased random walk\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Edge insertion (remove a random edge and reinsert it)\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    # Remove the edge between i and i+1\n    removed_node = new_solution[i + 1]\n    new_solution = np.concatenate([new_solution[:i + 1], new_solution[i + 2:]])\n\n    # Reinsert the removed node at a random position\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, removed_node)\n\n    # Step 2: Biased random walk (small perturbation to escape local optima)\n    if random.random() < 0.3:  # 30% chance to apply perturbation\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n        # Swap two segments to create a different tour structure\n        new_solution = np.concatenate([\n            new_solution[:k],\n            new_solution[l:],\n            new_solution[k:l]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -0.8165980395178163,
            2.225995659828186
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a bias towards those with higher potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement score (simplified: higher score for solutions with higher total distance)\n    improvement_scores = [sum(obj) for obj in archive_objectives]\n    total_score = sum(improvement_scores)\n    if total_score == 0:\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        probabilities = [score / total_score for score in improvement_scores]\n        selected_idx = np.random.choice(len(archive), p=probabilities)\n\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: edge insertion + biased random walk\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Edge insertion (remove a random edge and reinsert it)\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    # Remove the edge between i and i+1\n    removed_node = new_solution[i + 1]\n    new_solution = np.concatenate([new_solution[:i + 1], new_solution[i + 2:]])\n\n    # Reinsert the removed node at a random position\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, removed_node)\n\n    # Step 2: Biased random walk (small perturbation to escape local optima)\n    if random.random() < 0.3:  # 30% chance to apply perturbation\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n        # Swap two segments to create a different tour structure\n        new_solution = np.concatenate([\n            new_solution[:k],\n            new_solution[l:],\n            new_solution[k:l]\n        ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 184,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the most promising solution (non-dominated or least crowded)\n    # Here, we select the solution with the lowest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator (combination of 2-opt and node insertion)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    a, b = sorted(np.random.choice(range(n), size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Reverse the segment (similar to 2-opt but more flexible)\n    if len(segment) > 1:\n        segment = segment[::-1]\n        new_solution[a:b+1] = segment\n\n    # Randomly insert a node elsewhere (node insertion)\n    if n > 2:\n        node_to_move = np.random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.7428716976425584,
            2.4717044830322266
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the most promising solution (non-dominated or least crowded)\n    # Here, we select the solution with the lowest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator (combination of 2-opt and node insertion)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    a, b = sorted(np.random.choice(range(n), size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Reverse the segment (similar to 2-opt but more flexible)\n    if len(segment) > 1:\n        segment = segment[::-1]\n        new_solution[a:b+1] = segment\n\n    # Randomly insert a node elsewhere (node insertion)\n    if n > 2:\n        node_to_move = np.random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 185,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # Here, we select the solution with the highest sum of objectives (worst in both spaces)\n    objectives = [obj for _, obj in archive]\n    worst_idx = np.argmax([sum(obj) for obj in objectives])\n    base_solution = archive[worst_idx][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel segment relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Perform a 3-opt move (select three random segments and rearrange)\n    i, j, k = sorted(np.random.choice(range(1, n), 3, replace=False))\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Rearrange the segments in a random order\n    segments = [segment1, segment2, segment3, segment4]\n    np.random.shuffle(segments)\n    new_solution = np.concatenate(segments)\n\n    # Step 2: Novel segment relocation (move a segment to a different position)\n    seg_start = np.random.randint(1, n - 3)\n    seg_length = np.random.randint(2, min(5, n - seg_start))\n    segment = new_solution[seg_start:seg_start + seg_length]\n\n    # Remove the segment\n    new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_start + seg_length:]])\n\n    # Insert the segment at a new random position\n    insert_pos = np.random.randint(1, len(new_solution) + 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure the solution remains a valid tour\n    if len(new_solution) != len(base_solution) or len(set(new_solution)) != len(base_solution):\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8889905642623281,
            2.8152568340301514
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # Here, we select the solution with the highest sum of objectives (worst in both spaces)\n    objectives = [obj for _, obj in archive]\n    worst_idx = np.argmax([sum(obj) for obj in objectives])\n    base_solution = archive[worst_idx][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel segment relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Perform a 3-opt move (select three random segments and rearrange)\n    i, j, k = sorted(np.random.choice(range(1, n), 3, replace=False))\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Rearrange the segments in a random order\n    segments = [segment1, segment2, segment3, segment4]\n    np.random.shuffle(segments)\n    new_solution = np.concatenate(segments)\n\n    # Step 2: Novel segment relocation (move a segment to a different position)\n    seg_start = np.random.randint(1, n - 3)\n    seg_length = np.random.randint(2, min(5, n - seg_start))\n    segment = new_solution[seg_start:seg_start + seg_length]\n\n    # Remove the segment\n    new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_start + seg_length:]])\n\n    # Insert the segment at a new random position\n    insert_pos = np.random.randint(1, len(new_solution) + 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure the solution remains a valid tour\n    if len(new_solution) != len(base_solution) or len(set(new_solution)) != len(base_solution):\n        return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 186,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal in the archive)\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom move\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform a 3-opt move\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Custom move: swap two segments to explore different neighborhoods\n    if random.random() < 0.5:\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b].copy()\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    # Ensure the solution remains feasible (no duplicate nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple 2-opt if the move is invalid\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7953448714688364,
            2.287703037261963
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal in the archive)\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom move\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform a 3-opt move\n    i, j, k = sorted(random.sample(range(n), 3))\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Custom move: swap two segments to explore different neighborhoods\n    if random.random() < 0.5:\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b].copy()\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    # Ensure the solution remains feasible (no duplicate nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple 2-opt if the move is invalid\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 187,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a probability proportional to its potential improvement\n    # Higher probability for solutions with lower costs (more promising)\n    costs = np.array([obj[0] + obj[1] for _, obj in archive])\n    if np.all(costs == costs[0]):\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        probs = (costs.max() - costs) / (costs.max() - costs.min() + 1e-10)\n        probs /= probs.sum()\n        selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge insertion (for both objectives)\n    for _ in range(2):  # Apply twice for better exploration\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n        # Evaluate insertion in both spaces\n        cost1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        cost2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        cost1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        cost2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept if at least one objective improves\n        if (cost1_after < cost1_before) or (cost2_after < cost2_before):\n            new_solution[i:j] = segment[::-1]  # Reverse the segment\n\n    # Step 2: Novel segment reversal operator (for both objectives)\n    if n > 3:\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        segment = new_solution[i:j]\n        # Evaluate reversal in both spaces\n        cost1_before = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                       distance_matrix_1[new_solution[j-1], new_solution[j]])\n        cost2_before = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                       distance_matrix_2[new_solution[j-1], new_solution[j]])\n        cost1_after = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                      distance_matrix_1[new_solution[i], new_solution[j]])\n        cost2_after = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                      distance_matrix_2[new_solution[i], new_solution[j]])\n\n        # Accept if at least one objective improves\n        if (cost1_after < cost1_before) or (cost2_after < cost2_before):\n            new_solution[i:j] = segment[::-1]  # Reverse the segment\n\n    return new_solution\n\n",
        "score": [
            -0.8667861020964521,
            2.667280852794647
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a probability proportional to its potential improvement\n    # Higher probability for solutions with lower costs (more promising)\n    costs = np.array([obj[0] + obj[1] for _, obj in archive])\n    if np.all(costs == costs[0]):\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        probs = (costs.max() - costs) / (costs.max() - costs.min() + 1e-10)\n        probs /= probs.sum()\n        selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge insertion (for both objectives)\n    for _ in range(2):  # Apply twice for better exploration\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n        # Evaluate insertion in both spaces\n        cost1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        cost2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        cost1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        cost2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept if at least one objective improves\n        if (cost1_after < cost1_before) or (cost2_after < cost2_before):\n            new_solution[i:j] = segment[::-1]  # Reverse the segment\n\n    # Step 2: Novel segment reversal operator (for both objectives)\n    if n > 3:\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        segment = new_solution[i:j]\n        # Evaluate reversal in both spaces\n        cost1_before = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                       distance_matrix_1[new_solution[j-1], new_solution[j]])\n        cost2_before = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                       distance_matrix_2[new_solution[j-1], new_solution[j]])\n        cost1_after = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                      distance_matrix_1[new_solution[i], new_solution[j]])\n        cost2_after = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                      distance_matrix_2[new_solution[i], new_solution[j]])\n\n        # Accept if at least one objective improves\n        if (cost1_after < cost1_before) or (cost2_after < cost2_before):\n            new_solution[i:j] = segment[::-1]  # Reverse the segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 188,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best combined objective (weighted sum)\n    weights = [0.5, 0.5]  # Equal weights for bi-objective\n    selected_idx = np.argmin([weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt: reverse segments between i-j and j-k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Novel operator: reverse a random segment and insert it elsewhere\n    seg_start, seg_end = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[seg_start:seg_end+1].copy()\n    new_solution = np.concatenate([\n        new_solution[:seg_start],\n        new_solution[seg_end+1:],\n        segment[::-1]  # Reverse the segment before insertion\n    ])\n\n    # Ensure the solution remains valid (visits all nodes exactly once)\n    missing_nodes = set(range(n)) - set(new_solution)\n    if missing_nodes:\n        # Reinsert missing nodes at random positions\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7407345627610953,
            3.316503942012787
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best combined objective (weighted sum)\n    weights = [0.5, 0.5]  # Equal weights for bi-objective\n    selected_idx = np.argmin([weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt: reverse segments between i-j and j-k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Novel operator: reverse a random segment and insert it elsewhere\n    seg_start, seg_end = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[seg_start:seg_end+1].copy()\n    new_solution = np.concatenate([\n        new_solution[:seg_start],\n        new_solution[seg_end+1:],\n        segment[::-1]  # Reverse the segment before insertion\n    ])\n\n    # Ensure the solution remains valid (visits all nodes exactly once)\n    missing_nodes = set(range(n)) - set(new_solution)\n    if missing_nodes:\n        # Reinsert missing nodes at random positions\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 189,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]  # Inverse of total cost as weight\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge swap and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between edge swap or segment reversal\n    if random.random() < 0.5:\n        # Edge swap: swap two randomly selected edges\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal: reverse a random segment of the tour\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution (shouldn't happen with proper implementation)\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8423905694420949,
            3.1951971650123596
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]  # Inverse of total cost as weight\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge swap and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between edge swap or segment reversal\n    if random.random() < 0.5:\n        # Edge swap: swap two randomly selected edges\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal: reverse a random segment of the tour\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution (shouldn't happen with proper implementation)\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 190,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with high probability of improvement\n    # Here we use a simple but effective selection: choose a solution with low cost in at least one objective\n    min_cost1 = min(s[1][0] for s in archive)\n    min_cost2 = min(s[1][1] for s in archive)\n    candidates = [s for s in archive if s[1][0] <= min_cost1 * 1.5 or s[1][1] <= min_cost2 * 1.5]\n\n    if not candidates:\n        candidates = archive.copy()\n\n    selected = random.choice(candidates)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n\n    # Hybrid local search strategy\n    # 1. Randomly choose between two operators with different probabilities\n    operator = random.choices(\n        [\"edge_exchange\", \"segment_relocation\", \"segment_inversion\"],\n        weights=[0.4, 0.3, 0.3],\n        k=1\n    )[0]\n\n    if operator == \"edge_exchange\":\n        # Randomly select two edges and swap their positions\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n        # Ensure we don't create sub-tours\n        if abs(i - j) > 1 and abs(k - l) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    elif operator == \"segment_relocation\":\n        # Select a random segment and relocate it to a new position\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(0, n-1)\n\n        # Ensure the segment is not too large and the insertion point is valid\n        if j - i > 1 and k < n - (j - i):\n            segment = new_solution[i:j]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    elif operator == \"segment_inversion\":\n        # Select a random segment and invert its order\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Verify the solution remains valid (no duplicates and all nodes present)\n    if len(set(new_solution)) != n or len(new_solution) != n:\n        # Fallback to a simple swap if the solution is invalid\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8761276331492254,
            2.3779030442237854
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with high probability of improvement\n    # Here we use a simple but effective selection: choose a solution with low cost in at least one objective\n    min_cost1 = min(s[1][0] for s in archive)\n    min_cost2 = min(s[1][1] for s in archive)\n    candidates = [s for s in archive if s[1][0] <= min_cost1 * 1.5 or s[1][1] <= min_cost2 * 1.5]\n\n    if not candidates:\n        candidates = archive.copy()\n\n    selected = random.choice(candidates)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n\n    # Hybrid local search strategy\n    # 1. Randomly choose between two operators with different probabilities\n    operator = random.choices(\n        [\"edge_exchange\", \"segment_relocation\", \"segment_inversion\"],\n        weights=[0.4, 0.3, 0.3],\n        k=1\n    )[0]\n\n    if operator == \"edge_exchange\":\n        # Randomly select two edges and swap their positions\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n        # Ensure we don't create sub-tours\n        if abs(i - j) > 1 and abs(k - l) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    elif operator == \"segment_relocation\":\n        # Select a random segment and relocate it to a new position\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(0, n-1)\n\n        # Ensure the segment is not too large and the insertion point is valid\n        if j - i > 1 and k < n - (j - i):\n            segment = new_solution[i:j]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    elif operator == \"segment_inversion\":\n        # Select a random segment and invert its order\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Verify the solution remains valid (no duplicates and all nodes present)\n    if len(set(new_solution)) != n or len(new_solution) != n:\n        # Fallback to a simple swap if the solution is invalid\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 191,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated solutions)\n    # Here, we randomly select among the top 30% of solutions based on combined objective values\n    sorted_archive = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selection_pool = sorted_archive[:max(1, len(sorted_archive) // 3)]\n    selected_solution = random.choice(selection_pool)[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Edge exchange + Segment relocation\n    for _ in range(2):  # Perform multiple iterations for better exploration\n        # Edge exchange (similar to 2-opt but more flexible)\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Segment relocation (novel operator)\n        segment_length = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        remaining = np.setdiff1d(new_solution, segment)\n        insert_pos = random.randint(0, len(remaining) - segment_length)\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    # Verify all nodes are visited exactly once\n    assert len(np.unique(new_solution)) == n, \"Invalid tour: Nodes not visited exactly once.\"\n\n    return new_solution\n\n",
        "score": [
            -0.8191899294198485,
            2.857531189918518
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated solutions)\n    # Here, we randomly select among the top 30% of solutions based on combined objective values\n    sorted_archive = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selection_pool = sorted_archive[:max(1, len(sorted_archive) // 3)]\n    selected_solution = random.choice(selection_pool)[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Edge exchange + Segment relocation\n    for _ in range(2):  # Perform multiple iterations for better exploration\n        # Edge exchange (similar to 2-opt but more flexible)\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Segment relocation (novel operator)\n        segment_length = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        remaining = np.setdiff1d(new_solution, segment)\n        insert_pos = random.randint(0, len(remaining) - segment_length)\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    # Verify all nodes are visited exactly once\n    assert len(np.unique(new_solution)) == n, \"Invalid tour: Nodes not visited exactly once.\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 192,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., one with good balance between objectives)\n    selected = max(archive, key=lambda x: -(x[1][0] + x[1][1]))  # Simple selection criterion\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Step 1: Edge insertion (move a random segment to a new position)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b]\n    remaining = np.concatenate([new_solution[:a], new_solution[b:]])\n    insert_pos = np.random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Segment reversal (reverse a random segment)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 3: Swap-based perturbation (swap two random edges)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility (no duplicates, all nodes included)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7269678898382899,
            2.5272592902183533
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., one with good balance between objectives)\n    selected = max(archive, key=lambda x: -(x[1][0] + x[1][1]))  # Simple selection criterion\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Step 1: Edge insertion (move a random segment to a new position)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b]\n    remaining = np.concatenate([new_solution[:a], new_solution[b:]])\n    insert_pos = np.random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Segment reversal (reverse a random segment)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 3: Swap-based perturbation (swap two random edges)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility (no duplicates, all nodes included)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 193,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    archive.sort(key=lambda x: min(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Step 1: Adaptive segment selection\n    segment_length = max(2, min(5, n // 10))  # Adaptive segment length\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    segment = new_solution[start:end]\n\n    # Step 2: Hybrid operation - segment relocation with edge insertion\n    # Remove the segment\n    new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n\n    # Find insertion points based on both distance matrices\n    insertion_scores = []\n    for i in range(len(new_solution) - 1):\n        a, b = new_solution[i], new_solution[i+1]\n        # Combined score from both objectives\n        score = 0.5 * (distance_matrix_1[a, segment[0]] + distance_matrix_1[segment[-1], b] - distance_matrix_1[a, b]) + \\\n                0.5 * (distance_matrix_2[a, segment[0]] + distance_matrix_2[segment[-1], b] - distance_matrix_2[a, b])\n        insertion_scores.append(score)\n\n    if not insertion_scores:\n        return new_solution\n\n    # Select best insertion point\n    best_idx = np.argmin(insertion_scores)\n    new_solution = np.insert(new_solution, best_idx + 1, segment)\n\n    # Step 3: Local optimization with adaptive 3-opt\n    if n >= 6:\n        i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n        # Evaluate all possible 3-opt moves\n        options = [\n            new_solution.copy(),\n            np.concatenate([new_solution[:i], new_solution[i:j][::-1], new_solution[j:]]),\n            np.concatenate([new_solution[:j], new_solution[j:k][::-1], new_solution[k:]]),\n            np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j], new_solution[k:]])\n        ]\n        # Evaluate based on both objectives\n        best_option = min(options, key=lambda x: sum([\n            sum(distance_matrix_1[x[i], x[i+1]] for i in range(n-1)) + distance_matrix_1[x[-1], x[0]],\n            sum(distance_matrix_2[x[i], x[i+1]] for i in range(n-1)) + distance_matrix_2[x[-1], x[0]]\n        ]))\n        new_solution = best_option\n\n    return new_solution\n\n",
        "score": [
            -0.3092486275678654,
            5.624061822891235
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    archive.sort(key=lambda x: min(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Step 1: Adaptive segment selection\n    segment_length = max(2, min(5, n // 10))  # Adaptive segment length\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    segment = new_solution[start:end]\n\n    # Step 2: Hybrid operation - segment relocation with edge insertion\n    # Remove the segment\n    new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n\n    # Find insertion points based on both distance matrices\n    insertion_scores = []\n    for i in range(len(new_solution) - 1):\n        a, b = new_solution[i], new_solution[i+1]\n        # Combined score from both objectives\n        score = 0.5 * (distance_matrix_1[a, segment[0]] + distance_matrix_1[segment[-1], b] - distance_matrix_1[a, b]) + \\\n                0.5 * (distance_matrix_2[a, segment[0]] + distance_matrix_2[segment[-1], b] - distance_matrix_2[a, b])\n        insertion_scores.append(score)\n\n    if not insertion_scores:\n        return new_solution\n\n    # Select best insertion point\n    best_idx = np.argmin(insertion_scores)\n    new_solution = np.insert(new_solution, best_idx + 1, segment)\n\n    # Step 3: Local optimization with adaptive 3-opt\n    if n >= 6:\n        i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n        # Evaluate all possible 3-opt moves\n        options = [\n            new_solution.copy(),\n            np.concatenate([new_solution[:i], new_solution[i:j][::-1], new_solution[j:]]),\n            np.concatenate([new_solution[:j], new_solution[j:k][::-1], new_solution[k:]]),\n            np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j], new_solution[k:]])\n        ]\n        # Evaluate based on both objectives\n        best_option = min(options, key=lambda x: sum([\n            sum(distance_matrix_1[x[i], x[i+1]] for i in range(n-1)) + distance_matrix_1[x[-1], x[0]],\n            sum(distance_matrix_2[x[i], x[i+1]] for i in range(n-1)) + distance_matrix_2[x[-1], x[0]]\n        ]))\n        new_solution = best_option\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 194,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values and diversity\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combination of node insertion and edge exchange\n    for _ in range(10):  # Perform multiple iterations\n        # Randomly select two distinct nodes\n        i, j = random.sample(range(n), 2)\n\n        # Node insertion: remove node at i and insert it after j\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = (j + 1) % n\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Edge exchange: swap edges at i and j if it improves both objectives\n        if i != j:\n            a, b = new_solution[i], new_solution[(i+1)%n]\n            c, d = new_solution[j], new_solution[(j+1)%n]\n\n            # Calculate current and potential costs\n            current_cost1 = distance_matrix_1[a, b] + distance_matrix_1[c, d]\n            new_cost1 = distance_matrix_1[a, c] + distance_matrix_1[b, d]\n\n            current_cost2 = distance_matrix_2[a, b] + distance_matrix_2[c, d]\n            new_cost2 = distance_matrix_2[a, c] + distance_matrix_2[b, d]\n\n            # Accept if both objectives improve\n            if new_cost1 < current_cost1 and new_cost2 < current_cost2:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8225865639363537,
            2.7938880920410156
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values and diversity\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combination of node insertion and edge exchange\n    for _ in range(10):  # Perform multiple iterations\n        # Randomly select two distinct nodes\n        i, j = random.sample(range(n), 2)\n\n        # Node insertion: remove node at i and insert it after j\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = (j + 1) % n\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Edge exchange: swap edges at i and j if it improves both objectives\n        if i != j:\n            a, b = new_solution[i], new_solution[(i+1)%n]\n            c, d = new_solution[j], new_solution[(j+1)%n]\n\n            # Calculate current and potential costs\n            current_cost1 = distance_matrix_1[a, b] + distance_matrix_1[c, d]\n            new_cost1 = distance_matrix_1[a, c] + distance_matrix_1[b, d]\n\n            current_cost2 = distance_matrix_2[a, b] + distance_matrix_2[c, d]\n            new_cost2 = distance_matrix_2[a, c] + distance_matrix_2[b, d]\n\n            # Accept if both objectives improve\n            if new_cost1 < current_cost1 and new_cost2 < current_cost2:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 195,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = random.choice(archive)[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge-swap strategy\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select a segment to modify\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 2, min(start + 5, n - 1))\n\n    # Apply 3-opt within the selected segment\n    i, j, k = sorted(random.sample(range(start, end + 1), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Custom edge-swap: swap edges between non-adjacent nodes in the segment\n    if end - start >= 3:\n        a, b = sorted(random.sample(range(start, end + 1), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.unique(new_solution), np.unique(selected_solution)):\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.778289539084599,
            2.0802303552627563
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = random.choice(archive)[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge-swap strategy\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select a segment to modify\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 2, min(start + 5, n - 1))\n\n    # Apply 3-opt within the selected segment\n    i, j, k = sorted(random.sample(range(start, end + 1), 3))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Custom edge-swap: swap edges between non-adjacent nodes in the segment\n    if end - start >= 3:\n        a, b = sorted(random.sample(range(start, end + 1), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.unique(new_solution), np.unique(selected_solution)):\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 196,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (avoid duplicates and ensure exploration)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution, (cost1, cost2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: 3-opt with biased selection\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # No improvement possible\n\n    # Select three distinct edges to modify\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt move (reverse segments with probability based on cost reduction)\n    current_cost = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[k-1], new_solution[k]]\n    new_cost = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[j-1], new_solution[k-1]]\n\n    # Apply move if it improves at least one objective\n    if new_cost < current_cost or np.random.rand() < 0.3:  # 30% chance to accept non-improving move\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additional perturbation: swap two nodes if it improves both objectives\n    a, b = np.random.choice(n, 2, replace=False)\n    current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]]\n    current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]]\n    new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]]\n    new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]]\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.1:  # 10% chance to accept\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.781137488358677,
            2.8563855290412903
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (avoid duplicates and ensure exploration)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution, (cost1, cost2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: 3-opt with biased selection\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # No improvement possible\n\n    # Select three distinct edges to modify\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt move (reverse segments with probability based on cost reduction)\n    current_cost = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[k-1], new_solution[k]]\n    new_cost = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[j-1], new_solution[k-1]]\n\n    # Apply move if it improves at least one objective\n    if new_cost < current_cost or np.random.rand() < 0.3:  # 30% chance to accept non-improving move\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additional perturbation: swap two nodes if it improves both objectives\n    a, b = np.random.choice(n, 2, replace=False)\n    current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]]\n    current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]]\n    new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]]\n    new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]]\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.1:  # 10% chance to accept\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 197,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated solutions)\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if not non_dominated:\n        base_solution = archive[np.random.randint(len(archive))][0].copy()\n    else:\n        base_solution = non_dominated[np.random.randint(len(non_dominated))].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine edge insertion with segment reversal\n    for _ in range(3):  # Number of perturbation steps\n        # Randomly select a segment to reverse\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Randomly select an edge to insert elsewhere\n        k = np.random.randint(n)\n        l = np.random.randint(n)\n        if k != l:\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, l, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8405935799449138,
            2.6917142271995544
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated solutions)\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if not non_dominated:\n        base_solution = archive[np.random.randint(len(archive))][0].copy()\n    else:\n        base_solution = non_dominated[np.random.randint(len(non_dominated))].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine edge insertion with segment reversal\n    for _ in range(3):  # Number of perturbation steps\n        # Randomly select a segment to reverse\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Randomly select an edge to insert elsewhere\n        k = np.random.randint(n)\n        l = np.random.randint(n)\n        if k != l:\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, l, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 198,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated solutions)\n    candidates = [sol for sol, obj in archive if obj[0] > np.mean([o[0] for _, o in archive]) or obj[1] > np.mean([o[1] for _, o in archive])]\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n\n    base_solution = random.choice(candidates).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment inversion strategy\n    n = len(new_solution)\n    if n >= 3:\n        # Randomly select three distinct indices\n        i, j, k = sorted(random.sample(range(n), 3))\n\n        # Apply 3-opt: reverse the segment between i and j, then between j and k\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Novel segment inversion: invert a random segment with a bias towards longer segments\n        segment_length = random.randint(2, min(10, n))\n        start = random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8533718124877004,
            3.1690292954444885
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated solutions)\n    candidates = [sol for sol, obj in archive if obj[0] > np.mean([o[0] for _, o in archive]) or obj[1] > np.mean([o[1] for _, o in archive])]\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n\n    base_solution = random.choice(candidates).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment inversion strategy\n    n = len(new_solution)\n    if n >= 3:\n        # Randomly select three distinct indices\n        i, j, k = sorted(random.sample(range(n), 3))\n\n        # Apply 3-opt: reverse the segment between i and j, then between j and k\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Novel segment inversion: invert a random segment with a bias towards longer segments\n        segment_length = random.randint(2, min(10, n))\n        start = random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 199,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best but not the worst)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(len(sorted_archive) // 2, len(sorted_archive) - 1)\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse the segment between i and j, then between j and k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Novel segment inversion: invert a random segment of the solution\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If duplicates exist, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7847635463881022,
            1.3720281720161438
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best but not the worst)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(len(sorted_archive) // 2, len(sorted_archive) - 1)\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse the segment between i and j, then between j and k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Novel segment inversion: invert a random segment of the solution\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If duplicates exist, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 200,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by non-domination and then by a combined objective score\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        # Select a random solution from the top 30% of the archive\n        selected_idx = random.randint(0, max(0, int(0.3 * len(archive_sorted)) - 1))\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy combining edge insertion and edge reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful local search\n\n    # Randomly select a segment of the tour to modify\n    start = random.randint(0, n - 4)\n    end = random.randint(start + 2, n - 2)\n\n    # Extract the selected segment\n    segment = new_solution[start:end+1]\n\n    # Apply edge reversal to the segment (2-opt variant)\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Apply edge insertion: move a random node from the segment to a new position\n    if len(segment) > 1:\n        node_to_move = random.choice(segment)\n        new_position = random.randint(0, n - 1)\n        # Ensure the node is not placed back in its original segment\n        while new_position >= start and new_position <= end:\n            new_position = random.randint(0, n - 1)\n        # Remove the node from its current position\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        # Insert the node at the new position\n        new_solution = np.insert(new_solution, new_position, node_to_move)\n\n    # Ensure the solution remains valid (no duplicates, all nodes included)\n    assert len(new_solution) == len(base_solution), \"Invalid solution length\"\n    assert len(np.unique(new_solution)) == len(base_solution), \"Duplicate nodes in solution\"\n\n    return new_solution\n\n",
        "score": [
            -0.7114536940114773,
            1.8526340126991272
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by non-domination and then by a combined objective score\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        # Select a random solution from the top 30% of the archive\n        selected_idx = random.randint(0, max(0, int(0.3 * len(archive_sorted)) - 1))\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy combining edge insertion and edge reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful local search\n\n    # Randomly select a segment of the tour to modify\n    start = random.randint(0, n - 4)\n    end = random.randint(start + 2, n - 2)\n\n    # Extract the selected segment\n    segment = new_solution[start:end+1]\n\n    # Apply edge reversal to the segment (2-opt variant)\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Apply edge insertion: move a random node from the segment to a new position\n    if len(segment) > 1:\n        node_to_move = random.choice(segment)\n        new_position = random.randint(0, n - 1)\n        # Ensure the node is not placed back in its original segment\n        while new_position >= start and new_position <= end:\n            new_position = random.randint(0, n - 1)\n        # Remove the node from its current position\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        # Insert the node at the new position\n        new_solution = np.insert(new_solution, new_position, node_to_move)\n\n    # Ensure the solution remains valid (no duplicates, all nodes included)\n    assert len(new_solution) == len(base_solution), \"Invalid solution length\"\n    assert len(np.unique(new_solution)) == len(base_solution), \"Duplicate nodes in solution\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 201,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (randomly weighted by objective values)\n    total_cost = sum(obj[0] + obj[1] for _, obj in archive)\n    probabilities = [((obj[0] + obj[1]) / total_cost) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=probabilities, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct segments\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Apply 3-opt-like operation\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Reconstruct the solution with segments in a new order\n    candidates = [\n        np.concatenate([segment1, segment2, segment3, segment4]),\n        np.concatenate([segment1, segment3, segment2, segment4]),\n        np.concatenate([segment1, segment2[::-1], segment3, segment4]),\n        np.concatenate([segment1, segment3, segment2[::-1], segment4]),\n        np.concatenate([segment1, segment2, segment3[::-1], segment4]),\n        np.concatenate([segment1, segment3[::-1], segment2, segment4])\n    ]\n\n    # Evaluate all candidates based on both objectives\n    def evaluate(solution):\n        cost1 = sum(distance_matrix_1[solution[i-1], solution[i]] for i in range(len(solution)))\n        cost2 = sum(distance_matrix_2[solution[i-1], solution[i]] for i in range(len(solution)))\n        return (cost1, cost2)\n\n    best_solution = min(candidates, key=lambda x: evaluate(x)[0] + evaluate(x)[1])\n\n    # Additional novel operation: segment inversion with neighborhood consideration\n    if random.random() < 0.3:  # 30% chance for this operation\n        inv_start = random.randint(1, n-2)\n        inv_end = random.randint(inv_start+1, n-1)\n        segment = new_solution[inv_start:inv_end]\n\n        # Consider nearest neighbors for inversion\n        left_node = new_solution[inv_start-1]\n        right_node = new_solution[inv_end]\n\n        # Evaluate possible inversions\n        inv_candidates = [\n            np.concatenate([new_solution[:inv_start], segment[::-1], new_solution[inv_end:]]),\n            np.concatenate([new_solution[:inv_start], segment, new_solution[inv_end:]])\n        ]\n\n        # Select the best inversion based on both objectives\n        best_inv = min(inv_candidates, key=lambda x: evaluate(x)[0] + evaluate(x)[1])\n        new_solution = best_inv\n\n    return new_solution\n\n",
        "score": [
            -0.6251391717055739,
            5.612352550029755
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (randomly weighted by objective values)\n    total_cost = sum(obj[0] + obj[1] for _, obj in archive)\n    probabilities = [((obj[0] + obj[1]) / total_cost) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=probabilities, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct segments\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Apply 3-opt-like operation\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Reconstruct the solution with segments in a new order\n    candidates = [\n        np.concatenate([segment1, segment2, segment3, segment4]),\n        np.concatenate([segment1, segment3, segment2, segment4]),\n        np.concatenate([segment1, segment2[::-1], segment3, segment4]),\n        np.concatenate([segment1, segment3, segment2[::-1], segment4]),\n        np.concatenate([segment1, segment2, segment3[::-1], segment4]),\n        np.concatenate([segment1, segment3[::-1], segment2, segment4])\n    ]\n\n    # Evaluate all candidates based on both objectives\n    def evaluate(solution):\n        cost1 = sum(distance_matrix_1[solution[i-1], solution[i]] for i in range(len(solution)))\n        cost2 = sum(distance_matrix_2[solution[i-1], solution[i]] for i in range(len(solution)))\n        return (cost1, cost2)\n\n    best_solution = min(candidates, key=lambda x: evaluate(x)[0] + evaluate(x)[1])\n\n    # Additional novel operation: segment inversion with neighborhood consideration\n    if random.random() < 0.3:  # 30% chance for this operation\n        inv_start = random.randint(1, n-2)\n        inv_end = random.randint(inv_start+1, n-1)\n        segment = new_solution[inv_start:inv_end]\n\n        # Consider nearest neighbors for inversion\n        left_node = new_solution[inv_start-1]\n        right_node = new_solution[inv_end]\n\n        # Evaluate possible inversions\n        inv_candidates = [\n            np.concatenate([new_solution[:inv_start], segment[::-1], new_solution[inv_end:]]),\n            np.concatenate([new_solution[:inv_start], segment, new_solution[inv_end:]])\n        ]\n\n        # Select the best inversion based on both objectives\n        best_inv = min(inv_candidates, key=lambda x: evaluate(x)[0] + evaluate(x)[1])\n        new_solution = best_inv\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 202,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., low cost in at least one objective)\n    archive.sort(key=lambda x: min(x[1]))\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: combination of edge insertion and relocate moves\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b]\n\n    # Try inserting the segment in a different position\n    for _ in range(10):  # Limit the number of attempts\n        new_pos = random.randint(0, n - len(segment))\n        if new_pos >= a and new_pos < b:\n            continue  # Skip if the new position overlaps with the original segment\n\n        # Create a candidate solution\n        candidate = np.concatenate([\n            new_solution[:a],\n            new_solution[b:new_pos],\n            segment,\n            new_solution[new_pos:]\n        ])\n\n        # Ensure it's a valid TSP tour (no duplicates)\n        if len(np.unique(candidate)) == n:\n            # Evaluate the candidate\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n\n            # Accept if it improves at least one objective\n            if cost1 <= sum(distance_matrix_1[selected_solution[i-1], selected_solution[i]] for i in range(n)) or \\\n               cost2 <= sum(distance_matrix_2[selected_solution[i-1], selected_solution[i]] for i in range(n)):\n                new_solution = candidate\n                break\n\n    # If no improvement found, perform a relocate move\n    if new_solution is selected_solution:\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            candidate = new_solution.copy()\n            candidate[i], candidate[j] = candidate[j], candidate[i]\n\n            # Ensure it's a valid tour\n            if len(np.unique(candidate)) == n:\n                new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.40419887070246724,
            1.6886799335479736
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., low cost in at least one objective)\n    archive.sort(key=lambda x: min(x[1]))\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: combination of edge insertion and relocate moves\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b]\n\n    # Try inserting the segment in a different position\n    for _ in range(10):  # Limit the number of attempts\n        new_pos = random.randint(0, n - len(segment))\n        if new_pos >= a and new_pos < b:\n            continue  # Skip if the new position overlaps with the original segment\n\n        # Create a candidate solution\n        candidate = np.concatenate([\n            new_solution[:a],\n            new_solution[b:new_pos],\n            segment,\n            new_solution[new_pos:]\n        ])\n\n        # Ensure it's a valid TSP tour (no duplicates)\n        if len(np.unique(candidate)) == n:\n            # Evaluate the candidate\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n\n            # Accept if it improves at least one objective\n            if cost1 <= sum(distance_matrix_1[selected_solution[i-1], selected_solution[i]] for i in range(n)) or \\\n               cost2 <= sum(distance_matrix_2[selected_solution[i-1], selected_solution[i]] for i in range(n)):\n                new_solution = candidate\n                break\n\n    # If no improvement found, perform a relocate move\n    if new_solution is selected_solution:\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            candidate = new_solution.copy()\n            candidate[i], candidate[j] = candidate[j], candidate[i]\n\n            # Ensure it's a valid tour\n            if len(np.unique(candidate)) == n:\n                new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 203,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., one with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    mean_obj = np.mean(objectives, axis=0)\n    variance = np.mean((objectives - mean_obj) ** 2, axis=1)\n    selected_idx = np.argmax(variance)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of edge swap and segment reversal\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply edge swap\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Apply segment reversal between i and j\n    if j - i > 1:\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to edge swap if segment reversal causes duplicates\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.4035346905585629,
            1.9342783689498901
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., one with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    mean_obj = np.mean(objectives, axis=0)\n    variance = np.mean((objectives - mean_obj) ** 2, axis=1)\n    selected_idx = np.argmax(variance)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of edge swap and segment reversal\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply edge swap\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Apply segment reversal between i and j\n    if j - i > 1:\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to edge swap if segment reversal causes duplicates\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 204,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its objective values\n    objectives = [obj for _, obj in archive]\n    total_costs = [sum(obj) for obj in objectives]\n    weights = [1.0 / (cost + 1e-6) for cost in total_costs]  # Avoid division by zero\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a custom move based on objective dominance\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, try 3-opt for local improvement\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Try all possible 3-opt moves\n        candidates = [\n            new_solution.copy(),\n            np.concatenate([new_solution[:i], new_solution[j:k+1][::-1], new_solution[i:j], new_solution[k+1:]]),\n            np.concatenate([new_solution[:i], new_solution[k:j-1:-1], new_solution[i:j], new_solution[k+1:]])\n        ]\n\n        # Evaluate candidates based on both objectives\n        best_candidate = None\n        best_score = float('inf')\n\n        for candidate in candidates:\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            score = cost1 + cost2  # Combined score for selection\n\n            if score < best_score:\n                best_score = score\n                best_candidate = candidate.copy()\n\n        if best_candidate is not None:\n            new_solution = best_candidate\n\n    # Then apply a custom move based on objective dominance\n    if random.random() < 0.3:  # 30% chance to apply the custom move\n        i, j = sorted(random.sample(range(n), 2))\n        # Swap segments and reverse one of them\n        new_solution = np.concatenate([\n            new_solution[:i],\n            new_solution[j:][::-1],\n            new_solution[i:j]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -0.793155185395588,
            8.62597906589508
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its objective values\n    objectives = [obj for _, obj in archive]\n    total_costs = [sum(obj) for obj in objectives]\n    weights = [1.0 / (cost + 1e-6) for cost in total_costs]  # Avoid division by zero\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a custom move based on objective dominance\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, try 3-opt for local improvement\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Try all possible 3-opt moves\n        candidates = [\n            new_solution.copy(),\n            np.concatenate([new_solution[:i], new_solution[j:k+1][::-1], new_solution[i:j], new_solution[k+1:]]),\n            np.concatenate([new_solution[:i], new_solution[k:j-1:-1], new_solution[i:j], new_solution[k+1:]])\n        ]\n\n        # Evaluate candidates based on both objectives\n        best_candidate = None\n        best_score = float('inf')\n\n        for candidate in candidates:\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            score = cost1 + cost2  # Combined score for selection\n\n            if score < best_score:\n                best_score = score\n                best_candidate = candidate.copy()\n\n        if best_candidate is not None:\n            new_solution = best_candidate\n\n    # Then apply a custom move based on objective dominance\n    if random.random() < 0.3:  # 30% chance to apply the custom move\n        i, j = sorted(random.sample(range(n), 2))\n        # Swap segments and reverse one of them\n        new_solution = np.concatenate([\n            new_solution[:i],\n            new_solution[j:][::-1],\n            new_solution[i:j]\n        ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 205,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the lowest total cost (sum of both objectives) to prioritize high-quality solutions\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: apply a combination of segment inversion and insertion\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Step 1: Randomly select a segment and invert it (novel segment inversion)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 2: Apply a random insertion (edge swap variant) to further perturb the solution\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if c != d:\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.7602302912853482,
            1.9947373270988464
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the lowest total cost (sum of both objectives) to prioritize high-quality solutions\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: apply a combination of segment inversion and insertion\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Step 1: Randomly select a segment and invert it (novel segment inversion)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 2: Apply a random insertion (edge swap variant) to further perturb the solution\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if c != d:\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 206,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not the best but not the worst)\n    if len(archive) > 2:\n        # Exclude the best and worst solutions to encourage exploration\n        candidates = archive[1:-1]\n    else:\n        candidates = archive\n\n    # Select a solution with a high variance in objectives (indicative of trade-off potential)\n    selected_solution = max(candidates, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n\n    # Hybrid local search: combine edge insertion and segment relocation\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Step 1: Edge Insertion (similar to 3-opt but more flexible)\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n    if k > i and k < j:\n        # Insert segment [i+1, j] before k\n        segment = new_solution[i+1:j+1]\n        new_solution = np.concatenate([new_solution[:i+1], segment, new_solution[j+1:k+1], new_solution[k+1:]])\n    else:\n        # Insert node i between k and k+1\n        new_solution = np.concatenate([new_solution[:k+1], [new_solution[i]], new_solution[k+1:i], new_solution[i+1:]])\n\n    # Step 2: Segment Relocation (move a random segment to a new position)\n    a, b = sorted(random.sample(range(n), 2))\n    c = random.randint(0, n-1)\n    segment = new_solution[a:b+1]\n\n    # Remove segment and insert after c\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n    new_solution = np.concatenate([new_solution[:c+1], segment, new_solution[c+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.3823502831883753,
            0.9390740394592285
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not the best but not the worst)\n    if len(archive) > 2:\n        # Exclude the best and worst solutions to encourage exploration\n        candidates = archive[1:-1]\n    else:\n        candidates = archive\n\n    # Select a solution with a high variance in objectives (indicative of trade-off potential)\n    selected_solution = max(candidates, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n\n    # Hybrid local search: combine edge insertion and segment relocation\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Step 1: Edge Insertion (similar to 3-opt but more flexible)\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n    if k > i and k < j:\n        # Insert segment [i+1, j] before k\n        segment = new_solution[i+1:j+1]\n        new_solution = np.concatenate([new_solution[:i+1], segment, new_solution[j+1:k+1], new_solution[k+1:]])\n    else:\n        # Insert node i between k and k+1\n        new_solution = np.concatenate([new_solution[:k+1], [new_solution[i]], new_solution[k+1:i], new_solution[i+1:]])\n\n    # Step 2: Segment Relocation (move a random segment to a new position)\n    a, b = sorted(random.sample(range(n), 2))\n    c = random.randint(0, n-1)\n    segment = new_solution[a:b+1]\n\n    # Remove segment and insert after c\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n    new_solution = np.concatenate([new_solution[:c+1], segment, new_solution[c+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 207,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its dominance\n    # Solutions with lower objective values are more likely to be selected\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    normalized_obj = objectives - min_obj\n    weights = 1 / (1 + normalized_obj.sum(axis=1))\n    weights = weights / weights.sum()  # Normalize to probabilities\n\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy\n    n_nodes = len(new_solution)\n    if n_nodes < 3:\n        return new_solution  # No improvement possible\n\n    # Step 1: Randomly select a segment and reverse it (similar to 2-opt but more flexible)\n    a, b = sorted(random.sample(range(n_nodes), 2))\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Step 2: Randomly insert a node elsewhere in the tour\n    if n_nodes > 3:\n        node_idx = random.randint(0, n_nodes-1)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = random.randint(0, n_nodes-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 3: Randomly swap two non-adjacent edges\n    if n_nodes > 4:\n        i, j = sorted(random.sample(range(1, n_nodes-1), 2))\n        if i != j and abs(i - j) > 1:  # Ensure non-adjacent\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.0231420027530083,
            1.9127042293548584
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its dominance\n    # Solutions with lower objective values are more likely to be selected\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    normalized_obj = objectives - min_obj\n    weights = 1 / (1 + normalized_obj.sum(axis=1))\n    weights = weights / weights.sum()  # Normalize to probabilities\n\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy\n    n_nodes = len(new_solution)\n    if n_nodes < 3:\n        return new_solution  # No improvement possible\n\n    # Step 1: Randomly select a segment and reverse it (similar to 2-opt but more flexible)\n    a, b = sorted(random.sample(range(n_nodes), 2))\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Step 2: Randomly insert a node elsewhere in the tour\n    if n_nodes > 3:\n        node_idx = random.randint(0, n_nodes-1)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = random.randint(0, n_nodes-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 3: Randomly swap two non-adjacent edges\n    if n_nodes > 4:\n        i, j = sorted(random.sample(range(1, n_nodes-1), 2))\n        if i != j and abs(i - j) > 1:  # Ensure non-adjacent\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 207,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its dominance\n    # Solutions with lower objective values are more likely to be selected\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    normalized_obj = objectives - min_obj\n    weights = 1 / (1 + normalized_obj.sum(axis=1))\n    weights = weights / weights.sum()  # Normalize to probabilities\n\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy\n    n_nodes = len(new_solution)\n    if n_nodes < 3:\n        return new_solution  # No improvement possible\n\n    # Step 1: Randomly select a segment and reverse it (similar to 2-opt but more flexible)\n    a, b = sorted(random.sample(range(n_nodes), 2))\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Step 2: Randomly insert a node elsewhere in the tour\n    if n_nodes > 3:\n        node_idx = random.randint(0, n_nodes-1)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = random.randint(0, n_nodes-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 3: Randomly swap two non-adjacent edges\n    if n_nodes > 4:\n        i, j = sorted(random.sample(range(1, n_nodes-1), 2))\n        if i != j and abs(i - j) > 1:  # Ensure non-adjacent\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.0231420027530083,
            1.9127042293548584
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its dominance\n    # Solutions with lower objective values are more likely to be selected\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    normalized_obj = objectives - min_obj\n    weights = 1 / (1 + normalized_obj.sum(axis=1))\n    weights = weights / weights.sum()  # Normalize to probabilities\n\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy\n    n_nodes = len(new_solution)\n    if n_nodes < 3:\n        return new_solution  # No improvement possible\n\n    # Step 1: Randomly select a segment and reverse it (similar to 2-opt but more flexible)\n    a, b = sorted(random.sample(range(n_nodes), 2))\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Step 2: Randomly insert a node elsewhere in the tour\n    if n_nodes > 3:\n        node_idx = random.randint(0, n_nodes-1)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = random.randint(0, n_nodes-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 3: Randomly swap two non-adjacent edges\n    if n_nodes > 4:\n        i, j = sorted(random.sample(range(1, n_nodes-1), 2))\n        if i != j and abs(i - j) > 1:  # Ensure non-adjacent\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 208,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high potential for improvement (e.g., non-dominated or with high variance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Hybrid local search strategy: combine 2-opt with a novel edge insertion heuristic\n    new_solution = base_solution.copy()\n\n    # Perform 2-opt with a random segment\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Novel edge insertion heuristic: insert a randomly selected edge from another solution\n    if len(archive) > 1:\n        other_solution = archive[(selected_idx + 1) % len(archive)][0]\n        i, j = random.sample(range(n), 2)\n        edge = other_solution[i:j+1]\n\n        # Find a position to insert the edge without breaking the tour\n        insert_pos = random.randint(0, n - len(edge))\n        new_solution = np.concatenate([new_solution[:insert_pos], edge, new_solution[insert_pos + len(edge):]])\n\n        # Ensure no duplicates and all nodes are visited\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            # If duplicates exist, repair by filling missing nodes\n            missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n            for node in missing_nodes:\n                insert_pos = random.randint(0, n - 1)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution is a valid tour (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Invalid tour: duplicate nodes or missing nodes\"\n\n    return new_solution\n\n",
        "score": [
            -0.771154306374127,
            0.9471796154975891
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high potential for improvement (e.g., non-dominated or with high variance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Hybrid local search strategy: combine 2-opt with a novel edge insertion heuristic\n    new_solution = base_solution.copy()\n\n    # Perform 2-opt with a random segment\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Novel edge insertion heuristic: insert a randomly selected edge from another solution\n    if len(archive) > 1:\n        other_solution = archive[(selected_idx + 1) % len(archive)][0]\n        i, j = random.sample(range(n), 2)\n        edge = other_solution[i:j+1]\n\n        # Find a position to insert the edge without breaking the tour\n        insert_pos = random.randint(0, n - len(edge))\n        new_solution = np.concatenate([new_solution[:insert_pos], edge, new_solution[insert_pos + len(edge):]])\n\n        # Ensure no duplicates and all nodes are visited\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            # If duplicates exist, repair by filling missing nodes\n            missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n            for node in missing_nodes:\n                insert_pos = random.randint(0, n - 1)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution is a valid tour (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Invalid tour: duplicate nodes or missing nodes\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 209,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps with segment reversal\n    n = len(base_solution)\n    if n < 3:\n        return new_solution  # No improvement possible\n\n    # Randomly choose between edge swap or segment reversal\n    if random.random() < 0.5:\n        # Edge swap (2-opt with objective-aware selection)\n        i, j = sorted(random.sample(range(n), 2))\n        if i == 0 and j == n - 1:\n            pass  # Avoid invalid swaps\n        else:\n            # Evaluate the swap in both objectives\n            old_cost1 = distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]]\n            new_cost1 = distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]\n            old_cost2 = distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]]\n            new_cost2 = distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]\n\n            # Only accept if at least one objective improves\n            if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n                new_solution[i:j+1] = base_solution[i:j+1][::-1]\n    else:\n        # Segment reversal with objective-aware selection\n        a, b, c = sorted(random.sample(range(n), 3))\n        if a == 0 and c == n - 1:\n            pass  # Avoid invalid reversals\n        else:\n            # Evaluate the reversal in both objectives\n            old_cost1 = (distance_matrix_1[base_solution[a-1], base_solution[a]] +\n                         distance_matrix_1[base_solution[b], base_solution[b+1]] +\n                         distance_matrix_1[base_solution[c], base_solution[(c+1)%n]])\n            new_cost1 = (distance_matrix_1[base_solution[a-1], base_solution[b]] +\n                         distance_matrix_1[base_solution[a], base_solution[b+1]] +\n                         distance_matrix_1[base_solution[c], base_solution[a]])\n            old_cost2 = (distance_matrix_2[base_solution[a-1], base_solution[a]] +\n                         distance_matrix_2[base_solution[b], base_solution[b+1]] +\n                         distance_matrix_2[base_solution[c], base_solution[(c+1)%n]])\n            new_cost2 = (distance_matrix_2[base_solution[a-1], base_solution[b]] +\n                         distance_matrix_2[base_solution[a], base_solution[b+1]] +\n                         distance_matrix_2[base_solution[c], base_solution[a]])\n\n            # Only accept if at least one objective improves\n            if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n                new_solution[a:b+1] = base_solution[a:b+1][::-1]\n                new_solution[b+1:c+1] = base_solution[b+1:c+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8137112543766203,
            2.6519328355789185
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps with segment reversal\n    n = len(base_solution)\n    if n < 3:\n        return new_solution  # No improvement possible\n\n    # Randomly choose between edge swap or segment reversal\n    if random.random() < 0.5:\n        # Edge swap (2-opt with objective-aware selection)\n        i, j = sorted(random.sample(range(n), 2))\n        if i == 0 and j == n - 1:\n            pass  # Avoid invalid swaps\n        else:\n            # Evaluate the swap in both objectives\n            old_cost1 = distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]]\n            new_cost1 = distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]\n            old_cost2 = distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]]\n            new_cost2 = distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]\n\n            # Only accept if at least one objective improves\n            if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n                new_solution[i:j+1] = base_solution[i:j+1][::-1]\n    else:\n        # Segment reversal with objective-aware selection\n        a, b, c = sorted(random.sample(range(n), 3))\n        if a == 0 and c == n - 1:\n            pass  # Avoid invalid reversals\n        else:\n            # Evaluate the reversal in both objectives\n            old_cost1 = (distance_matrix_1[base_solution[a-1], base_solution[a]] +\n                         distance_matrix_1[base_solution[b], base_solution[b+1]] +\n                         distance_matrix_1[base_solution[c], base_solution[(c+1)%n]])\n            new_cost1 = (distance_matrix_1[base_solution[a-1], base_solution[b]] +\n                         distance_matrix_1[base_solution[a], base_solution[b+1]] +\n                         distance_matrix_1[base_solution[c], base_solution[a]])\n            old_cost2 = (distance_matrix_2[base_solution[a-1], base_solution[a]] +\n                         distance_matrix_2[base_solution[b], base_solution[b+1]] +\n                         distance_matrix_2[base_solution[c], base_solution[(c+1)%n]])\n            new_cost2 = (distance_matrix_2[base_solution[a-1], base_solution[b]] +\n                         distance_matrix_2[base_solution[a], base_solution[b+1]] +\n                         distance_matrix_2[base_solution[c], base_solution[a]])\n\n            # Only accept if at least one objective improves\n            if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n                new_solution[a:b+1] = base_solution[a:b+1][::-1]\n                new_solution[b+1:c+1] = base_solution[b+1:c+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 210,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high cost)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: Edge Insertion + Segment Relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge Insertion (randomly select two edges and swap their positions)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Segment Relocation (move a random segment to another position)\n    seg_start, seg_end = np.random.choice(n, 2, replace=False)\n    if seg_start > seg_end:\n        seg_start, seg_end = seg_end, seg_start\n    segment = new_solution[seg_start:seg_end]\n    new_solution = np.concatenate([\n        new_solution[:seg_start],\n        new_solution[seg_end:],\n        segment\n    ])\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Fallback: Revert to base solution if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7924247893925503,
            2.6764110922813416
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high cost)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: Edge Insertion + Segment Relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge Insertion (randomly select two edges and swap their positions)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Segment Relocation (move a random segment to another position)\n    seg_start, seg_end = np.random.choice(n, 2, replace=False)\n    if seg_start > seg_end:\n        seg_start, seg_end = seg_end, seg_start\n    segment = new_solution[seg_start:seg_end]\n    new_solution = np.concatenate([\n        new_solution[:seg_start],\n        new_solution[seg_end:],\n        segment\n    ])\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Fallback: Revert to base solution if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 211,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    non_dominated = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (other_sol, other_obj) in enumerate(archive):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_sol = archive[0][0].copy()\n    else:\n        selected_sol = random.choice(non_dominated)[0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge-swap strategy\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move to improve the tour\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, apply a novel edge-swap strategy to diversify the search\n    # Select two random edges and swap their endpoints if it improves both objectives\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n    current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n    new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n    new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n       (random.random() < 0.3):  # Sometimes accept worse moves for diversification\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Additional perturbation: reverse a random segment if it improves both objectives\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j+1]\n    reversed_segment = segment[::-1]\n\n    # Calculate costs before and after reversal\n    before_cost1 = distance_matrix_1[new_solution[i-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[j+1]] if i > 0 and j < n-1 else 0\n    after_cost1 = distance_matrix_1[new_solution[i-1], reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], new_solution[j+1]] if i > 0 and j < n-1 else 0\n\n    before_cost2 = distance_matrix_2[new_solution[i-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[j+1]] if i > 0 and j < n-1 else 0\n    after_cost2 = distance_matrix_2[new_solution[i-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], new_solution[j+1]] if i > 0 and j < n-1 else 0\n\n    if (after_cost1 < before_cost1 and after_cost2 < before_cost2) or \\\n       (random.random() < 0.2):  # Sometimes accept worse reversals\n        new_solution[i:j+1] = reversed_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8837957927393469,
            2.277868926525116
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    non_dominated = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (other_sol, other_obj) in enumerate(archive):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_sol = archive[0][0].copy()\n    else:\n        selected_sol = random.choice(non_dominated)[0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge-swap strategy\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move to improve the tour\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, apply a novel edge-swap strategy to diversify the search\n    # Select two random edges and swap their endpoints if it improves both objectives\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n    current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n    new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n    new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n       (random.random() < 0.3):  # Sometimes accept worse moves for diversification\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Additional perturbation: reverse a random segment if it improves both objectives\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j+1]\n    reversed_segment = segment[::-1]\n\n    # Calculate costs before and after reversal\n    before_cost1 = distance_matrix_1[new_solution[i-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[j+1]] if i > 0 and j < n-1 else 0\n    after_cost1 = distance_matrix_1[new_solution[i-1], reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], new_solution[j+1]] if i > 0 and j < n-1 else 0\n\n    before_cost2 = distance_matrix_2[new_solution[i-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[j+1]] if i > 0 and j < n-1 else 0\n    after_cost2 = distance_matrix_2[new_solution[i-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], new_solution[j+1]] if i > 0 and j < n-1 else 0\n\n    if (after_cost1 < before_cost1 and after_cost2 < before_cost2) or \\\n       (random.random() < 0.2):  # Sometimes accept worse reversals\n        new_solution[i:j+1] = reversed_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 212,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its \"promise\" (inverse of objective values)\n    objectives = np.array([obj for (sol, obj) in archive])\n    inverse_objectives = 1.0 / (objectives + 1e-6)  # Avoid division by zero\n    weights = inverse_objectives.sum(axis=1)\n    weights = weights / weights.sum()  # Normalize to probabilities\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel \"objective-biased\" move\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct nodes to perform a 3-opt move\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move: reverse the segment between i and j, then between j and k\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n    new_solution[j:k+1] = np.flip(new_solution[j:k+1])\n\n    # Novel objective-biased move: with 50% probability, swap two nodes based on their distance in one of the objectives\n    if random.random() < 0.5:\n        # Choose the objective space with higher variance (more diverse distances)\n        obj1_variance = np.var(distance_matrix_1[np.triu_indices(n, k=1)])\n        obj2_variance = np.var(distance_matrix_2[np.triu_indices(n, k=1)])\n        selected_matrix = distance_matrix_1 if obj1_variance > obj2_variance else distance_matrix_2\n\n        # Find the pair of nodes with the highest distance in the selected objective space\n        max_dist = -1\n        a, b = 0, 0\n        for x in range(n):\n            for y in range(x+1, n):\n                dist = selected_matrix[new_solution[x], new_solution[y]]\n                if dist > max_dist:\n                    max_dist = dist\n                    a, b = x, y\n\n        # Swap these nodes if they are not adjacent (to maintain feasibility)\n        if abs(a - b) > 1:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.911434744474977,
            3.5101124048233032
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its \"promise\" (inverse of objective values)\n    objectives = np.array([obj for (sol, obj) in archive])\n    inverse_objectives = 1.0 / (objectives + 1e-6)  # Avoid division by zero\n    weights = inverse_objectives.sum(axis=1)\n    weights = weights / weights.sum()  # Normalize to probabilities\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel \"objective-biased\" move\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct nodes to perform a 3-opt move\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move: reverse the segment between i and j, then between j and k\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n    new_solution[j:k+1] = np.flip(new_solution[j:k+1])\n\n    # Novel objective-biased move: with 50% probability, swap two nodes based on their distance in one of the objectives\n    if random.random() < 0.5:\n        # Choose the objective space with higher variance (more diverse distances)\n        obj1_variance = np.var(distance_matrix_1[np.triu_indices(n, k=1)])\n        obj2_variance = np.var(distance_matrix_2[np.triu_indices(n, k=1)])\n        selected_matrix = distance_matrix_1 if obj1_variance > obj2_variance else distance_matrix_2\n\n        # Find the pair of nodes with the highest distance in the selected objective space\n        max_dist = -1\n        a, b = 0, 0\n        for x in range(n):\n            for y in range(x+1, n):\n                dist = selected_matrix[new_solution[x], new_solution[y]]\n                if dist > max_dist:\n                    max_dist = dist\n                    a, b = x, y\n\n        # Swap these nodes if they are not adjacent (to maintain feasibility)\n        if abs(a - b) > 1:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 213,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    candidates = []\n    for sol, (cost1, cost2) in archive:\n        # Prioritize solutions with high potential (e.g., not too close to the Pareto front)\n        candidates.append((sol, cost1 + cost2))\n\n    # Select top 30% of candidates (or all if archive is small)\n    num_candidates = max(1, len(candidates) // 3)\n    candidates.sort(key=lambda x: x[1])\n    selected = random.choice(candidates[:num_candidates])[0]\n\n    new_solution = selected.copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel segment inversion\n    n = len(new_solution)\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n\n    if i > j:\n        i, j = j, i\n\n    # Apply 2-opt between i and j\n    if j - i > 1:\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Novel segment inversion: invert a segment with a probability\n    if random.random() < 0.3:\n        k = random.randint(0, n - 1)\n        l = random.randint(0, n - 1)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if not np.array_equal(np.unique(new_solution), np.arange(len(new_solution))):\n        # Fallback to a simple swap if inversion causes duplicates\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7786374547227347,
            2.39524644613266
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    candidates = []\n    for sol, (cost1, cost2) in archive:\n        # Prioritize solutions with high potential (e.g., not too close to the Pareto front)\n        candidates.append((sol, cost1 + cost2))\n\n    # Select top 30% of candidates (or all if archive is small)\n    num_candidates = max(1, len(candidates) // 3)\n    candidates.sort(key=lambda x: x[1])\n    selected = random.choice(candidates[:num_candidates])[0]\n\n    new_solution = selected.copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel segment inversion\n    n = len(new_solution)\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n\n    if i > j:\n        i, j = j, i\n\n    # Apply 2-opt between i and j\n    if j - i > 1:\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Novel segment inversion: invert a segment with a probability\n    if random.random() < 0.3:\n        k = random.randint(0, n - 1)\n        l = random.randint(0, n - 1)\n        if k > l:\n            k, l = l, k\n        if l - k > 1:\n            new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if not np.array_equal(np.unique(new_solution), np.arange(len(new_solution))):\n        # Fallback to a simple swap if inversion causes duplicates\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 214,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective values)\n    total_costs = [obj[0] + obj[1] for _, obj in archive]\n    if sum(total_costs) == 0:\n        weights = [1.0 / len(archive)] * len(archive)\n    else:\n        weights = [cost / sum(total_costs) for cost in total_costs]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: edge insertion + segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse (3-opt like operation)\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]  # Reverse the segment\n\n    # Randomly insert an edge (edge insertion)\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        if i != j:\n            # Remove edge (i, i+1) and insert between (j, j+1)\n            edge = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            insert_pos = (j + 1) % (n-1)\n            new_solution = np.concatenate([new_solution[:insert_pos], [edge], new_solution[insert_pos:]])\n\n    # Ensure the solution remains valid (no duplicates, all nodes present)\n    if len(set(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7830970919585372,
            2.489450216293335
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective values)\n    total_costs = [obj[0] + obj[1] for _, obj in archive]\n    if sum(total_costs) == 0:\n        weights = [1.0 / len(archive)] * len(archive)\n    else:\n        weights = [cost / sum(total_costs) for cost in total_costs]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: edge insertion + segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse (3-opt like operation)\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]  # Reverse the segment\n\n    # Randomly insert an edge (edge insertion)\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        if i != j:\n            # Remove edge (i, i+1) and insert between (j, j+1)\n            edge = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            insert_pos = (j + 1) % (n-1)\n            new_solution = np.concatenate([new_solution[:insert_pos], [edge], new_solution[insert_pos:]])\n\n    # Ensure the solution remains valid (no duplicates, all nodes present)\n    if len(set(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 215,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by a combination of objective values and diversity\n        archive.sort(key=lambda x: (x[1][0] + x[1][1], random.random()))  # Secondary randomness for tie-breaking\n        selected_solution = archive[0][0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: Edge Insertion + Node Reinsertion\n    if n > 3:\n        # Edge Insertion: Remove two edges and reconnect with a new path\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n        # Ensure the segments are not overlapping or adjacent\n        while abs(i - j) < 2 or abs(k - l) < 2 or (i <= k <= j) or (k <= i <= l):\n            i, j = sorted(random.sample(range(n), 2))\n            k, l = sorted(random.sample(range(n), 2))\n\n        # Extract segments and reinsert\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[k:l+1]\n        new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j+1:k], segment1, new_solution[l+1:]])\n\n        # Ensure the solution remains valid (no duplicates)\n        if len(np.unique(new_solution)) != n:\n            # Fallback to node reinsertion if edge insertion fails\n            idx = random.randint(0, n-1)\n            node = new_solution[idx]\n            new_solution = np.delete(new_solution, idx)\n            pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6477846386404981,
            1.3536822199821472
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by a combination of objective values and diversity\n        archive.sort(key=lambda x: (x[1][0] + x[1][1], random.random()))  # Secondary randomness for tie-breaking\n        selected_solution = archive[0][0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: Edge Insertion + Node Reinsertion\n    if n > 3:\n        # Edge Insertion: Remove two edges and reconnect with a new path\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n        # Ensure the segments are not overlapping or adjacent\n        while abs(i - j) < 2 or abs(k - l) < 2 or (i <= k <= j) or (k <= i <= l):\n            i, j = sorted(random.sample(range(n), 2))\n            k, l = sorted(random.sample(range(n), 2))\n\n        # Extract segments and reinsert\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[k:l+1]\n        new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j+1:k], segment1, new_solution[l+1:]])\n\n        # Ensure the solution remains valid (no duplicates)\n        if len(np.unique(new_solution)) != n:\n            # Fallback to node reinsertion if edge insertion fails\n            idx = random.randint(0, n-1)\n            node = new_solution[idx]\n            new_solution = np.delete(new_solution, idx)\n            pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 216,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their dominance (simplified: higher cost implies more potential)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select a solution from the top 30% with highest cost\n        selected_idx = random.randint(0, max(1, len(sorted_archive) // 3 - 1))\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment relocation with edge insertion\n    if n > 3:\n        # Step 1: Select a random segment of 3 consecutive nodes\n        segment_start = random.randint(0, n - 4)\n        segment = new_solution[segment_start:segment_start + 3]\n\n        # Step 2: Remove the segment from the solution\n        new_solution = np.concatenate([new_solution[:segment_start], new_solution[segment_start + 3:]])\n\n        # Step 3: Find the best insertion point for the segment\n        best_insert_cost = float('inf')\n        best_insert_pos = 0\n\n        for i in range(len(new_solution)):\n            # Insert segment between i and i+1\n            candidate = np.insert(new_solution, i, segment)\n\n            # Calculate the cost change in both objectives\n            cost1 = sum(distance_matrix_1[candidate[j], candidate[j+1]] for j in range(n - 1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[j], candidate[j+1]] for j in range(n - 1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            total_cost = cost1 + cost2\n\n            if total_cost < best_insert_cost:\n                best_insert_cost = total_cost\n                best_insert_pos = i\n\n        # Insert the segment at the best position\n        new_solution = np.insert(new_solution, best_insert_pos, segment)\n\n        # Step 4: Edge insertion for further improvement\n        for _ in range(2):  # Perform 2 edge insertions\n            i = random.randint(0, n - 2)\n            j = random.randint(0, n - 1)\n            if i != j and abs(i - j) > 1:\n                # Remove edge (i, i+1) and insert it between j and j+1\n                edge = new_solution[i]\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n                new_solution = np.insert(new_solution, j, edge)\n\n    return new_solution\n\n",
        "score": [
            -0.5791957229824348,
            13.986936926841736
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their dominance (simplified: higher cost implies more potential)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select a solution from the top 30% with highest cost\n        selected_idx = random.randint(0, max(1, len(sorted_archive) // 3 - 1))\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment relocation with edge insertion\n    if n > 3:\n        # Step 1: Select a random segment of 3 consecutive nodes\n        segment_start = random.randint(0, n - 4)\n        segment = new_solution[segment_start:segment_start + 3]\n\n        # Step 2: Remove the segment from the solution\n        new_solution = np.concatenate([new_solution[:segment_start], new_solution[segment_start + 3:]])\n\n        # Step 3: Find the best insertion point for the segment\n        best_insert_cost = float('inf')\n        best_insert_pos = 0\n\n        for i in range(len(new_solution)):\n            # Insert segment between i and i+1\n            candidate = np.insert(new_solution, i, segment)\n\n            # Calculate the cost change in both objectives\n            cost1 = sum(distance_matrix_1[candidate[j], candidate[j+1]] for j in range(n - 1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[j], candidate[j+1]] for j in range(n - 1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            total_cost = cost1 + cost2\n\n            if total_cost < best_insert_cost:\n                best_insert_cost = total_cost\n                best_insert_pos = i\n\n        # Insert the segment at the best position\n        new_solution = np.insert(new_solution, best_insert_pos, segment)\n\n        # Step 4: Edge insertion for further improvement\n        for _ in range(2):  # Perform 2 edge insertions\n            i = random.randint(0, n - 2)\n            j = random.randint(0, n - 1)\n            if i != j and abs(i - j) > 1:\n                # Remove edge (i, i+1) and insert it between j and j+1\n                edge = new_solution[i]\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n                new_solution = np.insert(new_solution, j, edge)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 217,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    weights = 1 / (normalized_objectives.sum(axis=1) + 1e-10)\n    weights = weights / weights.sum()  # Normalize weights\n\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel segment-based move\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # First, perform a 3-opt move\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:]\n\n    # Reconstruct the solution with the segments reversed or rotated\n    if random.random() < 0.5:\n        new_solution = np.concatenate([new_solution[:i], segment1[::-1], segment2[::-1], segment3])\n    else:\n        new_solution = np.concatenate([new_solution[:i], segment2, segment1, segment3])\n\n    # Then apply a novel segment-based move: reverse a random segment and insert it elsewhere\n    if n >= 4:\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n        remaining = np.concatenate([new_solution[:a], new_solution[b:]])\n        insert_pos = random.randint(0, len(remaining))\n        new_solution = np.concatenate([remaining[:insert_pos], segment[::-1], remaining[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8411982639575466,
            2.7536540627479553
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    weights = 1 / (normalized_objectives.sum(axis=1) + 1e-10)\n    weights = weights / weights.sum()  # Normalize weights\n\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel segment-based move\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # First, perform a 3-opt move\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:]\n\n    # Reconstruct the solution with the segments reversed or rotated\n    if random.random() < 0.5:\n        new_solution = np.concatenate([new_solution[:i], segment1[::-1], segment2[::-1], segment3])\n    else:\n        new_solution = np.concatenate([new_solution[:i], segment2, segment1, segment3])\n\n    # Then apply a novel segment-based move: reverse a random segment and insert it elsewhere\n    if n >= 4:\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n        remaining = np.concatenate([new_solution[:a], new_solution[b:]])\n        insert_pos = random.randint(0, len(remaining))\n        new_solution = np.concatenate([remaining[:insert_pos], segment[::-1], remaining[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 218,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-frontier solutions or those with high diversity)\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: combine edge swapping and segment reversal\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    k, l = sorted(np.random.choice(n, size=2, replace=False))\n\n    # Edge swapping: swap edges (i, i+1) and (j, j+1)\n    if i < j - 1:\n        new_solution[i+1:j] = np.flip(new_solution[i+1:j])\n\n    # Segment reversal: reverse a segment between k and l\n    if k < l - 1:\n        new_solution[k+1:l] = np.flip(new_solution[k+1:l])\n\n    # Ensure feasibility by checking for duplicates (though the above operations should already ensure it)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if the above operations cause duplicates\n        a, b = np.random.choice(n, size=2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8888371904639896,
            1.961877465248108
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-frontier solutions or those with high diversity)\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: combine edge swapping and segment reversal\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    k, l = sorted(np.random.choice(n, size=2, replace=False))\n\n    # Edge swapping: swap edges (i, i+1) and (j, j+1)\n    if i < j - 1:\n        new_solution[i+1:j] = np.flip(new_solution[i+1:j])\n\n    # Segment reversal: reverse a segment between k and l\n    if k < l - 1:\n        new_solution[k+1:l] = np.flip(new_solution[k+1:l])\n\n    # Ensure feasibility by checking for duplicates (though the above operations should already ensure it)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if the above operations cause duplicates\n        a, b = np.random.choice(n, size=2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 219,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on a weighted sum of objectives (can be adjusted)\n    weighted_scores = [0.5 * obj[0] + 0.5 * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct edges to modify\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Apply 3-opt: reverse the middle segment\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Novel edge swap: swap two non-adjacent edges if it improves both objectives\n    # Find two edges that can be swapped without creating duplicates\n    a, b = random.sample(range(1, n-1), 2)\n    if a > b:\n        a, b = b, a\n\n    # Check if swapping edges a and b improves both objectives\n    current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n    current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n    new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n    new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n    if new_cost1 < current_cost1 and new_cost2 < current_cost2:\n        # Perform the swap\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7669157810766818,
            2.0103769302368164
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on a weighted sum of objectives (can be adjusted)\n    weighted_scores = [0.5 * obj[0] + 0.5 * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct edges to modify\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Apply 3-opt: reverse the middle segment\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Novel edge swap: swap two non-adjacent edges if it improves both objectives\n    # Find two edges that can be swapped without creating duplicates\n    a, b = random.sample(range(1, n-1), 2)\n    if a > b:\n        a, b = b, a\n\n    # Check if swapping edges a and b improves both objectives\n    current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n    current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n    new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n    new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n    if new_cost1 < current_cost1 and new_cost2 < current_cost2:\n        # Perform the swap\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 220,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (lexicographic order)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Apply hybrid local search: edge exchange with path relocation\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two non-adjacent edges to exchange (similar to 2-opt but more flexible)\n    i, j = sorted(random.sample(range(1, n), 2))\n    if i == j:\n        j = (j + 1) % n\n\n    # Exchange the edges (i-1, i) and (j, j+1) with (i-1, j) and (i, j+1)\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    # Path relocation: move a random segment to a new position\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n    insert_pos = random.randint(0, len(new_solution) - segment_length)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure the solution remains a valid tour (no duplicates, all nodes included)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, fall back to a simple swap\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9038800805668522,
            1.8959854245185852
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (lexicographic order)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Apply hybrid local search: edge exchange with path relocation\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two non-adjacent edges to exchange (similar to 2-opt but more flexible)\n    i, j = sorted(random.sample(range(1, n), 2))\n    if i == j:\n        j = (j + 1) % n\n\n    # Exchange the edges (i-1, i) and (j, j+1) with (i-1, j) and (i, j+1)\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    # Path relocation: move a random segment to a new position\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n    insert_pos = random.randint(0, len(new_solution) - segment_length)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure the solution remains a valid tour (no duplicates, all nodes included)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, fall back to a simple swap\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 221,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high likelihood for improvement\n    # Here, we select a solution with the highest sum of objectives (can be modified)\n    base_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine 3-opt with a custom edge exchange\n    if n > 4:\n        # 3-opt move: randomly select three edges and reconnect them\n        i, j, k = sorted(random.sample(range(1, n-1), 3))\n        segment1 = new_solution[:i]\n        segment2 = new_solution[i:j]\n        segment3 = new_solution[j:k]\n        segment4 = new_solution[k:]\n        new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n        # Custom edge exchange: swap two non-adjacent edges if it improves both objectives\n        a, b = random.sample(range(1, n-1), 2)\n        if a > b:\n            a, b = b, a\n\n        # Check if the exchange improves both objectives\n        original_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        original_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n        temp = new_solution.copy()\n        temp[a], temp[b] = temp[b], temp[a]\n\n        new_cost1 = distance_matrix_1[temp[a-1], temp[a]] + distance_matrix_1[temp[b-1], temp[b]]\n        new_cost2 = distance_matrix_2[temp[a-1], temp[a]] + distance_matrix_2[temp[b-1], temp[b]]\n\n        if (new_cost1 < original_cost1) and (new_cost2 < original_cost2):\n            new_solution = temp\n    else:\n        # For small instances, just swap two nodes\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9340113073892072,
            2.358675956726074
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high likelihood for improvement\n    # Here, we select a solution with the highest sum of objectives (can be modified)\n    base_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine 3-opt with a custom edge exchange\n    if n > 4:\n        # 3-opt move: randomly select three edges and reconnect them\n        i, j, k = sorted(random.sample(range(1, n-1), 3))\n        segment1 = new_solution[:i]\n        segment2 = new_solution[i:j]\n        segment3 = new_solution[j:k]\n        segment4 = new_solution[k:]\n        new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n        # Custom edge exchange: swap two non-adjacent edges if it improves both objectives\n        a, b = random.sample(range(1, n-1), 2)\n        if a > b:\n            a, b = b, a\n\n        # Check if the exchange improves both objectives\n        original_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        original_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n        temp = new_solution.copy()\n        temp[a], temp[b] = temp[b], temp[a]\n\n        new_cost1 = distance_matrix_1[temp[a-1], temp[a]] + distance_matrix_1[temp[b-1], temp[b]]\n        new_cost2 = distance_matrix_2[temp[a-1], temp[a]] + distance_matrix_2[temp[b-1], temp[b]]\n\n        if (new_cost1 < original_cost1) and (new_cost2 < original_cost2):\n            new_solution = temp\n    else:\n        # For small instances, just swap two nodes\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 222,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on the best trade-off between objectives\n    def dominance_score(sol_obj: Tuple[float, float]) -> float:\n        # Normalize objectives to [0,1] range for comparison\n        min_obj1 = min(obj[0] for _, obj in archive)\n        max_obj1 = max(obj[0] for _, obj in archive)\n        min_obj2 = min(obj[1] for _, obj in archive)\n        max_obj2 = max(obj[1] for _, obj in archive)\n\n        norm_obj1 = (sol_obj[0] - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0.5\n        norm_obj2 = (sol_obj[1] - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0.5\n\n        # Score based on Pareto dominance potential\n        return 0.5 * norm_obj1 + 0.5 * norm_obj2\n\n    # Select top 3 solutions with best dominance scores\n    archive_sorted = sorted(archive, key=lambda x: dominance_score(x[1]))\n    candidates = archive_sorted[:min(3, len(archive_sorted))]\n\n    # Randomly select one from top candidates\n    selected_idx = np.random.randint(0, len(candidates))\n    base_solution = candidates[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combination of edge exchange and segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge exchange: swap two random edges\n    i, j = sorted(np.random.choice(range(1, n), 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Segment inversion: reverse a random segment\n    if n > 4:\n        a, b = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution remains feasible\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.6708529642515226,
            2.2784486413002014
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on the best trade-off between objectives\n    def dominance_score(sol_obj: Tuple[float, float]) -> float:\n        # Normalize objectives to [0,1] range for comparison\n        min_obj1 = min(obj[0] for _, obj in archive)\n        max_obj1 = max(obj[0] for _, obj in archive)\n        min_obj2 = min(obj[1] for _, obj in archive)\n        max_obj2 = max(obj[1] for _, obj in archive)\n\n        norm_obj1 = (sol_obj[0] - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0.5\n        norm_obj2 = (sol_obj[1] - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0.5\n\n        # Score based on Pareto dominance potential\n        return 0.5 * norm_obj1 + 0.5 * norm_obj2\n\n    # Select top 3 solutions with best dominance scores\n    archive_sorted = sorted(archive, key=lambda x: dominance_score(x[1]))\n    candidates = archive_sorted[:min(3, len(archive_sorted))]\n\n    # Randomly select one from top candidates\n    selected_idx = np.random.randint(0, len(candidates))\n    base_solution = candidates[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combination of edge exchange and segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge exchange: swap two random edges\n    i, j = sorted(np.random.choice(range(1, n), 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Segment inversion: reverse a random segment\n    if n > 4:\n        a, b = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution remains feasible\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 223,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    crowding_distances = np.sum(normalized_costs, axis=1)\n    selection_probs = 1 / (crowding_distances + 1e-10)\n    selection_probs /= np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combination of edge insertion and double-bridge moves\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # Edge insertion with diversity consideration\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n_nodes), 2))\n        if j - i > 1:\n            segment = new_solution[i:j]\n            remaining = np.concatenate([new_solution[:i], new_solution[j:]])\n            insert_pos = random.randint(0, len(remaining)-1)\n            new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Double-bridge move for further improvement\n    a, b, c, d = sorted(random.sample(range(n_nodes), 4))\n    if b - a > 1 and d - c > 1:\n        new_solution = np.concatenate([\n            new_solution[:a+1],\n            new_solution[c+1:d+1],\n            new_solution[b+1:c+1],\n            new_solution[a+1:b+1],\n            new_solution[d+1:]\n        ])\n\n    # Ensure feasibility by checking for duplicates and missing nodes\n    assert len(new_solution) == n_nodes, \"Solution length changed!\"\n    assert len(np.unique(new_solution)) == n_nodes, \"Duplicate nodes detected!\"\n\n    return new_solution\n\n",
        "score": [
            -0.9582090530735479,
            2.208043694496155
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    crowding_distances = np.sum(normalized_costs, axis=1)\n    selection_probs = 1 / (crowding_distances + 1e-10)\n    selection_probs /= np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combination of edge insertion and double-bridge moves\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # Edge insertion with diversity consideration\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n_nodes), 2))\n        if j - i > 1:\n            segment = new_solution[i:j]\n            remaining = np.concatenate([new_solution[:i], new_solution[j:]])\n            insert_pos = random.randint(0, len(remaining)-1)\n            new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Double-bridge move for further improvement\n    a, b, c, d = sorted(random.sample(range(n_nodes), 4))\n    if b - a > 1 and d - c > 1:\n        new_solution = np.concatenate([\n            new_solution[:a+1],\n            new_solution[c+1:d+1],\n            new_solution[b+1:c+1],\n            new_solution[a+1:b+1],\n            new_solution[d+1:]\n        ])\n\n    # Ensure feasibility by checking for duplicates and missing nodes\n    assert len(new_solution) == n_nodes, \"Solution length changed!\"\n    assert len(np.unique(new_solution)) == n_nodes, \"Duplicate nodes detected!\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 224,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    # This biases selection towards solutions with lower costs\n    objectives = np.array([obj for _, obj in archive])\n    min_costs = np.min(objectives, axis=0)\n    max_costs = np.max(objectives, axis=0)\n    normalized_costs = (objectives - min_costs) / (max_costs - min_costs + 1e-10)\n    weights = 1 / (1 + np.sum(normalized_costs, axis=1))\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine edge swaps and node insertions\n    for _ in range(10):  # Number of local search steps\n        # Choose between edge swap or node insertion with equal probability\n        if random.random() < 0.5:\n            # Edge swap: randomly select two edges and swap their nodes\n            i, j = sorted(random.sample(range(n), 2))\n            if i + 1 == j:\n                # If consecutive, swap the nodes\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                # Swap the middle segment\n                new_segment = new_solution[i+1:j][::-1]\n                new_solution[i+1:j] = new_segment\n        else:\n            # Node insertion: remove a node and reinsert it in a different position\n            node_pos = random.randint(0, n-1)\n            node = new_solution[node_pos]\n            # Remove the node\n            new_solution = np.delete(new_solution, node_pos)\n            # Insert it at a random position\n            insert_pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7939718869745348,
            2.8152090311050415
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    # This biases selection towards solutions with lower costs\n    objectives = np.array([obj for _, obj in archive])\n    min_costs = np.min(objectives, axis=0)\n    max_costs = np.max(objectives, axis=0)\n    normalized_costs = (objectives - min_costs) / (max_costs - min_costs + 1e-10)\n    weights = 1 / (1 + np.sum(normalized_costs, axis=1))\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine edge swaps and node insertions\n    for _ in range(10):  # Number of local search steps\n        # Choose between edge swap or node insertion with equal probability\n        if random.random() < 0.5:\n            # Edge swap: randomly select two edges and swap their nodes\n            i, j = sorted(random.sample(range(n), 2))\n            if i + 1 == j:\n                # If consecutive, swap the nodes\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                # Swap the middle segment\n                new_segment = new_solution[i+1:j][::-1]\n                new_solution[i+1:j] = new_segment\n        else:\n            # Node insertion: remove a node and reinsert it in a different position\n            node_pos = random.randint(0, n-1)\n            node = new_solution[node_pos]\n            # Remove the node\n            new_solution = np.delete(new_solution, node_pos)\n            # Insert it at a random position\n            insert_pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 225,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability of being non-dominated or having potential for improvement\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (1 + i) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment reversal strategy\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select two segments to reverse\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    k, l = sorted(random.sample(range(1, n-1), 2))\n\n    # Segment reversal operation (novel strategy)\n    if i < k < j < l:\n        # Reverse segments [i:k] and [j:l]\n        new_solution[i:k] = new_solution[i:k][::-1]\n        new_solution[j:l] = new_solution[j:l][::-1]\n    else:\n        # Standard 2-opt swap\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to standard 2-opt if the operation fails\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8099598328697782,
            1.904410183429718
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability of being non-dominated or having potential for improvement\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (1 + i) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment reversal strategy\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select two segments to reverse\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    k, l = sorted(random.sample(range(1, n-1), 2))\n\n    # Segment reversal operation (novel strategy)\n    if i < k < j < l:\n        # Reverse segments [i:k] and [j:l]\n        new_solution[i:k] = new_solution[i:k][::-1]\n        new_solution[j:l] = new_solution[j:l][::-1]\n    else:\n        # Standard 2-opt swap\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to standard 2-opt if the operation fails\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 226,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution (top 20% with best combined objective)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selection_pool = archive_sorted[:max(1, len(archive_sorted) // 5)]\n    selected_idx = np.random.choice(len(selection_pool))\n    base_solution = selection_pool[selected_idx][0].copy()\n\n    # Step 2: Hybrid 2.5-opt local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select 5 random edges to consider for optimization\n    edges = np.random.choice(n, size=5, replace=False)\n    edges.sort()\n\n    # Apply a combination of 2-opt and 3-opt moves\n    if len(edges) >= 4:\n        # 2.5-opt move: reverse a segment and then adjust connections\n        a, b, c, d = edges[:4]\n        if a < b < c < d:\n            # Reverse segment between b and c\n            new_solution[b:c+1] = new_solution[b:c+1][::-1]\n            # Then perform a 2-opt between a and d\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n            new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Step 3: Ensure feasibility by repairing cycles\n    # Check for duplicate nodes and repair if needed\n    unique, counts = np.unique(new_solution, return_counts=True)\n    duplicates = unique[counts > 1]\n\n    for dup in duplicates:\n        # Find all occurrences of the duplicate\n        indices = np.where(new_solution == dup)[0]\n        # Swap with another node not in the solution\n        available_nodes = np.setdiff1d(np.arange(n), new_solution)\n        if len(available_nodes) > 0:\n            new_node = np.random.choice(available_nodes)\n            new_solution[indices[1:]] = new_node\n\n    # Verify the solution is valid (contains all nodes exactly once)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.7566327056663862,
            1.9823150038719177
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution (top 20% with best combined objective)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selection_pool = archive_sorted[:max(1, len(archive_sorted) // 5)]\n    selected_idx = np.random.choice(len(selection_pool))\n    base_solution = selection_pool[selected_idx][0].copy()\n\n    # Step 2: Hybrid 2.5-opt local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select 5 random edges to consider for optimization\n    edges = np.random.choice(n, size=5, replace=False)\n    edges.sort()\n\n    # Apply a combination of 2-opt and 3-opt moves\n    if len(edges) >= 4:\n        # 2.5-opt move: reverse a segment and then adjust connections\n        a, b, c, d = edges[:4]\n        if a < b < c < d:\n            # Reverse segment between b and c\n            new_solution[b:c+1] = new_solution[b:c+1][::-1]\n            # Then perform a 2-opt between a and d\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n            new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Step 3: Ensure feasibility by repairing cycles\n    # Check for duplicate nodes and repair if needed\n    unique, counts = np.unique(new_solution, return_counts=True)\n    duplicates = unique[counts > 1]\n\n    for dup in duplicates:\n        # Find all occurrences of the duplicate\n        indices = np.where(new_solution == dup)[0]\n        # Swap with another node not in the solution\n        available_nodes = np.setdiff1d(np.arange(n), new_solution)\n        if len(available_nodes) > 0:\n            new_node = np.random.choice(available_nodes)\n            new_solution[indices[1:]] = new_node\n\n    # Verify the solution is valid (contains all nodes exactly once)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 227,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good trade-off between objectives\n    weights = [0.5, 0.5]  # Equal weights for both objectives\n    scored_solutions = [(weights[0] * obj[0] + weights[1] * obj[1], sol) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: x[0])\n    selected_solution = scored_solutions[0][1].copy()\n\n    # Hybrid local search operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Edge exchange with adaptive selection\n    for _ in range(2):  # Perform multiple edge exchanges\n        i, j = sorted(random.sample(range(n), 2))\n        if i + 1 < j:  # Ensure segments are valid\n            # Reverse the segment between i+1 and j\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Node insertion with distance-based selection\n    for _ in range(2):  # Perform multiple insertions\n        # Select a node to relocate\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n\n        # Find insertion positions based on both distance matrices\n        distances = []\n        for i in range(n):\n            if i != node_idx and i != (node_idx + 1) % n:\n                # Calculate combined distance impact\n                prev_node = new_solution[(i-1) % n]\n                next_node = new_solution[i]\n                dist1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n                dist2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n                distances.append((dist1 + dist2, i))\n\n        # Sort by combined distance impact and select best position\n        distances.sort(key=lambda x: x[0])\n        best_pos = distances[0][1]\n\n        # Perform insertion\n        new_solution = np.concatenate([\n            new_solution[:best_pos], [node], new_solution[best_pos:node_idx], new_solution[node_idx+1:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -0.8023907964804161,
            1.687052309513092
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good trade-off between objectives\n    weights = [0.5, 0.5]  # Equal weights for both objectives\n    scored_solutions = [(weights[0] * obj[0] + weights[1] * obj[1], sol) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: x[0])\n    selected_solution = scored_solutions[0][1].copy()\n\n    # Hybrid local search operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Edge exchange with adaptive selection\n    for _ in range(2):  # Perform multiple edge exchanges\n        i, j = sorted(random.sample(range(n), 2))\n        if i + 1 < j:  # Ensure segments are valid\n            # Reverse the segment between i+1 and j\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Node insertion with distance-based selection\n    for _ in range(2):  # Perform multiple insertions\n        # Select a node to relocate\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n\n        # Find insertion positions based on both distance matrices\n        distances = []\n        for i in range(n):\n            if i != node_idx and i != (node_idx + 1) % n:\n                # Calculate combined distance impact\n                prev_node = new_solution[(i-1) % n]\n                next_node = new_solution[i]\n                dist1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n                dist2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n                distances.append((dist1 + dist2, i))\n\n        # Sort by combined distance impact and select best position\n        distances.sort(key=lambda x: x[0])\n        best_pos = distances[0][1]\n\n        # Perform insertion\n        new_solution = np.concatenate([\n            new_solution[:best_pos], [node], new_solution[best_pos:node_idx], new_solution[node_idx+1:]\n        ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 228,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by their dominance (lower objectives are better)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n\n    # Select top 20% of solutions to consider\n    top_solutions = archive_sorted[:max(1, len(archive_sorted) // 5)]\n    selected_solution = random.choice(top_solutions)[0].copy()\n\n    # Hybrid local search: 70% edge swap, 30% node relocation\n    new_solution = selected_solution.copy()\n    num_nodes = len(new_solution)\n\n    if random.random() < 0.7:  # Edge swap\n        # Select two non-adjacent edges to swap\n        i, j = sorted(random.sample(range(num_nodes), 2))\n        if i == 0 and j == num_nodes - 1:\n            pass  # Avoid swapping first and last\n        else:\n            # Perform the swap\n            new_solution[i:j] = new_solution[i:j][::-1]\n    else:  # Node relocation\n        # Select a node and insert it in a different position\n        node_idx = random.randint(0, num_nodes - 1)\n        node = new_solution[node_idx]\n\n        # Remove the node\n        new_solution = np.delete(new_solution, node_idx)\n\n        # Insert in a new position\n        new_pos = random.randint(0, num_nodes - 2)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8949321122066356,
            2.1257762908935547
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by their dominance (lower objectives are better)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n\n    # Select top 20% of solutions to consider\n    top_solutions = archive_sorted[:max(1, len(archive_sorted) // 5)]\n    selected_solution = random.choice(top_solutions)[0].copy()\n\n    # Hybrid local search: 70% edge swap, 30% node relocation\n    new_solution = selected_solution.copy()\n    num_nodes = len(new_solution)\n\n    if random.random() < 0.7:  # Edge swap\n        # Select two non-adjacent edges to swap\n        i, j = sorted(random.sample(range(num_nodes), 2))\n        if i == 0 and j == num_nodes - 1:\n            pass  # Avoid swapping first and last\n        else:\n            # Perform the swap\n            new_solution[i:j] = new_solution[i:j][::-1]\n    else:  # Node relocation\n        # Select a node and insert it in a different position\n        node_idx = random.randint(0, num_nodes - 1)\n        node = new_solution[node_idx]\n\n        # Remove the node\n        new_solution = np.delete(new_solution, node_idx)\n\n        # Insert in a new position\n        new_pos = random.randint(0, num_nodes - 2)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 229,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best but not the worst)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate the 'improvement potential' as the difference between the solution's objectives and the archive's average\n    avg_obj1 = np.mean([obj[0] for obj in archive_objectives])\n    avg_obj2 = np.mean([obj[1] for obj in archive_objectives])\n\n    potential_scores = []\n    for obj in archive_objectives:\n        # Higher score for solutions that are worse than average (more room for improvement)\n        score = (obj[0] - avg_obj1) + (obj[1] - avg_obj2)\n        potential_scores.append(score)\n\n    # Select the solution with the highest potential (most room for improvement)\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Apply a hybrid local search strategy: combine 3-opt with a novel swap operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose segments for 3-opt\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt: reverse the middle segment\n    new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    # Apply a novel swap operator: swap two non-adjacent edges\n    if n > 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        while abs(i - j) < 2:  # Ensure non-adjacent\n            j = np.random.randint(n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    assert len(set(new_solution)) == n, \"Solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.9482687379706063,
            2.3116655945777893
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best but not the worst)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate the 'improvement potential' as the difference between the solution's objectives and the archive's average\n    avg_obj1 = np.mean([obj[0] for obj in archive_objectives])\n    avg_obj2 = np.mean([obj[1] for obj in archive_objectives])\n\n    potential_scores = []\n    for obj in archive_objectives:\n        # Higher score for solutions that are worse than average (more room for improvement)\n        score = (obj[0] - avg_obj1) + (obj[1] - avg_obj2)\n        potential_scores.append(score)\n\n    # Select the solution with the highest potential (most room for improvement)\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Apply a hybrid local search strategy: combine 3-opt with a novel swap operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose segments for 3-opt\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt: reverse the middle segment\n    new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    # Apply a novel swap operator: swap two non-adjacent edges\n    if n > 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        while abs(i - j) < 2:  # Ensure non-adjacent\n            j = np.random.randint(n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    assert len(set(new_solution)) == n, \"Solution is invalid\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 230,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability of being non-dominated or diverse\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: edge exchange + node insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Edge exchange (similar to 2-opt but more flexible)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if j - i > 1:  # Ensure we have at least one node in between\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Node insertion (relocate a node to a different position)\n    k = np.random.randint(0, n)\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    assert len(set(new_solution)) == n, \"Invalid solution: contains duplicates or missing nodes\"\n    assert len(new_solution) == n, \"Invalid solution: incorrect length\"\n\n    return new_solution\n\n",
        "score": [
            -0.8161726636930255,
            2.4757779836654663
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability of being non-dominated or diverse\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: edge exchange + node insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Edge exchange (similar to 2-opt but more flexible)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if j - i > 1:  # Ensure we have at least one node in between\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Node insertion (relocate a node to a different position)\n    k = np.random.randint(0, n)\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    assert len(set(new_solution)) == n, \"Invalid solution: contains duplicates or missing nodes\"\n    assert len(new_solution) == n, \"Invalid solution: incorrect length\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 231,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    norm_objectives = objectives / np.sum(objectives, axis=0, keepdims=True)\n    selection_probs = 1 / (1 + np.sum(norm_objectives, axis=1))\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment relocation strategy\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # First apply 2-opt for local improvement\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then apply segment relocation\n    segment_length = random.randint(2, min(5, n//2))\n    a, b = sorted(random.sample(range(n - segment_length), 2))\n    segment = new_solution[a:a+segment_length]\n\n    # Remove the segment and insert it at the new position\n    remaining = np.concatenate([new_solution[:a], new_solution[a+segment_length:]])\n    insert_pos = random.randint(0, len(remaining) - segment_length)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure the solution is valid (visits each node exactly once)\n    assert len(new_solution) == len(set(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.943586037918739,
            2.3336620330810547
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    norm_objectives = objectives / np.sum(objectives, axis=0, keepdims=True)\n    selection_probs = 1 / (1 + np.sum(norm_objectives, axis=1))\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment relocation strategy\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # First apply 2-opt for local improvement\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then apply segment relocation\n    segment_length = random.randint(2, min(5, n//2))\n    a, b = sorted(random.sample(range(n - segment_length), 2))\n    segment = new_solution[a:a+segment_length]\n\n    # Remove the segment and insert it at the new position\n    remaining = np.concatenate([new_solution[:a], new_solution[a+segment_length:]])\n    insert_pos = random.randint(0, len(remaining) - segment_length)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure the solution is valid (visits each node exactly once)\n    assert len(new_solution) == len(set(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 232,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly biased towards lower costs)\n    candidates = []\n    for sol, (cost1, cost2) in archive:\n        # Normalize costs to avoid bias towards one objective\n        norm_cost = (cost1 + cost2) / 2\n        candidates.append((sol, norm_cost))\n\n    # Sort by normalized cost (ascending) and select top 20% or at least 1\n    candidates.sort(key=lambda x: x[1])\n    top_candidates = candidates[:max(1, len(candidates) // 5)]\n    selected_sol = random.choice(top_candidates)[0].copy()\n\n    # Hybrid local search: combine 3-opt with path relinking\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct positions for 3-opt\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move (reverse segments)\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n    new_solution[j:k+1] = np.flip(new_solution[j:k+1])\n\n    # Path relinking: blend with another random solution from archive\n    if len(archive) > 1:\n        other_sol = random.choice(archive)[0]\n        # Find common nodes and preserve order\n        common_nodes = set(selected_sol).intersection(other_sol)\n        if common_nodes:\n            # Create a mask for common nodes\n            mask = np.isin(new_solution, list(common_nodes))\n            # Replace non-common nodes with other_sol's order\n            new_solution[~mask] = other_sol[~np.isin(other_sol, new_solution[mask])]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    if len(set(new_solution)) != n or len(new_solution) != n:\n        # Fallback to simple swap if feasibility violated\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.6229035586516867,
            2.7304906845092773
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly biased towards lower costs)\n    candidates = []\n    for sol, (cost1, cost2) in archive:\n        # Normalize costs to avoid bias towards one objective\n        norm_cost = (cost1 + cost2) / 2\n        candidates.append((sol, norm_cost))\n\n    # Sort by normalized cost (ascending) and select top 20% or at least 1\n    candidates.sort(key=lambda x: x[1])\n    top_candidates = candidates[:max(1, len(candidates) // 5)]\n    selected_sol = random.choice(top_candidates)[0].copy()\n\n    # Hybrid local search: combine 3-opt with path relinking\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct positions for 3-opt\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move (reverse segments)\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n    new_solution[j:k+1] = np.flip(new_solution[j:k+1])\n\n    # Path relinking: blend with another random solution from archive\n    if len(archive) > 1:\n        other_sol = random.choice(archive)[0]\n        # Find common nodes and preserve order\n        common_nodes = set(selected_sol).intersection(other_sol)\n        if common_nodes:\n            # Create a mask for common nodes\n            mask = np.isin(new_solution, list(common_nodes))\n            # Replace non-common nodes with other_sol's order\n            new_solution[~mask] = other_sol[~np.isin(other_sol, new_solution[mask])]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    if len(set(new_solution)) != n or len(new_solution) != n:\n        # Fallback to simple swap if feasibility violated\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 233,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by a combined score (lower is better)\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n        # Select the middle solution to balance exploration and exploitation\n        base_solution = archive_sorted[len(archive) // 2][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combination of edge insertion and segment reversal\n    if n > 3:\n        # Select two distinct random segments\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        c, d = sorted(random.sample(range(1, n-1), 2))\n\n        # Ensure we don't select the same segment\n        if a != c or b != d:\n            # Extract segments\n            segment1 = new_solution[a:b+1]\n            segment2 = new_solution[c:d+1]\n\n            # Reverse one of the segments with probability 0.5\n            if random.random() < 0.5:\n                segment1 = segment1[::-1]\n\n            # Insert segment1 into position c\n            new_solution = np.concatenate([new_solution[:c], segment1, new_solution[d+1:]])\n\n            # Find insertion point for segment2 in the modified solution\n            insert_pos = random.randint(1, n-2)\n            new_solution = np.concatenate([new_solution[:insert_pos], segment2, new_solution[insert_pos:]])\n\n            # Ensure the solution remains a valid tour\n            unique_nodes = np.unique(new_solution)\n            if len(unique_nodes) != n:\n                # If invalid, revert to original solution\n                new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9875048593451924,
            0.4530307650566101
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by a combined score (lower is better)\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n        # Select the middle solution to balance exploration and exploitation\n        base_solution = archive_sorted[len(archive) // 2][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combination of edge insertion and segment reversal\n    if n > 3:\n        # Select two distinct random segments\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        c, d = sorted(random.sample(range(1, n-1), 2))\n\n        # Ensure we don't select the same segment\n        if a != c or b != d:\n            # Extract segments\n            segment1 = new_solution[a:b+1]\n            segment2 = new_solution[c:d+1]\n\n            # Reverse one of the segments with probability 0.5\n            if random.random() < 0.5:\n                segment1 = segment1[::-1]\n\n            # Insert segment1 into position c\n            new_solution = np.concatenate([new_solution[:c], segment1, new_solution[d+1:]])\n\n            # Find insertion point for segment2 in the modified solution\n            insert_pos = random.randint(1, n-2)\n            new_solution = np.concatenate([new_solution[:insert_pos], segment2, new_solution[insert_pos:]])\n\n            # Ensure the solution remains a valid tour\n            unique_nodes = np.unique(new_solution)\n            if len(unique_nodes) != n:\n                # If invalid, revert to original solution\n                new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 233,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by a combined score (lower is better)\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n        # Select the middle solution to balance exploration and exploitation\n        base_solution = archive_sorted[len(archive) // 2][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combination of edge insertion and segment reversal\n    if n > 3:\n        # Select two distinct random segments\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        c, d = sorted(random.sample(range(1, n-1), 2))\n\n        # Ensure we don't select the same segment\n        if a != c or b != d:\n            # Extract segments\n            segment1 = new_solution[a:b+1]\n            segment2 = new_solution[c:d+1]\n\n            # Reverse one of the segments with probability 0.5\n            if random.random() < 0.5:\n                segment1 = segment1[::-1]\n\n            # Insert segment1 into position c\n            new_solution = np.concatenate([new_solution[:c], segment1, new_solution[d+1:]])\n\n            # Find insertion point for segment2 in the modified solution\n            insert_pos = random.randint(1, n-2)\n            new_solution = np.concatenate([new_solution[:insert_pos], segment2, new_solution[insert_pos:]])\n\n            # Ensure the solution remains a valid tour\n            unique_nodes = np.unique(new_solution)\n            if len(unique_nodes) != n:\n                # If invalid, revert to original solution\n                new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9875048593451924,
            0.4530307650566101
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by a combined score (lower is better)\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n        # Select the middle solution to balance exploration and exploitation\n        base_solution = archive_sorted[len(archive) // 2][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combination of edge insertion and segment reversal\n    if n > 3:\n        # Select two distinct random segments\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        c, d = sorted(random.sample(range(1, n-1), 2))\n\n        # Ensure we don't select the same segment\n        if a != c or b != d:\n            # Extract segments\n            segment1 = new_solution[a:b+1]\n            segment2 = new_solution[c:d+1]\n\n            # Reverse one of the segments with probability 0.5\n            if random.random() < 0.5:\n                segment1 = segment1[::-1]\n\n            # Insert segment1 into position c\n            new_solution = np.concatenate([new_solution[:c], segment1, new_solution[d+1:]])\n\n            # Find insertion point for segment2 in the modified solution\n            insert_pos = random.randint(1, n-2)\n            new_solution = np.concatenate([new_solution[:insert_pos], segment2, new_solution[insert_pos:]])\n\n            # Ensure the solution remains a valid tour\n            unique_nodes = np.unique(new_solution)\n            if len(unique_nodes) != n:\n                # If invalid, revert to original solution\n                new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 234,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weights = [0.5, 0.5]  # Equal weights for simplicity; can be adjusted\n    best_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = archive[best_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine 3-opt with a custom move\n    # Step 1: Randomly select three distinct indices\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Step 2: Apply a custom 3-opt-like move\n    # Reverse the segment between j and k\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Step 3: Apply a custom move: swap two nodes that are far apart in one objective space\n    # Find the pair of nodes with the largest distance in the first objective space\n    max_dist = -1\n    a, b = 0, 0\n    for x in range(n):\n        for y in range(x+1, n):\n            dist = distance_matrix_1[new_solution[x], new_solution[y]]\n            if dist > max_dist:\n                max_dist = dist\n                a, b = x, y\n\n    # Swap the nodes if they are not adjacent\n    if abs(a - b) > 1:\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8178457849712386,
            4.169983327388763
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weights = [0.5, 0.5]  # Equal weights for simplicity; can be adjusted\n    best_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = archive[best_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine 3-opt with a custom move\n    # Step 1: Randomly select three distinct indices\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Step 2: Apply a custom 3-opt-like move\n    # Reverse the segment between j and k\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Step 3: Apply a custom move: swap two nodes that are far apart in one objective space\n    # Find the pair of nodes with the largest distance in the first objective space\n    max_dist = -1\n    a, b = 0, 0\n    for x in range(n):\n        for y in range(x+1, n):\n            dist = distance_matrix_1[new_solution[x], new_solution[y]]\n            if dist > max_dist:\n                max_dist = dist\n                a, b = x, y\n\n    # Swap the nodes if they are not adjacent\n    if abs(a - b) > 1:\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 235,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    archive_sorted = sorted(archive, key=lambda x: min(x[1]))\n    selected_idx = random.randint(0, min(3, len(archive_sorted) - 1))  # Select from top 4 or available\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combination of node insertion and edge exchange\n    for _ in range(2):  # Perform multiple local search steps\n        # Randomly select two distinct positions\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n\n        # Node insertion: move a segment to a different position\n        segment = new_solution[i:j]\n        remaining = np.concatenate([new_solution[:i], new_solution[j:]])\n        insert_pos = random.randint(0, len(remaining) - 1)\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n        # Edge exchange: swap edges to reduce cost in both objectives\n        if n > 4:\n            a, b = random.sample(range(n), 2)\n            if a > b:\n                a, b = b, a\n            # Check if swapping edges would reduce both objectives\n            current_cost = (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost = (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                        distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]])\n            if new_cost < current_cost:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.5057525995783454,
            2.3189775347709656
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    archive_sorted = sorted(archive, key=lambda x: min(x[1]))\n    selected_idx = random.randint(0, min(3, len(archive_sorted) - 1))  # Select from top 4 or available\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combination of node insertion and edge exchange\n    for _ in range(2):  # Perform multiple local search steps\n        # Randomly select two distinct positions\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n\n        # Node insertion: move a segment to a different position\n        segment = new_solution[i:j]\n        remaining = np.concatenate([new_solution[:i], new_solution[j:]])\n        insert_pos = random.randint(0, len(remaining) - 1)\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n        # Edge exchange: swap edges to reduce cost in both objectives\n        if n > 4:\n            a, b = random.sample(range(n), 2)\n            if a > b:\n                a, b = b, a\n            # Check if swapping edges would reduce both objectives\n            current_cost = (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                            distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost = (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                        distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]])\n            if new_cost < current_cost:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 236,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with high diversity or non-dominated status)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: 3-opt with a probabilistic swap\n    n = len(new_solution)\n    if n < 4:\n        # If the tour is too small, perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select three distinct indices\n        i, j, k = sorted(random.sample(range(n), 3))\n\n        # Apply 3-opt: reverse the segment between j and k, then reverse the segment between i and j\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # With 30% probability, perform an additional swap to increase diversity\n        if random.random() < 0.3:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8790139359610105,
            2.2321361303329468
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with high diversity or non-dominated status)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: 3-opt with a probabilistic swap\n    n = len(new_solution)\n    if n < 4:\n        # If the tour is too small, perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select three distinct indices\n        i, j, k = sorted(random.sample(range(n), 3))\n\n        # Apply 3-opt: reverse the segment between j and k, then reverse the segment between i and j\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # With 30% probability, perform an additional swap to increase diversity\n        if random.random() < 0.3:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 237,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy combining edge exchange and segment reversal\n    n = len(base_solution)\n\n    # Randomly select two distinct segments\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Ensure segments are distinct and non-overlapping\n    if a == c and b == d:\n        # If segments are identical, try again\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n    # Extract segments\n    segment1 = base_solution[a:b+1]\n    segment2 = base_solution[c:d+1]\n\n    # Reverse one segment\n    reversed_segment = segment1[::-1]\n\n    # Replace the original segment with the reversed one\n    new_solution[a:b+1] = reversed_segment\n\n    # Insert the other segment at a different position\n    new_solution = np.concatenate([\n        new_solution[:a],\n        segment2,\n        new_solution[b+1:]\n    ])\n\n    # Ensure the solution remains a valid tour\n    # Check for duplicates and missing nodes\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6624003811660699,
            6.900328874588013
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy combining edge exchange and segment reversal\n    n = len(base_solution)\n\n    # Randomly select two distinct segments\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Ensure segments are distinct and non-overlapping\n    if a == c and b == d:\n        # If segments are identical, try again\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n    # Extract segments\n    segment1 = base_solution[a:b+1]\n    segment2 = base_solution[c:d+1]\n\n    # Reverse one segment\n    reversed_segment = segment1[::-1]\n\n    # Replace the original segment with the reversed one\n    new_solution[a:b+1] = reversed_segment\n\n    # Insert the other segment at a different position\n    new_solution = np.concatenate([\n        new_solution[:a],\n        segment2,\n        new_solution[b+1:]\n    ])\n\n    # Ensure the solution remains a valid tour\n    # Check for duplicates and missing nodes\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 238,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with high potential for improvement\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(3, len(archive) - 1)  # Select from top 3 or all if less than 3\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine edge insertion and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Edge insertion\n    a, b = sorted(random.sample(range(n), 2))\n    node = new_solution[b]\n    new_solution = np.concatenate([new_solution[:a], [node], new_solution[a:b], new_solution[b+1:]])\n\n    # Segment reversal (2-opt variant)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7114366044502489,
            1.9073964953422546
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with high potential for improvement\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(3, len(archive) - 1)  # Select from top 3 or all if less than 3\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine edge insertion and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Edge insertion\n    a, b = sorted(random.sample(range(n), 2))\n    node = new_solution[b]\n    new_solution = np.concatenate([new_solution[:a], [node], new_solution[a:b], new_solution[b+1:]])\n\n    # Segment reversal (2-opt variant)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 239,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate the total cost for each solution in the archive\n    costs = [sum(obj) for _, obj in archive]\n\n    # Normalize costs to avoid bias toward one objective\n    min_cost, max_cost = min(costs), max(costs)\n    if min_cost == max_cost:\n        normalized_costs = [0.5 for _ in costs]\n    else:\n        normalized_costs = [(c - min_cost) / (max_cost - min_cost) for c in costs]\n\n    # Select a solution with probability proportional to its normalized cost (inverse selection)\n    probabilities = [1 - c for c in normalized_costs]\n    total_prob = sum(probabilities)\n    if total_prob == 0:\n        probabilities = [1.0 / len(probabilities)] * len(probabilities)\n    else:\n        probabilities = [p / total_prob for p in probabilities]\n\n    selected_idx = random.choices(range(len(archive)), weights=probabilities, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose a segment to perturb (randomly select a start and length)\n    segment_length = random.randint(2, max(2, n // 4))\n    start = random.randint(0, n - segment_length)\n\n    # Extract the segment\n    segment = new_solution[start:start + segment_length]\n\n    # Apply a segment reversal (like 2-opt but for segments)\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    # Apply a segment shift (move the segment to a different position)\n    if random.random() < 0.5:\n        new_pos = random.randint(0, n - segment_length)\n        if new_pos != start:\n            # Remove the segment\n            new_solution = np.concatenate([new_solution[:start], new_solution[start + segment_length:]])\n            # Insert the segment at the new position\n            if new_pos == 0:\n                new_solution = np.concatenate([segment, new_solution])\n            elif new_pos >= len(new_solution):\n                new_solution = np.concatenate([new_solution, segment])\n            else:\n                new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Apply a segment rotation (rotate the segment left or right)\n    if random.random() < 0.3:\n        rotation = random.randint(1, segment_length - 1)\n        segment = np.roll(segment, rotation)\n\n    # Reconstruct the solution with the modified segment\n    if start + segment_length > len(new_solution):\n        new_solution[start:] = segment\n    else:\n        new_solution[start:start + segment_length] = segment\n\n    # Ensure the solution is valid (no duplicates and all nodes are visited)\n    if len(np.unique(new_solution)) != len(instance):\n        # Fallback to a simple swap if the solution is invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8186514976168796,
            1.4234156608581543
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate the total cost for each solution in the archive\n    costs = [sum(obj) for _, obj in archive]\n\n    # Normalize costs to avoid bias toward one objective\n    min_cost, max_cost = min(costs), max(costs)\n    if min_cost == max_cost:\n        normalized_costs = [0.5 for _ in costs]\n    else:\n        normalized_costs = [(c - min_cost) / (max_cost - min_cost) for c in costs]\n\n    # Select a solution with probability proportional to its normalized cost (inverse selection)\n    probabilities = [1 - c for c in normalized_costs]\n    total_prob = sum(probabilities)\n    if total_prob == 0:\n        probabilities = [1.0 / len(probabilities)] * len(probabilities)\n    else:\n        probabilities = [p / total_prob for p in probabilities]\n\n    selected_idx = random.choices(range(len(archive)), weights=probabilities, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose a segment to perturb (randomly select a start and length)\n    segment_length = random.randint(2, max(2, n // 4))\n    start = random.randint(0, n - segment_length)\n\n    # Extract the segment\n    segment = new_solution[start:start + segment_length]\n\n    # Apply a segment reversal (like 2-opt but for segments)\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    # Apply a segment shift (move the segment to a different position)\n    if random.random() < 0.5:\n        new_pos = random.randint(0, n - segment_length)\n        if new_pos != start:\n            # Remove the segment\n            new_solution = np.concatenate([new_solution[:start], new_solution[start + segment_length:]])\n            # Insert the segment at the new position\n            if new_pos == 0:\n                new_solution = np.concatenate([segment, new_solution])\n            elif new_pos >= len(new_solution):\n                new_solution = np.concatenate([new_solution, segment])\n            else:\n                new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Apply a segment rotation (rotate the segment left or right)\n    if random.random() < 0.3:\n        rotation = random.randint(1, segment_length - 1)\n        segment = np.roll(segment, rotation)\n\n    # Reconstruct the solution with the modified segment\n    if start + segment_length > len(new_solution):\n        new_solution[start:] = segment\n    else:\n        new_solution[start:start + segment_length] = segment\n\n    # Ensure the solution is valid (no duplicates and all nodes are visited)\n    if len(np.unique(new_solution)) != len(instance):\n        # Fallback to a simple swap if the solution is invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 240,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weights = np.array([0.5, 0.5])  # Equal weights for simplicity; can be adjusted\n    objectives = np.array([obj for _, obj in archive])\n    scores = np.dot(objectives, weights)\n    best_idx = np.argmin(scores)  # Assuming minimization problem\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge-swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct segments\n    while True:\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        if j - i > 1 and k - j > 1:  # Ensure segments are large enough\n            break\n\n    # Perform 3-opt: reverse segments and reconnect optimally\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n\n    # Try all possible combinations of segment reversals\n    candidates = [\n        np.concatenate([new_solution[:i], segment1[::-1], segment2, new_solution[k:]]),\n        np.concatenate([new_solution[:i], segment1, segment2[::-1], new_solution[k:]]),\n        np.concatenate([new_solution[:i], segment2, segment1[::-1], new_solution[k:]]),\n        np.concatenate([new_solution[:i], segment2[::-1], segment1, new_solution[k:]]),\n    ]\n\n    # Evaluate candidates based on both objectives\n    best_candidate = new_solution.copy()\n    min_score = float('inf')\n\n    for candidate in candidates:\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        score = weights[0] * cost1 + weights[1] * cost2\n\n        if score < min_score:\n            min_score = score\n            best_candidate = candidate.copy()\n\n    # Additional edge-swap for fine-tuning\n    for _ in range(2):  # Limit to 2 swaps to balance exploration/exploitation\n        a, b = np.random.choice(n, 2, replace=False)\n        if abs(a - b) > 1:  # Ensure non-adjacent nodes\n            new_candidate = best_candidate.copy()\n            new_candidate[a], new_candidate[b] = new_candidate[b], new_candidate[a]\n\n            # Check feasibility (no duplicates)\n            if len(np.unique(new_candidate)) == n:\n                cost1 = sum(distance_matrix_1[new_candidate[i], new_candidate[i+1]] for i in range(n-1)) + distance_matrix_1[new_candidate[-1], new_candidate[0]]\n                cost2 = sum(distance_matrix_2[new_candidate[i], new_candidate[i+1]] for i in range(n-1)) + distance_matrix_2[new_candidate[-1], new_candidate[0]]\n                new_score = weights[0] * cost1 + weights[1] * cost2\n\n                if new_score < min_score:\n                    best_candidate = new_candidate.copy()\n                    min_score = new_score\n\n    return best_candidate\n\n",
        "score": [
            -0.7821609013732308,
            3.7521057724952698
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weights = np.array([0.5, 0.5])  # Equal weights for simplicity; can be adjusted\n    objectives = np.array([obj for _, obj in archive])\n    scores = np.dot(objectives, weights)\n    best_idx = np.argmin(scores)  # Assuming minimization problem\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge-swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct segments\n    while True:\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        if j - i > 1 and k - j > 1:  # Ensure segments are large enough\n            break\n\n    # Perform 3-opt: reverse segments and reconnect optimally\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n\n    # Try all possible combinations of segment reversals\n    candidates = [\n        np.concatenate([new_solution[:i], segment1[::-1], segment2, new_solution[k:]]),\n        np.concatenate([new_solution[:i], segment1, segment2[::-1], new_solution[k:]]),\n        np.concatenate([new_solution[:i], segment2, segment1[::-1], new_solution[k:]]),\n        np.concatenate([new_solution[:i], segment2[::-1], segment1, new_solution[k:]]),\n    ]\n\n    # Evaluate candidates based on both objectives\n    best_candidate = new_solution.copy()\n    min_score = float('inf')\n\n    for candidate in candidates:\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        score = weights[0] * cost1 + weights[1] * cost2\n\n        if score < min_score:\n            min_score = score\n            best_candidate = candidate.copy()\n\n    # Additional edge-swap for fine-tuning\n    for _ in range(2):  # Limit to 2 swaps to balance exploration/exploitation\n        a, b = np.random.choice(n, 2, replace=False)\n        if abs(a - b) > 1:  # Ensure non-adjacent nodes\n            new_candidate = best_candidate.copy()\n            new_candidate[a], new_candidate[b] = new_candidate[b], new_candidate[a]\n\n            # Check feasibility (no duplicates)\n            if len(np.unique(new_candidate)) == n:\n                cost1 = sum(distance_matrix_1[new_candidate[i], new_candidate[i+1]] for i in range(n-1)) + distance_matrix_1[new_candidate[-1], new_candidate[0]]\n                cost2 = sum(distance_matrix_2[new_candidate[i], new_candidate[i+1]] for i in range(n-1)) + distance_matrix_2[new_candidate[-1], new_candidate[0]]\n                new_score = weights[0] * cost1 + weights[1] * cost2\n\n                if new_score < min_score:\n                    best_candidate = new_candidate.copy()\n                    min_score = new_score\n\n    return best_candidate\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 241,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    costs = [sum(obj) for _, obj in archive]\n    total_cost = sum(costs)\n    probabilities = [(total_cost - cost) / (len(archive) * total_cost) for cost in costs]\n    selected_idx = random.choices(range(len(archive)), weights=probabilities, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine edge swapping with segment relocation\n    for _ in range(10):  # Perform multiple iterations for better exploration\n        # Randomly choose between edge swap and segment relocation\n        if random.random() < 0.5:\n            # Edge swap\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Segment relocation\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8027889322482746,
            2.14945787191391
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    costs = [sum(obj) for _, obj in archive]\n    total_cost = sum(costs)\n    probabilities = [(total_cost - cost) / (len(archive) * total_cost) for cost in costs]\n    selected_idx = random.choices(range(len(archive)), weights=probabilities, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine edge swapping with segment relocation\n    for _ in range(10):  # Perform multiple iterations for better exploration\n        # Randomly choose between edge swap and segment relocation\n        if random.random() < 0.5:\n            # Edge swap\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Segment relocation\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 242,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (lexicographical order)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Hybrid local search strategy\n    # Step 1: Perform a probabilistic edge swap\n    if n > 2:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    # Step 2: Perform a segment reversal with probability 0.3\n    if np.random.random() < 0.3 and n > 3:\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Ensure the solution is valid (no duplicates, all nodes visited)\n    if len(set(new_solution)) != n:\n        # Fallback to a simple swap if invalid\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8556469664785702,
            2.2894203662872314
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (lexicographical order)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Hybrid local search strategy\n    # Step 1: Perform a probabilistic edge swap\n    if n > 2:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    # Step 2: Perform a segment reversal with probability 0.3\n    if np.random.random() < 0.3 and n > 3:\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Ensure the solution is valid (no duplicates, all nodes visited)\n    if len(set(new_solution)) != n:\n        # Fallback to a simple swap if invalid\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 243,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a novel segment inversion\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Select three random distinct indices\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Perform 3-opt: reverse segments between a-b, b-c, and a-c\n    new_solution[a:b] = base_solution[a:b][::-1]\n    new_solution[b:c] = base_solution[b:c][::-1]\n    new_solution[a:c] = base_solution[a:c][::-1]\n\n    # Novel segment inversion: invert a segment with probability 0.5\n    if random.random() < 0.5:\n        seg_start = random.randint(0, n - 2)\n        seg_end = random.randint(seg_start + 1, n - 1)\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.unique(new_solution), np.unique(base_solution)):\n        return base_solution  # Fallback to original if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.6758785361593653,
            1.8047658801078796
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a novel segment inversion\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Select three random distinct indices\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Perform 3-opt: reverse segments between a-b, b-c, and a-c\n    new_solution[a:b] = base_solution[a:b][::-1]\n    new_solution[b:c] = base_solution[b:c][::-1]\n    new_solution[a:c] = base_solution[a:c][::-1]\n\n    # Novel segment inversion: invert a segment with probability 0.5\n    if random.random() < 0.5:\n        seg_start = random.randint(0, n - 2)\n        seg_end = random.randint(seg_start + 1, n - 1)\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.unique(new_solution), np.unique(base_solution)):\n        return base_solution  # Fallback to original if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 244,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Sort solutions by a combined objective score (e.g., sum of normalized objectives)\n        objectives = [obj for _, obj in archive]\n        normalized_obj = np.array([(o1 - min(o for o, _ in objectives)) / (max(o for o, _ in objectives) - min(o for o, _ in objectives) + 1e-10),\n                                   (o2 - min(o for _, o in objectives)) / (max(o for _, o in objectives) - min(o for _, o in objectives) + 1e-10)]\n                                  for o1, o2 in objectives)\n        combined_scores = normalized_obj.sum(axis=0)\n        selected_idx = np.argmin(combined_scores)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine edge swapping with probabilistic acceptance\n    for _ in range(10):  # Number of perturbation attempts\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Create a candidate solution by swapping edges (novel operator)\n        candidate = new_solution.copy()\n        candidate[i:j] = candidate[i:j][::-1]  # Reverse subpath\n\n        # Calculate the cost of the candidate solution\n        cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n        cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n        # Probabilistic acceptance based on Pareto dominance\n        if (cost1 <= sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)) and\n            cost2 <= sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))):\n            new_solution = candidate\n        elif np.random.rand() < 0.3:  # Small probability to accept non-dominated solutions\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7440006104801593,
            6.462030351161957
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Sort solutions by a combined objective score (e.g., sum of normalized objectives)\n        objectives = [obj for _, obj in archive]\n        normalized_obj = np.array([(o1 - min(o for o, _ in objectives)) / (max(o for o, _ in objectives) - min(o for o, _ in objectives) + 1e-10),\n                                   (o2 - min(o for _, o in objectives)) / (max(o for _, o in objectives) - min(o for _, o in objectives) + 1e-10)]\n                                  for o1, o2 in objectives)\n        combined_scores = normalized_obj.sum(axis=0)\n        selected_idx = np.argmin(combined_scores)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine edge swapping with probabilistic acceptance\n    for _ in range(10):  # Number of perturbation attempts\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Create a candidate solution by swapping edges (novel operator)\n        candidate = new_solution.copy()\n        candidate[i:j] = candidate[i:j][::-1]  # Reverse subpath\n\n        # Calculate the cost of the candidate solution\n        cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n        cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n        # Probabilistic acceptance based on Pareto dominance\n        if (cost1 <= sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)) and\n            cost2 <= sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))):\n            new_solution = candidate\n        elif np.random.rand() < 0.3:  # Small probability to accept non-dominated solutions\n            new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 245,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on the sum of normalized objectives\n    normalized_objectives = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    min_obj = np.min(normalized_objectives)\n    max_obj = np.max(normalized_objectives)\n    if min_obj == max_obj:\n        probabilities = np.ones(len(archive)) / len(archive)\n    else:\n        normalized = (normalized_objectives - min_obj) / (max_obj - min_obj)\n        probabilities = 1 - normalized\n        probabilities /= np.sum(probabilities)\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search\n    n = len(new_solution)\n    if n < 4:\n        # For very small instances, just swap two random edges\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid strategy: segment inversion with edge swapping\n        segment_length = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        # Invert a segment to create a new structure\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Perform edge swapping in the inverted segment\n        if segment_length > 2:\n            swap_pos = random.randint(1, segment_length - 2)\n            new_solution[start + swap_pos], new_solution[start + swap_pos + 1] = new_solution[start + swap_pos + 1], new_solution[start + swap_pos]\n\n    return new_solution\n\n",
        "score": [
            -0.7814767636381474,
            2.0331095457077026
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on the sum of normalized objectives\n    normalized_objectives = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    min_obj = np.min(normalized_objectives)\n    max_obj = np.max(normalized_objectives)\n    if min_obj == max_obj:\n        probabilities = np.ones(len(archive)) / len(archive)\n    else:\n        normalized = (normalized_objectives - min_obj) / (max_obj - min_obj)\n        probabilities = 1 - normalized\n        probabilities /= np.sum(probabilities)\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search\n    n = len(new_solution)\n    if n < 4:\n        # For very small instances, just swap two random edges\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid strategy: segment inversion with edge swapping\n        segment_length = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        # Invert a segment to create a new structure\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Perform edge swapping in the inverted segment\n        if segment_length > 2:\n            swap_pos = random.randint(1, segment_length - 2)\n            new_solution[start + swap_pos], new_solution[start + swap_pos + 1] = new_solution[start + swap_pos + 1], new_solution[start + swap_pos]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 246,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives to create a combined fitness score\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = objectives.min(axis=0)\n    max_obj = objectives.max(axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    fitness = 1 - (normalized[:, 0] + normalized[:, 1]) / 2  # Inverse of average normalized score\n\n    # Select a solution with probability proportional to its fitness\n    selected_idx = random.choices(range(len(archive)), weights=fitness, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Make a copy to modify\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose a random local search operator\n    operator = random.choice(['segment_reversal', 'node_insertion', 'edge_exchange'])\n\n    if operator == 'segment_reversal':\n        # Random segment reversal (like 2-opt but with variable length)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == 'node_insertion':\n        # Random node insertion\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            insert_pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    elif operator == 'edge_exchange':\n        # Random edge exchange (swap two edges)\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7835123549706653,
            2.3046257495880127
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives to create a combined fitness score\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = objectives.min(axis=0)\n    max_obj = objectives.max(axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    fitness = 1 - (normalized[:, 0] + normalized[:, 1]) / 2  # Inverse of average normalized score\n\n    # Select a solution with probability proportional to its fitness\n    selected_idx = random.choices(range(len(archive)), weights=fitness, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Make a copy to modify\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose a random local search operator\n    operator = random.choice(['segment_reversal', 'node_insertion', 'edge_exchange'])\n\n    if operator == 'segment_reversal':\n        # Random segment reversal (like 2-opt but with variable length)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == 'node_insertion':\n        # Random node insertion\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            insert_pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    elif operator == 'edge_exchange':\n        # Random edge exchange (swap two edges)\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 247,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of edge exchange and segment inversion\n    n = len(base_solution)\n    a, b, c, d = sorted(random.sample(range(n), 4))\n\n    # Edge exchange: swap edges (a-b) and (c-d) with (a-c) and (b-d)\n    if random.random() < 0.5:\n        new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n        new_solution[b], new_solution[d] = new_solution[d], new_solution[b]\n    else:\n        # Segment inversion: reverse a segment between two random points\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7315101181880055,
            1.6968272924423218
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of edge exchange and segment inversion\n    n = len(base_solution)\n    a, b, c, d = sorted(random.sample(range(n), 4))\n\n    # Edge exchange: swap edges (a-b) and (c-d) with (a-c) and (b-d)\n    if random.random() < 0.5:\n        new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n        new_solution[b], new_solution[d] = new_solution[d], new_solution[b]\n    else:\n        # Segment inversion: reverse a segment between two random points\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 248,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-swap based on both objectives\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Perform a 3-opt move\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Novel edge-swap: swap edges based on both distance matrices\n    if np.random.rand() < 0.5:  # 50% chance to apply the novel operator\n        # Find edges with high combined distance\n        edges = [(new_solution[i], new_solution[(i+1)%n]) for i in range(n)]\n        edge_scores = [distance_matrix_1[e[0], e[1]] + distance_matrix_2[e[0], e[1]] for e in edges]\n        worst_edge_idx = np.argmax(edge_scores)\n        worst_edge = edges[worst_edge_idx]\n\n        # Find a better edge to replace it\n        candidates = []\n        for a in range(n):\n            for b in range(a+1, n):\n                if new_solution[a] != worst_edge[0] and new_solution[b] != worst_edge[1]:\n                    candidates.append((a, b))\n        if candidates:\n            a, b = candidates[np.random.choice(len(candidates))]\n            # Perform the swap\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8291248955462784,
            3.727888584136963
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-swap based on both objectives\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Perform a 3-opt move\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Novel edge-swap: swap edges based on both distance matrices\n    if np.random.rand() < 0.5:  # 50% chance to apply the novel operator\n        # Find edges with high combined distance\n        edges = [(new_solution[i], new_solution[(i+1)%n]) for i in range(n)]\n        edge_scores = [distance_matrix_1[e[0], e[1]] + distance_matrix_2[e[0], e[1]] for e in edges]\n        worst_edge_idx = np.argmax(edge_scores)\n        worst_edge = edges[worst_edge_idx]\n\n        # Find a better edge to replace it\n        candidates = []\n        for a in range(n):\n            for b in range(a+1, n):\n                if new_solution[a] != worst_edge[0] and new_solution[b] != worst_edge[1]:\n                    candidates.append((a, b))\n        if candidates:\n            a, b = candidates[np.random.choice(len(candidates))]\n            # Perform the swap\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 249,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # Here, we select a solution with the highest sum of objectives (worst solution in the archive)\n    # This is a heuristic to focus on solutions that may benefit from more exploration\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combination of edge exchange and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments to exchange\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Ensure segments are of reasonable size (at least 2 nodes)\n    segment_size = min(max(2, b - a + 1), max(2, d - c + 1))\n\n    # Perform edge exchange between the two segments\n    temp = new_solution[a:a+segment_size].copy()\n    new_solution[a:a+segment_size] = new_solution[c:c+segment_size]\n    new_solution[c:c+segment_size] = temp\n\n    # Randomly reverse a segment to introduce diversity\n    rev_start = random.randint(1, n - 2)\n    rev_end = random.randint(rev_start + 1, n - 1)\n    new_solution[rev_start:rev_end] = new_solution[rev_start:rev_end][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != len(instance):\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9522000966721047,
            2.57444566488266
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # Here, we select a solution with the highest sum of objectives (worst solution in the archive)\n    # This is a heuristic to focus on solutions that may benefit from more exploration\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combination of edge exchange and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments to exchange\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Ensure segments are of reasonable size (at least 2 nodes)\n    segment_size = min(max(2, b - a + 1), max(2, d - c + 1))\n\n    # Perform edge exchange between the two segments\n    temp = new_solution[a:a+segment_size].copy()\n    new_solution[a:a+segment_size] = new_solution[c:c+segment_size]\n    new_solution[c:c+segment_size] = temp\n\n    # Randomly reverse a segment to introduce diversity\n    rev_start = random.randint(1, n - 2)\n    rev_end = random.randint(rev_start + 1, n - 1)\n    new_solution[rev_start:rev_end] = new_solution[rev_start:rev_end][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != len(instance):\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 250,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-frontier solutions)\n    archive_solutions = [sol for sol, _ in archive]\n    selected_solution = archive_solutions[np.random.randint(len(archive_solutions))]\n\n    # Hybrid local search: 3-opt with segment-based perturbation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: 3-opt local search (randomly select 3 edges and reconnect)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    segment1 = new_solution[:i+1]\n    segment2 = new_solution[i+1:j+1]\n    segment3 = new_solution[j+1:k+1]\n    segment4 = new_solution[k+1:]\n\n    # Reconnect segments in a different order\n    new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Step 2: Segment-based perturbation (reverse a random segment)\n    if n > 3:\n        seg_start, seg_end = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    # Ensure the solution remains feasible\n    assert len(new_solution) == len(selected_solution)\n    assert len(np.unique(new_solution)) == len(selected_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.9021646755158659,
            2.30491441488266
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-frontier solutions)\n    archive_solutions = [sol for sol, _ in archive]\n    selected_solution = archive_solutions[np.random.randint(len(archive_solutions))]\n\n    # Hybrid local search: 3-opt with segment-based perturbation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: 3-opt local search (randomly select 3 edges and reconnect)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    segment1 = new_solution[:i+1]\n    segment2 = new_solution[i+1:j+1]\n    segment3 = new_solution[j+1:k+1]\n    segment4 = new_solution[k+1:]\n\n    # Reconnect segments in a different order\n    new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Step 2: Segment-based perturbation (reverse a random segment)\n    if n > 3:\n        seg_start, seg_end = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    # Ensure the solution remains feasible\n    assert len(new_solution) == len(selected_solution)\n    assert len(np.unique(new_solution)) == len(selected_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 251,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Identify non-dominated solutions\n    def is_dominated(a, b):\n        return a[0] <= b[0] and a[1] <= b[1] and (a[0] < b[0] or a[1] < b[1])\n\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if is_dominated(obj, other_obj):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Step 2: Select from top 20% of non-dominated solutions\n    top_k = max(1, int(0.2 * len(non_dominated)))\n    selected = random.choice(non_dominated[:top_k])\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 3: Hybrid local search operator\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Multi-objective segment inversion\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n\n    # Calculate segment costs in both objectives\n    seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment))) + distance_matrix_1[segment[-1], segment[0]]\n    seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment))) + distance_matrix_2[segment[-1], segment[0]]\n\n    # Invert the segment with probability based on cost improvement potential\n    if random.random() < 0.7:  # Higher probability for promising segments\n        new_segment = segment[::-1]\n        new_seg_cost1 = sum(distance_matrix_1[new_segment[i-1], new_segment[i]] for i in range(1, len(new_segment))) + distance_matrix_1[new_segment[-1], new_segment[0]]\n        new_seg_cost2 = sum(distance_matrix_2[new_segment[i-1], new_segment[i]] for i in range(1, len(new_segment))) + distance_matrix_2[new_segment[-1], new_segment[0]]\n\n        # Accept if at least one objective improves\n        if new_seg_cost1 <= seg_cost1 or new_seg_cost2 <= seg_cost2:\n            new_solution[a:b+1] = new_segment\n\n    # Additional small perturbation to escape local optima\n    if random.random() < 0.3:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9315905937183089,
            2.2850627303123474
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Identify non-dominated solutions\n    def is_dominated(a, b):\n        return a[0] <= b[0] and a[1] <= b[1] and (a[0] < b[0] or a[1] < b[1])\n\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if is_dominated(obj, other_obj):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Step 2: Select from top 20% of non-dominated solutions\n    top_k = max(1, int(0.2 * len(non_dominated)))\n    selected = random.choice(non_dominated[:top_k])\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 3: Hybrid local search operator\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Multi-objective segment inversion\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n\n    # Calculate segment costs in both objectives\n    seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment))) + distance_matrix_1[segment[-1], segment[0]]\n    seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment))) + distance_matrix_2[segment[-1], segment[0]]\n\n    # Invert the segment with probability based on cost improvement potential\n    if random.random() < 0.7:  # Higher probability for promising segments\n        new_segment = segment[::-1]\n        new_seg_cost1 = sum(distance_matrix_1[new_segment[i-1], new_segment[i]] for i in range(1, len(new_segment))) + distance_matrix_1[new_segment[-1], new_segment[0]]\n        new_seg_cost2 = sum(distance_matrix_2[new_segment[i-1], new_segment[i]] for i in range(1, len(new_segment))) + distance_matrix_2[new_segment[-1], new_segment[0]]\n\n        # Accept if at least one objective improves\n        if new_seg_cost1 <= seg_cost1 or new_seg_cost2 <= seg_cost2:\n            new_solution[a:b+1] = new_segment\n\n    # Additional small perturbation to escape local optima\n    if random.random() < 0.3:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 252,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high cost)\n    costs = [obj[0] + obj[1] for _, obj in archive]\n    if len(costs) > 1:\n        # Select solutions in the top 30% of cost\n        threshold = np.percentile(costs, 70)\n        candidates = [sol for sol, obj in archive if obj[0] + obj[1] >= threshold]\n    else:\n        candidates = [sol for sol, _ in archive]\n\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n\n    base_solution = random.choice(candidates).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a biased edge insertion\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select 3 distinct positions\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n\n    # Reverse one of the segments with probability 0.5\n    if random.random() < 0.5:\n        segment1 = segment1[::-1]\n    else:\n        segment2 = segment2[::-1]\n\n    # Reconstruct the tour\n    new_solution = np.concatenate([new_solution[:i], segment1, segment2, new_solution[k:]])\n\n    # With probability 0.3, perform a biased edge insertion\n    if random.random() < 0.3 and n > 3:\n        # Select a node to remove and reinsert at a better position\n        remove_idx = random.randint(0, n-1)\n        node = new_solution[remove_idx]\n\n        # Calculate potential insertion positions based on both objectives\n        costs = []\n        for pos in range(n):\n            if pos == remove_idx or pos == (remove_idx + 1) % n:\n                continue\n\n            # Calculate cost of inserting node at position pos\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n            costs.append((cost1 + cost2, pos))\n\n        if costs:\n            # Select the position with the best combined cost improvement\n            best_pos = min(costs, key=lambda x: x[0])[1]\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                np.array([node]),\n                new_solution[best_pos:remove_idx],\n                new_solution[remove_idx+1:]\n            ])\n\n    return new_solution\n\n",
        "score": [
            -0.8987911376853972,
            2.5090097188949585
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high cost)\n    costs = [obj[0] + obj[1] for _, obj in archive]\n    if len(costs) > 1:\n        # Select solutions in the top 30% of cost\n        threshold = np.percentile(costs, 70)\n        candidates = [sol for sol, obj in archive if obj[0] + obj[1] >= threshold]\n    else:\n        candidates = [sol for sol, _ in archive]\n\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n\n    base_solution = random.choice(candidates).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a biased edge insertion\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select 3 distinct positions\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n\n    # Reverse one of the segments with probability 0.5\n    if random.random() < 0.5:\n        segment1 = segment1[::-1]\n    else:\n        segment2 = segment2[::-1]\n\n    # Reconstruct the tour\n    new_solution = np.concatenate([new_solution[:i], segment1, segment2, new_solution[k:]])\n\n    # With probability 0.3, perform a biased edge insertion\n    if random.random() < 0.3 and n > 3:\n        # Select a node to remove and reinsert at a better position\n        remove_idx = random.randint(0, n-1)\n        node = new_solution[remove_idx]\n\n        # Calculate potential insertion positions based on both objectives\n        costs = []\n        for pos in range(n):\n            if pos == remove_idx or pos == (remove_idx + 1) % n:\n                continue\n\n            # Calculate cost of inserting node at position pos\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n            costs.append((cost1 + cost2, pos))\n\n        if costs:\n            # Select the position with the best combined cost improvement\n            best_pos = min(costs, key=lambda x: x[0])[1]\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                np.array([node]),\n                new_solution[best_pos:remove_idx],\n                new_solution[remove_idx+1:]\n            ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 253,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Filter non-dominated solutions if any\n    def is_dominated(obj1, obj2):\n        return obj1[0] >= obj2[0] and obj1[1] >= obj2[1] and (obj1[0] > obj2[0] or obj1[1] > obj2[1])\n\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if is_dominated(obj, other_obj):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    # Select from non-dominated if available, otherwise from entire archive\n    selection_pool = non_dominated if non_dominated else archive\n    selected_idx = np.random.randint(0, len(selection_pool))\n    base_solution, _ = selection_pool[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just do a random swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Hybrid 3-opt variant with segment inversion\n    for _ in range(2):  # Apply multiple times for better exploration\n        # Select three distinct segments\n        a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n\n        # Create three possible candidates\n        candidates = [\n            np.concatenate([new_solution[:a], new_solution[b:c][::-1], new_solution[a:b], new_solution[c:d][::-1], new_solution[d:]]),\n            np.concatenate([new_solution[:a], new_solution[c:d][::-1], new_solution[a:b], new_solution[b:c][::-1], new_solution[d:]]),\n            np.concatenate([new_solution[:a], new_solution[a:b][::-1], new_solution[b:c], new_solution[c:d][::-1], new_solution[d:]])\n        ]\n\n        # Evaluate candidates based on both objectives\n        current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n        best_candidate = new_solution\n        best_cost1, best_cost2 = current_cost1, current_cost2\n\n        for candidate in candidates:\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n\n            # Accept if Pareto improvement\n            if (cost1 < best_cost1 and cost2 <= best_cost2) or (cost1 <= best_cost1 and cost2 < best_cost2):\n                best_candidate = candidate\n                best_cost1, best_cost2 = cost1, cost2\n\n        new_solution = best_candidate\n\n    # Step 3: Apply segment inversion for diversification\n    if np.random.rand() < 0.3:  # 30% chance\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8087345154126365,
            7.449036955833435
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Filter non-dominated solutions if any\n    def is_dominated(obj1, obj2):\n        return obj1[0] >= obj2[0] and obj1[1] >= obj2[1] and (obj1[0] > obj2[0] or obj1[1] > obj2[1])\n\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if is_dominated(obj, other_obj):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    # Select from non-dominated if available, otherwise from entire archive\n    selection_pool = non_dominated if non_dominated else archive\n    selected_idx = np.random.randint(0, len(selection_pool))\n    base_solution, _ = selection_pool[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just do a random swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Hybrid 3-opt variant with segment inversion\n    for _ in range(2):  # Apply multiple times for better exploration\n        # Select three distinct segments\n        a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n\n        # Create three possible candidates\n        candidates = [\n            np.concatenate([new_solution[:a], new_solution[b:c][::-1], new_solution[a:b], new_solution[c:d][::-1], new_solution[d:]]),\n            np.concatenate([new_solution[:a], new_solution[c:d][::-1], new_solution[a:b], new_solution[b:c][::-1], new_solution[d:]]),\n            np.concatenate([new_solution[:a], new_solution[a:b][::-1], new_solution[b:c], new_solution[c:d][::-1], new_solution[d:]])\n        ]\n\n        # Evaluate candidates based on both objectives\n        current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n        best_candidate = new_solution\n        best_cost1, best_cost2 = current_cost1, current_cost2\n\n        for candidate in candidates:\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n\n            # Accept if Pareto improvement\n            if (cost1 < best_cost1 and cost2 <= best_cost2) or (cost1 <= best_cost1 and cost2 < best_cost2):\n                best_candidate = candidate\n                best_cost1, best_cost2 = cost1, cost2\n\n        new_solution = best_candidate\n\n    # Step 3: Apply segment inversion for diversification\n    if np.random.rand() < 0.3:  # 30% chance\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 254,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., worst in one objective)\n    objectives = [obj for (sol, obj) in archive]\n    objectives = np.array(objectives)\n    min_cost = np.min(objectives, axis=0)\n    max_cost = np.max(objectives, axis=0)\n\n    # Normalize objectives to identify solutions with high potential\n    normalized = (objectives - min_cost) / (max_cost - min_cost + 1e-10)\n    potential = np.max(normalized, axis=1)  # Solutions with high worst objective\n    selected_index = np.argmax(potential)\n    base_solution = archive[selected_index][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge-swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i, j = np.sort(np.random.choice(n, size=2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Novel edge-swap: reverse the segment and swap edges\n    if len(segment) > 2:\n        reversed_segment = segment[::-1]\n        new_solution[i:j+1] = reversed_segment\n\n        # Additional swap to improve both objectives\n        k = np.random.randint(0, n)\n        if k != i and k != j:\n            new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    # Ensure feasibility: check for duplicates and fix if needed\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Rebuild solution if invalid\n        missing = np.setdiff1d(np.arange(n), new_solution)\n        duplicates = unique[counts > 1]\n        for d in duplicates:\n            idx = np.where(new_solution == d)[0][1:]\n            for i in idx:\n                new_solution[i] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.93749131114538,
            2.652452826499939
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., worst in one objective)\n    objectives = [obj for (sol, obj) in archive]\n    objectives = np.array(objectives)\n    min_cost = np.min(objectives, axis=0)\n    max_cost = np.max(objectives, axis=0)\n\n    # Normalize objectives to identify solutions with high potential\n    normalized = (objectives - min_cost) / (max_cost - min_cost + 1e-10)\n    potential = np.max(normalized, axis=1)  # Solutions with high worst objective\n    selected_index = np.argmax(potential)\n    base_solution = archive[selected_index][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge-swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i, j = np.sort(np.random.choice(n, size=2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Novel edge-swap: reverse the segment and swap edges\n    if len(segment) > 2:\n        reversed_segment = segment[::-1]\n        new_solution[i:j+1] = reversed_segment\n\n        # Additional swap to improve both objectives\n        k = np.random.randint(0, n)\n        if k != i and k != j:\n            new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    # Ensure feasibility: check for duplicates and fix if needed\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Rebuild solution if invalid\n        missing = np.setdiff1d(np.arange(n), new_solution)\n        duplicates = unique[counts > 1]\n        for d in duplicates:\n            idx = np.where(new_solution == d)[0][1:]\n            for i in idx:\n                new_solution[i] = missing[0]\n                missing = missing[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 255,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Rank solutions by their diversity (e.g., sum of squared distances to other solutions)\n    diversity_scores = []\n    for i, sol in enumerate(solutions):\n        distances = [np.sum((sol - other_sol) ** 2) for j, other_sol in enumerate(solutions) if j != i]\n        diversity_scores.append(np.mean(distances))\n\n    # Select the solution with the highest diversity (most potential for improvement)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search strategy\n    for _ in range(3):  # Perform multiple operations for better exploration\n        op = np.random.choice(['insertion', 'reversal', 'swap'])\n\n        if op == 'insertion':\n            # Edge insertion: move a random edge to a new position\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            if i != j:\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [new_solution[i]], new_solution[j+1:]])\n\n        elif op == 'reversal':\n            # Segment reversal: reverse a random segment\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        elif op == 'swap':\n            # Segment swap: swap two random segments\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            k, l = sorted(np.random.choice(n, 2, replace=False))\n            if i != k:\n                seg1 = new_solution[i:j+1]\n                seg2 = new_solution[k:l+1]\n                new_solution = np.concatenate([\n                    new_solution[:i], seg2, new_solution[j+1:k], seg1, new_solution[l+1:]\n                ])\n\n    # Ensure the solution is valid (no duplicates, all nodes included)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or np.any(counts != 1):\n        # Fallback to a random valid solution if invalid\n        new_solution = np.random.permutation(np.arange(n))\n\n    return new_solution\n\n",
        "score": [
            -0.8267340939007801,
            7.556721568107605
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Rank solutions by their diversity (e.g., sum of squared distances to other solutions)\n    diversity_scores = []\n    for i, sol in enumerate(solutions):\n        distances = [np.sum((sol - other_sol) ** 2) for j, other_sol in enumerate(solutions) if j != i]\n        diversity_scores.append(np.mean(distances))\n\n    # Select the solution with the highest diversity (most potential for improvement)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search strategy\n    for _ in range(3):  # Perform multiple operations for better exploration\n        op = np.random.choice(['insertion', 'reversal', 'swap'])\n\n        if op == 'insertion':\n            # Edge insertion: move a random edge to a new position\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            if i != j:\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [new_solution[i]], new_solution[j+1:]])\n\n        elif op == 'reversal':\n            # Segment reversal: reverse a random segment\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        elif op == 'swap':\n            # Segment swap: swap two random segments\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            k, l = sorted(np.random.choice(n, 2, replace=False))\n            if i != k:\n                seg1 = new_solution[i:j+1]\n                seg2 = new_solution[k:l+1]\n                new_solution = np.concatenate([\n                    new_solution[:i], seg2, new_solution[j+1:k], seg1, new_solution[l+1:]\n                ])\n\n    # Ensure the solution is valid (no duplicates, all nodes included)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or np.any(counts != 1):\n        # Fallback to a random valid solution if invalid\n        new_solution = np.random.permutation(np.arange(n))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 256,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability of being non-dominated or showing improvement potential\n    selected_idx = random.choices(range(len(archive)), weights=[1/(i+1) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel segment relocation\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly choose a segment to relocate\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n\n    # Find the best insertion point for the segment in the remaining tour\n    remaining_tour = np.concatenate([new_solution[:a], new_solution[b+1:]])\n    best_cost = float('inf')\n    best_insert_pos = 0\n\n    for i in range(len(remaining_tour)):\n        # Insert segment at position i\n        candidate = np.insert(remaining_tour, i, segment)\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(len(candidate)))\n        cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(len(candidate)))\n\n        # Combine costs using a simple weighted sum (can be replaced with more sophisticated approach)\n        total_cost = 0.5 * cost1 + 0.5 * cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert_pos = i\n\n    # Apply the best insertion\n    new_solution = np.insert(remaining_tour, best_insert_pos, segment)\n\n    # Additional 2.5-opt improvement (optional but effective for TSP)\n    if n >= 5:\n        i, j, k, l, m = random.sample(range(n), 5)\n        if i > j: i, j = j, i\n        if k > l: k, l = l, k\n        if i > k: i, k = k, i\n        if j > l: j, l = l, j\n\n        # Try different permutations of the selected edges\n        candidates = [\n            np.concatenate([new_solution[:i], new_solution[k:l+1], new_solution[j:i:-1], new_solution[l+1:m+1], new_solution[i:j], new_solution[m+1:]]),\n            np.concatenate([new_solution[:i], new_solution[k:l+1], new_solution[j:i:-1], new_solution[m+1:], new_solution[l+1:m+1], new_solution[i:j]]),\n            np.concatenate([new_solution[:i], new_solution[k:l+1], new_solution[i:j], new_solution[l+1:m+1], new_solution[j:i:-1], new_solution[m+1:]])\n        ]\n\n        # Evaluate candidates and keep the best\n        for candidate in candidates:\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(len(candidate)))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(len(candidate)))\n            total_cost = 0.5 * cost1 + 0.5 * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                new_solution = candidate.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.820900886458517,
            11.399101257324219
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability of being non-dominated or showing improvement potential\n    selected_idx = random.choices(range(len(archive)), weights=[1/(i+1) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel segment relocation\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly choose a segment to relocate\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n\n    # Find the best insertion point for the segment in the remaining tour\n    remaining_tour = np.concatenate([new_solution[:a], new_solution[b+1:]])\n    best_cost = float('inf')\n    best_insert_pos = 0\n\n    for i in range(len(remaining_tour)):\n        # Insert segment at position i\n        candidate = np.insert(remaining_tour, i, segment)\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(len(candidate)))\n        cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(len(candidate)))\n\n        # Combine costs using a simple weighted sum (can be replaced with more sophisticated approach)\n        total_cost = 0.5 * cost1 + 0.5 * cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert_pos = i\n\n    # Apply the best insertion\n    new_solution = np.insert(remaining_tour, best_insert_pos, segment)\n\n    # Additional 2.5-opt improvement (optional but effective for TSP)\n    if n >= 5:\n        i, j, k, l, m = random.sample(range(n), 5)\n        if i > j: i, j = j, i\n        if k > l: k, l = l, k\n        if i > k: i, k = k, i\n        if j > l: j, l = l, j\n\n        # Try different permutations of the selected edges\n        candidates = [\n            np.concatenate([new_solution[:i], new_solution[k:l+1], new_solution[j:i:-1], new_solution[l+1:m+1], new_solution[i:j], new_solution[m+1:]]),\n            np.concatenate([new_solution[:i], new_solution[k:l+1], new_solution[j:i:-1], new_solution[m+1:], new_solution[l+1:m+1], new_solution[i:j]]),\n            np.concatenate([new_solution[:i], new_solution[k:l+1], new_solution[i:j], new_solution[l+1:m+1], new_solution[j:i:-1], new_solution[m+1:]])\n        ]\n\n        # Evaluate candidates and keep the best\n        for candidate in candidates:\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(len(candidate)))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(len(candidate)))\n            total_cost = 0.5 * cost1 + 0.5 * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                new_solution = candidate.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 257,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol_obj[0] for sol_obj in archive]\n    archive_objectives = [sol_obj[1] for sol_obj in archive]\n\n    # Calculate the improvement potential (simple heuristic: select solutions with lower costs)\n    potential_scores = [sum(obj) for obj in archive_objectives]\n    selected_index = np.argmin(potential_scores)\n    base_solution = archive_solutions[selected_index].copy()\n\n    # Hybrid local search strategy: combine 2-opt with a custom move\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a random 2-opt move\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then apply a custom move: relocate a segment to a different position\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length - 1)\n    segment = new_solution[start:start+segment_length]\n    remaining = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n    insert_pos = random.randint(0, len(remaining) - segment_length)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure the solution remains valid\n    if len(new_solution) != len(base_solution) or len(np.unique(new_solution)) != len(base_solution):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7639101703301994,
            4.131360411643982
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol_obj[0] for sol_obj in archive]\n    archive_objectives = [sol_obj[1] for sol_obj in archive]\n\n    # Calculate the improvement potential (simple heuristic: select solutions with lower costs)\n    potential_scores = [sum(obj) for obj in archive_objectives]\n    selected_index = np.argmin(potential_scores)\n    base_solution = archive_solutions[selected_index].copy()\n\n    # Hybrid local search strategy: combine 2-opt with a custom move\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a random 2-opt move\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then apply a custom move: relocate a segment to a different position\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length - 1)\n    segment = new_solution[start:start+segment_length]\n    remaining = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n    insert_pos = random.randint(0, len(remaining) - segment_length)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure the solution remains valid\n    if len(new_solution) != len(base_solution) or len(np.unique(new_solution)) != len(base_solution):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 258,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Combine 3-opt with a custom move to explore both objectives\n    n = len(base_solution)\n    if n < 3:\n        return new_solution  # No improvement possible for small instances\n\n    # Randomly select three distinct edges to modify\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Apply a custom 3-opt-like move that considers both objectives\n    # This move swaps segments to potentially reduce both costs\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[b:c] = np.flip(new_solution[b:c])\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if custom move is invalid\n        i, j = np.random.choice(n, size=2, replace=False)\n        i, j = min(i, j), max(i, j)\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.7829916598967559,
            2.722633481025696
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Combine 3-opt with a custom move to explore both objectives\n    n = len(base_solution)\n    if n < 3:\n        return new_solution  # No improvement possible for small instances\n\n    # Randomly select three distinct edges to modify\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Apply a custom 3-opt-like move that considers both objectives\n    # This move swaps segments to potentially reduce both costs\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[b:c] = np.flip(new_solution[b:c])\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if custom move is invalid\n        i, j = np.random.choice(n, size=2, replace=False)\n        i, j = min(i, j), max(i, j)\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 259,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.array([0.5, 0.5])  # Equal weights for both objectives\n    objectives = np.array([obj for _, obj in archive])\n    scores = np.dot(objectives, weights)\n    best_idx = np.argmin(scores)\n    base_solution = archive[best_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 2-opt with edge-swap consideration\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Perform 2-opt swap\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Evaluate the new solution\n        new_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        new_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # If the new solution is worse, revert with some probability\n        if np.random.rand() < 0.3:  # 30% chance to accept worse solution\n            new_solution = base_solution.copy()\n        else:\n            base_solution = new_solution.copy()\n\n        # Additional edge-swap heuristic: consider swapping edges based on both objectives\n        if np.random.rand() < 0.5:  # 50% chance to apply edge-swap\n            k, l = np.random.choice(n, size=2, replace=False)\n            if k > l:\n                k, l = l, k\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7640396728761236,
            6.81116658449173
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.array([0.5, 0.5])  # Equal weights for both objectives\n    objectives = np.array([obj for _, obj in archive])\n    scores = np.dot(objectives, weights)\n    best_idx = np.argmin(scores)\n    base_solution = archive[best_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 2-opt with edge-swap consideration\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Perform 2-opt swap\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Evaluate the new solution\n        new_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        new_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # If the new solution is worse, revert with some probability\n        if np.random.rand() < 0.3:  # 30% chance to accept worse solution\n            new_solution = base_solution.copy()\n        else:\n            base_solution = new_solution.copy()\n\n        # Additional edge-swap heuristic: consider swapping edges based on both objectives\n        if np.random.rand() < 0.5:  # 50% chance to apply edge-swap\n            k, l = np.random.choice(n, size=2, replace=False)\n            if k > l:\n                k, l = l, k\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 260,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its non-dominated rank\n    # (simplified heuristic: higher cost solutions are more likely to be selected)\n    weights = [sum(obj) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operators\n\n    # 1. Edge swapping (like 2-opt but more flexible)\n    i, j = sorted(random.sample(range(1, n), 2))\n    if j - i > 1:  # Ensure at least one node between i and j\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # 2. Segment reversal with insertion (novel operator)\n    if n > 4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    # 3. Random insertion (perturbation)\n    if n > 3:\n        pos = random.randint(1, n-1)\n        node = new_solution[pos]\n        new_solution = np.concatenate([new_solution[:pos], new_solution[pos+1:], [node]])\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if feasibility violated\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.73743165638093,
            1.407434105873108
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its non-dominated rank\n    # (simplified heuristic: higher cost solutions are more likely to be selected)\n    weights = [sum(obj) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operators\n\n    # 1. Edge swapping (like 2-opt but more flexible)\n    i, j = sorted(random.sample(range(1, n), 2))\n    if j - i > 1:  # Ensure at least one node between i and j\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # 2. Segment reversal with insertion (novel operator)\n    if n > 4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    # 3. Random insertion (perturbation)\n    if n > 3:\n        pos = random.randint(1, n-1)\n        node = new_solution[pos]\n        new_solution = np.concatenate([new_solution[:pos], new_solution[pos+1:], [node]])\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if feasibility violated\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 261,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    costs = np.sum(objectives, axis=1)\n    probabilities = 1 / (costs + 1e-8)  # Small epsilon to avoid division by zero\n    probabilities = probabilities / np.sum(probabilities)\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    N = len(base_solution)\n    if N < 4:\n        return new_solution  # Too small to apply meaningful operations\n\n    # Hybrid local search strategy\n    operation = random.choice(['edge_insertion', 'segment_reversal', 'edge_swap'])\n\n    if operation == 'edge_insertion':\n        # Randomly select two non-consecutive edges and reconnect them\n        i, j = sorted(random.sample(range(N), 2))\n        while j == i + 1:\n            i, j = sorted(random.sample(range(N), 2))\n\n        # Create new edges by inserting node j between i and i+1\n        new_solution = np.concatenate([\n            base_solution[:i+1],\n            [base_solution[j]],\n            base_solution[i+1:j],\n            base_solution[j+1:]\n        ])\n\n    elif operation == 'segment_reversal':\n        # Reverse a random segment of the tour\n        i, j = sorted(random.sample(range(N), 2))\n        new_solution[i:j+1] = base_solution[i:j+1][::-1]\n\n    elif operation == 'edge_swap':\n        # Novel edge swap operation: swap two edges that are not adjacent\n        i, j = sorted(random.sample(range(N), 2))\n        while j == i + 1 or abs(j - i) == N - 1:\n            i, j = sorted(random.sample(range(N), 2))\n\n        # Perform the swap\n        new_solution[i], new_solution[j] = base_solution[j], base_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.798710865229903,
            1.8023104071617126
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    costs = np.sum(objectives, axis=1)\n    probabilities = 1 / (costs + 1e-8)  # Small epsilon to avoid division by zero\n    probabilities = probabilities / np.sum(probabilities)\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    N = len(base_solution)\n    if N < 4:\n        return new_solution  # Too small to apply meaningful operations\n\n    # Hybrid local search strategy\n    operation = random.choice(['edge_insertion', 'segment_reversal', 'edge_swap'])\n\n    if operation == 'edge_insertion':\n        # Randomly select two non-consecutive edges and reconnect them\n        i, j = sorted(random.sample(range(N), 2))\n        while j == i + 1:\n            i, j = sorted(random.sample(range(N), 2))\n\n        # Create new edges by inserting node j between i and i+1\n        new_solution = np.concatenate([\n            base_solution[:i+1],\n            [base_solution[j]],\n            base_solution[i+1:j],\n            base_solution[j+1:]\n        ])\n\n    elif operation == 'segment_reversal':\n        # Reverse a random segment of the tour\n        i, j = sorted(random.sample(range(N), 2))\n        new_solution[i:j+1] = base_solution[i:j+1][::-1]\n\n    elif operation == 'edge_swap':\n        # Novel edge swap operation: swap two edges that are not adjacent\n        i, j = sorted(random.sample(range(N), 2))\n        while j == i + 1 or abs(j - i) == N - 1:\n            i, j = sorted(random.sample(range(N), 2))\n\n        # Perform the swap\n        new_solution[i], new_solution[j] = base_solution[j], base_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 262,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low objective values\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swapping with a novel insertion-based move\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Edge swapping (similar to 2-opt but more flexible)\n    if random.random() < 0.7:  # 70% chance for edge swap\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:  # Novel insertion-based move\n        # Remove a random segment and reinsert it in a different position\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure the solution remains feasible (no duplicates or omissions)\n    assert len(new_solution) == len(base_solution) and len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.8562472758645441,
            2.4548208713531494
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low objective values\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swapping with a novel insertion-based move\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Edge swapping (similar to 2-opt but more flexible)\n    if random.random() < 0.7:  # 70% chance for edge swap\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:  # Novel insertion-based move\n        # Remove a random segment and reinsert it in a different position\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure the solution remains feasible (no duplicates or omissions)\n    assert len(new_solution) == len(base_solution) and len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 263,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a bias towards non-dominated or high-potential solutions\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1.0 / (1 + i) for i in range(len(archive))],  # Higher probability for earlier (better) solutions\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a custom edge-swap\n    n = len(base_solution)\n    if n < 3:\n        return new_solution  # No improvement possible\n\n    # Randomly select three distinct edges to modify\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse the segment between i and j, then between j and k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Custom edge-swap: swap edges between i and k if it improves both objectives\n    if random.random() < 0.3:  # 30% chance to apply edge-swap\n        # Calculate current and potential costs\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[k], new_solution[(k+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[k], new_solution[(k+1)%n]]\n\n        # Propose new edges\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(k+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(k+1)%n]]\n\n        # Apply if both objectives improve\n        if new_cost1 < current_cost1 and new_cost2 < current_cost2:\n            new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates and all nodes visited)\n    assert len(new_solution) == len(np.unique(new_solution)), \"Invalid solution: duplicate nodes\"\n    assert len(new_solution) == len(instance), \"Invalid solution: missing nodes\"\n\n    return new_solution\n\n",
        "score": [
            -0.8475686363219197,
            2.4577507972717285
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a bias towards non-dominated or high-potential solutions\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1.0 / (1 + i) for i in range(len(archive))],  # Higher probability for earlier (better) solutions\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a custom edge-swap\n    n = len(base_solution)\n    if n < 3:\n        return new_solution  # No improvement possible\n\n    # Randomly select three distinct edges to modify\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse the segment between i and j, then between j and k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Custom edge-swap: swap edges between i and k if it improves both objectives\n    if random.random() < 0.3:  # 30% chance to apply edge-swap\n        # Calculate current and potential costs\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[k], new_solution[(k+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[k], new_solution[(k+1)%n]]\n\n        # Propose new edges\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(k+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(k+1)%n]]\n\n        # Apply if both objectives improve\n        if new_cost1 < current_cost1 and new_cost2 < current_cost2:\n            new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates and all nodes visited)\n    assert len(new_solution) == len(np.unique(new_solution)), \"Invalid solution: duplicate nodes\"\n    assert len(new_solution) == len(instance), \"Invalid solution: missing nodes\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 264,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its dominance rank\n    # (higher rank = more promising for improvement)\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate dominance ranks (simplified: higher cost = worse)\n    ranks = [sum(obj) for obj in objectives]\n    min_rank = min(ranks)\n    max_rank = max(ranks)\n\n    # Normalize ranks to [0, 1] for selection probability\n    if max_rank == min_rank:\n        probs = [1.0 / len(archive)] * len(archive)\n    else:\n        normalized_ranks = [(max_rank - r) / (max_rank - min_rank) for r in ranks]\n        probs = [r / sum(normalized_ranks) for r in normalized_ranks]\n\n    selected_idx = np.random.choice(len(solutions), p=probs)\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search: edge insertion + node relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge insertion: randomly select two edges and reconnect them\n    if n > 3:\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure we don't create a sub-tour\n        if i + 1 < j:\n            # Remove edges (i, i+1) and (j, j+1)\n            # Insert edges (i, j) and (i+1, j+1)\n            new_solution = np.concatenate([\n                new_solution[:i+1],\n                new_solution[j+1:],\n                new_solution[i+1:j+1],\n                new_solution[j+1:]\n            ])\n            if len(new_solution) != n:\n                # If length changed, revert to original\n                new_solution = base_solution.copy()\n\n    # Node relocation: move a random node to a new position\n    if n > 2:\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        # Remove the node\n        new_solution = np.delete(new_solution, node_idx)\n        # Insert at a random position\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Verify solution is valid (no duplicates, all nodes present)\n    if len(new_solution) != n or len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6862757391423032,
            2.6574804186820984
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its dominance rank\n    # (higher rank = more promising for improvement)\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate dominance ranks (simplified: higher cost = worse)\n    ranks = [sum(obj) for obj in objectives]\n    min_rank = min(ranks)\n    max_rank = max(ranks)\n\n    # Normalize ranks to [0, 1] for selection probability\n    if max_rank == min_rank:\n        probs = [1.0 / len(archive)] * len(archive)\n    else:\n        normalized_ranks = [(max_rank - r) / (max_rank - min_rank) for r in ranks]\n        probs = [r / sum(normalized_ranks) for r in normalized_ranks]\n\n    selected_idx = np.random.choice(len(solutions), p=probs)\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search: edge insertion + node relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge insertion: randomly select two edges and reconnect them\n    if n > 3:\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure we don't create a sub-tour\n        if i + 1 < j:\n            # Remove edges (i, i+1) and (j, j+1)\n            # Insert edges (i, j) and (i+1, j+1)\n            new_solution = np.concatenate([\n                new_solution[:i+1],\n                new_solution[j+1:],\n                new_solution[i+1:j+1],\n                new_solution[j+1:]\n            ])\n            if len(new_solution) != n:\n                # If length changed, revert to original\n                new_solution = base_solution.copy()\n\n    # Node relocation: move a random node to a new position\n    if n > 2:\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        # Remove the node\n        new_solution = np.delete(new_solution, node_idx)\n        # Insert at a random position\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Verify solution is valid (no duplicates, all nodes present)\n    if len(new_solution) != n or len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 265,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: edge insertion + node relocation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Edge insertion: remove a random edge and insert it elsewhere\n    if n > 3:\n        i = np.random.randint(0, n)\n        j = (i + 1) % n\n        k = np.random.randint(0, n)\n        while k in {i, j, (i-1)%n, (j+1)%n}:\n            k = np.random.randint(0, n)\n\n        # Reconstruct the tour with the new edge\n        new_solution = np.concatenate([\n            new_solution[:i+1],\n            new_solution[k:],\n            new_solution[i+1:k],\n            new_solution[:k]\n        ])\n\n    # Node relocation: move a random node to a better position\n    if n > 2:\n        node = np.random.randint(0, n)\n        current_pos = np.where(new_solution == node)[0][0]\n        new_solution = np.delete(new_solution, current_pos)\n\n        # Evaluate possible insertion positions\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(n-1):\n            candidate = np.insert(new_solution, pos, node)\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9010383654074712,
            12.010110437870026
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: edge insertion + node relocation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Edge insertion: remove a random edge and insert it elsewhere\n    if n > 3:\n        i = np.random.randint(0, n)\n        j = (i + 1) % n\n        k = np.random.randint(0, n)\n        while k in {i, j, (i-1)%n, (j+1)%n}:\n            k = np.random.randint(0, n)\n\n        # Reconstruct the tour with the new edge\n        new_solution = np.concatenate([\n            new_solution[:i+1],\n            new_solution[k:],\n            new_solution[i+1:k],\n            new_solution[:k]\n        ])\n\n    # Node relocation: move a random node to a better position\n    if n > 2:\n        node = np.random.randint(0, n)\n        current_pos = np.where(new_solution == node)[0][0]\n        new_solution = np.delete(new_solution, current_pos)\n\n        # Evaluate possible insertion positions\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(n-1):\n            candidate = np.insert(new_solution, pos, node)\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 266,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its dominance rank\n    # (higher-ranked solutions are more likely to be selected)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = np.sum(ranks, axis=1)\n    probabilities = 1.0 / (dominance_scores + 1)\n    probabilities = probabilities / np.sum(probabilities)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # Hybrid local search strategy: combine edge insertion with segment relocation\n    for _ in range(10):  # Perform multiple iterations for better exploration\n        # Randomly choose between two operators\n        if random.random() < 0.5:\n            # Edge insertion operator\n            i, j = sorted(random.sample(range(n_nodes), 2))\n            if i + 1 != j:  # Ensure we're not just swapping adjacent nodes\n                # Remove edge between i and i+1, and between j and j+1\n                # Insert the segment between i and j after i\n                segment = new_solution[i+1:j+1]\n                new_solution = np.concatenate([\n                    new_solution[:i+1],\n                    segment,\n                    new_solution[i+1:i+1],\n                    new_solution[j+1:]\n                ])\n        else:\n            # Novel segment relocation operator\n            # Select a random segment and relocate it to a different position\n            seg_length = random.randint(2, min(5, n_nodes // 2))\n            start = random.randint(0, n_nodes - seg_length)\n            segment = new_solution[start:start+seg_length]\n            # Find a new position that doesn't create duplicates\n            possible_positions = [i for i in range(n_nodes) if i < start or i >= start + seg_length]\n            if possible_positions:\n                new_pos = random.choice(possible_positions)\n                new_solution = np.concatenate([\n                    new_solution[:new_pos],\n                    segment,\n                    new_solution[new_pos:start],\n                    new_solution[start+seg_length:]\n                ])\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n_nodes, \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.5651087277271273,
            0.6484940052032471
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its dominance rank\n    # (higher-ranked solutions are more likely to be selected)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    dominance_scores = np.sum(ranks, axis=1)\n    probabilities = 1.0 / (dominance_scores + 1)\n    probabilities = probabilities / np.sum(probabilities)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # Hybrid local search strategy: combine edge insertion with segment relocation\n    for _ in range(10):  # Perform multiple iterations for better exploration\n        # Randomly choose between two operators\n        if random.random() < 0.5:\n            # Edge insertion operator\n            i, j = sorted(random.sample(range(n_nodes), 2))\n            if i + 1 != j:  # Ensure we're not just swapping adjacent nodes\n                # Remove edge between i and i+1, and between j and j+1\n                # Insert the segment between i and j after i\n                segment = new_solution[i+1:j+1]\n                new_solution = np.concatenate([\n                    new_solution[:i+1],\n                    segment,\n                    new_solution[i+1:i+1],\n                    new_solution[j+1:]\n                ])\n        else:\n            # Novel segment relocation operator\n            # Select a random segment and relocate it to a different position\n            seg_length = random.randint(2, min(5, n_nodes // 2))\n            start = random.randint(0, n_nodes - seg_length)\n            segment = new_solution[start:start+seg_length]\n            # Find a new position that doesn't create duplicates\n            possible_positions = [i for i in range(n_nodes) if i < start or i >= start + seg_length]\n            if possible_positions:\n                new_pos = random.choice(possible_positions)\n                new_solution = np.concatenate([\n                    new_solution[:new_pos],\n                    segment,\n                    new_solution[new_pos:start],\n                    new_solution[start+seg_length:]\n                ])\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n_nodes, \"Generated solution is invalid\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 267,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high variance in objectives)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of edge insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to reverse (3-opt like move)\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Randomly select a node to reinsert (edge insertion)\n    if n > 4:\n        d = random.randint(0, n-1)\n        if d != a and d != b:\n            node = new_solution[d]\n            new_solution = np.delete(new_solution, d)\n            insert_pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7775586930105982,
            2.1229280829429626
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high variance in objectives)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of edge insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to reverse (3-opt like move)\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Randomly select a node to reinsert (edge insertion)\n    if n > 4:\n        d = random.randint(0, n-1)\n        if d != a and d != b:\n            node = new_solution[d]\n            new_solution = np.delete(new_solution, d)\n            insert_pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 268,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution based on a combination of randomness and objective diversity\n    candidates = []\n    for sol, (obj1, obj2) in archive:\n        # Consider solutions with lower objectives as more promising\n        score = obj1 + obj2\n        candidates.append((sol, score))\n\n    # Sort by score and select top 30% candidates\n    candidates.sort(key=lambda x: x[1])\n    top_candidates = candidates[:max(1, len(candidates) // 3)]\n    base_solution, _ = random.choice(top_candidates)\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of edge insertion and node shift\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operators\n\n    # Step 1: Randomly select a segment to operate on\n    segment_length = min(4, n // 2)  # Ensure segment is not too large\n    start = random.randint(0, n - segment_length - 1)\n    end = start + segment_length\n\n    # Step 2: Extract the segment and remove it\n    segment = new_solution[start:end]\n    remaining = np.concatenate([new_solution[:start], new_solution[end:]])\n\n    # Step 3: Find the best insertion point for the segment\n    best_insert_pos = -1\n    min_total_cost = float('inf')\n\n    for i in range(len(remaining)):\n        # Insert segment at position i\n        candidate = np.concatenate([remaining[:i], segment, remaining[i:]])\n\n        # Calculate total cost in both objectives\n        cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(len(candidate)))\n        cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(len(candidate)))\n\n        if cost1 + cost2 < min_total_cost:\n            min_total_cost = cost1 + cost2\n            best_insert_pos = i\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([remaining[:best_insert_pos], segment, remaining[best_insert_pos:]])\n\n    # Step 4: Apply a node shift for further improvement\n    if n >= 4:\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        if i != j:\n            # Shift node i to position j\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6621358869673664,
            11.231392920017242
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution based on a combination of randomness and objective diversity\n    candidates = []\n    for sol, (obj1, obj2) in archive:\n        # Consider solutions with lower objectives as more promising\n        score = obj1 + obj2\n        candidates.append((sol, score))\n\n    # Sort by score and select top 30% candidates\n    candidates.sort(key=lambda x: x[1])\n    top_candidates = candidates[:max(1, len(candidates) // 3)]\n    base_solution, _ = random.choice(top_candidates)\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of edge insertion and node shift\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operators\n\n    # Step 1: Randomly select a segment to operate on\n    segment_length = min(4, n // 2)  # Ensure segment is not too large\n    start = random.randint(0, n - segment_length - 1)\n    end = start + segment_length\n\n    # Step 2: Extract the segment and remove it\n    segment = new_solution[start:end]\n    remaining = np.concatenate([new_solution[:start], new_solution[end:]])\n\n    # Step 3: Find the best insertion point for the segment\n    best_insert_pos = -1\n    min_total_cost = float('inf')\n\n    for i in range(len(remaining)):\n        # Insert segment at position i\n        candidate = np.concatenate([remaining[:i], segment, remaining[i:]])\n\n        # Calculate total cost in both objectives\n        cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(len(candidate)))\n        cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(len(candidate)))\n\n        if cost1 + cost2 < min_total_cost:\n            min_total_cost = cost1 + cost2\n            best_insert_pos = i\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([remaining[:best_insert_pos], segment, remaining[best_insert_pos:]])\n\n    # Step 4: Apply a node shift for further improvement\n    if n >= 4:\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        if i != j:\n            # Shift node i to position j\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 269,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weights = np.random.uniform(0.1, 0.9, size=2)\n    weights /= np.sum(weights)\n    weighted_costs = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    base_solution = archive[np.argmin(weighted_costs)][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    if n < 5:\n        # For small instances, use a simple 2-opt\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # For larger instances, use a combination of 3-opt and segment inversion\n        if np.random.random() < 0.7:\n            # 3-opt: choose 3 distinct positions and reverse segments\n            i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n            new_solution[i:j] = new_solution[i:j][::-1]\n            new_solution[j:k] = new_solution[j:k][::-1]\n        else:\n            # Novel segment inversion: reverse a segment and insert it at a different position\n            i, j = sorted(np.random.choice(n, size=2, replace=False))\n            segment = new_solution[i:j]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment[::-1]])\n\n    # Ensure the solution remains valid (no duplicates, all nodes present)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.775016412467041,
            2.0961769819259644
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weights = np.random.uniform(0.1, 0.9, size=2)\n    weights /= np.sum(weights)\n    weighted_costs = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    base_solution = archive[np.argmin(weighted_costs)][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    if n < 5:\n        # For small instances, use a simple 2-opt\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # For larger instances, use a combination of 3-opt and segment inversion\n        if np.random.random() < 0.7:\n            # 3-opt: choose 3 distinct positions and reverse segments\n            i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n            new_solution[i:j] = new_solution[i:j][::-1]\n            new_solution[j:k] = new_solution[j:k][::-1]\n        else:\n            # Novel segment inversion: reverse a segment and insert it at a different position\n            i, j = sorted(np.random.choice(n, size=2, replace=False))\n            segment = new_solution[i:j]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment[::-1]])\n\n    # Ensure the solution remains valid (no duplicates, all nodes present)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 270,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by a combined objective score (sum of normalized costs)\n        objectives = np.array([obj for _, obj in archive])\n        normalized_costs = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n        combined_scores = np.sum(normalized_costs, axis=1)\n        selected_idx = np.argmin(combined_scores)  # Prefer solutions with lower combined cost\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Random segment inversion or edge swap\n    if random.random() < 0.7:  # 70% chance for segment inversion\n        # Select a random segment to invert\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:  # 30% chance for edge swap\n        # Select two random edges and swap their nodes\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Invalid neighbor: Duplicate nodes or missing nodes\"\n\n    return new_solution\n\n",
        "score": [
            -0.681408365471076,
            1.7557934522628784
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by a combined objective score (sum of normalized costs)\n        objectives = np.array([obj for _, obj in archive])\n        normalized_costs = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n        combined_scores = np.sum(normalized_costs, axis=1)\n        selected_idx = np.argmin(combined_scores)  # Prefer solutions with lower combined cost\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Random segment inversion or edge swap\n    if random.random() < 0.7:  # 70% chance for segment inversion\n        # Select a random segment to invert\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:  # 30% chance for edge swap\n        # Select two random edges and swap their nodes\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Invalid neighbor: Duplicate nodes or missing nodes\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 271,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability based on its dominance or diversity\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate dominance scores (simplified for this example)\n    dominance_scores = []\n    for i in range(len(archive)):\n        dominated = 0\n        for j in range(len(archive)):\n            if i != j:\n                if objectives[i][0] <= objectives[j][0] and objectives[i][1] <= objectives[j][1] and (objectives[i][0] < objectives[j][0] or objectives[i][1] < objectives[j][1]):\n                    dominated += 1\n        dominance_scores.append(dominated)\n\n    # Select a solution with lower dominance score (more promising)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel move\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two non-adjacent edges to perform 2-opt\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    if i != j and abs(i - j) > 1:\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Novel move: swap two random nodes that are not adjacent\n    k, l = sorted(random.sample(range(n), 2))\n    if k != l and abs(k - l) > 1:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.unique(new_solution), np.arange(n)):\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9203352062089356,
            7.376961290836334
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability based on its dominance or diversity\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate dominance scores (simplified for this example)\n    dominance_scores = []\n    for i in range(len(archive)):\n        dominated = 0\n        for j in range(len(archive)):\n            if i != j:\n                if objectives[i][0] <= objectives[j][0] and objectives[i][1] <= objectives[j][1] and (objectives[i][0] < objectives[j][0] or objectives[i][1] < objectives[j][1]):\n                    dominated += 1\n        dominance_scores.append(dominated)\n\n    # Select a solution with lower dominance score (more promising)\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel move\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two non-adjacent edges to perform 2-opt\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    if i != j and abs(i - j) > 1:\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Novel move: swap two random nodes that are not adjacent\n    k, l = sorted(random.sample(range(n), 2))\n    if k != l and abs(k - l) > 1:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.unique(new_solution), np.arange(n)):\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 272,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in both objectives)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))  # Sort by sum of objectives\n    top_k = max(1, len(sorted_archive) // 5)\n    candidates = sorted_archive[:top_k]\n    base_solution, _ = random.choice(candidates)\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct positions\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse segments to potentially reduce tour length\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Novel segment reversal: reverse a segment and insert it elsewhere\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure the solution remains valid (no duplicates and all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or not np.array_equal(np.sort(unique_nodes), np.arange(n)):\n        # Fallback to 2-opt if the solution becomes invalid\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7851789373354541,
            2.0063206553459167
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in both objectives)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))  # Sort by sum of objectives\n    top_k = max(1, len(sorted_archive) // 5)\n    candidates = sorted_archive[:top_k]\n    base_solution, _ = random.choice(candidates)\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct positions\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse segments to potentially reduce tour length\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Novel segment reversal: reverse a segment and insert it elsewhere\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure the solution remains valid (no duplicates and all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or not np.array_equal(np.sort(unique_nodes), np.arange(n)):\n        # Fallback to 2-opt if the solution becomes invalid\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 273,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability of being non-dominated or having potential for improvement\n    selected_solution, _ = random.choices(\n        archive,\n        weights=[1 / (1 + np.mean(obj)) for _, obj in archive],  # Prefer solutions with lower average cost\n        k=1\n    )[0]\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal strategy\n    for _ in range(3):  # Perform multiple iterations to escape local optima\n        # Randomly select three distinct segments\n        i, j, k = sorted(random.sample(range(1, n-1), 3))\n\n        # Apply 3-opt: reverse segments to explore different tours\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Novel segment reversal: reverse a random segment and insert it elsewhere\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[start+segment_length:],\n            segment[::-1]  # Reverse the segment before insertion\n        ])\n\n        # Ensure the solution remains feasible by checking for duplicates\n        if len(np.unique(new_solution)) != n:\n            # If invalid, revert to the original segment\n            new_solution = np.concatenate([\n                new_solution[:start],\n                segment,\n                new_solution[start:]\n            ])\n\n    return new_solution\n\n",
        "score": [
            -0.8664155780586725,
            2.8768829703330994
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability of being non-dominated or having potential for improvement\n    selected_solution, _ = random.choices(\n        archive,\n        weights=[1 / (1 + np.mean(obj)) for _, obj in archive],  # Prefer solutions with lower average cost\n        k=1\n    )[0]\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal strategy\n    for _ in range(3):  # Perform multiple iterations to escape local optima\n        # Randomly select three distinct segments\n        i, j, k = sorted(random.sample(range(1, n-1), 3))\n\n        # Apply 3-opt: reverse segments to explore different tours\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Novel segment reversal: reverse a random segment and insert it elsewhere\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[start+segment_length:],\n            segment[::-1]  # Reverse the segment before insertion\n        ])\n\n        # Ensure the solution remains feasible by checking for duplicates\n        if len(np.unique(new_solution)) != n:\n            # If invalid, revert to the original segment\n            new_solution = np.concatenate([\n                new_solution[:start],\n                segment,\n                new_solution[start:]\n            ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 274,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with the best trade-off between objectives (using Pareto dominance or hypervolume)\n    selected_idx = np.argmin([(obj1 + obj2) for (sol, (obj1, obj2)) in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a custom edge-swap heuristic\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct edges to modify\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Perform a 3-opt move (reverses segments between selected edges)\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Custom edge-swap: Swap nodes at positions a and c if it improves both objectives\n    temp_solution = new_solution.copy()\n    temp_solution[a], temp_solution[c] = temp_solution[c], temp_solution[a]\n\n    # Evaluate the original and swapped solutions\n    def calculate_total_cost(solution, distance_matrix):\n        total = 0\n        for i in range(len(solution)):\n            total += distance_matrix[solution[i-1], solution[i]]\n        return total\n\n    original_cost1 = calculate_total_cost(new_solution, distance_matrix_1)\n    original_cost2 = calculate_total_cost(new_solution, distance_matrix_2)\n    swapped_cost1 = calculate_total_cost(temp_solution, distance_matrix_1)\n    swapped_cost2 = calculate_total_cost(temp_solution, distance_matrix_2)\n\n    # Accept the swap if it improves both objectives\n    if (swapped_cost1 < original_cost1) and (swapped_cost2 < original_cost2):\n        new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.6211571464337942,
            2.490059554576874
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with the best trade-off between objectives (using Pareto dominance or hypervolume)\n    selected_idx = np.argmin([(obj1 + obj2) for (sol, (obj1, obj2)) in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a custom edge-swap heuristic\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct edges to modify\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Perform a 3-opt move (reverses segments between selected edges)\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Custom edge-swap: Swap nodes at positions a and c if it improves both objectives\n    temp_solution = new_solution.copy()\n    temp_solution[a], temp_solution[c] = temp_solution[c], temp_solution[a]\n\n    # Evaluate the original and swapped solutions\n    def calculate_total_cost(solution, distance_matrix):\n        total = 0\n        for i in range(len(solution)):\n            total += distance_matrix[solution[i-1], solution[i]]\n        return total\n\n    original_cost1 = calculate_total_cost(new_solution, distance_matrix_1)\n    original_cost2 = calculate_total_cost(new_solution, distance_matrix_2)\n    swapped_cost1 = calculate_total_cost(temp_solution, distance_matrix_1)\n    swapped_cost2 = calculate_total_cost(temp_solution, distance_matrix_2)\n\n    # Accept the swap if it improves both objectives\n    if (swapped_cost1 < original_cost1) and (swapped_cost2 < original_cost2):\n        new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 275,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.5, 0.5]  # Equal weights for both objectives\n    archive_sorted = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel move\n    n = len(base_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Apply a novel move: reverse a segment and insert it elsewhere\n    if j - i > 2:\n        segment = new_solution[i:j+1]\n        np.random.shuffle(segment)\n        new_solution[i:j+1] = segment\n\n    # Ensure the solution remains feasible (no duplicates)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by reinserting missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            pos = np.random.randint(0, n)\n            new_solution[pos] = node\n\n    return new_solution\n\n",
        "score": [
            -0.6497276694729724,
            2.512991487979889
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.5, 0.5]  # Equal weights for both objectives\n    archive_sorted = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel move\n    n = len(base_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Apply a novel move: reverse a segment and insert it elsewhere\n    if j - i > 2:\n        segment = new_solution[i:j+1]\n        np.random.shuffle(segment)\n        new_solution[i:j+1] = segment\n\n    # Ensure the solution remains feasible (no duplicates)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by reinserting missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            pos = np.random.randint(0, n)\n            new_solution[pos] = node\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 276,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its total cost\n    costs = [sum(obj) for _, obj in archive]\n    total_cost = sum(costs)\n    probabilities = [1 - (cost / total_cost) for cost in costs]\n    probabilities = [p / sum(probabilities) for p in probabilities]\n\n    selected_idx = random.choices(range(len(archive)), weights=probabilities, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine segment reversal with edge exchange\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Segment reversal with random segment length\n    seg_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - seg_length)\n    end = start + seg_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge exchange with probability\n    if random.random() < 0.7:\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Perform a 2-opt-like exchange but with a twist\n            new_segment = new_solution[i:j+1]\n            new_segment[1:-1] = new_segment[-2:0:-1]\n            new_solution[i:j+1] = new_segment\n\n    # Novel insertion operator: move a random segment to a new position\n    if random.random() < 0.5 and n > 4:\n        seg_length = random.randint(2, min(4, n // 3))\n        start = random.randint(0, n - seg_length)\n        segment = new_solution[start:start+seg_length]\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[start+seg_length:]\n        ])\n        insert_pos = random.randint(0, len(new_solution) - seg_length)\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n    # Ensure the solution remains valid (no duplicates, all nodes present)\n    if len(np.unique(new_solution)) != len(instance):\n        # Fallback: random shuffle if invalid\n        np.random.shuffle(new_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.8213207872060864,
            2.2387918829917908
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its total cost\n    costs = [sum(obj) for _, obj in archive]\n    total_cost = sum(costs)\n    probabilities = [1 - (cost / total_cost) for cost in costs]\n    probabilities = [p / sum(probabilities) for p in probabilities]\n\n    selected_idx = random.choices(range(len(archive)), weights=probabilities, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine segment reversal with edge exchange\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Segment reversal with random segment length\n    seg_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - seg_length)\n    end = start + seg_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge exchange with probability\n    if random.random() < 0.7:\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Perform a 2-opt-like exchange but with a twist\n            new_segment = new_solution[i:j+1]\n            new_segment[1:-1] = new_segment[-2:0:-1]\n            new_solution[i:j+1] = new_segment\n\n    # Novel insertion operator: move a random segment to a new position\n    if random.random() < 0.5 and n > 4:\n        seg_length = random.randint(2, min(4, n // 3))\n        start = random.randint(0, n - seg_length)\n        segment = new_solution[start:start+seg_length]\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[start+seg_length:]\n        ])\n        insert_pos = random.randint(0, len(new_solution) - seg_length)\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n    # Ensure the solution remains valid (no duplicates, all nodes present)\n    if len(np.unique(new_solution)) != len(instance):\n        # Fallback: random shuffle if invalid\n        np.random.shuffle(new_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 277,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = [sol for sol, obj in archive if obj[0] > np.min([o[0] for _, o in archive]) or obj[1] > np.min([o[1] for _, o in archive])]\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n\n    base_solution = random.choice(candidates).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge insertion with a novel segment-based move\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Edge insertion (like 2-opt but more flexible)\n    i, j = sorted(random.sample(range(n), 2))\n    segment = base_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    # Step 2: Novel segment-based move (swap a segment with a new segment from another part of the tour)\n    if n > 5:\n        a, b = sorted(random.sample(range(n), 2))\n        if b - a > 2:\n            segment = base_solution[a:b]\n            new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    # Ensure the solution is a valid tour (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or not np.array_equal(sorted(unique_nodes), sorted(base_solution)):\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the move is invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6555247468480266,
            2.2558907866477966
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = [sol for sol, obj in archive if obj[0] > np.min([o[0] for _, o in archive]) or obj[1] > np.min([o[1] for _, o in archive])]\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n\n    base_solution = random.choice(candidates).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge insertion with a novel segment-based move\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Edge insertion (like 2-opt but more flexible)\n    i, j = sorted(random.sample(range(n), 2))\n    segment = base_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    # Step 2: Novel segment-based move (swap a segment with a new segment from another part of the tour)\n    if n > 5:\n        a, b = sorted(random.sample(range(n), 2))\n        if b - a > 2:\n            segment = base_solution[a:b]\n            new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    # Ensure the solution is a valid tour (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or not np.array_equal(sorted(unique_nodes), sorted(base_solution)):\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the move is invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 278,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Step 2: Select a base solution with preference for non-dominated solutions\n    if len(non_dominated) > 0:\n        base_solution, _ = random.choice(non_dominated)\n    else:\n        base_solution, _ = random.choice(archive)\n\n    new_solution = base_solution.copy()\n\n    # Step 3: Apply hybrid local search operator (combination of edge insertion and relocation)\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Choose a random segment to modify\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b]\n\n    # Relocate the segment to a different position\n    new_pos = random.randint(0, n - len(segment))\n    if new_pos > a:\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:new_pos], segment, new_solution[new_pos:]])\n    else:\n        new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[a:b], new_solution[new_pos + len(segment):]])\n\n    # Step 4: Apply edge insertion for further improvement\n    for _ in range(2):  # Limit the number of insertions\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            k = random.randint(i + 1, j - 1)\n            new_solution = np.concatenate([new_solution[:i+1], new_solution[k:j], new_solution[i+1:k], new_solution[j:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8065498496340233,
            0.7379396557807922
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Step 2: Select a base solution with preference for non-dominated solutions\n    if len(non_dominated) > 0:\n        base_solution, _ = random.choice(non_dominated)\n    else:\n        base_solution, _ = random.choice(archive)\n\n    new_solution = base_solution.copy()\n\n    # Step 3: Apply hybrid local search operator (combination of edge insertion and relocation)\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Choose a random segment to modify\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b]\n\n    # Relocate the segment to a different position\n    new_pos = random.randint(0, n - len(segment))\n    if new_pos > a:\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:new_pos], segment, new_solution[new_pos:]])\n    else:\n        new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[a:b], new_solution[new_pos + len(segment):]])\n\n    # Step 4: Apply edge insertion for further improvement\n    for _ in range(2):  # Limit the number of insertions\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            k = random.randint(i + 1, j - 1)\n            new_solution = np.concatenate([new_solution[:i+1], new_solution[k:j], new_solution[i+1:k], new_solution[j:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 279,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high variance in objectives)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    objectives = [obj for _, obj in archive]\n\n    # Hybrid local search: combine 3-opt with a custom move that considers both objectives\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform a 3-opt move (select three random edges and reconnect them)\n    i, j, k = sorted(random.sample(range(1, n), 3))\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Reconnect segments in a new order to create a valid tour\n    new_order = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Apply a custom move that considers both distance matrices\n    # Select two random nodes and swap them if it improves both objectives\n    a, b = random.sample(range(1, n), 2)\n    if a > b:\n        a, b = b, a\n\n    # Calculate current and new costs for both objectives\n    def calculate_cost(solution, matrix):\n        cost = 0\n        for i in range(len(solution)):\n            cost += matrix[solution[i-1], solution[i]]\n        return cost\n\n    current_cost1 = calculate_cost(new_order, distance_matrix_1)\n    current_cost2 = calculate_cost(new_order, distance_matrix_2)\n\n    # Try swapping a and b\n    temp_solution = new_order.copy()\n    temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    # Accept the swap if it improves both objectives\n    if new_cost1 <= current_cost1 and new_cost2 <= current_cost2:\n        new_order = temp_solution\n\n    return new_order\n\n",
        "score": [
            -0.8512016775054317,
            2.2866905331611633
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high variance in objectives)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    objectives = [obj for _, obj in archive]\n\n    # Hybrid local search: combine 3-opt with a custom move that considers both objectives\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform a 3-opt move (select three random edges and reconnect them)\n    i, j, k = sorted(random.sample(range(1, n), 3))\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Reconnect segments in a new order to create a valid tour\n    new_order = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Apply a custom move that considers both distance matrices\n    # Select two random nodes and swap them if it improves both objectives\n    a, b = random.sample(range(1, n), 2)\n    if a > b:\n        a, b = b, a\n\n    # Calculate current and new costs for both objectives\n    def calculate_cost(solution, matrix):\n        cost = 0\n        for i in range(len(solution)):\n            cost += matrix[solution[i-1], solution[i]]\n        return cost\n\n    current_cost1 = calculate_cost(new_order, distance_matrix_1)\n    current_cost2 = calculate_cost(new_order, distance_matrix_2)\n\n    # Try swapping a and b\n    temp_solution = new_order.copy()\n    temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    # Accept the swap if it improves both objectives\n    if new_cost1 <= current_cost1 and new_cost2 <= current_cost2:\n        new_order = temp_solution\n\n    return new_order\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 280,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        # Normalize objectives to avoid scale bias\n        normalized = (objectives - objectives.mean(axis=0)) / (objectives.std(axis=0) + 1e-10)\n        # Select a solution with high variance (potential for improvement)\n        variances = np.var(normalized, axis=1)\n        selected_idx = np.argmax(variances)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 3-opt and edge insertion\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select segments for modification\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move (reverses segments between i,j and j,k)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Apply edge insertion (reinsert a randomly selected node)\n    if n > 3:\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Verify feasibility (no duplicates, all nodes present)\n    assert len(new_solution) == len(base_solution)\n    assert np.array_equal(np.sort(new_solution), np.sort(base_solution))\n\n    return new_solution\n\n",
        "score": [
            -0.7086063575937513,
            1.6202678084373474
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        # Normalize objectives to avoid scale bias\n        normalized = (objectives - objectives.mean(axis=0)) / (objectives.std(axis=0) + 1e-10)\n        # Select a solution with high variance (potential for improvement)\n        variances = np.var(normalized, axis=1)\n        selected_idx = np.argmax(variances)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 3-opt and edge insertion\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select segments for modification\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move (reverses segments between i,j and j,k)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Apply edge insertion (reinsert a randomly selected node)\n    if n > 3:\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Verify feasibility (no duplicates, all nodes present)\n    assert len(new_solution) == len(base_solution)\n    assert np.array_equal(np.sort(new_solution), np.sort(base_solution))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 281,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate the normalized improvement potential (lower is better)\n    improvement_potential = []\n    for i in range(len(solutions)):\n        # Use a combination of objective values and diversity as potential\n        obj1, obj2 = objectives[i]\n        diversity = len(set(solutions[i])) / len(solutions[i])  # Should be 1 for valid TSP tours\n        potential = (obj1 + obj2) * (1 - diversity)\n        improvement_potential.append(potential)\n\n    # Select top 3 solutions with highest potential\n    top_indices = np.argsort(improvement_potential)[:min(3, len(archive))]\n    selected_idx = random.choice(top_indices)\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search operator: 3-opt with edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 edges to modify\n    if n >= 4:\n        i, j, k = sorted(random.sample(range(1, n-1), 3))\n\n        # Apply 3-opt move\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        segment3 = new_solution[k:]\n\n        # Recombine segments in different orders\n        new_segments = [segment1, segment2, segment3]\n        random.shuffle(new_segments)\n        new_solution = np.concatenate([new_solution[:i], *new_segments, new_solution[k:]])\n\n        # Apply edge exchange if it improves both objectives\n        if random.random() < 0.5 and n >= 6:\n            a, b = sorted(random.sample(range(1, n-1), 2))\n            if a != i and b != j and b != k:\n                # Calculate current and new costs\n                current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n                new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n\n                current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n                new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n                # Accept if both objectives improve\n                if new_cost1 < current_cost1 and new_cost2 < current_cost2:\n                    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains a valid tour\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9161203614308926,
            2.059476137161255
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate the normalized improvement potential (lower is better)\n    improvement_potential = []\n    for i in range(len(solutions)):\n        # Use a combination of objective values and diversity as potential\n        obj1, obj2 = objectives[i]\n        diversity = len(set(solutions[i])) / len(solutions[i])  # Should be 1 for valid TSP tours\n        potential = (obj1 + obj2) * (1 - diversity)\n        improvement_potential.append(potential)\n\n    # Select top 3 solutions with highest potential\n    top_indices = np.argsort(improvement_potential)[:min(3, len(archive))]\n    selected_idx = random.choice(top_indices)\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search operator: 3-opt with edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 edges to modify\n    if n >= 4:\n        i, j, k = sorted(random.sample(range(1, n-1), 3))\n\n        # Apply 3-opt move\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        segment3 = new_solution[k:]\n\n        # Recombine segments in different orders\n        new_segments = [segment1, segment2, segment3]\n        random.shuffle(new_segments)\n        new_solution = np.concatenate([new_solution[:i], *new_segments, new_solution[k:]])\n\n        # Apply edge exchange if it improves both objectives\n        if random.random() < 0.5 and n >= 6:\n            a, b = sorted(random.sample(range(1, n-1), 2))\n            if a != i and b != j and b != k:\n                # Calculate current and new costs\n                current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n                new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n\n                current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n                new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n                # Accept if both objectives improve\n                if new_cost1 < current_cost1 and new_cost2 < current_cost2:\n                    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains a valid tour\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 282,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with the best combined objective (weighted sum)\n    weights = np.random.uniform(0.3, 0.7)  # Randomly weigh between objectives\n    ranked_solutions = sorted(archive, key=lambda x: weights * x[1][0] + (1 - weights) * x[1][1])\n    base_solution = ranked_solutions[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Edge insertion: move a random segment to a new position\n    if j - i > 1:  # Ensure segment has at least 2 nodes\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n        insert_pos = np.random.randint(0, len(new_solution) + 1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure validity: check for duplicates and fix if necessary\n    unique, counts = np.unique(new_solution, return_counts=True)\n    duplicates = unique[counts > 1]\n    if len(duplicates) > 0:\n        # If duplicates exist, repair by inserting missing nodes\n        all_nodes = np.arange(len(instance))\n        missing_nodes = np.setdiff1d(all_nodes, new_solution)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution) + 1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8538522173247434,
            2.198408842086792
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with the best combined objective (weighted sum)\n    weights = np.random.uniform(0.3, 0.7)  # Randomly weigh between objectives\n    ranked_solutions = sorted(archive, key=lambda x: weights * x[1][0] + (1 - weights) * x[1][1])\n    base_solution = ranked_solutions[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Edge insertion: move a random segment to a new position\n    if j - i > 1:  # Ensure segment has at least 2 nodes\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n        insert_pos = np.random.randint(0, len(new_solution) + 1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure validity: check for duplicates and fix if necessary\n    unique, counts = np.unique(new_solution, return_counts=True)\n    duplicates = unique[counts > 1]\n    if len(duplicates) > 0:\n        # If duplicates exist, repair by inserting missing nodes\n        all_nodes = np.arange(len(instance))\n        missing_nodes = np.setdiff1d(all_nodes, new_solution)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution) + 1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 283,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    # We prioritize solutions with high variance in objectives (indicating potential for trade-offs)\n    objectives = [obj for _, obj in archive]\n    avg_obj1 = np.mean([o[0] for o in objectives])\n    avg_obj2 = np.mean([o[1] for o in objectives])\n    variances = [((o[0] - avg_obj1)**2 + (o[1] - avg_obj2)**2) for o in objectives]\n\n    # Select top 30% solutions with highest variance\n    threshold = np.percentile(variances, 70)\n    candidates = [sol for (sol, obj), var in zip(archive, variances) if var >= threshold]\n\n    if not candidates:\n        # If no candidates with high variance, select randomly\n        candidates = [sol for sol, _ in archive]\n\n    base_solution = random.choice(candidates).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of edge insertion and segment reversal\n    n = len(new_solution)\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    k = random.randint(0, n-1)\n\n    # Ensure all indices are distinct\n    while j == i or k == i or k == j:\n        j = random.randint(0, n-1)\n        k = random.randint(0, n-1)\n\n    # Sort indices to maintain order\n    i, j, k = sorted([i, j, k])\n\n    # Edge insertion: move segment between i and j to position k\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    # Segment reversal: reverse a random segment to improve local structure\n    rev_start = random.randint(0, n-2)\n    rev_end = random.randint(rev_start+1, n-1)\n    new_solution[rev_start:rev_end] = new_solution[rev_start:rev_end][::-1]\n\n    # Ensure the solution remains feasible (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or np.any(counts > 1):\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6980898227714372,
            3.0204492807388306
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    # We prioritize solutions with high variance in objectives (indicating potential for trade-offs)\n    objectives = [obj for _, obj in archive]\n    avg_obj1 = np.mean([o[0] for o in objectives])\n    avg_obj2 = np.mean([o[1] for o in objectives])\n    variances = [((o[0] - avg_obj1)**2 + (o[1] - avg_obj2)**2) for o in objectives]\n\n    # Select top 30% solutions with highest variance\n    threshold = np.percentile(variances, 70)\n    candidates = [sol for (sol, obj), var in zip(archive, variances) if var >= threshold]\n\n    if not candidates:\n        # If no candidates with high variance, select randomly\n        candidates = [sol for sol, _ in archive]\n\n    base_solution = random.choice(candidates).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of edge insertion and segment reversal\n    n = len(new_solution)\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    k = random.randint(0, n-1)\n\n    # Ensure all indices are distinct\n    while j == i or k == i or k == j:\n        j = random.randint(0, n-1)\n        k = random.randint(0, n-1)\n\n    # Sort indices to maintain order\n    i, j, k = sorted([i, j, k])\n\n    # Edge insertion: move segment between i and j to position k\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    # Segment reversal: reverse a random segment to improve local structure\n    rev_start = random.randint(0, n-2)\n    rev_end = random.randint(rev_start+1, n-1)\n    new_solution[rev_start:rev_end] = new_solution[rev_start:rev_end][::-1]\n\n    # Ensure the solution remains feasible (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or np.any(counts > 1):\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 284,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Identify non-dominated solutions\n        non_dominated = []\n        for i, (sol_i, obj_i) in enumerate(archive):\n            dominated = False\n            for j, (sol_j, obj_j) in enumerate(archive):\n                if i != j and obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1] and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                    dominated = True\n                    break\n            if not dominated:\n                non_dominated.append((sol_i, obj_i))\n\n        # Randomly select from non-dominated solutions (or from all if none exist)\n        if non_dominated:\n            selected = random.choice(non_dominated)[0].copy()\n        else:\n            selected = random.choice(archive)[0].copy()\n    else:\n        selected = archive[0][0].copy()\n\n    # Step 2: Apply hybrid local search operator\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Select three random edges to potentially reconnect\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Generate all possible 3-opt moves (6 possible reconnections)\n    candidates = []\n    for perm in [(a, b, c), (a, c, b), (b, a, c), (b, c, a), (c, a, b), (c, b, a)]:\n        # Create new solution for this permutation\n        temp = new_solution.copy()\n        temp[perm[0]:perm[1]] = temp[perm[0]:perm[1]][::-1]\n        temp[perm[1]:perm[2]] = temp[perm[1]:perm[2]][::-1]\n        candidates.append(temp)\n\n    # Evaluate all candidates based on both objectives\n    best_candidate = None\n    best_improvement = (0, 0)\n\n    for candidate in candidates:\n        # Calculate total distances for both objectives\n        total_dist1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n        total_dist2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n\n        # Calculate improvement in both objectives\n        current_dist1 = sum(distance_matrix_1[selected[i], selected[(i+1)%n]] for i in range(n))\n        current_dist2 = sum(distance_matrix_2[selected[i], selected[(i+1)%n]] for i in range(n))\n\n        improvement1 = current_dist1 - total_dist1\n        improvement2 = current_dist2 - total_dist2\n\n        # Accept if it's a Pareto improvement\n        if (improvement1 > 0 and improvement2 >= 0) or (improvement1 >= 0 and improvement2 > 0):\n            if best_candidate is None or (improvement1 > best_improvement[0] and improvement2 > best_improvement[1]):\n                best_candidate = candidate\n                best_improvement = (improvement1, improvement2)\n\n    # If no improvement found, apply a small random perturbation\n    if best_candidate is None:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution = selected.copy()\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        new_solution = best_candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7709435063503669,
            4.2301347851753235
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Identify non-dominated solutions\n        non_dominated = []\n        for i, (sol_i, obj_i) in enumerate(archive):\n            dominated = False\n            for j, (sol_j, obj_j) in enumerate(archive):\n                if i != j and obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1] and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                    dominated = True\n                    break\n            if not dominated:\n                non_dominated.append((sol_i, obj_i))\n\n        # Randomly select from non-dominated solutions (or from all if none exist)\n        if non_dominated:\n            selected = random.choice(non_dominated)[0].copy()\n        else:\n            selected = random.choice(archive)[0].copy()\n    else:\n        selected = archive[0][0].copy()\n\n    # Step 2: Apply hybrid local search operator\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Select three random edges to potentially reconnect\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Generate all possible 3-opt moves (6 possible reconnections)\n    candidates = []\n    for perm in [(a, b, c), (a, c, b), (b, a, c), (b, c, a), (c, a, b), (c, b, a)]:\n        # Create new solution for this permutation\n        temp = new_solution.copy()\n        temp[perm[0]:perm[1]] = temp[perm[0]:perm[1]][::-1]\n        temp[perm[1]:perm[2]] = temp[perm[1]:perm[2]][::-1]\n        candidates.append(temp)\n\n    # Evaluate all candidates based on both objectives\n    best_candidate = None\n    best_improvement = (0, 0)\n\n    for candidate in candidates:\n        # Calculate total distances for both objectives\n        total_dist1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n        total_dist2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n\n        # Calculate improvement in both objectives\n        current_dist1 = sum(distance_matrix_1[selected[i], selected[(i+1)%n]] for i in range(n))\n        current_dist2 = sum(distance_matrix_2[selected[i], selected[(i+1)%n]] for i in range(n))\n\n        improvement1 = current_dist1 - total_dist1\n        improvement2 = current_dist2 - total_dist2\n\n        # Accept if it's a Pareto improvement\n        if (improvement1 > 0 and improvement2 >= 0) or (improvement1 >= 0 and improvement2 > 0):\n            if best_candidate is None or (improvement1 > best_improvement[0] and improvement2 > best_improvement[1]):\n                best_candidate = candidate\n                best_improvement = (improvement1, improvement2)\n\n    # If no improvement found, apply a small random perturbation\n    if best_candidate is None:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution = selected.copy()\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        new_solution = best_candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 285,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: min(x[1]))\n    selected_idx = min(int(len(archive) * 0.2), len(archive) - 1)  # Select from top 20%\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a novel segment inversion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Not enough nodes for meaningful operations\n\n    # Randomly select three segments to operate on\n    i, j, k = sorted(random.sample(range(1, n-1), 3))\n\n    # Apply segment inversion with probability 0.7\n    if random.random() < 0.7:\n        # Reverse the middle segment (i to j)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply 3-opt style move with probability 0.5\n    if random.random() < 0.5:\n        # Reorder the selected segments to create a new path\n        segments = [\n            new_solution[:i],\n            new_solution[i:j+1],\n            new_solution[j+1:k+1],\n            new_solution[k+1:]\n        ]\n        # Randomly permute the middle two segments\n        random.shuffle(segments[1:3])\n        new_solution = np.concatenate(segments)\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or not np.all(counts == 1):\n        # Fallback to simple swap if invalid\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.49203081382474134,
            2.461293637752533
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: min(x[1]))\n    selected_idx = min(int(len(archive) * 0.2), len(archive) - 1)  # Select from top 20%\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a novel segment inversion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Not enough nodes for meaningful operations\n\n    # Randomly select three segments to operate on\n    i, j, k = sorted(random.sample(range(1, n-1), 3))\n\n    # Apply segment inversion with probability 0.7\n    if random.random() < 0.7:\n        # Reverse the middle segment (i to j)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply 3-opt style move with probability 0.5\n    if random.random() < 0.5:\n        # Reorder the selected segments to create a new path\n        segments = [\n            new_solution[:i],\n            new_solution[i:j+1],\n            new_solution[j+1:k+1],\n            new_solution[k+1:]\n        ]\n        # Randomly permute the middle two segments\n        random.shuffle(segments[1:3])\n        new_solution = np.concatenate(segments)\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or not np.all(counts == 1):\n        # Fallback to simple swap if invalid\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 286,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Intelligent selection: choose a solution with high diversity or non-dominated\n        objectives = np.array([obj for _, obj in archive])\n        # Normalize objectives for comparison\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n        # Select a solution with high diversity (e.g., far from the average)\n        avg_normalized = normalized.mean(axis=0)\n        distances = np.linalg.norm(normalized - avg_normalized, axis=1)\n        selected_idx = np.argmax(distances)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a custom move\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select 3 distinct positions to perform a 3-opt move\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Perform 3-opt move: reverse segments between a-b, b-c, and a-c\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n    new_solution[a:c] = new_solution[a:c][::-1]\n\n    # Additional custom move: swap two segments to diversify\n    if n > 4:\n        d, e = sorted(random.sample(range(n), 2))\n        new_solution[d:e] = new_solution[d:e][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6252413526679901,
            2.3241695761680603
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Intelligent selection: choose a solution with high diversity or non-dominated\n        objectives = np.array([obj for _, obj in archive])\n        # Normalize objectives for comparison\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n        # Select a solution with high diversity (e.g., far from the average)\n        avg_normalized = normalized.mean(axis=0)\n        distances = np.linalg.norm(normalized - avg_normalized, axis=1)\n        selected_idx = np.argmax(distances)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a custom move\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select 3 distinct positions to perform a 3-opt move\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Perform 3-opt move: reverse segments between a-b, b-c, and a-c\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n    new_solution[a:c] = new_solution[a:c][::-1]\n\n    # Additional custom move: swap two segments to diversify\n    if n > 4:\n        d, e = sorted(random.sample(range(n), 2))\n        new_solution[d:e] = new_solution[d:e][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 287,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a base solution with a preference for non-dominated solutions\n    non_dominated = [sol for sol, obj in archive if not any(obj1[0] <= obj[0] and obj1[1] <= obj[1] and (obj1[0] < obj[0] or obj1[1] < obj[1])\n                                                          for _, obj1 in archive)]\n    if non_dominated:\n        base_solution = random.choice(non_dominated)\n    else:\n        base_solution = random.choice(archive)[0]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Determine the segment to perturb (probabilistically larger segments for more significant changes)\n    segment_size = min(5, n // 2)\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    # Extract the segment and reverse it (edge insertion-like operation)\n    segment = new_solution[start:end]\n    new_solution[start:end] = segment[::-1]\n\n    # With 30% probability, perform a node displacement\n    if random.random() < 0.3:\n        node_pos = random.randint(0, n - 1)\n        node = new_solution[node_pos]\n        new_solution = np.delete(new_solution, node_pos)\n        insert_pos = random.randint(0, n - 2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour.\"\n\n    return new_solution\n\n",
        "score": [
            -0.7892358063246441,
            2.342147648334503
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a base solution with a preference for non-dominated solutions\n    non_dominated = [sol for sol, obj in archive if not any(obj1[0] <= obj[0] and obj1[1] <= obj[1] and (obj1[0] < obj[0] or obj1[1] < obj[1])\n                                                          for _, obj1 in archive)]\n    if non_dominated:\n        base_solution = random.choice(non_dominated)\n    else:\n        base_solution = random.choice(archive)[0]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Determine the segment to perturb (probabilistically larger segments for more significant changes)\n    segment_size = min(5, n // 2)\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    # Extract the segment and reverse it (edge insertion-like operation)\n    segment = new_solution[start:end]\n    new_solution[start:end] = segment[::-1]\n\n    # With 30% probability, perform a node displacement\n    if random.random() < 0.3:\n        node_pos = random.randint(0, n - 1)\n        node = new_solution[node_pos]\n        new_solution = np.delete(new_solution, node_pos)\n        insert_pos = random.randint(0, n - 2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour.\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 288,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    # Here, we use a simple heuristic: solutions with higher total cost have higher selection probability\n    objectives = np.array([obj for _, obj in archive])\n    total_costs = objectives[:, 0] + objectives[:, 1]\n    probabilities = total_costs / np.sum(total_costs)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply hybrid local search\n    # Step 1: Random 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Segment inversion with objective-aware selection\n    if random.random() < 0.5:  # 50% chance to apply segment inversion\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Evaluate segment in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[k], segment[(k+1)%segment_length]] for k in range(segment_length))\n        segment_cost2 = sum(distance_matrix_2[segment[k], segment[(k+1)%segment_length]] for k in range(segment_length))\n\n        # Decide whether to invert based on which objective is worse\n        if segment_cost1 > segment_cost2:\n            new_solution[start:start+segment_length] = segment[::-1]\n        else:\n            # Try insertion in a different position\n            insert_pos = random.randint(0, n - segment_length)\n            if insert_pos != start:\n                # Remove segment and insert elsewhere\n                remaining = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n                new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 3: Objective-aware node swap\n    if random.random() < 0.3:  # 30% chance to apply node swap\n        # Find nodes with high cost in either objective\n        costs = []\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            cost1 = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]\n            cost2 = distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n            costs.append((cost1 + cost2, i))\n\n        costs.sort(reverse=True, key=lambda x: x[0])\n        if len(costs) >= 2:\n            i, j = costs[0][1], costs[1][1]\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7214820670253228,
            2.6020636558532715
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    # Here, we use a simple heuristic: solutions with higher total cost have higher selection probability\n    objectives = np.array([obj for _, obj in archive])\n    total_costs = objectives[:, 0] + objectives[:, 1]\n    probabilities = total_costs / np.sum(total_costs)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply hybrid local search\n    # Step 1: Random 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Segment inversion with objective-aware selection\n    if random.random() < 0.5:  # 50% chance to apply segment inversion\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Evaluate segment in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[k], segment[(k+1)%segment_length]] for k in range(segment_length))\n        segment_cost2 = sum(distance_matrix_2[segment[k], segment[(k+1)%segment_length]] for k in range(segment_length))\n\n        # Decide whether to invert based on which objective is worse\n        if segment_cost1 > segment_cost2:\n            new_solution[start:start+segment_length] = segment[::-1]\n        else:\n            # Try insertion in a different position\n            insert_pos = random.randint(0, n - segment_length)\n            if insert_pos != start:\n                # Remove segment and insert elsewhere\n                remaining = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n                new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 3: Objective-aware node swap\n    if random.random() < 0.3:  # 30% chance to apply node swap\n        # Find nodes with high cost in either objective\n        costs = []\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            cost1 = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]\n            cost2 = distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n            costs.append((cost1 + cost2, i))\n\n        costs.sort(reverse=True, key=lambda x: x[0])\n        if len(costs) >= 2:\n            i, j = costs[0][1], costs[1][1]\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 289,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lower cost solutions)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge exchange and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge exchange with cost improvement check\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n\n    # Check if exchange improves both objectives\n    old_edges = [(new_solution[i-1], new_solution[i]), (new_solution[j-1], new_solution[j]),\n                 (new_solution[i], new_solution[(i+1)%n]), (new_solution[j], new_solution[(j+1)%n])]\n    new_edges = [(new_solution[i-1], new_solution[j]), (new_solution[j-1], new_solution[i]),\n                 (new_solution[j], new_solution[(i+1)%n]), (new_solution[i], new_solution[(j+1)%n])]\n\n    old_cost = sum(distance_matrix_1[a][b] + distance_matrix_2[a][b] for a, b in old_edges)\n    new_cost = sum(distance_matrix_1[a][b] + distance_matrix_2[a][b] for a, b in new_edges)\n\n    if new_cost < old_cost:\n        # Perform edge exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform segment reversal between i and j\n        segment = new_solution[i:j+1]\n        new_solution[i:j+1] = segment[::-1]\n\n    # Ensure solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution and try different indices\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7260831263369323,
            2.0241618752479553
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lower cost solutions)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge exchange and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge exchange with cost improvement check\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n\n    # Check if exchange improves both objectives\n    old_edges = [(new_solution[i-1], new_solution[i]), (new_solution[j-1], new_solution[j]),\n                 (new_solution[i], new_solution[(i+1)%n]), (new_solution[j], new_solution[(j+1)%n])]\n    new_edges = [(new_solution[i-1], new_solution[j]), (new_solution[j-1], new_solution[i]),\n                 (new_solution[j], new_solution[(i+1)%n]), (new_solution[i], new_solution[(j+1)%n])]\n\n    old_cost = sum(distance_matrix_1[a][b] + distance_matrix_2[a][b] for a, b in old_edges)\n    new_cost = sum(distance_matrix_1[a][b] + distance_matrix_2[a][b] for a, b in new_edges)\n\n    if new_cost < old_cost:\n        # Perform edge exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform segment reversal between i and j\n        segment = new_solution[i:j+1]\n        new_solution[i:j+1] = segment[::-1]\n\n    # Ensure solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution and try different indices\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 290,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., one with the best combined objective)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a biased edge swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform a 3-opt move\n    if n >= 4:\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Reverse the segment between i and j, then between j and k\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Perform a biased edge swap (prefer edges that improve both objectives)\n    if n >= 2:\n        # Select two random edges to swap\n        a, b = sorted(random.sample(range(n), 2))\n        # Check if swapping a and b improves both objectives\n        old_edges = [(new_solution[a-1], new_solution[a]), (new_solution[b-1], new_solution[b])]\n        new_edges = [(new_solution[a-1], new_solution[b]), (new_solution[b-1], new_solution[a])]\n\n        # Calculate the change in both objectives\n        delta_cost1 = (distance_matrix_1[new_edges[0][0], new_edges[0][1]] + distance_matrix_1[new_edges[1][0], new_edges[1][1]]) - \\\n                      (distance_matrix_1[old_edges[0][0], old_edges[0][1]] + distance_matrix_1[old_edges[1][0], old_edges[1][1]])\n        delta_cost2 = (distance_matrix_2[new_edges[0][0], new_edges[0][1]] + distance_matrix_2[new_edges[1][0], new_edges[1][1]]) - \\\n                      (distance_matrix_2[old_edges[0][0], old_edges[0][1]] + distance_matrix_2[old_edges[1][0], old_edges[1][1]])\n\n        if delta_cost1 < 0 and delta_cost2 < 0:  # If both objectives improve\n            # Perform the swap\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains a valid tour (circular)\n    if len(set(new_solution)) != n:\n        # If duplicates exist, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7456060506493121,
            2.298205256462097
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., one with the best combined objective)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a biased edge swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform a 3-opt move\n    if n >= 4:\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Reverse the segment between i and j, then between j and k\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Perform a biased edge swap (prefer edges that improve both objectives)\n    if n >= 2:\n        # Select two random edges to swap\n        a, b = sorted(random.sample(range(n), 2))\n        # Check if swapping a and b improves both objectives\n        old_edges = [(new_solution[a-1], new_solution[a]), (new_solution[b-1], new_solution[b])]\n        new_edges = [(new_solution[a-1], new_solution[b]), (new_solution[b-1], new_solution[a])]\n\n        # Calculate the change in both objectives\n        delta_cost1 = (distance_matrix_1[new_edges[0][0], new_edges[0][1]] + distance_matrix_1[new_edges[1][0], new_edges[1][1]]) - \\\n                      (distance_matrix_1[old_edges[0][0], old_edges[0][1]] + distance_matrix_1[old_edges[1][0], old_edges[1][1]])\n        delta_cost2 = (distance_matrix_2[new_edges[0][0], new_edges[0][1]] + distance_matrix_2[new_edges[1][0], new_edges[1][1]]) - \\\n                      (distance_matrix_2[old_edges[0][0], old_edges[0][1]] + distance_matrix_2[old_edges[1][0], old_edges[1][1]])\n\n        if delta_cost1 < 0 and delta_cost2 < 0:  # If both objectives improve\n            # Perform the swap\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains a valid tour (circular)\n    if len(set(new_solution)) != n:\n        # If duplicates exist, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 291,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a probability inversely proportional to its dominance rank\n    # (simplified here by selecting a random solution with higher probability for lower costs)\n    weights = [1.0 / (cost1 + cost2 + 1e-6) for _, (cost1, cost2) in archive]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Edge insertion: randomly select a segment and reinsert it at a different position\n    # 2. Segment reversal: reverse a segment with a probability based on its improvement potential\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Edge insertion\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n    k = random.randint(0, n - 1)\n    if k > i:\n        k += 1  # Adjust to avoid reinserting at the same position\n\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k], segment, new_solution[k:]])\n\n    # Segment reversal with probability based on improvement potential\n    if random.random() < 0.3:  # 30% chance to reverse a segment\n        i_rev = random.randint(0, n - 2)\n        j_rev = random.randint(i_rev + 1, min(i_rev + 5, n - 1))  # Limit segment length for efficiency\n        new_solution[i_rev:j_rev+1] = new_solution[i_rev:j_rev+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not feasible.\"\n\n    return new_solution\n\n",
        "score": [
            -0.6629643726130753,
            0.9493718147277832
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a probability inversely proportional to its dominance rank\n    # (simplified here by selecting a random solution with higher probability for lower costs)\n    weights = [1.0 / (cost1 + cost2 + 1e-6) for _, (cost1, cost2) in archive]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Edge insertion: randomly select a segment and reinsert it at a different position\n    # 2. Segment reversal: reverse a segment with a probability based on its improvement potential\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Edge insertion\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n    k = random.randint(0, n - 1)\n    if k > i:\n        k += 1  # Adjust to avoid reinserting at the same position\n\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k], segment, new_solution[k:]])\n\n    # Segment reversal with probability based on improvement potential\n    if random.random() < 0.3:  # 30% chance to reverse a segment\n        i_rev = random.randint(0, n - 2)\n        j_rev = random.randint(i_rev + 1, min(i_rev + 5, n - 1))  # Limit segment length for efficiency\n        new_solution[i_rev:j_rev+1] = new_solution[i_rev:j_rev+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not feasible.\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 292,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the lowest combined cost\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search operator: Partial Shuffle and Reinsertion (PSR)\n    # Select a random segment of the tour and reinsert it in a different position\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Remove the segment\n    remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n\n    # Reinsert the segment at a random position\n    k = np.random.randint(0, len(remaining)+1)\n    new_solution = np.concatenate([remaining[:k], segment, remaining[k:]])\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    assert len(new_solution) == n\n    assert len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.853981462322446,
            2.5793880224227905
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the lowest combined cost\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search operator: Partial Shuffle and Reinsertion (PSR)\n    # Select a random segment of the tour and reinsert it in a different position\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Remove the segment\n    remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n\n    # Reinsert the segment at a random position\n    k = np.random.randint(0, len(remaining)+1)\n    new_solution = np.concatenate([remaining[:k], segment, remaining[k:]])\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    assert len(new_solution) == n\n    assert len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 293,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto front or high variance in objectives)\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel edge insertion heuristic\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Perform a random 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Novel edge insertion heuristic: try to improve the solution by inserting edges that reduce both objectives\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        a, b = sorted(random.sample(range(n), 2))\n        # Check if removing edge (a, a+1) and inserting edge (a, b) improves both objectives\n        old_cost1 = distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[(a+1)%n], new_solution[(b+1)%n]]\n\n        old_cost2 = distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[(a+1)%n], new_solution[(b+1)%n]]\n\n        if (new_cost1 < old_cost1) and (new_cost2 < old_cost2):\n            # Perform the insertion\n            if b > a + 1:\n                new_solution[a+1:b+1] = new_solution[a+1:b+1][::-1]\n            break  # Only perform one insertion per iteration\n\n    return new_solution\n\n",
        "score": [
            -0.9608696401443695,
            2.385421335697174
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto front or high variance in objectives)\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel edge insertion heuristic\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Perform a random 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Novel edge insertion heuristic: try to improve the solution by inserting edges that reduce both objectives\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        a, b = sorted(random.sample(range(n), 2))\n        # Check if removing edge (a, a+1) and inserting edge (a, b) improves both objectives\n        old_cost1 = distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[(a+1)%n], new_solution[(b+1)%n]]\n\n        old_cost2 = distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[(a+1)%n], new_solution[(b+1)%n]]\n\n        if (new_cost1 < old_cost1) and (new_cost2 < old_cost2):\n            # Perform the insertion\n            if b > a + 1:\n                new_solution[a+1:b+1] = new_solution[a+1:b+1][::-1]\n            break  # Only perform one insertion per iteration\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 294,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-swap strategy\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Randomly select 3 distinct positions to perform 3-opt\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Step 2: Generate all possible 3-opt neighbors and evaluate them\n    candidates = []\n    # Case 1: Reverse segment [a, b]\n    candidate1 = new_solution.copy()\n    candidate1[a:b+1] = candidate1[a:b+1][::-1]\n    candidates.append(candidate1)\n\n    # Case 2: Reverse segment [b, c]\n    candidate2 = new_solution.copy()\n    candidate2[b:c+1] = candidate2[b:c+1][::-1]\n    candidates.append(candidate2)\n\n    # Case 3: Reverse segment [a, c]\n    candidate3 = new_solution.copy()\n    candidate3[a:c+1] = candidate3[a:c+1][::-1]\n    candidates.append(candidate3)\n\n    # Step 3: Evaluate all candidates based on both objectives\n    best_candidate = None\n    best_score = float('inf')\n\n    for candidate in candidates:\n        # Calculate total cost in both objective spaces\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        total_cost = cost1 + cost2  # Simple aggregation for selection\n\n        if total_cost < best_score:\n            best_score = total_cost\n            best_candidate = candidate\n\n    # Step 4: Apply a novel edge-swap strategy if 3-opt didn't improve\n    if best_candidate is None or best_candidate is new_solution:\n        # Randomly select two edges and attempt to swap them\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return best_candidate if best_candidate is not None else new_solution\n\n",
        "score": [
            -0.8689790613308888,
            3.544743835926056
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-swap strategy\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Randomly select 3 distinct positions to perform 3-opt\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Step 2: Generate all possible 3-opt neighbors and evaluate them\n    candidates = []\n    # Case 1: Reverse segment [a, b]\n    candidate1 = new_solution.copy()\n    candidate1[a:b+1] = candidate1[a:b+1][::-1]\n    candidates.append(candidate1)\n\n    # Case 2: Reverse segment [b, c]\n    candidate2 = new_solution.copy()\n    candidate2[b:c+1] = candidate2[b:c+1][::-1]\n    candidates.append(candidate2)\n\n    # Case 3: Reverse segment [a, c]\n    candidate3 = new_solution.copy()\n    candidate3[a:c+1] = candidate3[a:c+1][::-1]\n    candidates.append(candidate3)\n\n    # Step 3: Evaluate all candidates based on both objectives\n    best_candidate = None\n    best_score = float('inf')\n\n    for candidate in candidates:\n        # Calculate total cost in both objective spaces\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        total_cost = cost1 + cost2  # Simple aggregation for selection\n\n        if total_cost < best_score:\n            best_score = total_cost\n            best_candidate = candidate\n\n    # Step 4: Apply a novel edge-swap strategy if 3-opt didn't improve\n    if best_candidate is None or best_candidate is new_solution:\n        # Randomly select two edges and attempt to swap them\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return best_candidate if best_candidate is not None else new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 295,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest cost but still promising)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(len(archive_sorted) // 2, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine edge insertion with a biased random walk\n    n = len(base_solution)\n    for _ in range(5):  # Number of perturbation steps\n        # Randomly select a segment to perturb\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n\n        # Apply a biased random walk to the segment\n        if len(segment) > 2:\n            # Shuffle the segment with probability based on its length\n            if np.random.rand() < 0.7:\n                np.random.shuffle(segment)\n                new_solution[i:j+1] = segment\n            else:\n                # Reverse the segment\n                new_solution[i:j+1] = segment[::-1]\n\n        # Apply edge insertion for the entire solution\n        for k in range(1, n-1):\n            if np.random.rand() < 0.3:  # Low probability to avoid excessive changes\n                # Remove node and reinsert elsewhere\n                node = new_solution[k]\n                new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n                insert_pos = np.random.randint(1, n-1)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution is valid and circular\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if invalid\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the tour is circular (first and last nodes are the same)\n    if new_solution[0] != new_solution[-1]:\n        new_solution[-1] = new_solution[0]\n\n    return new_solution\n\n",
        "score": [
            -0.8529273822590582,
            8.066650688648224
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest cost but still promising)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(len(archive_sorted) // 2, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine edge insertion with a biased random walk\n    n = len(base_solution)\n    for _ in range(5):  # Number of perturbation steps\n        # Randomly select a segment to perturb\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n\n        # Apply a biased random walk to the segment\n        if len(segment) > 2:\n            # Shuffle the segment with probability based on its length\n            if np.random.rand() < 0.7:\n                np.random.shuffle(segment)\n                new_solution[i:j+1] = segment\n            else:\n                # Reverse the segment\n                new_solution[i:j+1] = segment[::-1]\n\n        # Apply edge insertion for the entire solution\n        for k in range(1, n-1):\n            if np.random.rand() < 0.3:  # Low probability to avoid excessive changes\n                # Remove node and reinsert elsewhere\n                node = new_solution[k]\n                new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n                insert_pos = np.random.randint(1, n-1)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution is valid and circular\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if invalid\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the tour is circular (first and last nodes are the same)\n    if new_solution[0] != new_solution[-1]:\n        new_solution[-1] = new_solution[0]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 296,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n\n    # Select a solution with a bias towards lower-cost solutions\n    if len(archive) > 1:\n        # Sort archive by total cost (sum of both objectives)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select from top 30% of solutions with some randomness\n        selection_pool = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        base_solution, _ = random.choice(selection_pool)\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    if n >= 4:\n        # 3-opt move with probability 0.7, otherwise use novel node swap\n        if random.random() < 0.7:\n            # 3-opt move: select 3 non-consecutive edges and reconnect them\n            i, j, k = sorted(random.sample(range(n), 3))\n            # Ensure edges are not consecutive\n            while j == i + 1 or k == j + 1:\n                i, j, k = sorted(random.sample(range(n), 3))\n            # Perform the 3-opt move\n            new_solution[i:j] = new_solution[i:j][::-1]\n            new_solution[j:k] = new_solution[j:k][::-1]\n        else:\n            # Novel node swap: swap two nodes that are not adjacent\n            i, j = random.sample(range(n), 2)\n            # Ensure nodes are not adjacent\n            while abs(i - j) == 1 or (i == 0 and j == n - 1) or (j == 0 and i == n - 1):\n                i, j = random.sample(range(n), 2)\n            # Perform the swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6640905677096461,
            1.8750186562538147
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n\n    # Select a solution with a bias towards lower-cost solutions\n    if len(archive) > 1:\n        # Sort archive by total cost (sum of both objectives)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select from top 30% of solutions with some randomness\n        selection_pool = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        base_solution, _ = random.choice(selection_pool)\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    if n >= 4:\n        # 3-opt move with probability 0.7, otherwise use novel node swap\n        if random.random() < 0.7:\n            # 3-opt move: select 3 non-consecutive edges and reconnect them\n            i, j, k = sorted(random.sample(range(n), 3))\n            # Ensure edges are not consecutive\n            while j == i + 1 or k == j + 1:\n                i, j, k = sorted(random.sample(range(n), 3))\n            # Perform the 3-opt move\n            new_solution[i:j] = new_solution[i:j][::-1]\n            new_solution[j:k] = new_solution[j:k][::-1]\n        else:\n            # Novel node swap: swap two nodes that are not adjacent\n            i, j = random.sample(range(n), 2)\n            # Ensure nodes are not adjacent\n            while abs(i - j) == 1 or (i == 0 and j == n - 1) or (j == 0 and i == n - 1):\n                i, j = random.sample(range(n), 2)\n            # Perform the swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 297,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weighted_scores = [(obj[0] + obj[1], idx) for idx, (sol, obj) in enumerate(archive)]\n    best_idx = min(weighted_scores, key=lambda x: x[0])[1]\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search: apply a mix of edge and node swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n\n    # Apply a random transformation to the segment\n    if random.random() < 0.5:\n        # Reverse the segment (like 2-opt but more flexible)\n        segment = segment[::-1]\n    else:\n        # Rotate the segment\n        k = random.randint(1, len(segment)-1)\n        segment = np.roll(segment, k)\n\n    # Insert the transformed segment back\n    new_solution[a:b+1] = segment\n\n    # Ensure the solution is valid (no duplicates and complete)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to nearest valid solution\n        # This is a simple recovery mechanism\n        new_solution = base_solution.copy()\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7636820264238455,
            2.568989336490631
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weighted_scores = [(obj[0] + obj[1], idx) for idx, (sol, obj) in enumerate(archive)]\n    best_idx = min(weighted_scores, key=lambda x: x[0])[1]\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search: apply a mix of edge and node swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n\n    # Apply a random transformation to the segment\n    if random.random() < 0.5:\n        # Reverse the segment (like 2-opt but more flexible)\n        segment = segment[::-1]\n    else:\n        # Rotate the segment\n        k = random.randint(1, len(segment)-1)\n        segment = np.roll(segment, k)\n\n    # Insert the transformed segment back\n    new_solution[a:b+1] = segment\n\n    # Ensure the solution is valid (no duplicates and complete)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to nearest valid solution\n        # This is a simple recovery mechanism\n        new_solution = base_solution.copy()\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 298,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high diversity)\n    selected = random.choices(\n        archive,\n        weights=[1/(1 + obj[0] + obj[1]) for _, obj in archive],  # Prefer solutions with lower combined cost\n        k=1\n    )[0][0].copy()\n\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine edge insertion and swap\n    # Step 1: Randomly select a segment to perturb\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b]\n\n    # Step 2: Apply edge insertion for the segment\n    for i in range(len(segment)):\n        node = segment[i]\n        # Find the best insertion position in the remaining part of the tour\n        best_pos = -1\n        best_gain = float('inf')\n        for j in range(n):\n            if j >= a and j < b:\n                continue  # Skip the segment itself\n            # Calculate cost change for insertion\n            before = new_solution[j-1] if j > 0 else new_solution[-1]\n            after = new_solution[j]\n            old_cost = distance_matrix_1[before, node] + distance_matrix_1[node, after] + \\\n                       distance_matrix_2[before, node] + distance_matrix_2[node, after]\n            new_cost = distance_matrix_1[before, after] + \\\n                       distance_matrix_2[before, after]\n            gain = new_cost - old_cost\n            if gain < best_gain:\n                best_gain = gain\n                best_pos = j\n        if best_pos != -1:\n            # Perform the insertion\n            new_solution = np.concatenate([\n                new_solution[:a+i], new_solution[a+i+1:best_pos], [node], new_solution[best_pos:]\n            ])\n\n    # Step 3: Apply a swap to further improve\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.840162794050894,
            3.8988542556762695
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high diversity)\n    selected = random.choices(\n        archive,\n        weights=[1/(1 + obj[0] + obj[1]) for _, obj in archive],  # Prefer solutions with lower combined cost\n        k=1\n    )[0][0].copy()\n\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine edge insertion and swap\n    # Step 1: Randomly select a segment to perturb\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b]\n\n    # Step 2: Apply edge insertion for the segment\n    for i in range(len(segment)):\n        node = segment[i]\n        # Find the best insertion position in the remaining part of the tour\n        best_pos = -1\n        best_gain = float('inf')\n        for j in range(n):\n            if j >= a and j < b:\n                continue  # Skip the segment itself\n            # Calculate cost change for insertion\n            before = new_solution[j-1] if j > 0 else new_solution[-1]\n            after = new_solution[j]\n            old_cost = distance_matrix_1[before, node] + distance_matrix_1[node, after] + \\\n                       distance_matrix_2[before, node] + distance_matrix_2[node, after]\n            new_cost = distance_matrix_1[before, after] + \\\n                       distance_matrix_2[before, after]\n            gain = new_cost - old_cost\n            if gain < best_gain:\n                best_gain = gain\n                best_pos = j\n        if best_pos != -1:\n            # Perform the insertion\n            new_solution = np.concatenate([\n                new_solution[:a+i], new_solution[a+i+1:best_pos], [node], new_solution[best_pos:]\n            ])\n\n    # Step 3: Apply a swap to further improve\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 299,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selection_prob = 1 - normalized_costs.mean(axis=1)  # Prefer solutions with lower combined costs\n    selection_prob = selection_prob / selection_prob.sum()\n\n    selected_idx = np.random.choice(len(archive), p=selection_prob)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    def calculate_tour_length(solution, distance_matrix):\n        total = 0.0\n        for i in range(len(solution)):\n            total += distance_matrix[solution[i-1], solution[i]]\n        return total\n\n    current_cost1 = calculate_tour_length(new_solution, distance_matrix_1)\n    current_cost2 = calculate_tour_length(new_solution, distance_matrix_2)\n\n    # 3-opt local search with random segment selection\n    improved = True\n    while improved:\n        improved = False\n        n = len(new_solution)\n        # Randomly select a segment to operate on\n        seg_start = random.randint(0, n-1)\n        seg_length = random.randint(3, min(10, n//2))\n        seg_end = (seg_start + seg_length) % n\n\n        # Extract the segment and reverse it (3-opt variant)\n        segment = new_solution[seg_start:seg_end]\n        reversed_segment = segment[::-1]\n        candidate = new_solution.copy()\n        candidate[seg_start:seg_end] = reversed_segment\n\n        # Calculate new costs\n        new_cost1 = calculate_tour_length(candidate, distance_matrix_1)\n        new_cost2 = calculate_tour_length(candidate, distance_matrix_2)\n\n        # Accept if at least one objective improves\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution = candidate\n            current_cost1, current_cost2 = new_cost1, new_cost2\n            improved = True\n\n    # Additional perturbation to escape local optima\n    if random.random() < 0.3:  # 30% chance for perturbation\n        # Randomly select two non-adjacent segments and swap them\n        n = len(new_solution)\n        split1 = random.randint(1, n-2)\n        split2 = random.randint(split1+1, n-1)\n\n        seg1 = new_solution[:split1]\n        seg2 = new_solution[split1:split2]\n        seg3 = new_solution[split2:]\n\n        # Create a new tour by rearranging segments\n        candidate = np.concatenate([seg1, seg3, seg2])\n\n        # Verify feasibility\n        if len(np.unique(candidate)) == len(new_solution):\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7570297520834632,
            3.8317850828170776
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selection_prob = 1 - normalized_costs.mean(axis=1)  # Prefer solutions with lower combined costs\n    selection_prob = selection_prob / selection_prob.sum()\n\n    selected_idx = np.random.choice(len(archive), p=selection_prob)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    def calculate_tour_length(solution, distance_matrix):\n        total = 0.0\n        for i in range(len(solution)):\n            total += distance_matrix[solution[i-1], solution[i]]\n        return total\n\n    current_cost1 = calculate_tour_length(new_solution, distance_matrix_1)\n    current_cost2 = calculate_tour_length(new_solution, distance_matrix_2)\n\n    # 3-opt local search with random segment selection\n    improved = True\n    while improved:\n        improved = False\n        n = len(new_solution)\n        # Randomly select a segment to operate on\n        seg_start = random.randint(0, n-1)\n        seg_length = random.randint(3, min(10, n//2))\n        seg_end = (seg_start + seg_length) % n\n\n        # Extract the segment and reverse it (3-opt variant)\n        segment = new_solution[seg_start:seg_end]\n        reversed_segment = segment[::-1]\n        candidate = new_solution.copy()\n        candidate[seg_start:seg_end] = reversed_segment\n\n        # Calculate new costs\n        new_cost1 = calculate_tour_length(candidate, distance_matrix_1)\n        new_cost2 = calculate_tour_length(candidate, distance_matrix_2)\n\n        # Accept if at least one objective improves\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution = candidate\n            current_cost1, current_cost2 = new_cost1, new_cost2\n            improved = True\n\n    # Additional perturbation to escape local optima\n    if random.random() < 0.3:  # 30% chance for perturbation\n        # Randomly select two non-adjacent segments and swap them\n        n = len(new_solution)\n        split1 = random.randint(1, n-2)\n        split2 = random.randint(split1+1, n-1)\n\n        seg1 = new_solution[:split1]\n        seg2 = new_solution[split1:split2]\n        seg3 = new_solution[split2:]\n\n        # Create a new tour by rearranging segments\n        candidate = np.concatenate([seg1, seg3, seg2])\n\n        # Verify feasibility\n        if len(np.unique(candidate)) == len(new_solution):\n            new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 300,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    def combined_cost(obj):\n        return obj[0] + obj[1]  # Simple sum for selection, can be adjusted\n\n    best_solution, _ = min(archive, key=lambda x: combined_cost(x[1]))\n    base_solution = best_solution.copy()\n\n    # Hybrid local search: combine edge insertion and partial reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse (3-opt-like operation)\n    i, j = sorted(np.random.choice(range(1, n), 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly insert a node elsewhere (edge insertion)\n    k = np.random.randint(1, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = np.random.randint(1, n)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.6440368005017879,
            2.835738241672516
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    def combined_cost(obj):\n        return obj[0] + obj[1]  # Simple sum for selection, can be adjusted\n\n    best_solution, _ = min(archive, key=lambda x: combined_cost(x[1]))\n    base_solution = best_solution.copy()\n\n    # Hybrid local search: combine edge insertion and partial reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse (3-opt-like operation)\n    i, j = sorted(np.random.choice(range(1, n), 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly insert a node elsewhere (edge insertion)\n    k = np.random.randint(1, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = np.random.randint(1, n)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    }
]