[
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 1,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate improvement potential (inverse of objective values)\n    improvement_potential = [1 / (obj[0] + obj[1] + obj[2]) for obj in archive_objectives]\n    selected_idx = random.choices(range(len(archive_solutions)), weights=improvement_potential, k=1)[0]\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search operator: combination of 2-opt and edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First apply 2-opt to improve one objective\n    obj_to_improve = random.choice([0, 1, 2])\n    if obj_to_improve == 0:\n        dist_matrix = distance_matrix_1\n    elif obj_to_improve == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the worst edge in the current solution for the selected objective\n    worst_edge = None\n    max_dist = -1\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i + 1) % n]\n        current_dist = dist_matrix[u, v]\n        if current_dist > max_dist:\n            max_dist = current_dist\n            worst_edge = (i, (i + 1) % n)\n\n    if worst_edge is not None:\n        i, j = worst_edge\n        # Try to replace the worst edge with a better one\n        for k in range(n):\n            if k == i or k == j or k == (i + 1) % n or k == (j - 1) % n:\n                continue\n            # Calculate potential new edges\n            u, v = new_solution[i], new_solution[k]\n            w, x = new_solution[(j + 1) % n], new_solution[(i + 1) % n]\n            gain = (dist_matrix[u, v] + dist_matrix[w, x]) - (dist_matrix[u, x] + dist_matrix[w, v])\n            if gain > 0:\n                # Perform 2-opt move\n                new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n                break\n\n    # Then apply edge insertion to balance other objectives\n    for _ in range(2):  # Limit to 2 insertions to maintain diversity\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i == j or abs(i - j) == 1 or (i == 0 and j == n-1) or (j == 0 and i == n-1):\n            continue\n\n        # Remove edge and insert node\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6924529662443951,
            1.3390172481536866
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate improvement potential (inverse of objective values)\n    improvement_potential = [1 / (obj[0] + obj[1] + obj[2]) for obj in archive_objectives]\n    selected_idx = random.choices(range(len(archive_solutions)), weights=improvement_potential, k=1)[0]\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search operator: combination of 2-opt and edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First apply 2-opt to improve one objective\n    obj_to_improve = random.choice([0, 1, 2])\n    if obj_to_improve == 0:\n        dist_matrix = distance_matrix_1\n    elif obj_to_improve == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the worst edge in the current solution for the selected objective\n    worst_edge = None\n    max_dist = -1\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i + 1) % n]\n        current_dist = dist_matrix[u, v]\n        if current_dist > max_dist:\n            max_dist = current_dist\n            worst_edge = (i, (i + 1) % n)\n\n    if worst_edge is not None:\n        i, j = worst_edge\n        # Try to replace the worst edge with a better one\n        for k in range(n):\n            if k == i or k == j or k == (i + 1) % n or k == (j - 1) % n:\n                continue\n            # Calculate potential new edges\n            u, v = new_solution[i], new_solution[k]\n            w, x = new_solution[(j + 1) % n], new_solution[(i + 1) % n]\n            gain = (dist_matrix[u, v] + dist_matrix[w, x]) - (dist_matrix[u, x] + dist_matrix[w, v])\n            if gain > 0:\n                # Perform 2-opt move\n                new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n                break\n\n    # Then apply edge insertion to balance other objectives\n    for _ in range(2):  # Limit to 2 insertions to maintain diversity\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i == j or abs(i - j) == 1 or (i == 0 and j == n-1) or (j == 0 and i == n-1):\n            continue\n\n        # Remove edge and insert node\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 1,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate improvement potential (inverse of objective values)\n    improvement_potential = [1 / (obj[0] + obj[1] + obj[2]) for obj in archive_objectives]\n    selected_idx = random.choices(range(len(archive_solutions)), weights=improvement_potential, k=1)[0]\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search operator: combination of 2-opt and edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First apply 2-opt to improve one objective\n    obj_to_improve = random.choice([0, 1, 2])\n    if obj_to_improve == 0:\n        dist_matrix = distance_matrix_1\n    elif obj_to_improve == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the worst edge in the current solution for the selected objective\n    worst_edge = None\n    max_dist = -1\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i + 1) % n]\n        current_dist = dist_matrix[u, v]\n        if current_dist > max_dist:\n            max_dist = current_dist\n            worst_edge = (i, (i + 1) % n)\n\n    if worst_edge is not None:\n        i, j = worst_edge\n        # Try to replace the worst edge with a better one\n        for k in range(n):\n            if k == i or k == j or k == (i + 1) % n or k == (j - 1) % n:\n                continue\n            # Calculate potential new edges\n            u, v = new_solution[i], new_solution[k]\n            w, x = new_solution[(j + 1) % n], new_solution[(i + 1) % n]\n            gain = (dist_matrix[u, v] + dist_matrix[w, x]) - (dist_matrix[u, x] + dist_matrix[w, v])\n            if gain > 0:\n                # Perform 2-opt move\n                new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n                break\n\n    # Then apply edge insertion to balance other objectives\n    for _ in range(2):  # Limit to 2 insertions to maintain diversity\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i == j or abs(i - j) == 1 or (i == 0 and j == n-1) or (j == 0 and i == n-1):\n            continue\n\n        # Remove edge and insert node\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6924529662443951,
            1.3390172481536866
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate improvement potential (inverse of objective values)\n    improvement_potential = [1 / (obj[0] + obj[1] + obj[2]) for obj in archive_objectives]\n    selected_idx = random.choices(range(len(archive_solutions)), weights=improvement_potential, k=1)[0]\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search operator: combination of 2-opt and edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First apply 2-opt to improve one objective\n    obj_to_improve = random.choice([0, 1, 2])\n    if obj_to_improve == 0:\n        dist_matrix = distance_matrix_1\n    elif obj_to_improve == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the worst edge in the current solution for the selected objective\n    worst_edge = None\n    max_dist = -1\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i + 1) % n]\n        current_dist = dist_matrix[u, v]\n        if current_dist > max_dist:\n            max_dist = current_dist\n            worst_edge = (i, (i + 1) % n)\n\n    if worst_edge is not None:\n        i, j = worst_edge\n        # Try to replace the worst edge with a better one\n        for k in range(n):\n            if k == i or k == j or k == (i + 1) % n or k == (j - 1) % n:\n                continue\n            # Calculate potential new edges\n            u, v = new_solution[i], new_solution[k]\n            w, x = new_solution[(j + 1) % n], new_solution[(i + 1) % n]\n            gain = (dist_matrix[u, v] + dist_matrix[w, x]) - (dist_matrix[u, x] + dist_matrix[w, v])\n            if gain > 0:\n                # Perform 2-opt move\n                new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n                break\n\n    # Then apply edge insertion to balance other objectives\n    for _ in range(2):  # Limit to 2 insertions to maintain diversity\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i == j or abs(i - j) == 1 or (i == 0 and j == n-1) or (j == 0 and i == n-1):\n            continue\n\n        # Remove edge and insert node\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 1,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate improvement potential (inverse of objective values)\n    improvement_potential = [1 / (obj[0] + obj[1] + obj[2]) for obj in archive_objectives]\n    selected_idx = random.choices(range(len(archive_solutions)), weights=improvement_potential, k=1)[0]\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search operator: combination of 2-opt and edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First apply 2-opt to improve one objective\n    obj_to_improve = random.choice([0, 1, 2])\n    if obj_to_improve == 0:\n        dist_matrix = distance_matrix_1\n    elif obj_to_improve == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the worst edge in the current solution for the selected objective\n    worst_edge = None\n    max_dist = -1\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i + 1) % n]\n        current_dist = dist_matrix[u, v]\n        if current_dist > max_dist:\n            max_dist = current_dist\n            worst_edge = (i, (i + 1) % n)\n\n    if worst_edge is not None:\n        i, j = worst_edge\n        # Try to replace the worst edge with a better one\n        for k in range(n):\n            if k == i or k == j or k == (i + 1) % n or k == (j - 1) % n:\n                continue\n            # Calculate potential new edges\n            u, v = new_solution[i], new_solution[k]\n            w, x = new_solution[(j + 1) % n], new_solution[(i + 1) % n]\n            gain = (dist_matrix[u, v] + dist_matrix[w, x]) - (dist_matrix[u, x] + dist_matrix[w, v])\n            if gain > 0:\n                # Perform 2-opt move\n                new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n                break\n\n    # Then apply edge insertion to balance other objectives\n    for _ in range(2):  # Limit to 2 insertions to maintain diversity\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i == j or abs(i - j) == 1 or (i == 0 and j == n-1) or (j == 0 and i == n-1):\n            continue\n\n        # Remove edge and insert node\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6924529662443951,
            1.3390172481536866
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate improvement potential (inverse of objective values)\n    improvement_potential = [1 / (obj[0] + obj[1] + obj[2]) for obj in archive_objectives]\n    selected_idx = random.choices(range(len(archive_solutions)), weights=improvement_potential, k=1)[0]\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search operator: combination of 2-opt and edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First apply 2-opt to improve one objective\n    obj_to_improve = random.choice([0, 1, 2])\n    if obj_to_improve == 0:\n        dist_matrix = distance_matrix_1\n    elif obj_to_improve == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the worst edge in the current solution for the selected objective\n    worst_edge = None\n    max_dist = -1\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i + 1) % n]\n        current_dist = dist_matrix[u, v]\n        if current_dist > max_dist:\n            max_dist = current_dist\n            worst_edge = (i, (i + 1) % n)\n\n    if worst_edge is not None:\n        i, j = worst_edge\n        # Try to replace the worst edge with a better one\n        for k in range(n):\n            if k == i or k == j or k == (i + 1) % n or k == (j - 1) % n:\n                continue\n            # Calculate potential new edges\n            u, v = new_solution[i], new_solution[k]\n            w, x = new_solution[(j + 1) % n], new_solution[(i + 1) % n]\n            gain = (dist_matrix[u, v] + dist_matrix[w, x]) - (dist_matrix[u, x] + dist_matrix[w, v])\n            if gain > 0:\n                # Perform 2-opt move\n                new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n                break\n\n    # Then apply edge insertion to balance other objectives\n    for _ in range(2):  # Limit to 2 insertions to maintain diversity\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i == j or abs(i - j) == 1 or (i == 0 and j == n-1) or (j == 0 and i == n-1):\n            continue\n\n        # Remove edge and insert node\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 2,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low cost in at least one objective\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of 2-opt and objective-aware swaps\n    n = len(base_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: swap nodes that are far apart in multiple objectives\n    if np.random.rand() < 0.5:  # 50% chance to apply objective-aware swap\n        # Find nodes that are far apart in at least two objectives\n        far_nodes = []\n        for k in range(n):\n            node1 = base_solution[k]\n            node2 = base_solution[(k+1)%n]\n            dist1 = distance_matrix_1[node1, node2]\n            dist2 = distance_matrix_2[node1, node2]\n            dist3 = distance_matrix_3[node1, node2]\n            if (dist1 > np.median(distance_matrix_1)) and (dist2 > np.median(distance_matrix_2)) or (dist3 > np.median(distance_matrix_3)):\n                far_nodes.append(k)\n\n        if len(far_nodes) >= 2:\n            # Swap two far nodes\n            swap_pos = np.random.choice(far_nodes, size=2, replace=False)\n            new_solution[swap_pos[0]], new_solution[swap_pos[1]] = new_solution[swap_pos[1]], new_solution[swap_pos[0]]\n\n    return new_solution\n\n",
        "score": [
            -0.7607252344898068,
            3.8897883534431457
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low cost in at least one objective\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of 2-opt and objective-aware swaps\n    n = len(base_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: swap nodes that are far apart in multiple objectives\n    if np.random.rand() < 0.5:  # 50% chance to apply objective-aware swap\n        # Find nodes that are far apart in at least two objectives\n        far_nodes = []\n        for k in range(n):\n            node1 = base_solution[k]\n            node2 = base_solution[(k+1)%n]\n            dist1 = distance_matrix_1[node1, node2]\n            dist2 = distance_matrix_2[node1, node2]\n            dist3 = distance_matrix_3[node1, node2]\n            if (dist1 > np.median(distance_matrix_1)) and (dist2 > np.median(distance_matrix_2)) or (dist3 > np.median(distance_matrix_3)):\n                far_nodes.append(k)\n\n        if len(far_nodes) >= 2:\n            # Swap two far nodes\n            swap_pos = np.random.choice(far_nodes, size=2, replace=False)\n            new_solution[swap_pos[0]], new_solution[swap_pos[1]] = new_solution[swap_pos[1]], new_solution[swap_pos[0]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 2,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low cost in at least one objective\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of 2-opt and objective-aware swaps\n    n = len(base_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: swap nodes that are far apart in multiple objectives\n    if np.random.rand() < 0.5:  # 50% chance to apply objective-aware swap\n        # Find nodes that are far apart in at least two objectives\n        far_nodes = []\n        for k in range(n):\n            node1 = base_solution[k]\n            node2 = base_solution[(k+1)%n]\n            dist1 = distance_matrix_1[node1, node2]\n            dist2 = distance_matrix_2[node1, node2]\n            dist3 = distance_matrix_3[node1, node2]\n            if (dist1 > np.median(distance_matrix_1)) and (dist2 > np.median(distance_matrix_2)) or (dist3 > np.median(distance_matrix_3)):\n                far_nodes.append(k)\n\n        if len(far_nodes) >= 2:\n            # Swap two far nodes\n            swap_pos = np.random.choice(far_nodes, size=2, replace=False)\n            new_solution[swap_pos[0]], new_solution[swap_pos[1]] = new_solution[swap_pos[1]], new_solution[swap_pos[0]]\n\n    return new_solution\n\n",
        "score": [
            -0.7607252344898068,
            3.8897883534431457
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low cost in at least one objective\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of 2-opt and objective-aware swaps\n    n = len(base_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: swap nodes that are far apart in multiple objectives\n    if np.random.rand() < 0.5:  # 50% chance to apply objective-aware swap\n        # Find nodes that are far apart in at least two objectives\n        far_nodes = []\n        for k in range(n):\n            node1 = base_solution[k]\n            node2 = base_solution[(k+1)%n]\n            dist1 = distance_matrix_1[node1, node2]\n            dist2 = distance_matrix_2[node1, node2]\n            dist3 = distance_matrix_3[node1, node2]\n            if (dist1 > np.median(distance_matrix_1)) and (dist2 > np.median(distance_matrix_2)) or (dist3 > np.median(distance_matrix_3)):\n                far_nodes.append(k)\n\n        if len(far_nodes) >= 2:\n            # Swap two far nodes\n            swap_pos = np.random.choice(far_nodes, size=2, replace=False)\n            new_solution[swap_pos[0]], new_solution[swap_pos[1]] = new_solution[swap_pos[1]], new_solution[swap_pos[0]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 3,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest combined improvement potential\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(selected_solution)\n    improved = False\n\n    # First, perform a random 2-opt move\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution = selected_solution.copy()\n    new_solution[i:j+1] = selected_solution[j:i-1 if i > 0 else None:-1]\n\n    # Evaluate the new solution\n    def evaluate(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n        cost3 = sum(distance_matrix_3[solution[i], solution[(i+1)%n]] for i in range(n))\n        return (cost1, cost2, cost3)\n\n    new_cost = evaluate(new_solution)\n    old_cost = evaluate(selected_solution)\n\n    # If the new solution is better in at least one objective, accept it\n    if any(new_cost[i] < old_cost[i] for i in range(3)):\n        selected_solution = new_solution\n        improved = True\n\n    # If no improvement, try objective-aware swaps\n    if not improved:\n        # Find the worst objective and try to improve it\n        worst_obj = np.argmax(old_cost)\n        if worst_obj == 0:\n            matrix = distance_matrix_1\n        elif worst_obj == 1:\n            matrix = distance_matrix_2\n        else:\n            matrix = distance_matrix_3\n\n        # Find the most promising swap to improve this objective\n        best_swap = None\n        best_improvement = 0\n\n        for i in range(n):\n            for j in range(i+1, n):\n                # Create a temporary swap\n                temp_solution = selected_solution.copy()\n                temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n                # Calculate the improvement in the worst objective\n                temp_cost = evaluate(temp_solution)\n                improvement = old_cost[worst_obj] - temp_cost[worst_obj]\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_swap = (i, j)\n\n        if best_swap is not None:\n            i, j = best_swap\n            selected_solution[i], selected_solution[j] = selected_solution[j], selected_solution[i]\n\n    return selected_solution\n\n",
        "score": [
            -0.7204870374240266,
            3.3512104630470274
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest combined improvement potential\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(selected_solution)\n    improved = False\n\n    # First, perform a random 2-opt move\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution = selected_solution.copy()\n    new_solution[i:j+1] = selected_solution[j:i-1 if i > 0 else None:-1]\n\n    # Evaluate the new solution\n    def evaluate(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n        cost3 = sum(distance_matrix_3[solution[i], solution[(i+1)%n]] for i in range(n))\n        return (cost1, cost2, cost3)\n\n    new_cost = evaluate(new_solution)\n    old_cost = evaluate(selected_solution)\n\n    # If the new solution is better in at least one objective, accept it\n    if any(new_cost[i] < old_cost[i] for i in range(3)):\n        selected_solution = new_solution\n        improved = True\n\n    # If no improvement, try objective-aware swaps\n    if not improved:\n        # Find the worst objective and try to improve it\n        worst_obj = np.argmax(old_cost)\n        if worst_obj == 0:\n            matrix = distance_matrix_1\n        elif worst_obj == 1:\n            matrix = distance_matrix_2\n        else:\n            matrix = distance_matrix_3\n\n        # Find the most promising swap to improve this objective\n        best_swap = None\n        best_improvement = 0\n\n        for i in range(n):\n            for j in range(i+1, n):\n                # Create a temporary swap\n                temp_solution = selected_solution.copy()\n                temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n                # Calculate the improvement in the worst objective\n                temp_cost = evaluate(temp_solution)\n                improvement = old_cost[worst_obj] - temp_cost[worst_obj]\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_swap = (i, j)\n\n        if best_swap is not None:\n            i, j = best_swap\n            selected_solution[i], selected_solution[j] = selected_solution[j], selected_solution[i]\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 4,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with high diversity or non-dominated status)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel 3-objective-aware perturbation\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move for one objective\n    obj_to_optimize = np.random.randint(0, 3)\n    if obj_to_optimize == 0:\n        dist_matrix = distance_matrix_1\n    elif obj_to_optimize == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the best 2-opt move for the selected objective\n    best_delta = 0\n    best_i, best_j = -1, -1\n\n    for i in range(n - 1):\n        for j in range(i + 2, n - 1):\n            # Current edges: (i, i+1) and (j, j+1)\n            # New edges: (i, j) and (i+1, j+1)\n            delta = (dist_matrix[new_solution[j], new_solution[i]] +\n                     dist_matrix[new_solution[i + 1], new_solution[j + 1]] -\n                     dist_matrix[new_solution[i], new_solution[i + 1]] -\n                     dist_matrix[new_solution[j], new_solution[j + 1]])\n\n            if delta < best_delta:\n                best_delta = delta\n                best_i, best_j = i, j\n\n    if best_i != -1:\n        # Apply the 2-opt move\n        new_solution[best_i + 1:best_j + 1] = np.flip(new_solution[best_i + 1:best_j + 1])\n\n    # Second, apply a novel 3-objective-aware perturbation\n    # Select two random segments and swap them, but ensure the move is beneficial across all objectives\n    if n > 4:\n        # Select two non-overlapping segments\n        seg1_start = np.random.randint(0, n - 4)\n        seg1_end = np.random.randint(seg1_start + 2, n - 2)\n        seg2_start = np.random.randint(seg1_end + 1, n - 1)\n        seg2_end = np.random.randint(seg2_start + 1, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[seg1_end], new_solution[seg2_start]] +\n                 distance_matrix_1[new_solution[seg1_start], new_solution[seg2_end]] -\n                 distance_matrix_1[new_solution[seg1_start], new_solution[seg1_end]] -\n                 distance_matrix_1[new_solution[seg2_start], new_solution[seg2_end]])\n\n        delta2 = (distance_matrix_2[new_solution[seg1_end], new_solution[seg2_start]] +\n                 distance_matrix_2[new_solution[seg1_start], new_solution[seg2_end]] -\n                 distance_matrix_2[new_solution[seg1_start], new_solution[seg1_end]] -\n                 distance_matrix_2[new_solution[seg2_start], new_solution[seg2_end]])\n\n        delta3 = (distance_matrix_3[new_solution[seg1_end], new_solution[seg2_start]] +\n                 distance_matrix_3[new_solution[seg1_start], new_solution[seg2_end]] -\n                 distance_matrix_3[new_solution[seg1_start], new_solution[seg1_end]] -\n                 distance_matrix_3[new_solution[seg2_start], new_solution[seg2_end]])\n\n        # Only apply if the move is beneficial for at least two objectives\n        if (delta1 < 0) + (delta2 < 0) + (delta3 < 0) >= 2:\n            # Swap the segments\n            temp = new_solution[seg1_start:seg1_end + 1].copy()\n            new_solution[seg1_start:seg1_end + 1] = new_solution[seg2_start:seg2_end + 1]\n            new_solution[seg2_start:seg2_end + 1] = temp\n\n    return new_solution\n\n",
        "score": [
            -0.7612458597537498,
            4.006470584869385
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with high diversity or non-dominated status)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel 3-objective-aware perturbation\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move for one objective\n    obj_to_optimize = np.random.randint(0, 3)\n    if obj_to_optimize == 0:\n        dist_matrix = distance_matrix_1\n    elif obj_to_optimize == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the best 2-opt move for the selected objective\n    best_delta = 0\n    best_i, best_j = -1, -1\n\n    for i in range(n - 1):\n        for j in range(i + 2, n - 1):\n            # Current edges: (i, i+1) and (j, j+1)\n            # New edges: (i, j) and (i+1, j+1)\n            delta = (dist_matrix[new_solution[j], new_solution[i]] +\n                     dist_matrix[new_solution[i + 1], new_solution[j + 1]] -\n                     dist_matrix[new_solution[i], new_solution[i + 1]] -\n                     dist_matrix[new_solution[j], new_solution[j + 1]])\n\n            if delta < best_delta:\n                best_delta = delta\n                best_i, best_j = i, j\n\n    if best_i != -1:\n        # Apply the 2-opt move\n        new_solution[best_i + 1:best_j + 1] = np.flip(new_solution[best_i + 1:best_j + 1])\n\n    # Second, apply a novel 3-objective-aware perturbation\n    # Select two random segments and swap them, but ensure the move is beneficial across all objectives\n    if n > 4:\n        # Select two non-overlapping segments\n        seg1_start = np.random.randint(0, n - 4)\n        seg1_end = np.random.randint(seg1_start + 2, n - 2)\n        seg2_start = np.random.randint(seg1_end + 1, n - 1)\n        seg2_end = np.random.randint(seg2_start + 1, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[seg1_end], new_solution[seg2_start]] +\n                 distance_matrix_1[new_solution[seg1_start], new_solution[seg2_end]] -\n                 distance_matrix_1[new_solution[seg1_start], new_solution[seg1_end]] -\n                 distance_matrix_1[new_solution[seg2_start], new_solution[seg2_end]])\n\n        delta2 = (distance_matrix_2[new_solution[seg1_end], new_solution[seg2_start]] +\n                 distance_matrix_2[new_solution[seg1_start], new_solution[seg2_end]] -\n                 distance_matrix_2[new_solution[seg1_start], new_solution[seg1_end]] -\n                 distance_matrix_2[new_solution[seg2_start], new_solution[seg2_end]])\n\n        delta3 = (distance_matrix_3[new_solution[seg1_end], new_solution[seg2_start]] +\n                 distance_matrix_3[new_solution[seg1_start], new_solution[seg2_end]] -\n                 distance_matrix_3[new_solution[seg1_start], new_solution[seg1_end]] -\n                 distance_matrix_3[new_solution[seg2_start], new_solution[seg2_end]])\n\n        # Only apply if the move is beneficial for at least two objectives\n        if (delta1 < 0) + (delta2 < 0) + (delta3 < 0) >= 2:\n            # Swap the segments\n            temp = new_solution[seg1_start:seg1_end + 1].copy()\n            new_solution[seg1_start:seg1_end + 1] = new_solution[seg2_start:seg2_end + 1]\n            new_solution[seg2_start:seg2_end + 1] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 4,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with high diversity or non-dominated status)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel 3-objective-aware perturbation\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move for one objective\n    obj_to_optimize = np.random.randint(0, 3)\n    if obj_to_optimize == 0:\n        dist_matrix = distance_matrix_1\n    elif obj_to_optimize == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the best 2-opt move for the selected objective\n    best_delta = 0\n    best_i, best_j = -1, -1\n\n    for i in range(n - 1):\n        for j in range(i + 2, n - 1):\n            # Current edges: (i, i+1) and (j, j+1)\n            # New edges: (i, j) and (i+1, j+1)\n            delta = (dist_matrix[new_solution[j], new_solution[i]] +\n                     dist_matrix[new_solution[i + 1], new_solution[j + 1]] -\n                     dist_matrix[new_solution[i], new_solution[i + 1]] -\n                     dist_matrix[new_solution[j], new_solution[j + 1]])\n\n            if delta < best_delta:\n                best_delta = delta\n                best_i, best_j = i, j\n\n    if best_i != -1:\n        # Apply the 2-opt move\n        new_solution[best_i + 1:best_j + 1] = np.flip(new_solution[best_i + 1:best_j + 1])\n\n    # Second, apply a novel 3-objective-aware perturbation\n    # Select two random segments and swap them, but ensure the move is beneficial across all objectives\n    if n > 4:\n        # Select two non-overlapping segments\n        seg1_start = np.random.randint(0, n - 4)\n        seg1_end = np.random.randint(seg1_start + 2, n - 2)\n        seg2_start = np.random.randint(seg1_end + 1, n - 1)\n        seg2_end = np.random.randint(seg2_start + 1, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[seg1_end], new_solution[seg2_start]] +\n                 distance_matrix_1[new_solution[seg1_start], new_solution[seg2_end]] -\n                 distance_matrix_1[new_solution[seg1_start], new_solution[seg1_end]] -\n                 distance_matrix_1[new_solution[seg2_start], new_solution[seg2_end]])\n\n        delta2 = (distance_matrix_2[new_solution[seg1_end], new_solution[seg2_start]] +\n                 distance_matrix_2[new_solution[seg1_start], new_solution[seg2_end]] -\n                 distance_matrix_2[new_solution[seg1_start], new_solution[seg1_end]] -\n                 distance_matrix_2[new_solution[seg2_start], new_solution[seg2_end]])\n\n        delta3 = (distance_matrix_3[new_solution[seg1_end], new_solution[seg2_start]] +\n                 distance_matrix_3[new_solution[seg1_start], new_solution[seg2_end]] -\n                 distance_matrix_3[new_solution[seg1_start], new_solution[seg1_end]] -\n                 distance_matrix_3[new_solution[seg2_start], new_solution[seg2_end]])\n\n        # Only apply if the move is beneficial for at least two objectives\n        if (delta1 < 0) + (delta2 < 0) + (delta3 < 0) >= 2:\n            # Swap the segments\n            temp = new_solution[seg1_start:seg1_end + 1].copy()\n            new_solution[seg1_start:seg1_end + 1] = new_solution[seg2_start:seg2_end + 1]\n            new_solution[seg2_start:seg2_end + 1] = temp\n\n    return new_solution\n\n",
        "score": [
            -0.7612458597537498,
            4.006470584869385
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with high diversity or non-dominated status)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel 3-objective-aware perturbation\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move for one objective\n    obj_to_optimize = np.random.randint(0, 3)\n    if obj_to_optimize == 0:\n        dist_matrix = distance_matrix_1\n    elif obj_to_optimize == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the best 2-opt move for the selected objective\n    best_delta = 0\n    best_i, best_j = -1, -1\n\n    for i in range(n - 1):\n        for j in range(i + 2, n - 1):\n            # Current edges: (i, i+1) and (j, j+1)\n            # New edges: (i, j) and (i+1, j+1)\n            delta = (dist_matrix[new_solution[j], new_solution[i]] +\n                     dist_matrix[new_solution[i + 1], new_solution[j + 1]] -\n                     dist_matrix[new_solution[i], new_solution[i + 1]] -\n                     dist_matrix[new_solution[j], new_solution[j + 1]])\n\n            if delta < best_delta:\n                best_delta = delta\n                best_i, best_j = i, j\n\n    if best_i != -1:\n        # Apply the 2-opt move\n        new_solution[best_i + 1:best_j + 1] = np.flip(new_solution[best_i + 1:best_j + 1])\n\n    # Second, apply a novel 3-objective-aware perturbation\n    # Select two random segments and swap them, but ensure the move is beneficial across all objectives\n    if n > 4:\n        # Select two non-overlapping segments\n        seg1_start = np.random.randint(0, n - 4)\n        seg1_end = np.random.randint(seg1_start + 2, n - 2)\n        seg2_start = np.random.randint(seg1_end + 1, n - 1)\n        seg2_end = np.random.randint(seg2_start + 1, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[seg1_end], new_solution[seg2_start]] +\n                 distance_matrix_1[new_solution[seg1_start], new_solution[seg2_end]] -\n                 distance_matrix_1[new_solution[seg1_start], new_solution[seg1_end]] -\n                 distance_matrix_1[new_solution[seg2_start], new_solution[seg2_end]])\n\n        delta2 = (distance_matrix_2[new_solution[seg1_end], new_solution[seg2_start]] +\n                 distance_matrix_2[new_solution[seg1_start], new_solution[seg2_end]] -\n                 distance_matrix_2[new_solution[seg1_start], new_solution[seg1_end]] -\n                 distance_matrix_2[new_solution[seg2_start], new_solution[seg2_end]])\n\n        delta3 = (distance_matrix_3[new_solution[seg1_end], new_solution[seg2_start]] +\n                 distance_matrix_3[new_solution[seg1_start], new_solution[seg2_end]] -\n                 distance_matrix_3[new_solution[seg1_start], new_solution[seg1_end]] -\n                 distance_matrix_3[new_solution[seg2_start], new_solution[seg2_end]])\n\n        # Only apply if the move is beneficial for at least two objectives\n        if (delta1 < 0) + (delta2 < 0) + (delta3 < 0) >= 2:\n            # Swap the segments\n            temp = new_solution[seg1_start:seg1_end + 1].copy()\n            new_solution[seg1_start:seg1_end + 1] = new_solution[seg2_start:seg2_end + 1]\n            new_solution[seg2_start:seg2_end + 1] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 5,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with the highest objective values)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and objective-aware edge swapping\n    n = len(base_solution)\n    i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n\n    # 2-opt swap for the first objective\n    if np.random.random() < 0.5:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Objective-aware edge swapping: prioritize edges that improve the worst objective\n        obj1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        obj2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        obj3 = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n\n        worst_obj = min(obj1, obj2, obj3)\n        if worst_obj == obj1:\n            # Swap edges in the first objective space\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n        elif worst_obj == obj2:\n            # Swap edges in the second objective space\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n        else:\n            # Swap edges in the third objective space\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    # Ensure the solution is valid (no duplicates and all nodes visited)\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.6154823709272905,
            1.3441361665725708
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with the highest objective values)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and objective-aware edge swapping\n    n = len(base_solution)\n    i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n\n    # 2-opt swap for the first objective\n    if np.random.random() < 0.5:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Objective-aware edge swapping: prioritize edges that improve the worst objective\n        obj1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        obj2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        obj3 = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n\n        worst_obj = min(obj1, obj2, obj3)\n        if worst_obj == obj1:\n            # Swap edges in the first objective space\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n        elif worst_obj == obj2:\n            # Swap edges in the second objective space\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n        else:\n            # Swap edges in the third objective space\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    # Ensure the solution is valid (no duplicates and all nodes visited)\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 6,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest objective values)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine 2-opt and segment inversion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Randomly choose between 2-opt and segment inversion\n    if np.random.rand() < 0.5:\n        # 2-opt local search\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Segment inversion with objective-aware selection\n        # Find the segment with the highest total distance in any objective space\n        max_segment_distance = -1\n        best_i, best_j = 0, 0\n        for i in range(n):\n            for j in range(i + 2, min(i + 10, n)):  # Limit segment size for efficiency\n                segment = selected_solution[i:j]\n                dist1 = sum(distance_matrix_1[segment[k], segment[k+1]] for k in range(len(segment)-1))\n                dist2 = sum(distance_matrix_2[segment[k], segment[k+1]] for k in range(len(segment)-1))\n                dist3 = sum(distance_matrix_3[segment[k], segment[k+1]] for k in range(len(segment)-1))\n                total_dist = dist1 + dist2 + dist3\n                if total_dist > max_segment_distance:\n                    max_segment_distance = total_dist\n                    best_i, best_j = i, j\n\n        if best_i != best_j:\n            new_solution[best_i:best_j] = new_solution[best_i:best_j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6740316769530033,
            3.5952950000762938
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest objective values)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine 2-opt and segment inversion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Randomly choose between 2-opt and segment inversion\n    if np.random.rand() < 0.5:\n        # 2-opt local search\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Segment inversion with objective-aware selection\n        # Find the segment with the highest total distance in any objective space\n        max_segment_distance = -1\n        best_i, best_j = 0, 0\n        for i in range(n):\n            for j in range(i + 2, min(i + 10, n)):  # Limit segment size for efficiency\n                segment = selected_solution[i:j]\n                dist1 = sum(distance_matrix_1[segment[k], segment[k+1]] for k in range(len(segment)-1))\n                dist2 = sum(distance_matrix_2[segment[k], segment[k+1]] for k in range(len(segment)-1))\n                dist3 = sum(distance_matrix_3[segment[k], segment[k+1]] for k in range(len(segment)-1))\n                total_dist = dist1 + dist2 + dist3\n                if total_dist > max_segment_distance:\n                    max_segment_distance = total_dist\n                    best_i, best_j = i, j\n\n        if best_i != best_j:\n            new_solution[best_i:best_j] = new_solution[best_i:best_j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 7,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective diversity)\n    weights = [1.0 / (1.0 + obj[0] + obj[1] + obj[2]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combination of 2-opt and objective-specific swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move (standard local search)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform an objective-specific swap based on the worst objective\n    obj = archive[selected_idx][1]\n    worst_obj = np.argmax(obj)\n\n    if worst_obj == 0:\n        # For the first objective, find the pair of nodes with the highest distance\n        max_dist = -1\n        best_i, best_j = 0, 0\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = distance_matrix_1[new_solution[i], new_solution[j]]\n                if dist > max_dist:\n                    max_dist = dist\n                    best_i, best_j = i, j\n        # Swap these nodes to potentially reduce the worst objective\n        new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    elif worst_obj == 1:\n        # For the second objective, find the pair of nodes with the highest distance\n        max_dist = -1\n        best_i, best_j = 0, 0\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = distance_matrix_2[new_solution[i], new_solution[j]]\n                if dist > max_dist:\n                    max_dist = dist\n                    best_i, best_j = i, j\n        # Swap these nodes to potentially reduce the worst objective\n        new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    else:\n        # For the third objective, find the pair of nodes with the highest distance\n        max_dist = -1\n        best_i, best_j = 0, 0\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = distance_matrix_3[new_solution[i], new_solution[j]]\n                if dist > max_dist:\n                    max_dist = dist\n                    best_i, best_j = i, j\n        # Swap these nodes to potentially reduce the worst objective\n        new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    return new_solution\n\n",
        "score": [
            -0.8030580081367799,
            1.8447717547416687
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective diversity)\n    weights = [1.0 / (1.0 + obj[0] + obj[1] + obj[2]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combination of 2-opt and objective-specific swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move (standard local search)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform an objective-specific swap based on the worst objective\n    obj = archive[selected_idx][1]\n    worst_obj = np.argmax(obj)\n\n    if worst_obj == 0:\n        # For the first objective, find the pair of nodes with the highest distance\n        max_dist = -1\n        best_i, best_j = 0, 0\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = distance_matrix_1[new_solution[i], new_solution[j]]\n                if dist > max_dist:\n                    max_dist = dist\n                    best_i, best_j = i, j\n        # Swap these nodes to potentially reduce the worst objective\n        new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    elif worst_obj == 1:\n        # For the second objective, find the pair of nodes with the highest distance\n        max_dist = -1\n        best_i, best_j = 0, 0\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = distance_matrix_2[new_solution[i], new_solution[j]]\n                if dist > max_dist:\n                    max_dist = dist\n                    best_i, best_j = i, j\n        # Swap these nodes to potentially reduce the worst objective\n        new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    else:\n        # For the third objective, find the pair of nodes with the highest distance\n        max_dist = -1\n        best_i, best_j = 0, 0\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = distance_matrix_3[new_solution[i], new_solution[j]]\n                if dist > max_dist:\n                    max_dist = dist\n                    best_i, best_j = i, j\n        # Swap these nodes to potentially reduce the worst objective\n        new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 7,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective diversity)\n    weights = [1.0 / (1.0 + obj[0] + obj[1] + obj[2]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combination of 2-opt and objective-specific swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move (standard local search)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform an objective-specific swap based on the worst objective\n    obj = archive[selected_idx][1]\n    worst_obj = np.argmax(obj)\n\n    if worst_obj == 0:\n        # For the first objective, find the pair of nodes with the highest distance\n        max_dist = -1\n        best_i, best_j = 0, 0\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = distance_matrix_1[new_solution[i], new_solution[j]]\n                if dist > max_dist:\n                    max_dist = dist\n                    best_i, best_j = i, j\n        # Swap these nodes to potentially reduce the worst objective\n        new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    elif worst_obj == 1:\n        # For the second objective, find the pair of nodes with the highest distance\n        max_dist = -1\n        best_i, best_j = 0, 0\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = distance_matrix_2[new_solution[i], new_solution[j]]\n                if dist > max_dist:\n                    max_dist = dist\n                    best_i, best_j = i, j\n        # Swap these nodes to potentially reduce the worst objective\n        new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    else:\n        # For the third objective, find the pair of nodes with the highest distance\n        max_dist = -1\n        best_i, best_j = 0, 0\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = distance_matrix_3[new_solution[i], new_solution[j]]\n                if dist > max_dist:\n                    max_dist = dist\n                    best_i, best_j = i, j\n        # Swap these nodes to potentially reduce the worst objective\n        new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    return new_solution\n\n",
        "score": [
            -0.8030580081367799,
            1.8447717547416687
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective diversity)\n    weights = [1.0 / (1.0 + obj[0] + obj[1] + obj[2]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combination of 2-opt and objective-specific swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move (standard local search)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform an objective-specific swap based on the worst objective\n    obj = archive[selected_idx][1]\n    worst_obj = np.argmax(obj)\n\n    if worst_obj == 0:\n        # For the first objective, find the pair of nodes with the highest distance\n        max_dist = -1\n        best_i, best_j = 0, 0\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = distance_matrix_1[new_solution[i], new_solution[j]]\n                if dist > max_dist:\n                    max_dist = dist\n                    best_i, best_j = i, j\n        # Swap these nodes to potentially reduce the worst objective\n        new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    elif worst_obj == 1:\n        # For the second objective, find the pair of nodes with the highest distance\n        max_dist = -1\n        best_i, best_j = 0, 0\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = distance_matrix_2[new_solution[i], new_solution[j]]\n                if dist > max_dist:\n                    max_dist = dist\n                    best_i, best_j = i, j\n        # Swap these nodes to potentially reduce the worst objective\n        new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    else:\n        # For the third objective, find the pair of nodes with the highest distance\n        max_dist = -1\n        best_i, best_j = 0, 0\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = distance_matrix_3[new_solution[i], new_solution[j]]\n                if dist > max_dist:\n                    max_dist = dist\n                    best_i, best_j = i, j\n        # Swap these nodes to potentially reduce the worst objective\n        new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 8,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest potential for improvement (lowest objective diversity)\n    objectives = np.array([obj for _, obj in archive])\n    objective_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    diversity_scores = np.sum(objective_ranges - (objectives - np.min(objectives, axis=0)) ** 2, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a random 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform objective-aware swaps based on the worst-performing objective\n    obj_values = archive[selected_idx][1]\n    worst_obj = np.argmax(obj_values)\n\n    if worst_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the worst edge in the tour based on the worst objective\n    worst_edge = None\n    worst_edge_value = -1\n    for i in range(n):\n        u, v = new_solution[i], new_solution[(i+1)%n]\n        edge_value = dist_matrix[u, v]\n        if edge_value > worst_edge_value:\n            worst_edge_value = edge_value\n            worst_edge = (i, (i+1)%n)\n\n    if worst_edge:\n        i, j = worst_edge\n        # Try to replace the worst edge with a better one\n        candidates = []\n        for k in range(n):\n            if k != i and k != j and k != (i-1)%n and k != (j+1)%n:\n                # Calculate the improvement\n                old_cost = dist_matrix[new_solution[i], new_solution[j]] + dist_matrix[new_solution[(i-1)%n], new_solution[i]] + dist_matrix[new_solution[j], new_solution[(j+1)%n]]\n                new_cost = dist_matrix[new_solution[(i-1)%n], new_solution[k]] + dist_matrix[new_solution[k], new_solution[i]] + dist_matrix[new_solution[j], new_solution[(j+1)%n]]\n                improvement = old_cost - new_cost\n                candidates.append((improvement, k))\n\n        if candidates:\n            best_improvement, best_k = max(candidates)\n            if best_improvement > 0:\n                # Perform the swap\n                new_solution[i], new_solution[best_k] = new_solution[best_k], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6482982324148605,
            2.2189115405082704
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest potential for improvement (lowest objective diversity)\n    objectives = np.array([obj for _, obj in archive])\n    objective_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    diversity_scores = np.sum(objective_ranges - (objectives - np.min(objectives, axis=0)) ** 2, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a random 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform objective-aware swaps based on the worst-performing objective\n    obj_values = archive[selected_idx][1]\n    worst_obj = np.argmax(obj_values)\n\n    if worst_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the worst edge in the tour based on the worst objective\n    worst_edge = None\n    worst_edge_value = -1\n    for i in range(n):\n        u, v = new_solution[i], new_solution[(i+1)%n]\n        edge_value = dist_matrix[u, v]\n        if edge_value > worst_edge_value:\n            worst_edge_value = edge_value\n            worst_edge = (i, (i+1)%n)\n\n    if worst_edge:\n        i, j = worst_edge\n        # Try to replace the worst edge with a better one\n        candidates = []\n        for k in range(n):\n            if k != i and k != j and k != (i-1)%n and k != (j+1)%n:\n                # Calculate the improvement\n                old_cost = dist_matrix[new_solution[i], new_solution[j]] + dist_matrix[new_solution[(i-1)%n], new_solution[i]] + dist_matrix[new_solution[j], new_solution[(j+1)%n]]\n                new_cost = dist_matrix[new_solution[(i-1)%n], new_solution[k]] + dist_matrix[new_solution[k], new_solution[i]] + dist_matrix[new_solution[j], new_solution[(j+1)%n]]\n                improvement = old_cost - new_cost\n                candidates.append((improvement, k))\n\n        if candidates:\n            best_improvement, best_k = max(candidates)\n            if best_improvement > 0:\n                # Perform the swap\n                new_solution[i], new_solution[best_k] = new_solution[best_k], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 9,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select top 20% solutions with the highest diversity in objectives\n    top_solutions = sorted(archive, key=lambda x: sum(x[1]))[:max(1, len(archive) // 5)]\n    selected_pair = random.choice(top_solutions)\n    base_solution = selected_pair[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt, 3-opt, and objective-aware swaps\n    n = len(base_solution)\n    if n < 3:\n        return new_solution  # No improvement possible\n\n    # Randomly choose between different local search strategies\n    search_strategy = random.choice(['2-opt', '3-opt', 'objective-aware'])\n\n    if search_strategy == '2-opt':\n        # Standard 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif search_strategy == '3-opt':\n        # 3-opt local search\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    else:  # objective-aware\n        # Objective-aware local search: prioritize edges that improve the worst objective\n        objectives = selected_pair[1]\n        worst_obj = np.argmax(objectives)\n\n        # Find the worst edge in the current solution\n        worst_edge = None\n        max_dist = -1\n        for i in range(n):\n            node1 = new_solution[i]\n            node2 = new_solution[(i + 1) % n]\n            if worst_obj == 0:\n                dist = distance_matrix_1[node1, node2]\n            elif worst_obj == 1:\n                dist = distance_matrix_2[node1, node2]\n            else:\n                dist = distance_matrix_3[node1, node2]\n\n            if dist > max_dist:\n                max_dist = dist\n                worst_edge = (i, (i + 1) % n)\n\n        if worst_edge:\n            # Replace the worst edge with a better one\n            i, j = worst_edge\n            candidates = []\n            for k in range(n):\n                if k != i and k != j:\n                    if worst_obj == 0:\n                        new_dist = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n                    elif worst_obj == 1:\n                        new_dist = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n                    else:\n                        new_dist = distance_matrix_3[new_solution[i], new_solution[k]] + distance_matrix_3[new_solution[k], new_solution[j]]\n\n                    if new_dist < max_dist:\n                        candidates.append((k, new_dist))\n\n            if candidates:\n                best_k, _ = min(candidates, key=lambda x: x[1])\n                new_solution[i], new_solution[best_k] = new_solution[best_k], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6529562502229365,
            2.673131227493286
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select top 20% solutions with the highest diversity in objectives\n    top_solutions = sorted(archive, key=lambda x: sum(x[1]))[:max(1, len(archive) // 5)]\n    selected_pair = random.choice(top_solutions)\n    base_solution = selected_pair[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt, 3-opt, and objective-aware swaps\n    n = len(base_solution)\n    if n < 3:\n        return new_solution  # No improvement possible\n\n    # Randomly choose between different local search strategies\n    search_strategy = random.choice(['2-opt', '3-opt', 'objective-aware'])\n\n    if search_strategy == '2-opt':\n        # Standard 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif search_strategy == '3-opt':\n        # 3-opt local search\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    else:  # objective-aware\n        # Objective-aware local search: prioritize edges that improve the worst objective\n        objectives = selected_pair[1]\n        worst_obj = np.argmax(objectives)\n\n        # Find the worst edge in the current solution\n        worst_edge = None\n        max_dist = -1\n        for i in range(n):\n            node1 = new_solution[i]\n            node2 = new_solution[(i + 1) % n]\n            if worst_obj == 0:\n                dist = distance_matrix_1[node1, node2]\n            elif worst_obj == 1:\n                dist = distance_matrix_2[node1, node2]\n            else:\n                dist = distance_matrix_3[node1, node2]\n\n            if dist > max_dist:\n                max_dist = dist\n                worst_edge = (i, (i + 1) % n)\n\n        if worst_edge:\n            # Replace the worst edge with a better one\n            i, j = worst_edge\n            candidates = []\n            for k in range(n):\n                if k != i and k != j:\n                    if worst_obj == 0:\n                        new_dist = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n                    elif worst_obj == 1:\n                        new_dist = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n                    else:\n                        new_dist = distance_matrix_3[new_solution[i], new_solution[k]] + distance_matrix_3[new_solution[k], new_solution[j]]\n\n                    if new_dist < max_dist:\n                        candidates.append((k, new_dist))\n\n            if candidates:\n                best_k, _ = min(candidates, key=lambda x: x[1])\n                new_solution[i], new_solution[best_k] = new_solution[best_k], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 10,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with the highest crowding distance)\n    # Here, we approximate crowding distance by selecting solutions with high variance in objectives\n    objectives = np.array([obj for _, obj in archive])\n    obj_variance = np.var(objectives, axis=0)\n    weighted_scores = np.dot(objectives, obj_variance)  # Higher variance = higher potential\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt swap to reduce total distance across all objectives\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware swap to further optimize\n    # Select a segment to swap based on which objective is currently worse\n    obj_values = archive[selected_idx][1]\n    worst_obj = np.argmax(obj_values)\n    distance_matrices = [distance_matrix_1, distance_matrix_2, distance_matrix_3]\n\n    # Find the best possible swap for the worst objective\n    best_improvement = 0\n    best_swap = None\n\n    for k in range(n):\n        for l in range(k+1, n):\n            # Calculate change in distance for the worst objective\n            old_dist = (distance_matrices[worst_obj][new_solution[k-1], new_solution[k]] +\n                        distance_matrices[worst_obj][new_solution[l], new_solution[(l+1)%n]])\n            new_dist = (distance_matrices[worst_obj][new_solution[k-1], new_solution[l]] +\n                        distance_matrices[worst_obj][new_solution[k], new_solution[(l+1)%n]])\n\n            improvement = old_dist - new_dist\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_swap = (k, l)\n\n    if best_swap:\n        k, l = best_swap\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure the solution remains valid\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.7173160544725676,
            3.2389107823371885
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with the highest crowding distance)\n    # Here, we approximate crowding distance by selecting solutions with high variance in objectives\n    objectives = np.array([obj for _, obj in archive])\n    obj_variance = np.var(objectives, axis=0)\n    weighted_scores = np.dot(objectives, obj_variance)  # Higher variance = higher potential\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt swap to reduce total distance across all objectives\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware swap to further optimize\n    # Select a segment to swap based on which objective is currently worse\n    obj_values = archive[selected_idx][1]\n    worst_obj = np.argmax(obj_values)\n    distance_matrices = [distance_matrix_1, distance_matrix_2, distance_matrix_3]\n\n    # Find the best possible swap for the worst objective\n    best_improvement = 0\n    best_swap = None\n\n    for k in range(n):\n        for l in range(k+1, n):\n            # Calculate change in distance for the worst objective\n            old_dist = (distance_matrices[worst_obj][new_solution[k-1], new_solution[k]] +\n                        distance_matrices[worst_obj][new_solution[l], new_solution[(l+1)%n]])\n            new_dist = (distance_matrices[worst_obj][new_solution[k-1], new_solution[l]] +\n                        distance_matrices[worst_obj][new_solution[k], new_solution[(l+1)%n]])\n\n            improvement = old_dist - new_dist\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_swap = (k, l)\n\n    if best_swap:\n        k, l = best_swap\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure the solution remains valid\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 11,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest objective values)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate a combined score based on objective values (lower is better)\n    scores = [sum(obj) for obj in archive_objectives]\n    min_score = min(scores)\n    max_score = max(scores)\n\n    # Normalize scores to [0, 1] and select solutions with scores near the min\n    normalized_scores = [(score - min_score) / (max_score - min_score + 1e-10) for score in scores]\n    threshold = 0.3  # Select solutions with normalized score <= threshold\n    candidates = [sol for sol, score in zip(archive_solutions, normalized_scores) if score <= threshold]\n\n    if not candidates:\n        candidates = archive_solutions  # Fallback to all solutions if no candidates\n\n    base_solution = random.choice(candidates).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel 3-objective-aware move\n    n = len(base_solution)\n\n    # First, perform a 2-opt move (standard local search)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform a novel 3-objective-aware move: rotate a segment and adjust based on objectives\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n\n    # Calculate the improvement potential for each objective\n    def calculate_improvement(sol):\n        total_1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n        total_2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n        total_3 = sum(distance_matrix_3[sol[i], sol[(i+1)%n]] for i in range(n))\n        return (total_1, total_2, total_3)\n\n    current_obj = calculate_improvement(new_solution)\n\n    # Rotate the segment in a direction that improves the worst-performing objective\n    worst_obj = np.argmax(current_obj)\n    if worst_obj == 0:\n        rotated_segment = np.roll(segment, -1)\n    elif worst_obj == 1:\n        rotated_segment = np.roll(segment, 1)\n    else:\n        rotated_segment = np.roll(segment, -1 if random.random() > 0.5 else 1)\n\n    new_solution[a:b+1] = rotated_segment\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.7546144826720924,
            1.9352136611938477
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest objective values)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate a combined score based on objective values (lower is better)\n    scores = [sum(obj) for obj in archive_objectives]\n    min_score = min(scores)\n    max_score = max(scores)\n\n    # Normalize scores to [0, 1] and select solutions with scores near the min\n    normalized_scores = [(score - min_score) / (max_score - min_score + 1e-10) for score in scores]\n    threshold = 0.3  # Select solutions with normalized score <= threshold\n    candidates = [sol for sol, score in zip(archive_solutions, normalized_scores) if score <= threshold]\n\n    if not candidates:\n        candidates = archive_solutions  # Fallback to all solutions if no candidates\n\n    base_solution = random.choice(candidates).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel 3-objective-aware move\n    n = len(base_solution)\n\n    # First, perform a 2-opt move (standard local search)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform a novel 3-objective-aware move: rotate a segment and adjust based on objectives\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n\n    # Calculate the improvement potential for each objective\n    def calculate_improvement(sol):\n        total_1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n        total_2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n        total_3 = sum(distance_matrix_3[sol[i], sol[(i+1)%n]] for i in range(n))\n        return (total_1, total_2, total_3)\n\n    current_obj = calculate_improvement(new_solution)\n\n    # Rotate the segment in a direction that improves the worst-performing objective\n    worst_obj = np.argmax(current_obj)\n    if worst_obj == 0:\n        rotated_segment = np.roll(segment, -1)\n    elif worst_obj == 1:\n        rotated_segment = np.roll(segment, 1)\n    else:\n        rotated_segment = np.roll(segment, -1 if random.random() > 0.5 else 1)\n\n    new_solution[a:b+1] = rotated_segment\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 12,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too good in all objectives)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_objectives = archive[selected_idx][1]\n\n    # Calculate diversity of the solution (how much it deviates from the average objectives)\n    avg_objectives = np.mean([obj for _, obj in archive], axis=0)\n    diversity = np.sum(np.abs(np.array(current_objectives) - avg_objectives))\n\n    # Apply a hybrid local search operator based on diversity\n    new_solution = base_solution.copy()\n\n    if diversity > np.mean([np.sum(np.abs(np.array(obj) - avg_objectives)) for _, obj in archive]):\n        # Apply a more aggressive operator for diverse solutions\n        # 3-opt move (swap three edges)\n        n = len(new_solution)\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n    else:\n        # Apply a more conservative operator for solutions close to the average\n        # 2-opt move (swap two edges)\n        n = len(new_solution)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != len(new_solution):\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7659513302136008,
            3.5264686703681947
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too good in all objectives)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_objectives = archive[selected_idx][1]\n\n    # Calculate diversity of the solution (how much it deviates from the average objectives)\n    avg_objectives = np.mean([obj for _, obj in archive], axis=0)\n    diversity = np.sum(np.abs(np.array(current_objectives) - avg_objectives))\n\n    # Apply a hybrid local search operator based on diversity\n    new_solution = base_solution.copy()\n\n    if diversity > np.mean([np.sum(np.abs(np.array(obj) - avg_objectives)) for _, obj in archive]):\n        # Apply a more aggressive operator for diverse solutions\n        # 3-opt move (swap three edges)\n        n = len(new_solution)\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n    else:\n        # Apply a more conservative operator for solutions close to the average\n        # 2-opt move (swap two edges)\n        n = len(new_solution)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != len(new_solution):\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 13,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.std(objectives, axis=0).sum()\n        sorted_indices = np.argsort(-diversity)\n        selected_idx = sorted_indices[0]\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Perform 2-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: identify the worst edge in any objective space\n    worst_edge = -1\n    worst_obj = -1\n    for k in range(n):\n        node1, node2 = new_solution[k], new_solution[(k+1)%n]\n        cost1 = distance_matrix_1[node1, node2]\n        cost2 = distance_matrix_2[node1, node2]\n        cost3 = distance_matrix_3[node1, node2]\n        total_cost = cost1 + cost2 + cost3\n        if total_cost > worst_obj:\n            worst_obj = total_cost\n            worst_edge = k\n\n    if worst_edge != -1:\n        # Swap nodes to potentially improve all objectives\n        l, m = np.random.choice(n, size=2, replace=False)\n        new_solution[l], new_solution[m] = new_solution[m], new_solution[l]\n\n    return new_solution\n\n",
        "score": [
            -0.7656568586230209,
            1.456427800655365
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.std(objectives, axis=0).sum()\n        sorted_indices = np.argsort(-diversity)\n        selected_idx = sorted_indices[0]\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Perform 2-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: identify the worst edge in any objective space\n    worst_edge = -1\n    worst_obj = -1\n    for k in range(n):\n        node1, node2 = new_solution[k], new_solution[(k+1)%n]\n        cost1 = distance_matrix_1[node1, node2]\n        cost2 = distance_matrix_2[node1, node2]\n        cost3 = distance_matrix_3[node1, node2]\n        total_cost = cost1 + cost2 + cost3\n        if total_cost > worst_obj:\n            worst_obj = total_cost\n            worst_edge = k\n\n    if worst_edge != -1:\n        # Swap nodes to potentially improve all objectives\n        l, m = np.random.choice(n, size=2, replace=False)\n        new_solution[l], new_solution[m] = new_solution[m], new_solution[l]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 14,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not the best but not the worst)\n    if len(archive) > 2:\n        # Sort by the sum of objectives to find solutions that are not the best but have room for improvement\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution in the middle of the sorted list to balance exploration and exploitation\n        selected_idx = len(archive_sorted) // 2\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: combine 2-opt with a biased random walk for multi-objective optimization\n    # Step 1: Perform a biased random 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Apply a biased random walk to further improve the solution\n    if np.random.rand() < 0.5:  # 50% chance to apply the walk\n        k = np.random.randint(1, n // 2)  # Random segment length\n        segment = new_solution[i:i+k]\n        np.random.shuffle(segment)\n        new_solution[i:i+k] = segment\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid.\"\n\n    return new_solution\n\n",
        "score": [
            -0.7081226599861138,
            1.4006073832511903
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not the best but not the worst)\n    if len(archive) > 2:\n        # Sort by the sum of objectives to find solutions that are not the best but have room for improvement\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution in the middle of the sorted list to balance exploration and exploitation\n        selected_idx = len(archive_sorted) // 2\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: combine 2-opt with a biased random walk for multi-objective optimization\n    # Step 1: Perform a biased random 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Apply a biased random walk to further improve the solution\n    if np.random.rand() < 0.5:  # 50% chance to apply the walk\n        k = np.random.randint(1, n // 2)  # Random segment length\n        segment = new_solution[i:i+k]\n        np.random.shuffle(segment)\n        new_solution[i:i+k] = segment\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid.\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 15,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    from typing import List\n    import numpy as np\n\n    # Select a solution with high potential for improvement (randomly weighted by objective values)\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate potential improvement scores for each solution\n    improvement_scores = []\n    for sol, obj in archive:\n        # Combine objectives into a single score (could be more sophisticated)\n        score = sum(obj)\n        improvement_scores.append(score)\n\n    # Normalize scores to get probabilities\n    total = sum(improvement_scores)\n    if total == 0:\n        probabilities = [1.0 / len(improvement_scores) for _ in improvement_scores]\n    else:\n        probabilities = [score / total for score in improvement_scores]\n\n    # Select a solution based on the probabilities\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct positions\n    i, j = random.sample(range(n), 2)\n\n    # Apply 2-opt swap (standard local search)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply objective-aware perturbation\n    # Calculate the change in each objective space\n    delta_obj1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n    delta_obj2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n    delta_obj3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n    # If the perturbation improves at least one objective, keep it; otherwise, revert\n    if delta_obj1 < 0 or delta_obj2 < 0 or delta_obj3 < 0:\n        # Accept the change\n        pass\n    else:\n        # Revert the change\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additional perturbation: swap two nodes based on their positions in all three objectives\n    if random.random() < 0.3:  # 30% chance for this perturbation\n        k, l = random.sample(range(n), 2)\n        if k > l:\n            k, l = l, k\n\n        # Calculate the change in all three objectives\n        delta_obj1_swap = (distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                           distance_matrix_1[new_solution[l], new_solution[(k+1)%n]] +\n                           distance_matrix_1[new_solution[l-1], new_solution[k]] +\n                           distance_matrix_1[new_solution[k], new_solution[(l+1)%n]] -\n                           distance_matrix_1[new_solution[k-1], new_solution[k]] -\n                           distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] -\n                           distance_matrix_1[new_solution[l-1], new_solution[l]] -\n                           distance_matrix_1[new_solution[l], new_solution[(l+1)%n]])\n\n        delta_obj2_swap = (distance_matrix_2[new_solution[k-1], new_solution[l]] +\n                           distance_matrix_2[new_solution[l], new_solution[(k+1)%n]] +\n                           distance_matrix_2[new_solution[l-1], new_solution[k]] +\n                           distance_matrix_2[new_solution[k], new_solution[(l+1)%n]] -\n                           distance_matrix_2[new_solution[k-1], new_solution[k]] -\n                           distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] -\n                           distance_matrix_2[new_solution[l-1], new_solution[l]] -\n                           distance_matrix_2[new_solution[l], new_solution[(l+1)%n]])\n\n        delta_obj3_swap = (distance_matrix_3[new_solution[k-1], new_solution[l]] +\n                           distance_matrix_3[new_solution[l], new_solution[(k+1)%n]] +\n                           distance_matrix_3[new_solution[l-1], new_solution[k]] +\n                           distance_matrix_3[new_solution[k], new_solution[(l+1)%n]] -\n                           distance_matrix_3[new_solution[k-1], new_solution[k]] -\n                           distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] -\n                           distance_matrix_3[new_solution[l-1], new_solution[l]] -\n                           distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n        # If the swap improves at least one objective, accept it\n        if delta_obj1_swap < 0 or delta_obj2_swap < 0 or delta_obj3_swap < 0:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7903644786827783,
            2.045451319217682
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    from typing import List\n    import numpy as np\n\n    # Select a solution with high potential for improvement (randomly weighted by objective values)\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate potential improvement scores for each solution\n    improvement_scores = []\n    for sol, obj in archive:\n        # Combine objectives into a single score (could be more sophisticated)\n        score = sum(obj)\n        improvement_scores.append(score)\n\n    # Normalize scores to get probabilities\n    total = sum(improvement_scores)\n    if total == 0:\n        probabilities = [1.0 / len(improvement_scores) for _ in improvement_scores]\n    else:\n        probabilities = [score / total for score in improvement_scores]\n\n    # Select a solution based on the probabilities\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct positions\n    i, j = random.sample(range(n), 2)\n\n    # Apply 2-opt swap (standard local search)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply objective-aware perturbation\n    # Calculate the change in each objective space\n    delta_obj1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n    delta_obj2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n    delta_obj3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n    # If the perturbation improves at least one objective, keep it; otherwise, revert\n    if delta_obj1 < 0 or delta_obj2 < 0 or delta_obj3 < 0:\n        # Accept the change\n        pass\n    else:\n        # Revert the change\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additional perturbation: swap two nodes based on their positions in all three objectives\n    if random.random() < 0.3:  # 30% chance for this perturbation\n        k, l = random.sample(range(n), 2)\n        if k > l:\n            k, l = l, k\n\n        # Calculate the change in all three objectives\n        delta_obj1_swap = (distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                           distance_matrix_1[new_solution[l], new_solution[(k+1)%n]] +\n                           distance_matrix_1[new_solution[l-1], new_solution[k]] +\n                           distance_matrix_1[new_solution[k], new_solution[(l+1)%n]] -\n                           distance_matrix_1[new_solution[k-1], new_solution[k]] -\n                           distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] -\n                           distance_matrix_1[new_solution[l-1], new_solution[l]] -\n                           distance_matrix_1[new_solution[l], new_solution[(l+1)%n]])\n\n        delta_obj2_swap = (distance_matrix_2[new_solution[k-1], new_solution[l]] +\n                           distance_matrix_2[new_solution[l], new_solution[(k+1)%n]] +\n                           distance_matrix_2[new_solution[l-1], new_solution[k]] +\n                           distance_matrix_2[new_solution[k], new_solution[(l+1)%n]] -\n                           distance_matrix_2[new_solution[k-1], new_solution[k]] -\n                           distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] -\n                           distance_matrix_2[new_solution[l-1], new_solution[l]] -\n                           distance_matrix_2[new_solution[l], new_solution[(l+1)%n]])\n\n        delta_obj3_swap = (distance_matrix_3[new_solution[k-1], new_solution[l]] +\n                           distance_matrix_3[new_solution[l], new_solution[(k+1)%n]] +\n                           distance_matrix_3[new_solution[l-1], new_solution[k]] +\n                           distance_matrix_3[new_solution[k], new_solution[(l+1)%n]] -\n                           distance_matrix_3[new_solution[k-1], new_solution[k]] -\n                           distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] -\n                           distance_matrix_3[new_solution[l-1], new_solution[l]] -\n                           distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n        # If the swap improves at least one objective, accept it\n        if delta_obj1_swap < 0 or delta_obj2_swap < 0 or delta_obj3_swap < 0:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 16,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distance for each solution in the archive\n        crowding_distances = []\n        objectives = np.array([obj for _, obj in archive])\n        for i in range(3):\n            sorted_idx = np.argsort(objectives[:, i])\n            sorted_obj = objectives[sorted_idx, i]\n            crowding = np.zeros(len(sorted_obj))\n            crowding[0] = crowding[-1] = float('inf')\n            for j in range(1, len(sorted_obj) - 1):\n                crowding[j] = sorted_obj[j+1] - sorted_obj[j-1]\n            crowding_distances.append(crowding[np.argsort(sorted_idx)])\n\n        # Combine crowding distances and select the most crowded solution\n        total_crowding = np.sum(crowding_distances, axis=0)\n        selected_idx = np.argmax(total_crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel 3-way swap\n    n = len(new_solution)\n    if n < 4:\n        # If the tour is too small, just perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # With 70% probability, perform 2-opt\n        if random.random() < 0.7:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # With 30% probability, perform a novel 3-way swap\n            # Select three distinct positions and swap their nodes in a way that improves all objectives\n            i, j, k = sorted(random.sample(range(n), 3))\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = new_solution[k]\n            new_solution[k] = temp\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6669731179111723,
            2.451138937473297
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distance for each solution in the archive\n        crowding_distances = []\n        objectives = np.array([obj for _, obj in archive])\n        for i in range(3):\n            sorted_idx = np.argsort(objectives[:, i])\n            sorted_obj = objectives[sorted_idx, i]\n            crowding = np.zeros(len(sorted_obj))\n            crowding[0] = crowding[-1] = float('inf')\n            for j in range(1, len(sorted_obj) - 1):\n                crowding[j] = sorted_obj[j+1] - sorted_obj[j-1]\n            crowding_distances.append(crowding[np.argsort(sorted_idx)])\n\n        # Combine crowding distances and select the most crowded solution\n        total_crowding = np.sum(crowding_distances, axis=0)\n        selected_idx = np.argmax(total_crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel 3-way swap\n    n = len(new_solution)\n    if n < 4:\n        # If the tour is too small, just perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # With 70% probability, perform 2-opt\n        if random.random() < 0.7:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # With 30% probability, perform a novel 3-way swap\n            # Select three distinct positions and swap their nodes in a way that improves all objectives\n            i, j, k = sorted(random.sample(range(n), 3))\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = new_solution[k]\n            new_solution[k] = temp\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 17,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        # Calculate the range of each objective\n        obj_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n        # Select the solution with the highest total range (most diverse)\n        selected_idx = np.argmax(np.sum(obj_ranges))\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: combine 2-opt and 3-opt with objective-aware selection\n    for _ in range(10):  # Perform multiple iterations\n        # Randomly select two distinct positions\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in each objective\n        delta_obj1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                      distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta_obj2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                      distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta_obj3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                      distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                      distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept the move if it improves at least one objective or if it's a balanced improvement\n        if (delta_obj1 < 0 or delta_obj2 < 0 or delta_obj3 < 0) or (abs(delta_obj1) + abs(delta_obj2) + abs(delta_obj3) < 1e-6):\n            # Perform the 2-opt move\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # With some probability, try a 3-opt move for more exploration\n        if np.random.rand() < 0.3:\n            k, l = np.random.choice(n, size=2, replace=False)\n            if k > l:\n                k, l = l, k\n            # Calculate the change for 3-opt (simplified version)\n            delta_obj1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                          distance_matrix_1[new_solution[k-1], new_solution[l]] -\n                          distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                          distance_matrix_1[new_solution[j], new_solution[k]] -\n                          distance_matrix_1[new_solution[l], new_solution[(l+1)%n]])\n\n            delta_obj2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                          distance_matrix_2[new_solution[k-1], new_solution[l]] -\n                          distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                          distance_matrix_2[new_solution[j], new_solution[k]] -\n                          distance_matrix_2[new_solution[l], new_solution[(l+1)%n]])\n\n            delta_obj3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                          distance_matrix_3[new_solution[k-1], new_solution[l]] -\n                          distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                          distance_matrix_3[new_solution[j], new_solution[k]] -\n                          distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n            if (delta_obj1 < 0 or delta_obj2 < 0 or delta_obj3 < 0) or (abs(delta_obj1) + abs(delta_obj2) + abs(delta_obj3) < 1e-6):\n                # Perform the 3-opt move (simplified version)\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n                new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7163782422114706,
            2.802195107936859
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        # Calculate the range of each objective\n        obj_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n        # Select the solution with the highest total range (most diverse)\n        selected_idx = np.argmax(np.sum(obj_ranges))\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: combine 2-opt and 3-opt with objective-aware selection\n    for _ in range(10):  # Perform multiple iterations\n        # Randomly select two distinct positions\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in each objective\n        delta_obj1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                      distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta_obj2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                      distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta_obj3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                      distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                      distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept the move if it improves at least one objective or if it's a balanced improvement\n        if (delta_obj1 < 0 or delta_obj2 < 0 or delta_obj3 < 0) or (abs(delta_obj1) + abs(delta_obj2) + abs(delta_obj3) < 1e-6):\n            # Perform the 2-opt move\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # With some probability, try a 3-opt move for more exploration\n        if np.random.rand() < 0.3:\n            k, l = np.random.choice(n, size=2, replace=False)\n            if k > l:\n                k, l = l, k\n            # Calculate the change for 3-opt (simplified version)\n            delta_obj1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                          distance_matrix_1[new_solution[k-1], new_solution[l]] -\n                          distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                          distance_matrix_1[new_solution[j], new_solution[k]] -\n                          distance_matrix_1[new_solution[l], new_solution[(l+1)%n]])\n\n            delta_obj2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                          distance_matrix_2[new_solution[k-1], new_solution[l]] -\n                          distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                          distance_matrix_2[new_solution[j], new_solution[k]] -\n                          distance_matrix_2[new_solution[l], new_solution[(l+1)%n]])\n\n            delta_obj3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                          distance_matrix_3[new_solution[k-1], new_solution[l]] -\n                          distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                          distance_matrix_3[new_solution[j], new_solution[k]] -\n                          distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n            if (delta_obj1 < 0 or delta_obj2 < 0 or delta_obj3 < 0) or (abs(delta_obj1) + abs(delta_obj2) + abs(delta_obj3) < 1e-6):\n                # Perform the 3-opt move (simplified version)\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n                new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 18,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best in all objectives)\n    selected = max(archive, key=lambda x: sum(x[1]) - min(x[1]))[0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(selected)\n    new_solution = selected.copy()\n\n    # Perform 2-opt for one objective\n    i, j = np.random.randint(0, n, size=2)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform objective-aware swap\n    obj1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    obj2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    obj3 = sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n    # Find the worst objective and improve it\n    worst_obj = np.argmax([obj1, obj2, obj3])\n    if worst_obj == 0:\n        distance_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Find the best possible swap to improve the worst objective\n    best_improvement = 0\n    best_swap = None\n\n    for a in range(n):\n        for b in range(a+1, n):\n            current_cost = distance_matrix[new_solution[a-1], new_solution[a]] + distance_matrix[new_solution[b-1], new_solution[b]]\n            new_cost = distance_matrix[new_solution[a-1], new_solution[b]] + distance_matrix[new_solution[b-1], new_solution[a]]\n            improvement = current_cost - new_cost\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_swap = (a, b)\n\n    if best_swap:\n        a, b = best_swap\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.6123968749445632,
            2.459951102733612
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best in all objectives)\n    selected = max(archive, key=lambda x: sum(x[1]) - min(x[1]))[0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(selected)\n    new_solution = selected.copy()\n\n    # Perform 2-opt for one objective\n    i, j = np.random.randint(0, n, size=2)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform objective-aware swap\n    obj1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    obj2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    obj3 = sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n    # Find the worst objective and improve it\n    worst_obj = np.argmax([obj1, obj2, obj3])\n    if worst_obj == 0:\n        distance_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Find the best possible swap to improve the worst objective\n    best_improvement = 0\n    best_swap = None\n\n    for a in range(n):\n        for b in range(a+1, n):\n            current_cost = distance_matrix[new_solution[a-1], new_solution[a]] + distance_matrix[new_solution[b-1], new_solution[b]]\n            new_cost = distance_matrix[new_solution[a-1], new_solution[b]] + distance_matrix[new_solution[b-1], new_solution[a]]\n            improvement = current_cost - new_cost\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_swap = (a, b)\n\n    if best_swap:\n        a, b = best_swap\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 19,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # We prioritize solutions with the highest average improvement potential\n    improvement_potentials = []\n    for sol, obj in archive:\n        total_cost = sum(obj)\n        # Estimate improvement potential based on edge diversity\n        edge_diversity = len(set(tuple(sorted((sol[i], sol[(i+1)%len(sol)])))\n                                for i in range(len(sol))))\n        potential = total_cost / edge_diversity if edge_diversity > 0 else total_cost\n        improvement_potentials.append(potential)\n\n    # Select top 20% solutions with highest potential\n    top_indices = np.argsort(improvement_potentials)[-max(1, len(archive)//5):]\n    selected_idx = random.choice(top_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    for _ in range(3):  # Perform 3 local search steps\n        # Randomly choose between 3 local search operators\n        operator = random.choice(['2opt', 'edge_insertion', 'objective_aware_swap'])\n\n        if operator == '2opt':\n            # 2-opt local search\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        elif operator == 'edge_insertion':\n            # Edge insertion\n            if n > 3:\n                i = random.randint(0, n-1)\n                j = random.randint(0, n-1)\n                if i != j:\n                    node = new_solution[i]\n                    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n        elif operator == 'objective_aware_swap':\n            # Objective-aware swap that considers all three objectives\n            if n > 1:\n                i, j = random.sample(range(n), 2)\n                # Calculate the cost change for all three objectives\n                old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n                old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n                old_cost3 = (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                             distance_matrix_3[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n                # Perform the swap\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n                new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n                new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n                new_cost3 = (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                             distance_matrix_3[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n                # If the swap doesn't improve any objective, revert it\n                if (new_cost1 >= old_cost1 and new_cost2 >= old_cost2 and new_cost3 >= old_cost3):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.5820289074745161,
            3.805553340911865
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # We prioritize solutions with the highest average improvement potential\n    improvement_potentials = []\n    for sol, obj in archive:\n        total_cost = sum(obj)\n        # Estimate improvement potential based on edge diversity\n        edge_diversity = len(set(tuple(sorted((sol[i], sol[(i+1)%len(sol)])))\n                                for i in range(len(sol))))\n        potential = total_cost / edge_diversity if edge_diversity > 0 else total_cost\n        improvement_potentials.append(potential)\n\n    # Select top 20% solutions with highest potential\n    top_indices = np.argsort(improvement_potentials)[-max(1, len(archive)//5):]\n    selected_idx = random.choice(top_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    for _ in range(3):  # Perform 3 local search steps\n        # Randomly choose between 3 local search operators\n        operator = random.choice(['2opt', 'edge_insertion', 'objective_aware_swap'])\n\n        if operator == '2opt':\n            # 2-opt local search\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        elif operator == 'edge_insertion':\n            # Edge insertion\n            if n > 3:\n                i = random.randint(0, n-1)\n                j = random.randint(0, n-1)\n                if i != j:\n                    node = new_solution[i]\n                    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n        elif operator == 'objective_aware_swap':\n            # Objective-aware swap that considers all three objectives\n            if n > 1:\n                i, j = random.sample(range(n), 2)\n                # Calculate the cost change for all three objectives\n                old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n                old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n                old_cost3 = (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                             distance_matrix_3[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n                # Perform the swap\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n                new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n                new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n                new_cost3 = (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                             distance_matrix_3[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n                # If the swap doesn't improve any objective, revert it\n                if (new_cost1 >= old_cost1 and new_cost2 >= old_cost2 and new_cost3 >= old_cost3):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 20,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Calculate crowding distance for each solution in the archive\n        objectives = np.array([obj for _, obj in archive])\n        crowding_distances = np.zeros(len(archive))\n\n        for m in range(3):  # For each objective\n            sorted_indices = np.argsort(objectives[:, m])\n            sorted_obj = objectives[sorted_indices, m]\n            crowding_distances[sorted_indices[1:-1]] += (sorted_obj[2:] - sorted_obj[:-2]) / (sorted_obj[-1] - sorted_obj[0] + 1e-10)\n\n        # Select the solution with the highest crowding distance\n        selected_idx = np.argmax(crowding_distances)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a multi-objective-aware swap\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n\n    # Standard 2-opt move\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective-aware swap: swap nodes that improve the worst objective\n    if np.random.rand() < 0.5:  # 50% chance to apply the swap\n        k, l = np.random.choice(n, size=2, replace=False)\n        if k > l:\n            k, l = l, k\n\n        # Calculate the change in all three objectives\n        original_costs = [\n            distance_matrix_1[new_solution[k-1], new_solution[k]] +\n            distance_matrix_1[new_solution[l], new_solution[(l+1)%n]] +\n            distance_matrix_1[new_solution[l-1], new_solution[l]],\n\n            distance_matrix_2[new_solution[k-1], new_solution[k]] +\n            distance_matrix_2[new_solution[l], new_solution[(l+1)%n]] +\n            distance_matrix_2[new_solution[l-1], new_solution[l]],\n\n            distance_matrix_3[new_solution[k-1], new_solution[k]] +\n            distance_matrix_3[new_solution[l], new_solution[(l+1)%n]] +\n            distance_matrix_3[new_solution[l-1], new_solution[l]]\n        ]\n\n        swapped_costs = [\n            distance_matrix_1[new_solution[k-1], new_solution[l]] +\n            distance_matrix_1[new_solution[k], new_solution[(l+1)%n]] +\n            distance_matrix_1[new_solution[l-1], new_solution[k]],\n\n            distance_matrix_2[new_solution[k-1], new_solution[l]] +\n            distance_matrix_2[new_solution[k], new_solution[(l+1)%n]] +\n            distance_matrix_2[new_solution[l-1], new_solution[k]],\n\n            distance_matrix_3[new_solution[k-1], new_solution[l]] +\n            distance_matrix_3[new_solution[k], new_solution[(l+1)%n]] +\n            distance_matrix_3[new_solution[l-1], new_solution[k]]\n        ]\n\n        # If the swap improves the worst objective, perform it\n        if any(swapped_costs[m] < original_costs[m] for m in range(3)):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7010961540643889,
            2.1435582280158996
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Calculate crowding distance for each solution in the archive\n        objectives = np.array([obj for _, obj in archive])\n        crowding_distances = np.zeros(len(archive))\n\n        for m in range(3):  # For each objective\n            sorted_indices = np.argsort(objectives[:, m])\n            sorted_obj = objectives[sorted_indices, m]\n            crowding_distances[sorted_indices[1:-1]] += (sorted_obj[2:] - sorted_obj[:-2]) / (sorted_obj[-1] - sorted_obj[0] + 1e-10)\n\n        # Select the solution with the highest crowding distance\n        selected_idx = np.argmax(crowding_distances)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a multi-objective-aware swap\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n\n    # Standard 2-opt move\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective-aware swap: swap nodes that improve the worst objective\n    if np.random.rand() < 0.5:  # 50% chance to apply the swap\n        k, l = np.random.choice(n, size=2, replace=False)\n        if k > l:\n            k, l = l, k\n\n        # Calculate the change in all three objectives\n        original_costs = [\n            distance_matrix_1[new_solution[k-1], new_solution[k]] +\n            distance_matrix_1[new_solution[l], new_solution[(l+1)%n]] +\n            distance_matrix_1[new_solution[l-1], new_solution[l]],\n\n            distance_matrix_2[new_solution[k-1], new_solution[k]] +\n            distance_matrix_2[new_solution[l], new_solution[(l+1)%n]] +\n            distance_matrix_2[new_solution[l-1], new_solution[l]],\n\n            distance_matrix_3[new_solution[k-1], new_solution[k]] +\n            distance_matrix_3[new_solution[l], new_solution[(l+1)%n]] +\n            distance_matrix_3[new_solution[l-1], new_solution[l]]\n        ]\n\n        swapped_costs = [\n            distance_matrix_1[new_solution[k-1], new_solution[l]] +\n            distance_matrix_1[new_solution[k], new_solution[(l+1)%n]] +\n            distance_matrix_1[new_solution[l-1], new_solution[k]],\n\n            distance_matrix_2[new_solution[k-1], new_solution[l]] +\n            distance_matrix_2[new_solution[k], new_solution[(l+1)%n]] +\n            distance_matrix_2[new_solution[l-1], new_solution[k]],\n\n            distance_matrix_3[new_solution[k-1], new_solution[l]] +\n            distance_matrix_3[new_solution[k], new_solution[(l+1)%n]] +\n            distance_matrix_3[new_solution[l-1], new_solution[k]]\n        ]\n\n        # If the swap improves the worst objective, perform it\n        if any(swapped_costs[m] < original_costs[m] for m in range(3)):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 21,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel 3-objective-aware move\n    n = len(base_solution)\n\n    # First, perform standard 2-opt\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, apply a 3-objective-aware move: select a segment and reorder it based on a weighted distance\n    if n > 3:\n        k = np.random.randint(1, n-1)\n        l = np.random.randint(1, n-1)\n        if k > l:\n            k, l = l, k\n\n        # Calculate weighted distances for the segment\n        segment = new_solution[k:l+1]\n        segment_distances = np.zeros(len(segment))\n\n        for idx, node in enumerate(segment):\n            prev_node = segment[idx-1] if idx > 0 else new_solution[k-1]\n            next_node = segment[idx+1] if idx < len(segment)-1 else new_solution[l+1]\n\n            # Weighted distance considering all three objectives\n            dist1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n            dist2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n            dist3 = distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node]\n\n            # Simple weighted sum (could be replaced with more sophisticated weighting)\n            segment_distances[idx] = 0.33 * dist1 + 0.33 * dist2 + 0.33 * dist3\n\n        # Reorder the segment to minimize the weighted distance\n        sorted_indices = np.argsort(segment_distances)\n        new_solution[k:l+1] = segment[sorted_indices]\n\n    return new_solution\n\n",
        "score": [
            -0.7363994910705801,
            1.5511872172355652
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel 3-objective-aware move\n    n = len(base_solution)\n\n    # First, perform standard 2-opt\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, apply a 3-objective-aware move: select a segment and reorder it based on a weighted distance\n    if n > 3:\n        k = np.random.randint(1, n-1)\n        l = np.random.randint(1, n-1)\n        if k > l:\n            k, l = l, k\n\n        # Calculate weighted distances for the segment\n        segment = new_solution[k:l+1]\n        segment_distances = np.zeros(len(segment))\n\n        for idx, node in enumerate(segment):\n            prev_node = segment[idx-1] if idx > 0 else new_solution[k-1]\n            next_node = segment[idx+1] if idx < len(segment)-1 else new_solution[l+1]\n\n            # Weighted distance considering all three objectives\n            dist1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n            dist2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n            dist3 = distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node]\n\n            # Simple weighted sum (could be replaced with more sophisticated weighting)\n            segment_distances[idx] = 0.33 * dist1 + 0.33 * dist2 + 0.33 * dist3\n\n        # Reorder the segment to minimize the weighted distance\n        sorted_indices = np.argsort(segment_distances)\n        new_solution[k:l+1] = segment[sorted_indices]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 22,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly biased towards solutions with lower objectives)\n    weights = [1 / (sum(obj) + 1e-6) for _, obj in archive]  # Inverse of total objective as weight\n    selected_idx = np.random.choice(len(archive), p=np.array(weights) / sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: apply a combination of 2-opt and random swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt with objective-aware selection\n    for _ in range(5):  # Limited iterations to balance exploration and exploitation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == j:\n            continue\n\n        # Evaluate the new segment in all three objectives\n        original_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j-1], new_solution[j]] +\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j-1], new_solution[j]] +\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j-1], new_solution[j]]\n        )\n\n        new_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_1[new_solution[i], new_solution[j-1]] +\n            distance_matrix_2[new_solution[i-1], new_solution[j]] +\n            distance_matrix_2[new_solution[i], new_solution[j-1]] +\n            distance_matrix_3[new_solution[i-1], new_solution[j]] +\n            distance_matrix_3[new_solution[i], new_solution[j-1]]\n        )\n\n        if new_cost < original_cost:\n            # Reverse the segment\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Random swap to maintain diversity\n    if np.random.random() < 0.3:  # 30% chance of random swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7627645522897729,
            2.9201945185661318
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly biased towards solutions with lower objectives)\n    weights = [1 / (sum(obj) + 1e-6) for _, obj in archive]  # Inverse of total objective as weight\n    selected_idx = np.random.choice(len(archive), p=np.array(weights) / sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: apply a combination of 2-opt and random swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt with objective-aware selection\n    for _ in range(5):  # Limited iterations to balance exploration and exploitation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == j:\n            continue\n\n        # Evaluate the new segment in all three objectives\n        original_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j-1], new_solution[j]] +\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j-1], new_solution[j]] +\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j-1], new_solution[j]]\n        )\n\n        new_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_1[new_solution[i], new_solution[j-1]] +\n            distance_matrix_2[new_solution[i-1], new_solution[j]] +\n            distance_matrix_2[new_solution[i], new_solution[j-1]] +\n            distance_matrix_3[new_solution[i-1], new_solution[j]] +\n            distance_matrix_3[new_solution[i], new_solution[j-1]]\n        )\n\n        if new_cost < original_cost:\n            # Reverse the segment\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Random swap to maintain diversity\n    if np.random.random() < 0.3:  # 30% chance of random swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 23,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low objective values\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and 3-opt\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n - 1)\n\n    # Apply 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply 3-opt perturbation\n    if random.random() < 0.5:  # 50% chance to apply 3-opt\n        x, y, z = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[x:y]\n        segment2 = new_solution[y:z]\n        new_solution[x:z] = np.concatenate([segment2, segment1])\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8476633825926445,
            1.497619903087616
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low objective values\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and 3-opt\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n - 1)\n\n    # Apply 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply 3-opt perturbation\n    if random.random() < 0.5:  # 50% chance to apply 3-opt\n        x, y, z = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[x:y]\n        segment2 = new_solution[y:z]\n        new_solution[x:z] = np.concatenate([segment2, segment1])\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 23,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low objective values\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and 3-opt\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n - 1)\n\n    # Apply 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply 3-opt perturbation\n    if random.random() < 0.5:  # 50% chance to apply 3-opt\n        x, y, z = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[x:y]\n        segment2 = new_solution[y:z]\n        new_solution[x:z] = np.concatenate([segment2, segment1])\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8476633825926445,
            1.497619903087616
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low objective values\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and 3-opt\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n - 1)\n\n    # Apply 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply 3-opt perturbation\n    if random.random() < 0.5:  # 50% chance to apply 3-opt\n        x, y, z = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[x:y]\n        segment2 = new_solution[y:z]\n        new_solution[x:z] = np.concatenate([segment2, segment1])\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 24,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware refinement: try to improve each objective\n    for _ in range(3):  # Limit attempts to avoid excessive computation\n        k, l = np.random.choice(n, size=2, replace=False)\n        if k > l:\n            k, l = l, k\n\n        # Calculate current and potential costs for all three objectives\n        current_costs = []\n        for dm in [distance_matrix_1, distance_matrix_2, distance_matrix_3]:\n            current_cost = dm[new_solution[k-1], new_solution[k]] + dm[new_solution[l], new_solution[(l+1)%n]]\n            current_costs.append(current_cost)\n\n        # Calculate potential costs after swap\n        potential_costs = []\n        for dm in [distance_matrix_1, distance_matrix_2, distance_matrix_3]:\n            potential_cost = dm[new_solution[k-1], new_solution[l]] + dm[new_solution[k], new_solution[(l+1)%n]]\n            potential_costs.append(potential_cost)\n\n        # Accept swap if it improves at least one objective\n        if any(p < c for p, c in zip(potential_costs, current_costs)):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7782622645950386,
            1.423466718196869
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware refinement: try to improve each objective\n    for _ in range(3):  # Limit attempts to avoid excessive computation\n        k, l = np.random.choice(n, size=2, replace=False)\n        if k > l:\n            k, l = l, k\n\n        # Calculate current and potential costs for all three objectives\n        current_costs = []\n        for dm in [distance_matrix_1, distance_matrix_2, distance_matrix_3]:\n            current_cost = dm[new_solution[k-1], new_solution[k]] + dm[new_solution[l], new_solution[(l+1)%n]]\n            current_costs.append(current_cost)\n\n        # Calculate potential costs after swap\n        potential_costs = []\n        for dm in [distance_matrix_1, distance_matrix_2, distance_matrix_3]:\n            potential_cost = dm[new_solution[k-1], new_solution[l]] + dm[new_solution[k], new_solution[(l+1)%n]]\n            potential_costs.append(potential_cost)\n\n        # Accept swap if it improves at least one objective\n        if any(p < c for p, c in zip(potential_costs, current_costs)):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 25,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate diversity scores for each solution\n        diversity_scores = []\n        for sol, obj in archive:\n            diversity = (obj[0] - obj[1])**2 + (obj[1] - obj[2])**2 + (obj[2] - obj[0])**2\n            diversity_scores.append(diversity)\n\n        # Select a solution with high diversity (potential for improvement)\n        selected_idx = np.argmax(diversity_scores)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    # 1. Randomly select a segment of the tour\n    n = len(new_solution)\n    start = random.randint(0, n - 2)\n    length = random.randint(2, min(10, n // 2))\n    end = min(start + length, n - 1)\n\n    segment = new_solution[start:end+1]\n\n    # 2. Apply different operators based on objective diversity\n    obj_diversity = (archive[selected_idx][1][0] - archive[selected_idx][1][1])**2 + \\\n                   (archive[selected_idx][1][1] - archive[selected_idx][1][2])**2 + \\\n                   (archive[selected_idx][1][2] - archive[selected_idx][1][0])**2\n\n    if obj_diversity > 1000:  # High diversity - use more disruptive operators\n        # Reverse the segment\n        new_solution[start:end+1] = segment[::-1]\n    else:  # Low diversity - use more conservative operators\n        # Swap two nodes in the segment\n        if len(segment) >= 2:\n            i, j = random.sample(range(len(segment)), 2)\n            segment[i], segment[j] = segment[j], segment[i]\n            new_solution[start:end+1] = segment\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != len(new_solution):\n        # If invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5024017417707489,
            1.9233582973480225
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate diversity scores for each solution\n        diversity_scores = []\n        for sol, obj in archive:\n            diversity = (obj[0] - obj[1])**2 + (obj[1] - obj[2])**2 + (obj[2] - obj[0])**2\n            diversity_scores.append(diversity)\n\n        # Select a solution with high diversity (potential for improvement)\n        selected_idx = np.argmax(diversity_scores)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    # 1. Randomly select a segment of the tour\n    n = len(new_solution)\n    start = random.randint(0, n - 2)\n    length = random.randint(2, min(10, n // 2))\n    end = min(start + length, n - 1)\n\n    segment = new_solution[start:end+1]\n\n    # 2. Apply different operators based on objective diversity\n    obj_diversity = (archive[selected_idx][1][0] - archive[selected_idx][1][1])**2 + \\\n                   (archive[selected_idx][1][1] - archive[selected_idx][1][2])**2 + \\\n                   (archive[selected_idx][1][2] - archive[selected_idx][1][0])**2\n\n    if obj_diversity > 1000:  # High diversity - use more disruptive operators\n        # Reverse the segment\n        new_solution[start:end+1] = segment[::-1]\n    else:  # Low diversity - use more conservative operators\n        # Swap two nodes in the segment\n        if len(segment) >= 2:\n            i, j = random.sample(range(len(segment)), 2)\n            segment[i], segment[j] = segment[j], segment[i]\n            new_solution[start:end+1] = segment\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != len(new_solution):\n        # If invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 26,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., largest objective values)\n    objectives = [obj for sol, obj in archive]\n    max_obj = max(objectives, key=lambda x: sum(x))\n    selected_idx = objectives.index(max_obj)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: combine 2-opt and objective-aware swaps\n    for _ in range(5):  # Perform multiple iterations\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        # 2-opt move (standard local search)\n        if np.random.rand() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Objective-aware swap: prioritize nodes with high contribution to objectives\n            # Calculate contribution of each node to the objectives\n            contributions = []\n            for k in range(n):\n                prev = new_solution[k-1]\n                curr = new_solution[k]\n                next_node = new_solution[(k+1) % n]\n                contrib = (distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] +\n                           distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node] +\n                           distance_matrix_3[prev, curr] + distance_matrix_3[curr, next_node])\n                contributions.append(contrib)\n\n            # Select nodes with highest contribution for possible swap\n            sorted_indices = np.argsort(contributions)[::-1]\n            a, b = sorted_indices[0], sorted_indices[1]\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.6577086184053256,
            1.6744542121887207
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., largest objective values)\n    objectives = [obj for sol, obj in archive]\n    max_obj = max(objectives, key=lambda x: sum(x))\n    selected_idx = objectives.index(max_obj)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: combine 2-opt and objective-aware swaps\n    for _ in range(5):  # Perform multiple iterations\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        # 2-opt move (standard local search)\n        if np.random.rand() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Objective-aware swap: prioritize nodes with high contribution to objectives\n            # Calculate contribution of each node to the objectives\n            contributions = []\n            for k in range(n):\n                prev = new_solution[k-1]\n                curr = new_solution[k]\n                next_node = new_solution[(k+1) % n]\n                contrib = (distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] +\n                           distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node] +\n                           distance_matrix_3[prev, curr] + distance_matrix_3[curr, next_node])\n                contributions.append(contrib)\n\n            # Select nodes with highest contribution for possible swap\n            sorted_indices = np.argsort(contributions)[::-1]\n            a, b = sorted_indices[0], sorted_indices[1]\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 27,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., low objective values)\n    selected = random.choice(archive)\n    base_solution = selected[0].copy()\n    current_objectives = selected[1]\n\n    # Hybrid local search operator: combine 2-opt with a novel 3-opt-like move\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move (standard local search)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, apply a novel 3-opt-like move that considers all three objectives\n    if n > 3:\n        a, b, c = sorted(random.sample(range(n), 3))\n        # Calculate the current and potential costs for all three objectives\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] +\n            distance_matrix_1[new_solution[b-1], new_solution[b]] +\n            distance_matrix_1[new_solution[c-1], new_solution[c]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] +\n            distance_matrix_2[new_solution[b-1], new_solution[b]] +\n            distance_matrix_2[new_solution[c-1], new_solution[c]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] +\n            distance_matrix_3[new_solution[b-1], new_solution[b]] +\n            distance_matrix_3[new_solution[c-1], new_solution[c]]\n        ]\n\n        # Try different configurations of the 3-opt move\n        configurations = [\n            (a, b, c),\n            (a, c, b),\n            (b, a, c),\n            (b, c, a),\n            (c, a, b),\n            (c, b, a)\n        ]\n\n        best_config = (a, b, c)\n        best_improvement = 0\n\n        for config in configurations:\n            x, y, z = config\n            # Calculate the potential costs for this configuration\n            potential_costs = [\n                distance_matrix_1[new_solution[x-1], new_solution[y]] +\n                distance_matrix_1[new_solution[y-1], new_solution[z]] +\n                distance_matrix_1[new_solution[z-1], new_solution[x]],\n                distance_matrix_2[new_solution[x-1], new_solution[y]] +\n                distance_matrix_2[new_solution[y-1], new_solution[z]] +\n                distance_matrix_2[new_solution[z-1], new_solution[x]],\n                distance_matrix_3[new_solution[x-1], new_solution[y]] +\n                distance_matrix_3[new_solution[y-1], new_solution[z]] +\n                distance_matrix_3[new_solution[z-1], new_solution[x]]\n            ]\n\n            # Calculate the improvement (negative means better)\n            improvement = sum(potential_costs) - sum(current_costs)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_config = config\n\n        # Apply the best configuration\n        x, y, z = best_config\n        new_solution[x:z] = new_solution[x:z][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8115176381469917,
            1.611056125164032
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., low objective values)\n    selected = random.choice(archive)\n    base_solution = selected[0].copy()\n    current_objectives = selected[1]\n\n    # Hybrid local search operator: combine 2-opt with a novel 3-opt-like move\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move (standard local search)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, apply a novel 3-opt-like move that considers all three objectives\n    if n > 3:\n        a, b, c = sorted(random.sample(range(n), 3))\n        # Calculate the current and potential costs for all three objectives\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] +\n            distance_matrix_1[new_solution[b-1], new_solution[b]] +\n            distance_matrix_1[new_solution[c-1], new_solution[c]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] +\n            distance_matrix_2[new_solution[b-1], new_solution[b]] +\n            distance_matrix_2[new_solution[c-1], new_solution[c]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] +\n            distance_matrix_3[new_solution[b-1], new_solution[b]] +\n            distance_matrix_3[new_solution[c-1], new_solution[c]]\n        ]\n\n        # Try different configurations of the 3-opt move\n        configurations = [\n            (a, b, c),\n            (a, c, b),\n            (b, a, c),\n            (b, c, a),\n            (c, a, b),\n            (c, b, a)\n        ]\n\n        best_config = (a, b, c)\n        best_improvement = 0\n\n        for config in configurations:\n            x, y, z = config\n            # Calculate the potential costs for this configuration\n            potential_costs = [\n                distance_matrix_1[new_solution[x-1], new_solution[y]] +\n                distance_matrix_1[new_solution[y-1], new_solution[z]] +\n                distance_matrix_1[new_solution[z-1], new_solution[x]],\n                distance_matrix_2[new_solution[x-1], new_solution[y]] +\n                distance_matrix_2[new_solution[y-1], new_solution[z]] +\n                distance_matrix_2[new_solution[z-1], new_solution[x]],\n                distance_matrix_3[new_solution[x-1], new_solution[y]] +\n                distance_matrix_3[new_solution[y-1], new_solution[z]] +\n                distance_matrix_3[new_solution[z-1], new_solution[x]]\n            ]\n\n            # Calculate the improvement (negative means better)\n            improvement = sum(potential_costs) - sum(current_costs)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_config = config\n\n        # Apply the best configuration\n        x, y, z = best_config\n        new_solution[x:z] = new_solution[x:z][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 28,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate objective diversity (range of each objective)\n        objectives = np.array([obj for _, obj in archive])\n        obj_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n        # Select solution with highest diversity\n        diversity_scores = np.sum(objectives / obj_ranges, axis=1)\n        selected_idx = np.argmax(diversity_scores)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy combining 2-opt and 3-opt\n    n = len(new_solution)\n    if n < 4:\n        # For very small tours, just swap two random nodes\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # With 70% probability, apply 2-opt\n        if np.random.rand() < 0.7:\n            # 2-opt: reverse a segment of the tour\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # With 30% probability, apply 3-opt\n            # 3-opt: reverse three segments of the tour\n            points = sorted(np.random.choice(n, 3, replace=False))\n            i, j, k = points\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[j:k+1] = new_solution[j:k+1][::-1]\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If duplicates exist, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6817624397051516,
            1.6867359042167664
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate objective diversity (range of each objective)\n        objectives = np.array([obj for _, obj in archive])\n        obj_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n        # Select solution with highest diversity\n        diversity_scores = np.sum(objectives / obj_ranges, axis=1)\n        selected_idx = np.argmax(diversity_scores)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy combining 2-opt and 3-opt\n    n = len(new_solution)\n    if n < 4:\n        # For very small tours, just swap two random nodes\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # With 70% probability, apply 2-opt\n        if np.random.rand() < 0.7:\n            # 2-opt: reverse a segment of the tour\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # With 30% probability, apply 3-opt\n            # 3-opt: reverse three segments of the tour\n            points = sorted(np.random.choice(n, 3, replace=False))\n            i, j, k = points\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[j:k+1] = new_solution[j:k+1][::-1]\n            new_solution[i:k+1] = new_solution[i:k+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If duplicates exist, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 29,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (not just the first one)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware move selection\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform 2-opt swap\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware refinement: check if the move improves any objective\n    current_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # If the move doesn't improve any objective, try a different approach\n    if all(c >= archive[selected_idx][1][m] for m, c in enumerate(current_costs)):\n        # Try a 3-opt move (more disruptive)\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution[a:c] = np.concatenate([segment2, segment1])\n\n    return new_solution\n\n",
        "score": [
            -0.7902123106744064,
            1.8712688565254212
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (not just the first one)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware move selection\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform 2-opt swap\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware refinement: check if the move improves any objective\n    current_costs = [\n        sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n    ]\n\n    # If the move doesn't improve any objective, try a different approach\n    if all(c >= archive[selected_idx][1][m] for m, c in enumerate(current_costs)):\n        # Try a 3-opt move (more disruptive)\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution[a:c] = np.concatenate([segment2, segment1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 30,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (ascending)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the top 30% of the archive\n        selected_idx = random.randint(0, max(0, len(archive_sorted) // 3 - 1))\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and edge insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful local search\n\n    # Randomly choose between 2-opt and edge insertion\n    if random.random() < 0.5:\n        # 2-opt: randomly select two edges and reverse the segment between them\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Edge insertion: remove a random edge and reinsert it in a different position\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            insert_pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains a valid tour (visits each node exactly once)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6095452415306382,
            1.6729649662971497
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (ascending)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the top 30% of the archive\n        selected_idx = random.randint(0, max(0, len(archive_sorted) // 3 - 1))\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and edge insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful local search\n\n    # Randomly choose between 2-opt and edge insertion\n    if random.random() < 0.5:\n        # 2-opt: randomly select two edges and reverse the segment between them\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Edge insertion: remove a random edge and reinsert it in a different position\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            insert_pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains a valid tour (visits each node exactly once)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 31,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too diverse)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.9, 0.1, len(archive)) / np.linspace(0.9, 0.1, len(archive)).sum())\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Perform a 2-opt move (standard local search)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: find the best swap in terms of all three objectives\n    for _ in range(3):  # Try multiple swaps\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Evaluate current and swapped segments\n        current_cost = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                         distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                         distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                         distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                         distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                         distance_matrix_3[new_solution[b-1], new_solution[b]])\n\n        swapped_cost = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                         distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_2[new_solution[b-1], new_solution[a]] +\n                         distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_3[new_solution[b-1], new_solution[a]])\n\n        if swapped_cost < current_cost:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.792012918867656,
            2.8244102954864503
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too diverse)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.9, 0.1, len(archive)) / np.linspace(0.9, 0.1, len(archive)).sum())\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Perform a 2-opt move (standard local search)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: find the best swap in terms of all three objectives\n    for _ in range(3):  # Try multiple swaps\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Evaluate current and swapped segments\n        current_cost = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                         distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                         distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                         distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                         distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                         distance_matrix_3[new_solution[b-1], new_solution[b]])\n\n        swapped_cost = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                         distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_2[new_solution[b-1], new_solution[a]] +\n                         distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_3[new_solution[b-1], new_solution[a]])\n\n        if swapped_cost < current_cost:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 32,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives to avoid bias toward any single objective\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    total_objectives = normalized_objectives.sum(axis=1)\n\n    # Select the solution with the best balance (lowest total normalized objective)\n    selected_idx = np.argmin(total_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to modify (avoid consecutive edges to ensure diversity)\n    i, j = sorted(random.sample(range(n), 2))\n    while j - i <= 1:  # Ensure non-adjacent edges\n        i, j = sorted(random.sample(range(n), 2))\n\n    # Calculate the objective-aware edge cost: sum of costs in all three objectives\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v] +\n                distance_matrix_2[u, v] +\n                distance_matrix_3[u, v])\n\n    # Try reversing the segment between i and j (2-opt move)\n    candidate_solution = new_solution.copy()\n    candidate_solution[i:j] = new_solution[i:j][::-1]\n\n    # Calculate the cost of the original and candidate segments\n    original_cost = (edge_cost(new_solution[i-1], new_solution[i]) +\n                     edge_cost(new_solution[j-1], new_solution[j]))\n    candidate_cost = (edge_cost(candidate_solution[i-1], candidate_solution[i]) +\n                      edge_cost(candidate_solution[j-1], candidate_solution[j]))\n\n    # Accept the move if it improves the total objective-aware cost\n    if candidate_cost < original_cost:\n        new_solution = candidate_solution\n    else:\n        # If not improving, try a random swap to escape local optima\n        k, l = random.sample(range(n), 2)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.6898867206595356,
            1.6645735859870912
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives to avoid bias toward any single objective\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    total_objectives = normalized_objectives.sum(axis=1)\n\n    # Select the solution with the best balance (lowest total normalized objective)\n    selected_idx = np.argmin(total_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to modify (avoid consecutive edges to ensure diversity)\n    i, j = sorted(random.sample(range(n), 2))\n    while j - i <= 1:  # Ensure non-adjacent edges\n        i, j = sorted(random.sample(range(n), 2))\n\n    # Calculate the objective-aware edge cost: sum of costs in all three objectives\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v] +\n                distance_matrix_2[u, v] +\n                distance_matrix_3[u, v])\n\n    # Try reversing the segment between i and j (2-opt move)\n    candidate_solution = new_solution.copy()\n    candidate_solution[i:j] = new_solution[i:j][::-1]\n\n    # Calculate the cost of the original and candidate segments\n    original_cost = (edge_cost(new_solution[i-1], new_solution[i]) +\n                     edge_cost(new_solution[j-1], new_solution[j]))\n    candidate_cost = (edge_cost(candidate_solution[i-1], candidate_solution[i]) +\n                      edge_cost(candidate_solution[j-1], candidate_solution[j]))\n\n    # Accept the move if it improves the total objective-aware cost\n    if candidate_cost < original_cost:\n        new_solution = candidate_solution\n    else:\n        # If not improving, try a random swap to escape local optima\n        k, l = random.sample(range(n), 2)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 33,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low improvement potential\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and edge swapping\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    k, l = np.random.choice(n, 2, replace=False)\n\n    # Apply 2-opt to the first pair of nodes\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    # Apply edge swapping to the second pair of nodes\n    if k > l:\n        k, l = l, k\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains feasible (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple 2-opt if the solution becomes invalid\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    return new_solution\n\n",
        "score": [
            -0.7723567878820025,
            1.6519476532936097
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low improvement potential\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and edge swapping\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    k, l = np.random.choice(n, 2, replace=False)\n\n    # Apply 2-opt to the first pair of nodes\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    # Apply edge swapping to the second pair of nodes\n    if k > l:\n        k, l = l, k\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains feasible (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple 2-opt if the solution becomes invalid\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 34,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt and edge insertion\n    n = len(base_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt to the selected segment\n    new_solution[i:j+1] = base_solution[i:j+1][::-1]\n\n    # Apply edge insertion to further improve the solution\n    k = np.random.randint(0, n)\n    if k != i and k != j:\n        # Remove a random edge and reinsert it elsewhere\n        edge_node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, edge_node)\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Invalid neighbor solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.8029517630877411,
            1.77195200920105
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt and edge insertion\n    n = len(base_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt to the selected segment\n    new_solution[i:j+1] = base_solution[i:j+1][::-1]\n\n    # Apply edge insertion to further improve the solution\n    k = np.random.randint(0, n)\n    if k != i and k != j:\n        # Remove a random edge and reinsert it elsewhere\n        edge_node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, edge_node)\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Invalid neighbor solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 35,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., with high crowding distance or low objective values)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel 3-opt-inspired move\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small tours\n\n    # Randomly select two edges to break (2-opt)\n    i, j = sorted(random.sample(range(n), 2))\n    if i == j or (i == 0 and j == n-1):\n        return new_solution  # Invalid selection, skip\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additional 3-opt-inspired move: randomly select three nodes and reorder them\n    if n >= 4 and random.random() < 0.5:  # 50% chance to apply the additional move\n        k, l, m = sorted(random.sample(range(n), 3))\n        # Create a new segment by reordering the three selected nodes\n        segment = new_solution[k:l+1]\n        if len(segment) > 1:\n            # Rotate the segment to create a new ordering\n            shift = random.randint(1, len(segment)-1)\n            segment = np.roll(segment, shift)\n            new_solution[k:l+1] = segment\n\n    return new_solution\n\n",
        "score": [
            -0.7559820967007856,
            1.365219247341156
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., with high crowding distance or low objective values)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel 3-opt-inspired move\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small tours\n\n    # Randomly select two edges to break (2-opt)\n    i, j = sorted(random.sample(range(n), 2))\n    if i == j or (i == 0 and j == n-1):\n        return new_solution  # Invalid selection, skip\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additional 3-opt-inspired move: randomly select three nodes and reorder them\n    if n >= 4 and random.random() < 0.5:  # 50% chance to apply the additional move\n        k, l, m = sorted(random.sample(range(n), 3))\n        # Create a new segment by reordering the three selected nodes\n        segment = new_solution[k:l+1]\n        if len(segment) > 1:\n            # Rotate the segment to create a new ordering\n            shift = random.randint(1, len(segment)-1)\n            segment = np.roll(segment, shift)\n            new_solution[k:l+1] = segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 36,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the best in all objectives)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware edge swaps\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations\n        # Randomly select two distinct edges\n        i, j = np.random.choice(n, 2, replace=False)\n\n        # Calculate the current and potential new costs for all three objectives\n        current_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j-1], new_solution[j]] +\n            distance_matrix_2[new_solution[j-1], new_solution[j]] +\n            distance_matrix_3[new_solution[j-1], new_solution[j]]\n        )\n\n        new_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_2[new_solution[i-1], new_solution[j]] +\n            distance_matrix_3[new_solution[i-1], new_solution[j]] +\n            distance_matrix_1[new_solution[j-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j-1], new_solution[i]]\n        )\n\n        # Accept the move if it improves at least one objective\n        if new_cost < current_cost:\n            # Reverse the segment between i and j\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Final check to ensure validity\n    if len(set(new_solution)) != n:\n        raise ValueError(\"Generated solution is invalid\")\n\n    return new_solution\n\n",
        "score": [
            -0.6667401320141886,
            3.8563260436058044
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the best in all objectives)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware edge swaps\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations\n        # Randomly select two distinct edges\n        i, j = np.random.choice(n, 2, replace=False)\n\n        # Calculate the current and potential new costs for all three objectives\n        current_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j-1], new_solution[j]] +\n            distance_matrix_2[new_solution[j-1], new_solution[j]] +\n            distance_matrix_3[new_solution[j-1], new_solution[j]]\n        )\n\n        new_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_2[new_solution[i-1], new_solution[j]] +\n            distance_matrix_3[new_solution[i-1], new_solution[j]] +\n            distance_matrix_1[new_solution[j-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j-1], new_solution[i]]\n        )\n\n        # Accept the move if it improves at least one objective\n        if new_cost < current_cost:\n            # Reverse the segment between i and j\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Final check to ensure validity\n    if len(set(new_solution)) != n:\n        raise ValueError(\"Generated solution is invalid\")\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 37,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    i, j = np.random.randint(0, n, size=2)\n    if i > j:\n        i, j = j, i\n\n    # Apply 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware refinement: check if swapping nodes improves any objective\n    for _ in range(2):  # Limit refinement steps to avoid excessive computation\n        a, b = np.random.randint(0, n, size=2)\n        if a == b:\n            continue\n\n        # Calculate current and potential costs for all three objectives\n        current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        potential_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n\n        current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        potential_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n        current_cost3 = distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        potential_cost3 = distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n\n        # If any objective improves, perform the swap\n        if (potential_cost1 < current_cost1) or (potential_cost2 < current_cost2) or (potential_cost3 < current_cost3):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7427979238862437,
            1.6847549080848694
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    i, j = np.random.randint(0, n, size=2)\n    if i > j:\n        i, j = j, i\n\n    # Apply 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware refinement: check if swapping nodes improves any objective\n    for _ in range(2):  # Limit refinement steps to avoid excessive computation\n        a, b = np.random.randint(0, n, size=2)\n        if a == b:\n            continue\n\n        # Calculate current and potential costs for all three objectives\n        current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        potential_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n\n        current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        potential_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n        current_cost3 = distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        potential_cost3 = distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n\n        # If any objective improves, perform the swap\n        if (potential_cost1 < current_cost1) or (potential_cost2 < current_cost2) or (potential_cost3 < current_cost3):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 38,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best but not the worst)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    candidate_indices = [i for i in range(1, len(sorted_archive) - 1)]  # Exclude best and worst\n    if not candidate_indices:\n        selected_idx = np.random.randint(0, len(archive))\n    else:\n        selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on the objective with the highest improvement potential\n    objective_values = archive[selected_idx][1]\n    worst_obj_idx = np.argmax(objective_values)\n\n    if worst_obj_idx == 0:\n        distance_matrix = distance_matrix_1\n    elif worst_obj_idx == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Find the worst edge in the selected objective\n    max_edge = -1\n    i_max, j_max = -1, -1\n    for i in range(n - 1):\n        u, v = new_solution[i], new_solution[i + 1]\n        edge_cost = distance_matrix[u, v]\n        if edge_cost > max_edge:\n            max_edge = edge_cost\n            i_max, j_max = i, i + 1\n\n    # Perform 2-opt on the worst edge\n    if i_max != -1 and j_max != -1:\n        new_solution[i_max:j_max] = new_solution[i_max:j_max][::-1]\n\n    # Perform objective-aware swaps to improve other objectives\n    for _ in range(2):  # Limit the number of swaps for efficiency\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate current and potential costs\n        current_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        new_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]],\n            distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]],\n            distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j-1], new_solution[i]]\n        ]\n\n        # Count improvements across objectives\n        improvements = sum(1 for a, b in zip(current_costs, new_costs) if b < a)\n\n        if improvements >= 2:  # Require at least two objectives to improve\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7585641738719309,
            2.8458184480667112
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best but not the worst)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    candidate_indices = [i for i in range(1, len(sorted_archive) - 1)]  # Exclude best and worst\n    if not candidate_indices:\n        selected_idx = np.random.randint(0, len(archive))\n    else:\n        selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on the objective with the highest improvement potential\n    objective_values = archive[selected_idx][1]\n    worst_obj_idx = np.argmax(objective_values)\n\n    if worst_obj_idx == 0:\n        distance_matrix = distance_matrix_1\n    elif worst_obj_idx == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Find the worst edge in the selected objective\n    max_edge = -1\n    i_max, j_max = -1, -1\n    for i in range(n - 1):\n        u, v = new_solution[i], new_solution[i + 1]\n        edge_cost = distance_matrix[u, v]\n        if edge_cost > max_edge:\n            max_edge = edge_cost\n            i_max, j_max = i, i + 1\n\n    # Perform 2-opt on the worst edge\n    if i_max != -1 and j_max != -1:\n        new_solution[i_max:j_max] = new_solution[i_max:j_max][::-1]\n\n    # Perform objective-aware swaps to improve other objectives\n    for _ in range(2):  # Limit the number of swaps for efficiency\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate current and potential costs\n        current_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        new_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]],\n            distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]],\n            distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j-1], new_solution[i]]\n        ]\n\n        # Count improvements across objectives\n        improvements = sum(1 for a, b in zip(current_costs, new_costs) if b < a)\n\n        if improvements >= 2:  # Require at least two objectives to improve\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 39,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with probability proportional to its potential for improvement\n    weights = [1.0 / (1.0 + sum(obj)) for _, obj in archive]  # Higher weight for solutions with lower total cost\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n\n    # First, perform a standard 2-opt move\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, perform an objective-aware swap to balance the three objectives\n    # Calculate the current costs for each objective\n    def calculate_cost(solution, distance_matrix):\n        cost = 0\n        for k in range(len(solution)):\n            cost += distance_matrix[solution[k-1]][solution[k]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n    current_cost3 = calculate_cost(new_solution, distance_matrix_3)\n\n    # Find the most imbalanced objective\n    costs = [current_cost1, current_cost2, current_cost3]\n    max_cost = max(costs)\n    max_idx = costs.index(max_cost)\n\n    # Try to improve the most imbalanced objective\n    for _ in range(10):  # Limit the number of attempts to avoid excessive computation\n        a, b = sorted(random.sample(range(n), 2))\n        temp_solution = new_solution.copy()\n        temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n        # Calculate the new cost for the most imbalanced objective\n        new_cost = calculate_cost(temp_solution, [distance_matrix_1, distance_matrix_2, distance_matrix_3][max_idx])\n\n        # Accept the move if it improves the most imbalanced objective\n        if new_cost < max_cost:\n            new_solution = temp_solution\n            max_cost = new_cost\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.6701730229214561,
            1.7964785814285278
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with probability proportional to its potential for improvement\n    weights = [1.0 / (1.0 + sum(obj)) for _, obj in archive]  # Higher weight for solutions with lower total cost\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n\n    # First, perform a standard 2-opt move\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, perform an objective-aware swap to balance the three objectives\n    # Calculate the current costs for each objective\n    def calculate_cost(solution, distance_matrix):\n        cost = 0\n        for k in range(len(solution)):\n            cost += distance_matrix[solution[k-1]][solution[k]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n    current_cost3 = calculate_cost(new_solution, distance_matrix_3)\n\n    # Find the most imbalanced objective\n    costs = [current_cost1, current_cost2, current_cost3]\n    max_cost = max(costs)\n    max_idx = costs.index(max_cost)\n\n    # Try to improve the most imbalanced objective\n    for _ in range(10):  # Limit the number of attempts to avoid excessive computation\n        a, b = sorted(random.sample(range(n), 2))\n        temp_solution = new_solution.copy()\n        temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n        # Calculate the new cost for the most imbalanced objective\n        new_cost = calculate_cost(temp_solution, [distance_matrix_1, distance_matrix_2, distance_matrix_3][max_idx])\n\n        # Accept the move if it improves the most imbalanced objective\n        if new_cost < max_cost:\n            new_solution = temp_solution\n            max_cost = new_cost\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 40,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its \"improvement potential\"\n    # Here, we use the sum of normalized objective values to estimate potential\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    improvement_potential = normalized_obj.sum(axis=1)\n    probabilities = improvement_potential / improvement_potential.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First perform a standard 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform an objective-aware swap\n    if n > 2:\n        # Calculate the current and potential costs for all objectives\n        current_costs = [\n            sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]],\n            sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]],\n            sum(distance_matrix_3[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n        ]\n\n        # Try swapping nodes that are critical in any objective\n        for _ in range(5):  # Limit attempts to prevent excessive computation\n            a, b = np.random.choice(n, 2, replace=False)\n            if a > b:\n                a, b = b, a\n\n            # Calculate potential new costs\n            new_costs = [\n                current_costs[0] - distance_matrix_1[new_solution[a-1], new_solution[a]] - distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n                + distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]],\n\n                current_costs[1] - distance_matrix_2[new_solution[a-1], new_solution[a]] - distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n                + distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]],\n\n                current_costs[2] - distance_matrix_3[new_solution[a-1], new_solution[a]] - distance_matrix_3[new_solution[b], new_solution[(b+1)%n]]\n                + distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[a], new_solution[(b+1)%n]]\n            ]\n\n            # If the swap improves at least one objective without worsening others too much\n            if any(new_costs[i] < current_costs[i] for i in range(3)) and not any(new_costs[i] > 1.1 * current_costs[i] for i in range(3)):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.7588208171723905,
            1.9313361287117004
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its \"improvement potential\"\n    # Here, we use the sum of normalized objective values to estimate potential\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    improvement_potential = normalized_obj.sum(axis=1)\n    probabilities = improvement_potential / improvement_potential.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First perform a standard 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform an objective-aware swap\n    if n > 2:\n        # Calculate the current and potential costs for all objectives\n        current_costs = [\n            sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]],\n            sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]],\n            sum(distance_matrix_3[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n        ]\n\n        # Try swapping nodes that are critical in any objective\n        for _ in range(5):  # Limit attempts to prevent excessive computation\n            a, b = np.random.choice(n, 2, replace=False)\n            if a > b:\n                a, b = b, a\n\n            # Calculate potential new costs\n            new_costs = [\n                current_costs[0] - distance_matrix_1[new_solution[a-1], new_solution[a]] - distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n                + distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]],\n\n                current_costs[1] - distance_matrix_2[new_solution[a-1], new_solution[a]] - distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n                + distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]],\n\n                current_costs[2] - distance_matrix_3[new_solution[a-1], new_solution[a]] - distance_matrix_3[new_solution[b], new_solution[(b+1)%n]]\n                + distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[a], new_solution[(b+1)%n]]\n            ]\n\n            # If the swap improves at least one objective without worsening others too much\n            if any(new_costs[i] < current_costs[i] for i in range(3)) and not any(new_costs[i] > 1.1 * current_costs[i] for i in range(3)):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 41,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low objective values\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and edge insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly choose between 2-opt or edge insertion\n    if random.random() < 0.5:\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Edge insertion: remove a random edge and reinsert it\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            # Remove edge between i and (i+1)%n\n            removed_node = new_solution[(i+1)%n]\n            new_solution = np.delete(new_solution, (i+1)%n)\n            # Insert removed node at position j\n            new_solution = np.insert(new_solution, j, removed_node)\n\n    # Ensure the solution remains a valid tour\n    if len(new_solution) != len(base_solution) or len(np.unique(new_solution)) != len(base_solution):\n        return base_solution  # Fallback to base solution if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.7092028057407782,
            1.05277818441391
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low objective values\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and edge insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly choose between 2-opt or edge insertion\n    if random.random() < 0.5:\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Edge insertion: remove a random edge and reinsert it\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            # Remove edge between i and (i+1)%n\n            removed_node = new_solution[(i+1)%n]\n            new_solution = np.delete(new_solution, (i+1)%n)\n            # Insert removed node at position j\n            new_solution = np.insert(new_solution, j, removed_node)\n\n    # Ensure the solution remains a valid tour\n    if len(new_solution) != len(base_solution) or len(np.unique(new_solution)) != len(base_solution):\n        return base_solution  # Fallback to base solution if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 41,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low objective values\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and edge insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly choose between 2-opt or edge insertion\n    if random.random() < 0.5:\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Edge insertion: remove a random edge and reinsert it\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            # Remove edge between i and (i+1)%n\n            removed_node = new_solution[(i+1)%n]\n            new_solution = np.delete(new_solution, (i+1)%n)\n            # Insert removed node at position j\n            new_solution = np.insert(new_solution, j, removed_node)\n\n    # Ensure the solution remains a valid tour\n    if len(new_solution) != len(base_solution) or len(np.unique(new_solution)) != len(base_solution):\n        return base_solution  # Fallback to base solution if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.7092028057407782,
            1.05277818441391
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low objective values\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and edge insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly choose between 2-opt or edge insertion\n    if random.random() < 0.5:\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Edge insertion: remove a random edge and reinsert it\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            # Remove edge between i and (i+1)%n\n            removed_node = new_solution[(i+1)%n]\n            new_solution = np.delete(new_solution, (i+1)%n)\n            # Insert removed node at position j\n            new_solution = np.insert(new_solution, j, removed_node)\n\n    # Ensure the solution remains a valid tour\n    if len(new_solution) != len(base_solution) or len(np.unique(new_solution)) != len(base_solution):\n        return base_solution  # Fallback to base solution if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 42,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # We prioritize solutions with high variance in objectives to explore diverse regions\n    objectives = np.array([obj for _, obj in archive])\n    objective_variance = np.var(objectives, axis=0)\n    weighted_scores = np.sum((objectives - np.mean(objectives, axis=0)) ** 2 / objective_variance, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator combining 2-opt and objective-aware swaps\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform an objective-aware swap\n    # Calculate the current objective values\n    def calculate_objective(sol):\n        cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1))\n        cost1 += distance_matrix_1[sol[-1], sol[0]]  # Return to start\n        cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1))\n        cost2 += distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1))\n        cost3 += distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_obj = calculate_objective(new_solution)\n\n    # Try swapping nodes that are far in at least one objective space\n    for _ in range(10):  # Limit attempts to avoid excessive computation\n        a, b = random.sample(range(n), 2)\n        if a == b:\n            continue\n\n        # Create a candidate solution\n        candidate = new_solution.copy()\n        candidate[a], candidate[b] = candidate[b], candidate[a]\n\n        # Calculate the new objective\n        new_obj = calculate_objective(candidate)\n\n        # If the new solution improves at least one objective (or is non-dominated)\n        if (new_obj[0] <= current_obj[0] and new_obj[1] <= current_obj[1] and new_obj[2] <= current_obj[2] and\n            (new_obj[0] < current_obj[0] or new_obj[1] < current_obj[1] or new_obj[2] < current_obj[2])):\n            new_solution = candidate\n            current_obj = new_obj\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.6800066609417532,
            3.035037040710449
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # We prioritize solutions with high variance in objectives to explore diverse regions\n    objectives = np.array([obj for _, obj in archive])\n    objective_variance = np.var(objectives, axis=0)\n    weighted_scores = np.sum((objectives - np.mean(objectives, axis=0)) ** 2 / objective_variance, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator combining 2-opt and objective-aware swaps\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform an objective-aware swap\n    # Calculate the current objective values\n    def calculate_objective(sol):\n        cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1))\n        cost1 += distance_matrix_1[sol[-1], sol[0]]  # Return to start\n        cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1))\n        cost2 += distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1))\n        cost3 += distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_obj = calculate_objective(new_solution)\n\n    # Try swapping nodes that are far in at least one objective space\n    for _ in range(10):  # Limit attempts to avoid excessive computation\n        a, b = random.sample(range(n), 2)\n        if a == b:\n            continue\n\n        # Create a candidate solution\n        candidate = new_solution.copy()\n        candidate[a], candidate[b] = candidate[b], candidate[a]\n\n        # Calculate the new objective\n        new_obj = calculate_objective(candidate)\n\n        # If the new solution improves at least one objective (or is non-dominated)\n        if (new_obj[0] <= current_obj[0] and new_obj[1] <= current_obj[1] and new_obj[2] <= current_obj[2] and\n            (new_obj[0] < current_obj[0] or new_obj[1] < current_obj[1] or new_obj[2] < current_obj[2])):\n            new_solution = candidate\n            current_obj = new_obj\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 43,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective values)\n    weights = np.array([1 / (obj[0] + obj[1] + obj[2] + 1e-6) for _, obj in archive])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations\n        # Randomly select two distinct edges to break and reconnect\n        i, j = np.random.choice(n, size=2, replace=False)\n        k, l = np.random.choice(n, size=2, replace=False)\n\n        # Ensure we're not creating invalid tours\n        if i == j or k == l:\n            continue\n\n        # Calculate the change in all three objectives\n        old_edges = [\n            (new_solution[i], new_solution[(i+1)%n]),\n            (new_solution[j], new_solution[(j+1)%n]),\n            (new_solution[k], new_solution[(k+1)%n]),\n            (new_solution[l], new_solution[(l+1)%n])\n        ]\n\n        new_edges = [\n            (new_solution[i], new_solution[k]),\n            (new_solution[j], new_solution[l]),\n            (new_solution[i], new_solution[j]),\n            (new_solution[k], new_solution[l])\n        ]\n\n        delta_obj = [\n            sum(distance_matrix_1[a][b] for a, b in new_edges) - sum(distance_matrix_1[a][b] for a, b in old_edges),\n            sum(distance_matrix_2[a][b] for a, b in new_edges) - sum(distance_matrix_2[a][b] for a, b in old_edges),\n            sum(distance_matrix_3[a][b] for a, b in new_edges) - sum(distance_matrix_3[a][b] for a, b in old_edges)\n        ]\n\n        # Apply the move if it improves at least one objective\n        if any(d < 0 for d in delta_obj):\n            # Perform the 2-opt move\n            new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n            new_solution[j], new_solution[l] = new_solution[l], new_solution[j]\n\n            # Optionally perform a local 2-opt to fix any potential issues\n            if np.random.rand() < 0.3:\n                a, b = np.random.choice(n, size=2, replace=False)\n                if a > b:\n                    a, b = b, a\n                new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7512897968315756,
            2.499624156951904
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective values)\n    weights = np.array([1 / (obj[0] + obj[1] + obj[2] + 1e-6) for _, obj in archive])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations\n        # Randomly select two distinct edges to break and reconnect\n        i, j = np.random.choice(n, size=2, replace=False)\n        k, l = np.random.choice(n, size=2, replace=False)\n\n        # Ensure we're not creating invalid tours\n        if i == j or k == l:\n            continue\n\n        # Calculate the change in all three objectives\n        old_edges = [\n            (new_solution[i], new_solution[(i+1)%n]),\n            (new_solution[j], new_solution[(j+1)%n]),\n            (new_solution[k], new_solution[(k+1)%n]),\n            (new_solution[l], new_solution[(l+1)%n])\n        ]\n\n        new_edges = [\n            (new_solution[i], new_solution[k]),\n            (new_solution[j], new_solution[l]),\n            (new_solution[i], new_solution[j]),\n            (new_solution[k], new_solution[l])\n        ]\n\n        delta_obj = [\n            sum(distance_matrix_1[a][b] for a, b in new_edges) - sum(distance_matrix_1[a][b] for a, b in old_edges),\n            sum(distance_matrix_2[a][b] for a, b in new_edges) - sum(distance_matrix_2[a][b] for a, b in old_edges),\n            sum(distance_matrix_3[a][b] for a, b in new_edges) - sum(distance_matrix_3[a][b] for a, b in old_edges)\n        ]\n\n        # Apply the move if it improves at least one objective\n        if any(d < 0 for d in delta_obj):\n            # Perform the 2-opt move\n            new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n            new_solution[j], new_solution[l] = new_solution[l], new_solution[j]\n\n            # Optionally perform a local 2-opt to fix any potential issues\n            if np.random.rand() < 0.3:\n                a, b = np.random.choice(n, size=2, replace=False)\n                if a > b:\n                    a, b = b, a\n                new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 44,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_optimal_solutions = [sol for sol, obj in archive if not all(obj[i] == min(archive, key=lambda x: x[1][i])[1][i] for i in range(3))]\n    if not non_optimal_solutions:\n        non_optimal_solutions = [sol for sol, _ in archive]\n\n    base_solution = random.choice(non_optimal_solutions).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations\n        # Select a random segment to modify\n        i, j = sorted(random.sample(range(n), 2))\n\n        # 2-opt move (reverse a segment)\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Objective-aware swap: identify which objective is worst and try to improve it\n        obj_values = [sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)) +\n                      sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)) +\n                      sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))]\n\n        worst_obj = np.argmax(obj_values)\n        if worst_obj == 0:\n            # Improve first objective\n            for _ in range(3):\n                a, b = sorted(random.sample(range(n), 2))\n                if distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]] < \\\n                   distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]:\n                    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        elif worst_obj == 1:\n            # Improve second objective\n            for _ in range(3):\n                a, b = sorted(random.sample(range(n), 2))\n                if distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]] < \\\n                   distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]:\n                    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        else:\n            # Improve third objective\n            for _ in range(3):\n                a, b = sorted(random.sample(range(n), 2))\n                if distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]] < \\\n                   distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]:\n                    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7808502716704424,
            3.99320729970932
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_optimal_solutions = [sol for sol, obj in archive if not all(obj[i] == min(archive, key=lambda x: x[1][i])[1][i] for i in range(3))]\n    if not non_optimal_solutions:\n        non_optimal_solutions = [sol for sol, _ in archive]\n\n    base_solution = random.choice(non_optimal_solutions).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations\n        # Select a random segment to modify\n        i, j = sorted(random.sample(range(n), 2))\n\n        # 2-opt move (reverse a segment)\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Objective-aware swap: identify which objective is worst and try to improve it\n        obj_values = [sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)) +\n                      sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)) +\n                      sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))]\n\n        worst_obj = np.argmax(obj_values)\n        if worst_obj == 0:\n            # Improve first objective\n            for _ in range(3):\n                a, b = sorted(random.sample(range(n), 2))\n                if distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]] < \\\n                   distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]:\n                    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        elif worst_obj == 1:\n            # Improve second objective\n            for _ in range(3):\n                a, b = sorted(random.sample(range(n), 2))\n                if distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]] < \\\n                   distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]:\n                    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        else:\n            # Improve third objective\n            for _ in range(3):\n                a, b = sorted(random.sample(range(n), 2))\n                if distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]] < \\\n                   distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]:\n                    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 45,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    from math import sqrt\n\n    # Select a solution with high potential for improvement (lowest combined cost)\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_solution = archive[0][0].copy()\n\n    # Calculate the current costs for the selected solution\n    def calculate_cost(solution, distance_matrix):\n        cost = 0\n        for i in range(len(solution)):\n            cost += distance_matrix[solution[i-1], solution[i]]\n        return cost\n\n    current_cost1 = calculate_cost(selected_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(selected_solution, distance_matrix_2)\n    current_cost3 = calculate_cost(selected_solution, distance_matrix_3)\n\n    # Hybrid local search operator: combine 2-opt and edge swapping\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on the objective with the highest cost\n    if current_cost1 >= current_cost2 and current_cost1 >= current_cost3:\n        # 2-opt for the first objective\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    elif current_cost2 >= current_cost1 and current_cost2 >= current_cost3:\n        # Edge swapping for the second objective\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # 2-opt for the third objective\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly apply a second operator to explore more neighbors\n    if random.random() < 0.5:\n        # Apply 2-opt on a random segment\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Apply edge swapping on two random nodes\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7600910284625784,
            1.546786892414093
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    from math import sqrt\n\n    # Select a solution with high potential for improvement (lowest combined cost)\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_solution = archive[0][0].copy()\n\n    # Calculate the current costs for the selected solution\n    def calculate_cost(solution, distance_matrix):\n        cost = 0\n        for i in range(len(solution)):\n            cost += distance_matrix[solution[i-1], solution[i]]\n        return cost\n\n    current_cost1 = calculate_cost(selected_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(selected_solution, distance_matrix_2)\n    current_cost3 = calculate_cost(selected_solution, distance_matrix_3)\n\n    # Hybrid local search operator: combine 2-opt and edge swapping\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on the objective with the highest cost\n    if current_cost1 >= current_cost2 and current_cost1 >= current_cost3:\n        # 2-opt for the first objective\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    elif current_cost2 >= current_cost1 and current_cost2 >= current_cost3:\n        # Edge swapping for the second objective\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # 2-opt for the third objective\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly apply a second operator to explore more neighbors\n    if random.random() < 0.5:\n        # Apply 2-opt on a random segment\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Apply edge swapping on two random nodes\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 46,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (higher sum indicates potential)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select top 20% solutions\n        top_solutions = archive_sorted[:max(1, len(archive) // 5)]\n        # Randomly select one from top solutions\n        selected_solution = random.choice(top_solutions)[0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Multi-objective aware 2-opt with random objective selection\n    objective_to_optimize = random.choice([0, 1, 2])\n    if objective_to_optimize == 0:\n        # Optimize first objective space\n        if distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] < \\\n           distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    elif objective_to_optimize == 1:\n        # Optimize second objective space\n        if distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] < \\\n           distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Optimize third objective space\n        if distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] < \\\n           distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additional 2-opt with random selection to improve other objectives\n    i, j = sorted(random.sample(range(n), 2))\n    if random.random() < 0.5:  # Randomly decide to apply 2-opt\n        if distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] < \\\n           distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.5169301888420146,
            2.0846116662025453
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (higher sum indicates potential)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select top 20% solutions\n        top_solutions = archive_sorted[:max(1, len(archive) // 5)]\n        # Randomly select one from top solutions\n        selected_solution = random.choice(top_solutions)[0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Multi-objective aware 2-opt with random objective selection\n    objective_to_optimize = random.choice([0, 1, 2])\n    if objective_to_optimize == 0:\n        # Optimize first objective space\n        if distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] < \\\n           distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    elif objective_to_optimize == 1:\n        # Optimize second objective space\n        if distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] < \\\n           distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Optimize third objective space\n        if distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] < \\\n           distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additional 2-opt with random selection to improve other objectives\n    i, j = sorted(random.sample(range(n), 2))\n    if random.random() < 0.5:  # Randomly decide to apply 2-opt\n        if distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] < \\\n           distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 47,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solutions with the best objective values in each dimension\n    best_obj1 = min(archive, key=lambda x: x[1][0])[1][0]\n    best_obj2 = min(archive, key=lambda x: x[1][1])[1][1]\n    best_obj3 = min(archive, key=lambda x: x[1][2])[1][2]\n\n    # Filter solutions that are within 20% of the best in at least one dimension\n    candidates = []\n    for sol, obj in archive:\n        if (obj[0] <= best_obj1 * 1.2 or\n            obj[1] <= best_obj2 * 1.2 or\n            obj[2] <= best_obj3 * 1.2):\n            candidates.append(sol)\n\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n\n    # Select a random candidate solution\n    base_solution = random.choice(candidates).copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # 1. Randomly select two segments to swap (multi-segment inversion)\n    n = len(new_solution)\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Ensure segments are distinct\n    if a == c and b == d:\n        a, b = (a + 1) % n, (b + 1) % n\n\n    # Invert the first segment\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Invert the second segment\n    new_solution[c:d] = new_solution[c:d][::-1]\n\n    # 2. Apply a 2-opt move to improve the tour\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # 3. Apply a node swap based on the most critical objective\n    obj_values = [sum(obj) for _, obj in archive]\n    critical_obj = np.argmax(obj_values)\n\n    if critical_obj == 0:\n        # For the first objective, swap nodes that would reduce distance in space 1\n        for _ in range(5):\n            i, j = random.sample(range(n), 2)\n            original_dist = (distance_matrix_1[base_solution[i-1], base_solution[i]] +\n                            distance_matrix_1[base_solution[j-1], base_solution[j]])\n            new_dist = (distance_matrix_1[base_solution[i-1], base_solution[j]] +\n                        distance_matrix_1[base_solution[j-1], base_solution[i]])\n            if new_dist < original_dist:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                break\n    elif critical_obj == 1:\n        # For the second objective, swap nodes that would reduce distance in space 2\n        for _ in range(5):\n            i, j = random.sample(range(n), 2)\n            original_dist = (distance_matrix_2[base_solution[i-1], base_solution[i]] +\n                            distance_matrix_2[base_solution[j-1], base_solution[j]])\n            new_dist = (distance_matrix_2[base_solution[i-1], base_solution[j]] +\n                        distance_matrix_2[base_solution[j-1], base_solution[i]])\n            if new_dist < original_dist:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                break\n    else:\n        # For the third objective, swap nodes that would reduce distance in space 3\n        for _ in range(5):\n            i, j = random.sample(range(n), 2)\n            original_dist = (distance_matrix_3[base_solution[i-1], base_solution[i]] +\n                            distance_matrix_3[base_solution[j-1], base_solution[j]])\n            new_dist = (distance_matrix_3[base_solution[i-1], base_solution[j]] +\n                        distance_matrix_3[base_solution[j-1], base_solution[i]])\n            if new_dist < original_dist:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.8161535094351533,
            1.4021430492401123
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solutions with the best objective values in each dimension\n    best_obj1 = min(archive, key=lambda x: x[1][0])[1][0]\n    best_obj2 = min(archive, key=lambda x: x[1][1])[1][1]\n    best_obj3 = min(archive, key=lambda x: x[1][2])[1][2]\n\n    # Filter solutions that are within 20% of the best in at least one dimension\n    candidates = []\n    for sol, obj in archive:\n        if (obj[0] <= best_obj1 * 1.2 or\n            obj[1] <= best_obj2 * 1.2 or\n            obj[2] <= best_obj3 * 1.2):\n            candidates.append(sol)\n\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n\n    # Select a random candidate solution\n    base_solution = random.choice(candidates).copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # 1. Randomly select two segments to swap (multi-segment inversion)\n    n = len(new_solution)\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Ensure segments are distinct\n    if a == c and b == d:\n        a, b = (a + 1) % n, (b + 1) % n\n\n    # Invert the first segment\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Invert the second segment\n    new_solution[c:d] = new_solution[c:d][::-1]\n\n    # 2. Apply a 2-opt move to improve the tour\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # 3. Apply a node swap based on the most critical objective\n    obj_values = [sum(obj) for _, obj in archive]\n    critical_obj = np.argmax(obj_values)\n\n    if critical_obj == 0:\n        # For the first objective, swap nodes that would reduce distance in space 1\n        for _ in range(5):\n            i, j = random.sample(range(n), 2)\n            original_dist = (distance_matrix_1[base_solution[i-1], base_solution[i]] +\n                            distance_matrix_1[base_solution[j-1], base_solution[j]])\n            new_dist = (distance_matrix_1[base_solution[i-1], base_solution[j]] +\n                        distance_matrix_1[base_solution[j-1], base_solution[i]])\n            if new_dist < original_dist:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                break\n    elif critical_obj == 1:\n        # For the second objective, swap nodes that would reduce distance in space 2\n        for _ in range(5):\n            i, j = random.sample(range(n), 2)\n            original_dist = (distance_matrix_2[base_solution[i-1], base_solution[i]] +\n                            distance_matrix_2[base_solution[j-1], base_solution[j]])\n            new_dist = (distance_matrix_2[base_solution[i-1], base_solution[j]] +\n                        distance_matrix_2[base_solution[j-1], base_solution[i]])\n            if new_dist < original_dist:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                break\n    else:\n        # For the third objective, swap nodes that would reduce distance in space 3\n        for _ in range(5):\n            i, j = random.sample(range(n), 2)\n            original_dist = (distance_matrix_3[base_solution[i-1], base_solution[i]] +\n                            distance_matrix_3[base_solution[j-1], base_solution[j]])\n            new_dist = (distance_matrix_3[base_solution[i-1], base_solution[j]] +\n                        distance_matrix_3[base_solution[j-1], base_solution[i]])\n            if new_dist < original_dist:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 48,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective values)\n    weights = [sum(obj) for _, obj in archive]\n    total_weight = sum(weights)\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt and objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move (standard local search)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform an objective-aware swap\n    # Calculate the current total distance for each objective\n    def calculate_total_distance(sol, dist_matrix):\n        total = 0.0\n        for a, b in zip(sol, np.roll(sol, -1)):\n            total += dist_matrix[a, b]\n        return total\n\n    current_obj1 = calculate_total_distance(new_solution, distance_matrix_1)\n    current_obj2 = calculate_total_distance(new_solution, distance_matrix_2)\n    current_obj3 = calculate_total_distance(new_solution, distance_matrix_3)\n\n    # Find the worst objective and try to improve it\n    worst_obj = np.argmax([current_obj1, current_obj2, current_obj3])\n    if worst_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the best possible swap to improve the worst objective\n    best_improvement = 0\n    best_swap = None\n\n    for a in range(n):\n        for b in range(a+1, n):\n            # Calculate the change in distance for this swap\n            old_dist = (dist_matrix[new_solution[a-1], new_solution[a]] +\n                        dist_matrix[new_solution[b-1], new_solution[b]] +\n                        dist_matrix[new_solution[a], new_solution[(a+1)%n]] +\n                        dist_matrix[new_solution[b], new_solution[(b+1)%n]])\n\n            new_dist = (dist_matrix[new_solution[a-1], new_solution[b]] +\n                        dist_matrix[new_solution[b-1], new_solution[a]] +\n                        dist_matrix[new_solution[b], new_solution[(a+1)%n]] +\n                        dist_matrix[new_solution[a], new_solution[(b+1)%n]])\n\n            improvement = old_dist - new_dist\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_swap = (a, b)\n\n    if best_swap is not None:\n        a, b = best_swap\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8052485963338099,
            4.475822603702545
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective values)\n    weights = [sum(obj) for _, obj in archive]\n    total_weight = sum(weights)\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt and objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move (standard local search)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform an objective-aware swap\n    # Calculate the current total distance for each objective\n    def calculate_total_distance(sol, dist_matrix):\n        total = 0.0\n        for a, b in zip(sol, np.roll(sol, -1)):\n            total += dist_matrix[a, b]\n        return total\n\n    current_obj1 = calculate_total_distance(new_solution, distance_matrix_1)\n    current_obj2 = calculate_total_distance(new_solution, distance_matrix_2)\n    current_obj3 = calculate_total_distance(new_solution, distance_matrix_3)\n\n    # Find the worst objective and try to improve it\n    worst_obj = np.argmax([current_obj1, current_obj2, current_obj3])\n    if worst_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the best possible swap to improve the worst objective\n    best_improvement = 0\n    best_swap = None\n\n    for a in range(n):\n        for b in range(a+1, n):\n            # Calculate the change in distance for this swap\n            old_dist = (dist_matrix[new_solution[a-1], new_solution[a]] +\n                        dist_matrix[new_solution[b-1], new_solution[b]] +\n                        dist_matrix[new_solution[a], new_solution[(a+1)%n]] +\n                        dist_matrix[new_solution[b], new_solution[(b+1)%n]])\n\n            new_dist = (dist_matrix[new_solution[a-1], new_solution[b]] +\n                        dist_matrix[new_solution[b-1], new_solution[a]] +\n                        dist_matrix[new_solution[b], new_solution[(a+1)%n]] +\n                        dist_matrix[new_solution[a], new_solution[(b+1)%n]])\n\n            improvement = old_dist - new_dist\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_swap = (a, b)\n\n    if best_swap is not None:\n        a, b = best_swap\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 49,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best overall objective (sum of all objectives)\n    best_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search: apply 2-opt and swap operations based on objective dominance\n    new_solution = base_solution.copy()\n\n    # Apply 2-opt to the first objective space\n    i, j = np.random.choice(len(new_solution), 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply swap operation to the second objective space\n    k, l = np.random.choice(len(new_solution), 2, replace=False)\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Apply 3-opt to the third objective space (more complex operation)\n    a, b, c = np.random.choice(len(new_solution), 3, replace=False)\n    a, b, c = sorted([a, b, c])\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    new_solution[a:c] = np.concatenate([segment2, segment1])\n\n    return new_solution\n\n",
        "score": [
            -0.7344704326401887,
            1.4797068595886231
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best overall objective (sum of all objectives)\n    best_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search: apply 2-opt and swap operations based on objective dominance\n    new_solution = base_solution.copy()\n\n    # Apply 2-opt to the first objective space\n    i, j = np.random.choice(len(new_solution), 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply swap operation to the second objective space\n    k, l = np.random.choice(len(new_solution), 2, replace=False)\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Apply 3-opt to the third objective space (more complex operation)\n    a, b, c = np.random.choice(len(new_solution), 3, replace=False)\n    a, b, c = sorted([a, b, c])\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    new_solution[a:c] = np.concatenate([segment2, segment1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 50,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly biased towards better solutions)\n    weights = np.array([1.0 / (1 + obj[0] + obj[1] + obj[2]) for _, obj in archive])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Choose between 2-opt, 3-opt, or objective-aware swap\n        operator = random.choice(['2-opt', '3-opt', 'objective-aware'])\n\n        if operator == '2-opt':\n            # Perform 2-opt: reverse a random segment\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        elif operator == '3-opt':\n            # Perform 3-opt: reverse three segments\n            points = sorted(random.sample(range(n), 3))\n            a, b, c = points[0], points[1], points[2]\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n            new_solution[b:c+1] = new_solution[b:c+1][::-1]\n            new_solution[a:c+1] = new_solution[a:c+1][::-1]\n\n        else:  # objective-aware swap\n            # Find the worst edge in one of the objectives and swap it\n            def calculate_total_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n                cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n                cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n                return cost1, cost2, cost3\n\n            current_costs = calculate_total_cost(new_solution)\n\n            # Find the worst edge in any objective\n            worst_edge = None\n            worst_improvement = 0\n            worst_obj = 0\n\n            for obj_idx in range(3):\n                if obj_idx == 0:\n                    dm = distance_matrix_1\n                elif obj_idx == 1:\n                    dm = distance_matrix_2\n                else:\n                    dm = distance_matrix_3\n\n                for i in range(n-1):\n                    a, b = new_solution[i], new_solution[i+1]\n                    for j in range(i+2, n-1):\n                        c, d = new_solution[j], new_solution[j+1]\n\n                        # Calculate potential improvement\n                        old_cost = dm[a,b] + dm[c,d]\n                        new_cost = dm[a,c] + dm[b,d]\n                        improvement = old_cost - new_cost\n\n                        if improvement > worst_improvement:\n                            worst_improvement = improvement\n                            worst_edge = (i, j)\n                            worst_obj = obj_idx\n\n            if worst_edge is not None:\n                i, j = worst_edge\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7783496278335371,
            2.96717609167099
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly biased towards better solutions)\n    weights = np.array([1.0 / (1 + obj[0] + obj[1] + obj[2]) for _, obj in archive])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Choose between 2-opt, 3-opt, or objective-aware swap\n        operator = random.choice(['2-opt', '3-opt', 'objective-aware'])\n\n        if operator == '2-opt':\n            # Perform 2-opt: reverse a random segment\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        elif operator == '3-opt':\n            # Perform 3-opt: reverse three segments\n            points = sorted(random.sample(range(n), 3))\n            a, b, c = points[0], points[1], points[2]\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n            new_solution[b:c+1] = new_solution[b:c+1][::-1]\n            new_solution[a:c+1] = new_solution[a:c+1][::-1]\n\n        else:  # objective-aware swap\n            # Find the worst edge in one of the objectives and swap it\n            def calculate_total_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n                cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n                cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n                return cost1, cost2, cost3\n\n            current_costs = calculate_total_cost(new_solution)\n\n            # Find the worst edge in any objective\n            worst_edge = None\n            worst_improvement = 0\n            worst_obj = 0\n\n            for obj_idx in range(3):\n                if obj_idx == 0:\n                    dm = distance_matrix_1\n                elif obj_idx == 1:\n                    dm = distance_matrix_2\n                else:\n                    dm = distance_matrix_3\n\n                for i in range(n-1):\n                    a, b = new_solution[i], new_solution[i+1]\n                    for j in range(i+2, n-1):\n                        c, d = new_solution[j], new_solution[j+1]\n\n                        # Calculate potential improvement\n                        old_cost = dm[a,b] + dm[c,d]\n                        new_cost = dm[a,c] + dm[b,d]\n                        improvement = old_cost - new_cost\n\n                        if improvement > worst_improvement:\n                            worst_improvement = improvement\n                            worst_edge = (i, j)\n                            worst_obj = obj_idx\n\n            if worst_edge is not None:\n                i, j = worst_edge\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 51,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest objective values)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Rank solutions based on their objective values (lower is better)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    ranked_indices = np.argsort(objective_sums)\n    selected_index = ranked_indices[0]  # Select the best solution\n\n    base_solution = archive_solutions[selected_index].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt and edge insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Randomly choose between 2-opt and edge insertion\n    if random.random() < 0.5:\n        # 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Edge insertion move\n        i = random.randint(1, n-2)\n        j = random.randint(1, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            -0.5429544616978139,
            1.8905466794967651
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest objective values)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Rank solutions based on their objective values (lower is better)\n    objective_sums = [sum(obj) for obj in archive_objectives]\n    ranked_indices = np.argsort(objective_sums)\n    selected_index = ranked_indices[0]  # Select the best solution\n\n    base_solution = archive_solutions[selected_index].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt and edge insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Randomly choose between 2-opt and edge insertion\n    if random.random() < 0.5:\n        # 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Edge insertion move\n        i = random.randint(1, n-2)\n        j = random.randint(1, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 52,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest objective values)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    crowding_distance = np.mean(normalized_objectives, axis=1)\n    selected_idx = np.argmax(crowding_distance)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # Hybrid local search strategy\n    if random.random() < 0.5:\n        # 2-opt with objective-weighted edge selection\n        i, j = sorted(random.sample(range(n_nodes), 2))\n        # Calculate edge weights considering all three objectives\n        edge_weights = (\n            distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_2[new_solution[i-1], new_solution[j]] +\n            distance_matrix_3[new_solution[i-1], new_solution[j]]\n        ) - (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j-1], new_solution[j]] +\n            distance_matrix_2[new_solution[j-1], new_solution[j]] +\n            distance_matrix_3[new_solution[j-1], new_solution[j]]\n        )\n        if edge_weights < 0:  # Only perform if it improves the solution\n            new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # 3-opt with objective-aware edge selection\n        i, j, k = sorted(random.sample(range(n_nodes), 3))\n        # Calculate different 3-opt configurations and select the best\n        configs = [\n            (new_solution[i:j], new_solution[j:k], new_solution[k:]),\n            (new_solution[i:j][::-1], new_solution[j:k], new_solution[k:]),\n            (new_solution[i:j], new_solution[j:k][::-1], new_solution[k:]),\n            (new_solution[i:j], new_solution[j:k], new_solution[k:][::-1]),\n            (new_solution[i:j][::-1], new_solution[j:k][::-1], new_solution[k:]),\n            (new_solution[i:j], new_solution[j:k][::-1], new_solution[k:][::-1]),\n            (new_solution[i:j][::-1], new_solution[j:k], new_solution[k:][::-1])\n        ]\n\n        best_config = None\n        best_improvement = 0\n\n        for config in configs:\n            # Calculate total improvement across all objectives\n            improvement = 0\n            # Original edges\n            orig_edges = [\n                (new_solution[i-1], new_solution[i]),\n                (new_solution[j-1], new_solution[j]),\n                (new_solution[k-1], new_solution[k])\n            ]\n            # New edges in the configuration\n            new_edges = [\n                (new_solution[i-1], config[0][0]),\n                (config[0][-1], new_solution[j]),\n                (new_solution[j-1], config[1][0]),\n                (config[1][-1], new_solution[k]),\n                (new_solution[k-1], config[2][0]),\n                (config[2][-1], new_solution[(i+1)%n_nodes])\n            ]\n\n            # Calculate improvement for each objective\n            for dm in [distance_matrix_1, distance_matrix_2, distance_matrix_3]:\n                orig_cost = sum(dm[a, b] for a, b in orig_edges)\n                new_cost = sum(dm[a, b] for a, b in new_edges)\n                improvement += (orig_cost - new_cost)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_config = config\n\n        if best_config is not None:\n            new_solution[i:j], new_solution[j:k], new_solution[k:] = best_config\n\n    return new_solution\n\n",
        "score": [
            -0.6218958392743226,
            1.6159354329109192
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest objective values)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    crowding_distance = np.mean(normalized_objectives, axis=1)\n    selected_idx = np.argmax(crowding_distance)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # Hybrid local search strategy\n    if random.random() < 0.5:\n        # 2-opt with objective-weighted edge selection\n        i, j = sorted(random.sample(range(n_nodes), 2))\n        # Calculate edge weights considering all three objectives\n        edge_weights = (\n            distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_2[new_solution[i-1], new_solution[j]] +\n            distance_matrix_3[new_solution[i-1], new_solution[j]]\n        ) - (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j-1], new_solution[j]] +\n            distance_matrix_2[new_solution[j-1], new_solution[j]] +\n            distance_matrix_3[new_solution[j-1], new_solution[j]]\n        )\n        if edge_weights < 0:  # Only perform if it improves the solution\n            new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # 3-opt with objective-aware edge selection\n        i, j, k = sorted(random.sample(range(n_nodes), 3))\n        # Calculate different 3-opt configurations and select the best\n        configs = [\n            (new_solution[i:j], new_solution[j:k], new_solution[k:]),\n            (new_solution[i:j][::-1], new_solution[j:k], new_solution[k:]),\n            (new_solution[i:j], new_solution[j:k][::-1], new_solution[k:]),\n            (new_solution[i:j], new_solution[j:k], new_solution[k:][::-1]),\n            (new_solution[i:j][::-1], new_solution[j:k][::-1], new_solution[k:]),\n            (new_solution[i:j], new_solution[j:k][::-1], new_solution[k:][::-1]),\n            (new_solution[i:j][::-1], new_solution[j:k], new_solution[k:][::-1])\n        ]\n\n        best_config = None\n        best_improvement = 0\n\n        for config in configs:\n            # Calculate total improvement across all objectives\n            improvement = 0\n            # Original edges\n            orig_edges = [\n                (new_solution[i-1], new_solution[i]),\n                (new_solution[j-1], new_solution[j]),\n                (new_solution[k-1], new_solution[k])\n            ]\n            # New edges in the configuration\n            new_edges = [\n                (new_solution[i-1], config[0][0]),\n                (config[0][-1], new_solution[j]),\n                (new_solution[j-1], config[1][0]),\n                (config[1][-1], new_solution[k]),\n                (new_solution[k-1], config[2][0]),\n                (config[2][-1], new_solution[(i+1)%n_nodes])\n            ]\n\n            # Calculate improvement for each objective\n            for dm in [distance_matrix_1, distance_matrix_2, distance_matrix_3]:\n                orig_cost = sum(dm[a, b] for a, b in orig_edges)\n                new_cost = sum(dm[a, b] for a, b in new_edges)\n                improvement += (orig_cost - new_cost)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_config = config\n\n        if best_config is not None:\n            new_solution[i:j], new_solution[j:k], new_solution[k:] = best_config\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 53,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search: combine 2-opt with a multi-objective aware perturbation\n    new_solution = selected_solution.copy()\n\n    # Perform 2-opt for one objective (randomly chosen)\n    objective = random.randint(0, 2)\n    if objective == 0:\n        distance_matrix = distance_matrix_1\n    elif objective == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Apply 2-opt to the selected objective\n    n = len(new_solution)\n    for _ in range(10):  # Limit the number of attempts to avoid excessive computation\n        i, j = sorted(random.sample(range(n), 2))\n        if i == j:\n            continue\n\n        # Calculate the change in distance\n        old_distance = (distance_matrix[new_solution[i-1], new_solution[i]] +\n                        distance_matrix[new_solution[j-1], new_solution[j]])\n        new_distance = (distance_matrix[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix[new_solution[i], new_solution[j]])\n\n        if new_distance < old_distance:\n            # Reverse the segment between i and j\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Multi-objective aware perturbation: swap two nodes based on their contribution to all objectives\n    if random.random() < 0.3:  # 30% chance for perturbation\n        i, j = random.sample(range(n), 2)\n        if i == j:\n            return new_solution\n\n        # Calculate the change in all three objectives\n        old_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_1[new_solution[j-1], new_solution[j]])\n        new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                    distance_matrix_1[new_solution[i], new_solution[j]])\n\n        old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_2[new_solution[j-1], new_solution[j]])\n        new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                     distance_matrix_2[new_solution[i], new_solution[j]])\n\n        old_cost3 = (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_3[new_solution[j-1], new_solution[j]])\n        new_cost3 = (distance_matrix_3[new_solution[i-1], new_solution[j-1]] +\n                     distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Accept the swap if it improves at least one objective\n        if (new_cost < old_cost) or (new_cost2 < old_cost2) or (new_cost3 < old_cost3):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8806160429663905,
            1.6241708397865295
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search: combine 2-opt with a multi-objective aware perturbation\n    new_solution = selected_solution.copy()\n\n    # Perform 2-opt for one objective (randomly chosen)\n    objective = random.randint(0, 2)\n    if objective == 0:\n        distance_matrix = distance_matrix_1\n    elif objective == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Apply 2-opt to the selected objective\n    n = len(new_solution)\n    for _ in range(10):  # Limit the number of attempts to avoid excessive computation\n        i, j = sorted(random.sample(range(n), 2))\n        if i == j:\n            continue\n\n        # Calculate the change in distance\n        old_distance = (distance_matrix[new_solution[i-1], new_solution[i]] +\n                        distance_matrix[new_solution[j-1], new_solution[j]])\n        new_distance = (distance_matrix[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix[new_solution[i], new_solution[j]])\n\n        if new_distance < old_distance:\n            # Reverse the segment between i and j\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Multi-objective aware perturbation: swap two nodes based on their contribution to all objectives\n    if random.random() < 0.3:  # 30% chance for perturbation\n        i, j = random.sample(range(n), 2)\n        if i == j:\n            return new_solution\n\n        # Calculate the change in all three objectives\n        old_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_1[new_solution[j-1], new_solution[j]])\n        new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                    distance_matrix_1[new_solution[i], new_solution[j]])\n\n        old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_2[new_solution[j-1], new_solution[j]])\n        new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                     distance_matrix_2[new_solution[i], new_solution[j]])\n\n        old_cost3 = (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_3[new_solution[j-1], new_solution[j]])\n        new_cost3 = (distance_matrix_3[new_solution[i-1], new_solution[j-1]] +\n                     distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Accept the swap if it improves at least one objective\n        if (new_cost < old_cost) or (new_cost2 < old_cost2) or (new_cost3 < old_cost3):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 53,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search: combine 2-opt with a multi-objective aware perturbation\n    new_solution = selected_solution.copy()\n\n    # Perform 2-opt for one objective (randomly chosen)\n    objective = random.randint(0, 2)\n    if objective == 0:\n        distance_matrix = distance_matrix_1\n    elif objective == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Apply 2-opt to the selected objective\n    n = len(new_solution)\n    for _ in range(10):  # Limit the number of attempts to avoid excessive computation\n        i, j = sorted(random.sample(range(n), 2))\n        if i == j:\n            continue\n\n        # Calculate the change in distance\n        old_distance = (distance_matrix[new_solution[i-1], new_solution[i]] +\n                        distance_matrix[new_solution[j-1], new_solution[j]])\n        new_distance = (distance_matrix[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix[new_solution[i], new_solution[j]])\n\n        if new_distance < old_distance:\n            # Reverse the segment between i and j\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Multi-objective aware perturbation: swap two nodes based on their contribution to all objectives\n    if random.random() < 0.3:  # 30% chance for perturbation\n        i, j = random.sample(range(n), 2)\n        if i == j:\n            return new_solution\n\n        # Calculate the change in all three objectives\n        old_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_1[new_solution[j-1], new_solution[j]])\n        new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                    distance_matrix_1[new_solution[i], new_solution[j]])\n\n        old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_2[new_solution[j-1], new_solution[j]])\n        new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                     distance_matrix_2[new_solution[i], new_solution[j]])\n\n        old_cost3 = (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_3[new_solution[j-1], new_solution[j]])\n        new_cost3 = (distance_matrix_3[new_solution[i-1], new_solution[j-1]] +\n                     distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Accept the swap if it improves at least one objective\n        if (new_cost < old_cost) or (new_cost2 < old_cost2) or (new_cost3 < old_cost3):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8806160429663905,
            1.6241708397865295
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search: combine 2-opt with a multi-objective aware perturbation\n    new_solution = selected_solution.copy()\n\n    # Perform 2-opt for one objective (randomly chosen)\n    objective = random.randint(0, 2)\n    if objective == 0:\n        distance_matrix = distance_matrix_1\n    elif objective == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Apply 2-opt to the selected objective\n    n = len(new_solution)\n    for _ in range(10):  # Limit the number of attempts to avoid excessive computation\n        i, j = sorted(random.sample(range(n), 2))\n        if i == j:\n            continue\n\n        # Calculate the change in distance\n        old_distance = (distance_matrix[new_solution[i-1], new_solution[i]] +\n                        distance_matrix[new_solution[j-1], new_solution[j]])\n        new_distance = (distance_matrix[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix[new_solution[i], new_solution[j]])\n\n        if new_distance < old_distance:\n            # Reverse the segment between i and j\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Multi-objective aware perturbation: swap two nodes based on their contribution to all objectives\n    if random.random() < 0.3:  # 30% chance for perturbation\n        i, j = random.sample(range(n), 2)\n        if i == j:\n            return new_solution\n\n        # Calculate the change in all three objectives\n        old_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_1[new_solution[j-1], new_solution[j]])\n        new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                    distance_matrix_1[new_solution[i], new_solution[j]])\n\n        old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_2[new_solution[j-1], new_solution[j]])\n        new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                     distance_matrix_2[new_solution[i], new_solution[j]])\n\n        old_cost3 = (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_3[new_solution[j-1], new_solution[j]])\n        new_cost3 = (distance_matrix_3[new_solution[i-1], new_solution[j-1]] +\n                     distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Accept the swap if it improves at least one objective\n        if (new_cost < old_cost) or (new_cost2 < old_cost2) or (new_cost3 < old_cost3):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 54,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already in local optima)\n    # Here, we select the solution with the highest sum of objectives (worst solution) for more exploration\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments to exchange\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Perform a 2-opt swap between the selected segments\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Further refine with edge exchange based on all three objectives\n    for _ in range(3):  # Perform a few iterations of refinement\n        # Select a random edge to consider for exchange\n        k = np.random.randint(0, n)\n        l = (k + 1) % n\n\n        # Calculate the current and potential new costs for all three objectives\n        current_cost = (\n            distance_matrix_1[new_solution[k], new_solution[l]] +\n            distance_matrix_2[new_solution[k], new_solution[l]] +\n            distance_matrix_3[new_solution[k], new_solution[l]]\n        )\n\n        # Try to find a better edge to replace (k, l)\n        for m in range(n):\n            if m == k or m == l or (m + 1) % n == k or (m + 1) % n == l:\n                continue\n\n            new_cost = (\n                distance_matrix_1[new_solution[k], new_solution[m]] +\n                distance_matrix_1[new_solution[l], new_solution[(m + 1) % n]] +\n                distance_matrix_2[new_solution[k], new_solution[m]] +\n                distance_matrix_2[new_solution[l], new_solution[(m + 1) % n]] +\n                distance_matrix_3[new_solution[k], new_solution[m]] +\n                distance_matrix_3[new_solution[l], new_solution[(m + 1) % n]]\n            )\n\n            if new_cost < current_cost:\n                # Perform the exchange\n                new_solution[k], new_solution[(m + 1) % n] = new_solution[(m + 1) % n], new_solution[k]\n                break  # Only perform one exchange per iteration\n\n    return new_solution\n\n",
        "score": [
            -0.5969985656667635,
            2.189572536945343
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already in local optima)\n    # Here, we select the solution with the highest sum of objectives (worst solution) for more exploration\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments to exchange\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Perform a 2-opt swap between the selected segments\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Further refine with edge exchange based on all three objectives\n    for _ in range(3):  # Perform a few iterations of refinement\n        # Select a random edge to consider for exchange\n        k = np.random.randint(0, n)\n        l = (k + 1) % n\n\n        # Calculate the current and potential new costs for all three objectives\n        current_cost = (\n            distance_matrix_1[new_solution[k], new_solution[l]] +\n            distance_matrix_2[new_solution[k], new_solution[l]] +\n            distance_matrix_3[new_solution[k], new_solution[l]]\n        )\n\n        # Try to find a better edge to replace (k, l)\n        for m in range(n):\n            if m == k or m == l or (m + 1) % n == k or (m + 1) % n == l:\n                continue\n\n            new_cost = (\n                distance_matrix_1[new_solution[k], new_solution[m]] +\n                distance_matrix_1[new_solution[l], new_solution[(m + 1) % n]] +\n                distance_matrix_2[new_solution[k], new_solution[m]] +\n                distance_matrix_2[new_solution[l], new_solution[(m + 1) % n]] +\n                distance_matrix_3[new_solution[k], new_solution[m]] +\n                distance_matrix_3[new_solution[l], new_solution[(m + 1) % n]]\n            )\n\n            if new_cost < current_cost:\n                # Perform the exchange\n                new_solution[k], new_solution[(m + 1) % n] = new_solution[(m + 1) % n], new_solution[k]\n                break  # Only perform one exchange per iteration\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 55,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or low objective values\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange with multi-objective perturbation\n    n = len(new_solution)\n    a, b = np.random.choice(n, 2, replace=False)\n    i, j = sorted([a, b])\n\n    # Edge exchange (2-opt)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective aware perturbation\n    if np.random.rand() < 0.3:  # 30% chance for perturbation\n        # Select a segment based on the worst objective\n        objectives = [obj for _, obj in archive]\n        worst_obj = np.argmax(np.sum(objectives, axis=0))  # Objective with highest total cost\n\n        # Perturb the segment based on the worst objective\n        if worst_obj == 0:\n            # Perturb based on distance_matrix_1\n            segment = new_solution[i:j+1]\n            segment_costs = np.array([distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment))])\n            worst_segment = np.argmax(segment_costs)\n            # Reverse the worst segment\n            new_solution[i+worst_segment:i+worst_segment+2] = new_solution[i+worst_segment:i+worst_segment+2][::-1]\n        elif worst_obj == 1:\n            # Perturb based on distance_matrix_2\n            segment = new_solution[i:j+1]\n            segment_costs = np.array([distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment))])\n            worst_segment = np.argmax(segment_costs)\n            # Reverse the worst segment\n            new_solution[i+worst_segment:i+worst_segment+2] = new_solution[i+worst_segment:i+worst_segment+2][::-1]\n        else:\n            # Perturb based on distance_matrix_3\n            segment = new_solution[i:j+1]\n            segment_costs = np.array([distance_matrix_3[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment))])\n            worst_segment = np.argmax(segment_costs)\n            # Reverse the worst segment\n            new_solution[i+worst_segment:i+worst_segment+2] = new_solution[i+worst_segment:i+worst_segment+2][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7416960258151919,
            1.4185718655586244
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or low objective values\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange with multi-objective perturbation\n    n = len(new_solution)\n    a, b = np.random.choice(n, 2, replace=False)\n    i, j = sorted([a, b])\n\n    # Edge exchange (2-opt)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective aware perturbation\n    if np.random.rand() < 0.3:  # 30% chance for perturbation\n        # Select a segment based on the worst objective\n        objectives = [obj for _, obj in archive]\n        worst_obj = np.argmax(np.sum(objectives, axis=0))  # Objective with highest total cost\n\n        # Perturb the segment based on the worst objective\n        if worst_obj == 0:\n            # Perturb based on distance_matrix_1\n            segment = new_solution[i:j+1]\n            segment_costs = np.array([distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment))])\n            worst_segment = np.argmax(segment_costs)\n            # Reverse the worst segment\n            new_solution[i+worst_segment:i+worst_segment+2] = new_solution[i+worst_segment:i+worst_segment+2][::-1]\n        elif worst_obj == 1:\n            # Perturb based on distance_matrix_2\n            segment = new_solution[i:j+1]\n            segment_costs = np.array([distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment))])\n            worst_segment = np.argmax(segment_costs)\n            # Reverse the worst segment\n            new_solution[i+worst_segment:i+worst_segment+2] = new_solution[i+worst_segment:i+worst_segment+2][::-1]\n        else:\n            # Perturb based on distance_matrix_3\n            segment = new_solution[i:j+1]\n            segment_costs = np.array([distance_matrix_3[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment))])\n            worst_segment = np.argmax(segment_costs)\n            # Reverse the worst segment\n            new_solution[i+worst_segment:i+worst_segment+2] = new_solution[i+worst_segment:i+worst_segment+2][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 56,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    weights = []\n    for sol, obj in archive:\n        # Calculate the \"potential\" as the sum of the inverse of the objectives (higher objective = less potential)\n        potential = sum(1.0 / (val + 1e-6) for val in obj)\n        weights.append(potential)\n\n    # Normalize weights to form a probability distribution\n    total_weight = sum(weights)\n    if total_weight == 0:\n        # If all weights are zero, select uniformly\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        normalized_weights = [w / total_weight for w in weights]\n        selected_idx = np.random.choice(len(archive), p=normalized_weights)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    if n < 4:\n        # For very small tours, just swap two random edges\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select two edges to swap based on their contribution to the objectives\n        # Calculate the \"edge importance\" as the sum of the distances in all three objectives\n        edge_importance = []\n        for i in range(n):\n            u, v = new_solution[i], new_solution[(i + 1) % n]\n            importance = (distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v])\n            edge_importance.append(importance)\n\n        # Select edges with probability inversely proportional to their importance\n        edge_probs = [1.0 / (imp + 1e-6) for imp in edge_importance]\n        total_prob = sum(edge_probs)\n        edge_probs = [p / total_prob for p in edge_probs]\n\n        # Select two distinct edges to swap\n        i, j = np.random.choice(n, size=2, replace=False, p=edge_probs)\n\n        # Perform 2-opt swap\n        if i > j:\n            i, j = j, i\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7175117976373746,
            2.3071290612220765
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    weights = []\n    for sol, obj in archive:\n        # Calculate the \"potential\" as the sum of the inverse of the objectives (higher objective = less potential)\n        potential = sum(1.0 / (val + 1e-6) for val in obj)\n        weights.append(potential)\n\n    # Normalize weights to form a probability distribution\n    total_weight = sum(weights)\n    if total_weight == 0:\n        # If all weights are zero, select uniformly\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        normalized_weights = [w / total_weight for w in weights]\n        selected_idx = np.random.choice(len(archive), p=normalized_weights)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    if n < 4:\n        # For very small tours, just swap two random edges\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select two edges to swap based on their contribution to the objectives\n        # Calculate the \"edge importance\" as the sum of the distances in all three objectives\n        edge_importance = []\n        for i in range(n):\n            u, v = new_solution[i], new_solution[(i + 1) % n]\n            importance = (distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v])\n            edge_importance.append(importance)\n\n        # Select edges with probability inversely proportional to their importance\n        edge_probs = [1.0 / (imp + 1e-6) for imp in edge_importance]\n        total_prob = sum(edge_probs)\n        edge_probs = [p / total_prob for p in edge_probs]\n\n        # Select two distinct edges to swap\n        i, j = np.random.choice(n, size=2, replace=False, p=edge_probs)\n\n        # Perform 2-opt swap\n        if i > j:\n            i, j = j, i\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 57,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must contain at least one solution.\")\n\n    # Select a solution with high potential for improvement (lowest sum of objectives)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    candidates = archive_sorted[:max(1, len(archive) // 2)]  # Top 50% candidates\n\n    # Randomly select a candidate from the promising ones\n    selected = candidates[np.random.randint(0, len(candidates))]\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small tours\n\n    # Step 1: Perform 2-opt move (standard local search)\n    i, j = sorted(np.random.choice(range(1, n), 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Objective-aware edge swap\n    # Select two edges with high potential for improvement across objectives\n    def calculate_improvement(solution, i, j, k, l):\n        # Calculate change in objectives for swapping edges (i,j) and (k,l)\n        delta1 = (distance_matrix_1[solution[i], solution[l]] + distance_matrix_1[solution[j], solution[k]] -\n                  distance_matrix_1[solution[i], solution[j]] - distance_matrix_1[solution[k], solution[l]])\n        delta2 = (distance_matrix_2[solution[i], solution[l]] + distance_matrix_2[solution[j], solution[k]] -\n                  distance_matrix_2[solution[i], solution[j]] - distance_matrix_2[solution[k], solution[l]])\n        delta3 = (distance_matrix_3[solution[i], solution[l]] + distance_matrix_3[solution[j], solution[k]] -\n                  distance_matrix_3[solution[i], solution[j]] - distance_matrix_3[solution[k], solution[l]])\n        return delta1 + delta2 + delta3\n\n    # Find the best edge swap among random candidates\n    best_improvement = 0\n    best_swap = None\n    for _ in range(10):  # Try 10 random swaps\n        i, j = sorted(np.random.choice(range(1, n), 2, replace=False))\n        k, l = sorted(np.random.choice(range(1, n), 2, replace=False))\n        improvement = calculate_improvement(new_solution, i, j, k, l)\n        if improvement < best_improvement:\n            best_improvement = improvement\n            best_swap = (i, j, k, l)\n\n    if best_swap is not None:\n        i, j, k, l = best_swap\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n        new_solution[j], new_solution[l] = new_solution[l], new_solution[j]\n\n    # Step 3: Randomly reverse a segment to escape local optima\n    if np.random.random() < 0.3:  # 30% chance\n        i, j = sorted(np.random.choice(range(1, n), 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7175910297745731,
            2.6720773577690125
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must contain at least one solution.\")\n\n    # Select a solution with high potential for improvement (lowest sum of objectives)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    candidates = archive_sorted[:max(1, len(archive) // 2)]  # Top 50% candidates\n\n    # Randomly select a candidate from the promising ones\n    selected = candidates[np.random.randint(0, len(candidates))]\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small tours\n\n    # Step 1: Perform 2-opt move (standard local search)\n    i, j = sorted(np.random.choice(range(1, n), 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Objective-aware edge swap\n    # Select two edges with high potential for improvement across objectives\n    def calculate_improvement(solution, i, j, k, l):\n        # Calculate change in objectives for swapping edges (i,j) and (k,l)\n        delta1 = (distance_matrix_1[solution[i], solution[l]] + distance_matrix_1[solution[j], solution[k]] -\n                  distance_matrix_1[solution[i], solution[j]] - distance_matrix_1[solution[k], solution[l]])\n        delta2 = (distance_matrix_2[solution[i], solution[l]] + distance_matrix_2[solution[j], solution[k]] -\n                  distance_matrix_2[solution[i], solution[j]] - distance_matrix_2[solution[k], solution[l]])\n        delta3 = (distance_matrix_3[solution[i], solution[l]] + distance_matrix_3[solution[j], solution[k]] -\n                  distance_matrix_3[solution[i], solution[j]] - distance_matrix_3[solution[k], solution[l]])\n        return delta1 + delta2 + delta3\n\n    # Find the best edge swap among random candidates\n    best_improvement = 0\n    best_swap = None\n    for _ in range(10):  # Try 10 random swaps\n        i, j = sorted(np.random.choice(range(1, n), 2, replace=False))\n        k, l = sorted(np.random.choice(range(1, n), 2, replace=False))\n        improvement = calculate_improvement(new_solution, i, j, k, l)\n        if improvement < best_improvement:\n            best_improvement = improvement\n            best_swap = (i, j, k, l)\n\n    if best_swap is not None:\n        i, j, k, l = best_swap\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n        new_solution[j], new_solution[l] = new_solution[l], new_solution[j]\n\n    # Step 3: Randomly reverse a segment to escape local optima\n    if np.random.random() < 0.3:  # 30% chance\n        i, j = sorted(np.random.choice(range(1, n), 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 58,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (descending) to prioritize those with higher potential\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select top 20% of solutions for random selection\n        top_percentile = max(1, int(0.2 * len(archive_sorted)))\n        selected_idx = random.randint(0, top_percentile - 1)\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Apply a 3-opt move (improves tour structure across all objectives)\n    # 2. Apply a random swap (diversification)\n    # 3. Apply a greedy insertion (improvement in one objective)\n\n    # 3-opt move\n    n = len(new_solution)\n    if n >= 4:\n        a, b, c = sorted(random.sample(range(n), 3))\n        # Reverse segments to create a 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Random swap\n    if n >= 2:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Greedy insertion (improve one objective)\n    if n >= 3:\n        # Choose an objective to improve (randomly)\n        obj_choice = random.choice([0, 1, 2])\n        if obj_choice == 0:\n            distance_matrix = distance_matrix_1\n        elif obj_choice == 1:\n            distance_matrix = distance_matrix_2\n        else:\n            distance_matrix = distance_matrix_3\n\n        # Find the best insertion point for a random node\n        node_to_move = random.choice(new_solution)\n        current_pos = np.where(new_solution == node_to_move)[0][0]\n        new_solution = np.delete(new_solution, current_pos)\n\n        best_pos = 0\n        best_cost = float('inf')\n        for i in range(n - 1):\n            # Insert node_to_move between new_solution[i] and new_solution[i+1]\n            temp_solution = np.insert(new_solution, i, node_to_move)\n            cost = sum(distance_matrix[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix[temp_solution[-1], temp_solution[0]]\n            if cost < best_cost:\n                best_cost = cost\n                best_pos = i\n\n        new_solution = np.insert(new_solution, best_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.7246597971145816,
            2.6458580255508424
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (descending) to prioritize those with higher potential\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select top 20% of solutions for random selection\n        top_percentile = max(1, int(0.2 * len(archive_sorted)))\n        selected_idx = random.randint(0, top_percentile - 1)\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Apply a 3-opt move (improves tour structure across all objectives)\n    # 2. Apply a random swap (diversification)\n    # 3. Apply a greedy insertion (improvement in one objective)\n\n    # 3-opt move\n    n = len(new_solution)\n    if n >= 4:\n        a, b, c = sorted(random.sample(range(n), 3))\n        # Reverse segments to create a 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Random swap\n    if n >= 2:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Greedy insertion (improve one objective)\n    if n >= 3:\n        # Choose an objective to improve (randomly)\n        obj_choice = random.choice([0, 1, 2])\n        if obj_choice == 0:\n            distance_matrix = distance_matrix_1\n        elif obj_choice == 1:\n            distance_matrix = distance_matrix_2\n        else:\n            distance_matrix = distance_matrix_3\n\n        # Find the best insertion point for a random node\n        node_to_move = random.choice(new_solution)\n        current_pos = np.where(new_solution == node_to_move)[0][0]\n        new_solution = np.delete(new_solution, current_pos)\n\n        best_pos = 0\n        best_cost = float('inf')\n        for i in range(n - 1):\n            # Insert node_to_move between new_solution[i] and new_solution[i+1]\n            temp_solution = np.insert(new_solution, i, node_to_move)\n            cost = sum(distance_matrix[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix[temp_solution[-1], temp_solution[0]]\n            if cost < best_cost:\n                best_cost = cost\n                best_pos = i\n\n        new_solution = np.insert(new_solution, best_pos, node_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 59,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distances for all solutions in the archive\n        crowding_distances = []\n        objectives = [obj for (sol, obj) in archive]\n\n        for m in range(3):  # For each objective\n            sorted_indices = np.argsort([obj[m] for obj in objectives])\n            min_obj, max_obj = objectives[sorted_indices[0]][m], objectives[sorted_indices[-1]][m]\n            crowding = np.zeros(len(objectives))\n            crowding[sorted_indices[0]] = np.inf\n            crowding[sorted_indices[-1]] = np.inf\n\n            for i in range(1, len(objectives)-1):\n                crowding[i] = (objectives[sorted_indices[i+1]][m] - objectives[sorted_indices[i-1]][m]) / (max_obj - min_obj)\n\n            # Combine crowding distances across objectives\n            if m == 0:\n                combined_crowding = crowding\n            else:\n                combined_crowding += crowding\n\n        # Select the solution with highest combined crowding distance\n        selected_index = np.argmax(combined_crowding)\n    else:\n        selected_index = 0\n\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of 2-opt and edge exchange\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # 2-opt move\n    if j - i > 1:\n        new_solution[i+1:j] = new_solution[i+1:j][::-1]\n\n    # Edge exchange move\n    if random.random() < 0.5 and j - i > 2:\n        k = random.randint(i+1, j-2)\n        new_solution[k], new_solution[k+1] = new_solution[k+1], new_solution[k]\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5797571933115744,
            2.3224406003952027
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distances for all solutions in the archive\n        crowding_distances = []\n        objectives = [obj for (sol, obj) in archive]\n\n        for m in range(3):  # For each objective\n            sorted_indices = np.argsort([obj[m] for obj in objectives])\n            min_obj, max_obj = objectives[sorted_indices[0]][m], objectives[sorted_indices[-1]][m]\n            crowding = np.zeros(len(objectives))\n            crowding[sorted_indices[0]] = np.inf\n            crowding[sorted_indices[-1]] = np.inf\n\n            for i in range(1, len(objectives)-1):\n                crowding[i] = (objectives[sorted_indices[i+1]][m] - objectives[sorted_indices[i-1]][m]) / (max_obj - min_obj)\n\n            # Combine crowding distances across objectives\n            if m == 0:\n                combined_crowding = crowding\n            else:\n                combined_crowding += crowding\n\n        # Select the solution with highest combined crowding distance\n        selected_index = np.argmax(combined_crowding)\n    else:\n        selected_index = 0\n\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of 2-opt and edge exchange\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # 2-opt move\n    if j - i > 1:\n        new_solution[i+1:j] = new_solution[i+1:j][::-1]\n\n    # Edge exchange move\n    if random.random() < 0.5 and j - i > 2:\n        k = random.randint(i+1, j-2)\n        new_solution[k], new_solution[k+1] = new_solution[k+1], new_solution[k]\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 60,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        # Calculate the variance of objectives for each solution\n        variance = np.var(objectives, axis=1)\n        # Select the solution with the highest variance\n        selected_idx = np.argmax(variance)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of 2-opt and edge exchange\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    k, l = np.random.choice(n, 2, replace=False)\n\n    # Ensure i < j and k < l\n    i, j = min(i, j), max(i, j)\n    k, l = min(k, l), max(k, l)\n\n    # Apply 2-opt between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply edge exchange between k and l\n    if k < l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or np.any(counts != 1):\n        # If invalid, revert to a simple 2-opt\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        i, j = min(i, j), max(i, j)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.529391786938121,
            1.5546071767807006
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        # Calculate the variance of objectives for each solution\n        variance = np.var(objectives, axis=1)\n        # Select the solution with the highest variance\n        selected_idx = np.argmax(variance)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of 2-opt and edge exchange\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    k, l = np.random.choice(n, 2, replace=False)\n\n    # Ensure i < j and k < l\n    i, j = min(i, j), max(i, j)\n    k, l = min(k, l), max(k, l)\n\n    # Apply 2-opt between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply edge exchange between k and l\n    if k < l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or np.any(counts != 1):\n        # If invalid, revert to a simple 2-opt\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        i, j = min(i, j), max(i, j)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 61,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by a combined objective score (sum of normalized objectives)\n        objectives = np.array([obj for _, obj in archive])\n        normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-6)\n        combined_scores = normalized_objectives.sum(axis=1)\n        # Select the solution with the highest combined score (most potential for improvement)\n        selected_idx = np.argmax(combined_scores)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a multi-objective aware swap\n    n = len(new_solution)\n    if n < 2:\n        return new_solution\n\n    # Randomly choose a segment to modify\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt (swap edges)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective aware swap: swap nodes that are most critical in at least one objective\n    if j - i > 1:\n        # Calculate the improvement potential for each node in the segment\n        improvements = []\n        for k in range(i, j+1):\n            original_cost = (distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                             distance_matrix_2[new_solution[k-1], new_solution[k]] +\n                             distance_matrix_3[new_solution[k-1], new_solution[k]])\n            if k < n-1:\n                original_cost += (distance_matrix_1[new_solution[k], new_solution[k+1]] +\n                                 distance_matrix_2[new_solution[k], new_solution[k+1]] +\n                                 distance_matrix_3[new_solution[k], new_solution[k+1]])\n\n            # Try swapping with a random node in the segment\n            l = random.randint(i, j)\n            if l != k:\n                new_cost = (distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                            distance_matrix_2[new_solution[k-1], new_solution[l]] +\n                            distance_matrix_3[new_solution[k-1], new_solution[l]])\n                if k < n-1:\n                    new_cost += (distance_matrix_1[new_solution[l], new_solution[k+1]] +\n                                distance_matrix_2[new_solution[l], new_solution[k+1]] +\n                                distance_matrix_3[new_solution[l], new_solution[k+1]])\n                improvements.append((new_cost - original_cost, k, l))\n\n        # If there are improvements, apply the best one\n        if improvements:\n            best_improvement = min(improvements, key=lambda x: x[0])\n            if best_improvement[0] < 0:  # Only apply if it improves the solution\n                new_solution[best_improvement[1]], new_solution[best_improvement[2]] = new_solution[best_improvement[2]], new_solution[best_improvement[1]]\n\n    return new_solution\n\n",
        "score": [
            -0.5174056809182546,
            1.6569095253944397
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by a combined objective score (sum of normalized objectives)\n        objectives = np.array([obj for _, obj in archive])\n        normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-6)\n        combined_scores = normalized_objectives.sum(axis=1)\n        # Select the solution with the highest combined score (most potential for improvement)\n        selected_idx = np.argmax(combined_scores)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a multi-objective aware swap\n    n = len(new_solution)\n    if n < 2:\n        return new_solution\n\n    # Randomly choose a segment to modify\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt (swap edges)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective aware swap: swap nodes that are most critical in at least one objective\n    if j - i > 1:\n        # Calculate the improvement potential for each node in the segment\n        improvements = []\n        for k in range(i, j+1):\n            original_cost = (distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                             distance_matrix_2[new_solution[k-1], new_solution[k]] +\n                             distance_matrix_3[new_solution[k-1], new_solution[k]])\n            if k < n-1:\n                original_cost += (distance_matrix_1[new_solution[k], new_solution[k+1]] +\n                                 distance_matrix_2[new_solution[k], new_solution[k+1]] +\n                                 distance_matrix_3[new_solution[k], new_solution[k+1]])\n\n            # Try swapping with a random node in the segment\n            l = random.randint(i, j)\n            if l != k:\n                new_cost = (distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                            distance_matrix_2[new_solution[k-1], new_solution[l]] +\n                            distance_matrix_3[new_solution[k-1], new_solution[l]])\n                if k < n-1:\n                    new_cost += (distance_matrix_1[new_solution[l], new_solution[k+1]] +\n                                distance_matrix_2[new_solution[l], new_solution[k+1]] +\n                                distance_matrix_3[new_solution[l], new_solution[k+1]])\n                improvements.append((new_cost - original_cost, k, l))\n\n        # If there are improvements, apply the best one\n        if improvements:\n            best_improvement = min(improvements, key=lambda x: x[0])\n            if best_improvement[0] < 0:  # Only apply if it improves the solution\n                new_solution[best_improvement[1]], new_solution[best_improvement[2]] = new_solution[best_improvement[2]], new_solution[best_improvement[1]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 62,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement based on objective diversity\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        # Randomly select two distinct edges to break\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Perform 2-opt swap\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Evaluate the new solution's objectives\n        cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        cost3 = sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n        # If the new solution dominates the original, keep it; otherwise revert\n        if (cost1 <= archive[selected_idx][1][0] and cost2 <= archive[selected_idx][1][1] and cost3 <= archive[selected_idx][1][2] and\n            (cost1 < archive[selected_idx][1][0] or cost2 < archive[selected_idx][1][1] or cost3 < archive[selected_idx][1][2])):\n            base_solution = new_solution.copy()\n        else:\n            new_solution = base_solution.copy()\n\n    # Final objective-aware 2-opt pass\n    for _ in range(5):\n        # Select edges with worst impact on any objective\n        worst_edge = None\n        worst_impact = -float('inf')\n\n        for i in range(n):\n            node_a = new_solution[i]\n            node_b = new_solution[(i+1)%n]\n            impact = min(\n                distance_matrix_1[node_a, node_b],\n                distance_matrix_2[node_a, node_b],\n                distance_matrix_3[node_a, node_b]\n            )\n            if impact > worst_impact:\n                worst_impact = impact\n                worst_edge = i\n\n        if worst_edge is not None:\n            # Perform 2-opt on the worst edge\n            j = (worst_edge + 1) % n\n            new_solution[worst_edge:j+1] = new_solution[worst_edge:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6075380873945557,
            4.2494657158851625
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement based on objective diversity\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        # Randomly select two distinct edges to break\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Perform 2-opt swap\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Evaluate the new solution's objectives\n        cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        cost3 = sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n        # If the new solution dominates the original, keep it; otherwise revert\n        if (cost1 <= archive[selected_idx][1][0] and cost2 <= archive[selected_idx][1][1] and cost3 <= archive[selected_idx][1][2] and\n            (cost1 < archive[selected_idx][1][0] or cost2 < archive[selected_idx][1][1] or cost3 < archive[selected_idx][1][2])):\n            base_solution = new_solution.copy()\n        else:\n            new_solution = base_solution.copy()\n\n    # Final objective-aware 2-opt pass\n    for _ in range(5):\n        # Select edges with worst impact on any objective\n        worst_edge = None\n        worst_impact = -float('inf')\n\n        for i in range(n):\n            node_a = new_solution[i]\n            node_b = new_solution[(i+1)%n]\n            impact = min(\n                distance_matrix_1[node_a, node_b],\n                distance_matrix_2[node_a, node_b],\n                distance_matrix_3[node_a, node_b]\n            )\n            if impact > worst_impact:\n                worst_impact = impact\n                worst_edge = i\n\n        if worst_edge is not None:\n            # Perform 2-opt on the worst edge\n            j = (worst_edge + 1) % n\n            new_solution[worst_edge:j+1] = new_solution[worst_edge:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 63,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability weighted by its potential for improvement\n    weights = np.array([1.0 / (1 + obj[0] + obj[1] + obj[2]) for _, obj in archive])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Choose between three different local search operators\n    operator_choice = random.random()\n\n    if operator_choice < 0.33:  # 2-opt with objective-aware edge selection\n        # Select edges that are critical in any of the three objectives\n        n = len(new_solution)\n        i, j = sorted(random.sample(range(n), 2))\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator_choice < 0.66:  # Objective-aware swap\n        # Find the worst edges in any of the three objectives\n        n = len(new_solution)\n        total_costs = [\n            sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        ]\n\n        # Identify the objective with the highest cost\n        worst_obj = np.argmax(total_costs)\n\n        # Find the edge with the highest cost in the worst objective\n        max_cost = -1\n        max_i = 0\n        for i in range(n):\n            cost = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] if worst_obj == 0 else \\\n                   distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] if worst_obj == 1 else \\\n                   distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n            if cost > max_cost:\n                max_cost = cost\n                max_i = i\n\n        # Swap nodes to potentially improve the worst objective\n        if max_i < n-1:\n            new_solution[max_i], new_solution[max_i+1] = new_solution[max_i+1], new_solution[max_i]\n\n    else:  # Multi-objective edge insertion\n        # Select a random node and insert it in a position that improves multiple objectives\n        n = len(new_solution)\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n\n        # Remove the node from its current position\n        new_solution = np.delete(new_solution, k)\n\n        # Find the best insertion position that improves multiple objectives\n        best_pos = 0\n        best_improvement = -np.inf\n\n        for i in range(len(new_solution)):\n            # Try inserting the node at position i\n            temp_solution = np.insert(new_solution, i, node)\n\n            # Calculate the improvement in all three objectives\n            improvement = 0\n            for j in range(len(temp_solution)):\n                prev_node = temp_solution[j-1]\n                curr_node = temp_solution[j]\n                next_node = temp_solution[(j+1)%len(temp_solution)]\n\n                # Calculate the change in each objective\n                original_cost = distance_matrix_1[prev_node, curr_node] + distance_matrix_1[curr_node, next_node]\n                new_cost = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                improvement += (original_cost - new_cost)\n\n                original_cost = distance_matrix_2[prev_node, curr_node] + distance_matrix_2[curr_node, next_node]\n                new_cost = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                improvement += (original_cost - new_cost)\n\n                original_cost = distance_matrix_3[prev_node, curr_node] + distance_matrix_3[curr_node, next_node]\n                new_cost = distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node]\n                improvement += (original_cost - new_cost)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = i\n\n        # Insert the node at the best position\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7620982581075657,
            3.2134859204292296
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability weighted by its potential for improvement\n    weights = np.array([1.0 / (1 + obj[0] + obj[1] + obj[2]) for _, obj in archive])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Choose between three different local search operators\n    operator_choice = random.random()\n\n    if operator_choice < 0.33:  # 2-opt with objective-aware edge selection\n        # Select edges that are critical in any of the three objectives\n        n = len(new_solution)\n        i, j = sorted(random.sample(range(n), 2))\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator_choice < 0.66:  # Objective-aware swap\n        # Find the worst edges in any of the three objectives\n        n = len(new_solution)\n        total_costs = [\n            sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        ]\n\n        # Identify the objective with the highest cost\n        worst_obj = np.argmax(total_costs)\n\n        # Find the edge with the highest cost in the worst objective\n        max_cost = -1\n        max_i = 0\n        for i in range(n):\n            cost = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] if worst_obj == 0 else \\\n                   distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] if worst_obj == 1 else \\\n                   distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n            if cost > max_cost:\n                max_cost = cost\n                max_i = i\n\n        # Swap nodes to potentially improve the worst objective\n        if max_i < n-1:\n            new_solution[max_i], new_solution[max_i+1] = new_solution[max_i+1], new_solution[max_i]\n\n    else:  # Multi-objective edge insertion\n        # Select a random node and insert it in a position that improves multiple objectives\n        n = len(new_solution)\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n\n        # Remove the node from its current position\n        new_solution = np.delete(new_solution, k)\n\n        # Find the best insertion position that improves multiple objectives\n        best_pos = 0\n        best_improvement = -np.inf\n\n        for i in range(len(new_solution)):\n            # Try inserting the node at position i\n            temp_solution = np.insert(new_solution, i, node)\n\n            # Calculate the improvement in all three objectives\n            improvement = 0\n            for j in range(len(temp_solution)):\n                prev_node = temp_solution[j-1]\n                curr_node = temp_solution[j]\n                next_node = temp_solution[(j+1)%len(temp_solution)]\n\n                # Calculate the change in each objective\n                original_cost = distance_matrix_1[prev_node, curr_node] + distance_matrix_1[curr_node, next_node]\n                new_cost = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                improvement += (original_cost - new_cost)\n\n                original_cost = distance_matrix_2[prev_node, curr_node] + distance_matrix_2[curr_node, next_node]\n                new_cost = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                improvement += (original_cost - new_cost)\n\n                original_cost = distance_matrix_3[prev_node, curr_node] + distance_matrix_3[curr_node, next_node]\n                new_cost = distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node]\n                improvement += (original_cost - new_cost)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = i\n\n        # Insert the node at the best position\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 64,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 2:\n        # Sort solutions by the sum of objectives (could be replaced with other criteria)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution in the middle range for exploration\n        candidate_solutions = sorted_archive[len(archive)//4 : -len(archive)//4]\n        selected = random.choice(candidate_solutions)\n    else:\n        selected = random.choice(archive)\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a multi-objective local search operator\n    # Step 1: Select a random segment of the tour\n    n = len(base_solution)\n    start = random.randint(0, n-1)\n    end = random.randint(start, min(start + n//4, n-1))  # Limit segment size to avoid excessive computation\n\n    # Step 2: Reverse the segment (2-opt move)\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Step 3: If the segment is small, consider a 3-opt move for more exploration\n    if (end - start + 1) <= 3:\n        # Randomly choose two additional points and perform a 3-opt move\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Step 4: Evaluate the new solution and ensure feasibility\n    # Verify all nodes are visited exactly once\n    if len(np.unique(new_solution)) == len(new_solution):\n        return new_solution\n    else:\n        return base_solution  # Fallback to original if invalid\n\n",
        "score": [
            -0.6731066802641794,
            2.224828910827637
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 2:\n        # Sort solutions by the sum of objectives (could be replaced with other criteria)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution in the middle range for exploration\n        candidate_solutions = sorted_archive[len(archive)//4 : -len(archive)//4]\n        selected = random.choice(candidate_solutions)\n    else:\n        selected = random.choice(archive)\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a multi-objective local search operator\n    # Step 1: Select a random segment of the tour\n    n = len(base_solution)\n    start = random.randint(0, n-1)\n    end = random.randint(start, min(start + n//4, n-1))  # Limit segment size to avoid excessive computation\n\n    # Step 2: Reverse the segment (2-opt move)\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Step 3: If the segment is small, consider a 3-opt move for more exploration\n    if (end - start + 1) <= 3:\n        # Randomly choose two additional points and perform a 3-opt move\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Step 4: Evaluate the new solution and ensure feasibility\n    # Verify all nodes are visited exactly once\n    if len(np.unique(new_solution)) == len(new_solution):\n        return new_solution\n    else:\n        return base_solution  # Fallback to original if invalid\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 65,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    import numpy as np\n\n    # Select a solution with high potential for improvement (e.g., solutions with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weighted_scores = np.dot(objectives, variances)  # Higher variance = higher potential\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # Hybrid local search: combine 2-opt with objective-aware node swaps\n    if random.random() < 0.5:\n        # 2-opt: randomly select two edges and reverse the segment between them\n        i, j = sorted(random.sample(range(n_nodes), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Objective-aware node swap: swap nodes that are far apart in any objective space\n        k, l = random.sample(range(n_nodes), 2)\n        node_k, node_l = new_solution[k], new_solution[l]\n\n        # Calculate total distance improvement across all objectives\n        def total_distance(sol):\n            total = 0\n            for i in range(len(sol)):\n                u, v = sol[i], sol[(i+1)%len(sol)]\n                total += distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v]\n            return total\n\n        current_dist = total_distance(new_solution)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n        new_dist = total_distance(new_solution)\n\n        # Revert if no improvement\n        if new_dist >= current_dist:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.6799496033208707,
            2.6541980147361754
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    import numpy as np\n\n    # Select a solution with high potential for improvement (e.g., solutions with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weighted_scores = np.dot(objectives, variances)  # Higher variance = higher potential\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # Hybrid local search: combine 2-opt with objective-aware node swaps\n    if random.random() < 0.5:\n        # 2-opt: randomly select two edges and reverse the segment between them\n        i, j = sorted(random.sample(range(n_nodes), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Objective-aware node swap: swap nodes that are far apart in any objective space\n        k, l = random.sample(range(n_nodes), 2)\n        node_k, node_l = new_solution[k], new_solution[l]\n\n        # Calculate total distance improvement across all objectives\n        def total_distance(sol):\n            total = 0\n            for i in range(len(sol)):\n                u, v = sol[i], sol[(i+1)%len(sol)]\n                total += distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v]\n            return total\n\n        current_dist = total_distance(new_solution)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n        new_dist = total_distance(new_solution)\n\n        # Revert if no improvement\n        if new_dist >= current_dist:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 66,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal)\n    # Here, we select a solution that is not the best in all three objectives\n    selected_idx = -1\n    selected_solution = None\n    for i, (sol, obj) in enumerate(archive):\n        is_optimal = True\n        for j in range(3):\n            # Check if this solution is the best in the j-th objective\n            if not all(obj[j] <= other_obj[j] for _, other_obj in archive):\n                is_optimal = False\n                break\n        if not is_optimal:\n            selected_idx = i\n            selected_solution = sol.copy()\n            break\n\n    if selected_solution is None:\n        selected_solution = random.choice(archive)[0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Choose a random segment to modify\n    start = random.randint(0, n - 1)\n    length = random.randint(2, min(5, n // 2))\n    end = (start + length) % n\n\n    # Extract the segment\n    segment = new_solution[start:end].copy()\n\n    # Reverse the segment (2-opt)\n    if random.random() < 0.5:\n        segment = segment[::-1]\n    else:\n        # Or apply a different local search operator\n        # For example, swap nodes with the highest contribution to the worst objective\n        worst_obj = max(archive[selected_idx][1])\n        if worst_obj == archive[selected_idx][1][0]:\n            dist_matrix = distance_matrix_1\n        elif worst_obj == archive[selected_idx][1][1]:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Find the node with the highest contribution to the worst objective\n        max_contribution = -1\n        max_node = -1\n        for i in range(len(segment)):\n            node = segment[i]\n            prev_node = segment[i-1] if i > 0 else segment[-1]\n            next_node = segment[(i+1)%len(segment)]\n            contribution = dist_matrix[prev_node, node] + dist_matrix[node, next_node] - dist_matrix[prev_node, next_node]\n            if contribution > max_contribution:\n                max_contribution = contribution\n                max_node = node\n\n        # Swap this node with another random node in the segment\n        if max_node != -1:\n            swap_idx = random.randint(0, len(segment)-1)\n            segment[swap_idx], segment[np.where(segment == max_node)[0][0]] = segment[np.where(segment == max_node)[0][0]], segment[swap_idx]\n\n    # Insert the modified segment back\n    new_solution[start:end] = segment\n\n    # Ensure the solution is valid (no duplicates)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6706078624084991,
            1.513806688785553
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal)\n    # Here, we select a solution that is not the best in all three objectives\n    selected_idx = -1\n    selected_solution = None\n    for i, (sol, obj) in enumerate(archive):\n        is_optimal = True\n        for j in range(3):\n            # Check if this solution is the best in the j-th objective\n            if not all(obj[j] <= other_obj[j] for _, other_obj in archive):\n                is_optimal = False\n                break\n        if not is_optimal:\n            selected_idx = i\n            selected_solution = sol.copy()\n            break\n\n    if selected_solution is None:\n        selected_solution = random.choice(archive)[0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Choose a random segment to modify\n    start = random.randint(0, n - 1)\n    length = random.randint(2, min(5, n // 2))\n    end = (start + length) % n\n\n    # Extract the segment\n    segment = new_solution[start:end].copy()\n\n    # Reverse the segment (2-opt)\n    if random.random() < 0.5:\n        segment = segment[::-1]\n    else:\n        # Or apply a different local search operator\n        # For example, swap nodes with the highest contribution to the worst objective\n        worst_obj = max(archive[selected_idx][1])\n        if worst_obj == archive[selected_idx][1][0]:\n            dist_matrix = distance_matrix_1\n        elif worst_obj == archive[selected_idx][1][1]:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Find the node with the highest contribution to the worst objective\n        max_contribution = -1\n        max_node = -1\n        for i in range(len(segment)):\n            node = segment[i]\n            prev_node = segment[i-1] if i > 0 else segment[-1]\n            next_node = segment[(i+1)%len(segment)]\n            contribution = dist_matrix[prev_node, node] + dist_matrix[node, next_node] - dist_matrix[prev_node, next_node]\n            if contribution > max_contribution:\n                max_contribution = contribution\n                max_node = node\n\n        # Swap this node with another random node in the segment\n        if max_node != -1:\n            swap_idx = random.randint(0, len(segment)-1)\n            segment[swap_idx], segment[np.where(segment == max_node)[0][0]] = segment[np.where(segment == max_node)[0][0]], segment[swap_idx]\n\n    # Insert the modified segment back\n    new_solution[start:end] = segment\n\n    # Ensure the solution is valid (no duplicates)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 67,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with higher potential for improvement\n    # We prioritize solutions that are not too close to the current Pareto front\n    # and have diverse objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity = normalized_obj.std(axis=0).mean()  # Higher diversity is better\n\n    # Select the solution with highest diversity (potential for improvement)\n    selected_idx = np.argmax(diversity)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First apply 2-opt to improve the worst objective\n    # Calculate current objectives\n    def calculate_objectives(sol):\n        obj1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n        obj2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n        obj3 = sum(distance_matrix_3[sol[i], sol[(i+1)%n]] for i in range(n))\n        return (obj1, obj2, obj3)\n\n    current_obj = calculate_objectives(new_solution)\n    worst_obj_idx = np.argmax(current_obj)\n\n    # 2-opt for the worst objective\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Create candidate solution\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n\n        # Check if better for the worst objective\n        candidate_obj = calculate_objectives(candidate)\n        if candidate_obj[worst_obj_idx] < current_obj[worst_obj_idx]:\n            new_solution = candidate\n            current_obj = candidate_obj\n\n    # Then apply objective-aware swaps\n    for _ in range(5):  # Additional swaps\n        i, j = np.random.choice(n, 2, replace=False)\n        if i == j:\n            continue\n\n        # Swap nodes\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        # Check if better for at least one objective\n        candidate_obj = calculate_objectives(candidate)\n        if any(candidate_obj[k] < current_obj[k] for k in range(3)):\n            new_solution = candidate\n            current_obj = candidate_obj\n\n    return new_solution\n\n",
        "score": [
            -0.7880094124491918,
            4.159202122688294
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with higher potential for improvement\n    # We prioritize solutions that are not too close to the current Pareto front\n    # and have diverse objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity = normalized_obj.std(axis=0).mean()  # Higher diversity is better\n\n    # Select the solution with highest diversity (potential for improvement)\n    selected_idx = np.argmax(diversity)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First apply 2-opt to improve the worst objective\n    # Calculate current objectives\n    def calculate_objectives(sol):\n        obj1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n        obj2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n        obj3 = sum(distance_matrix_3[sol[i], sol[(i+1)%n]] for i in range(n))\n        return (obj1, obj2, obj3)\n\n    current_obj = calculate_objectives(new_solution)\n    worst_obj_idx = np.argmax(current_obj)\n\n    # 2-opt for the worst objective\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Create candidate solution\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n\n        # Check if better for the worst objective\n        candidate_obj = calculate_objectives(candidate)\n        if candidate_obj[worst_obj_idx] < current_obj[worst_obj_idx]:\n            new_solution = candidate\n            current_obj = candidate_obj\n\n    # Then apply objective-aware swaps\n    for _ in range(5):  # Additional swaps\n        i, j = np.random.choice(n, 2, replace=False)\n        if i == j:\n            continue\n\n        # Swap nodes\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        # Check if better for at least one objective\n        candidate_obj = calculate_objectives(candidate)\n        if any(candidate_obj[k] < current_obj[k] for k in range(3)):\n            new_solution = candidate\n            current_obj = candidate_obj\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 68,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (e.g., those with the worst objectives)\n    objectives = [obj for _, obj in archive]\n    worst_indices = np.argsort([sum(obj) for obj in objectives])[-min(5, len(archive)):]  # Top 5 worst solutions\n    selected_idx = np.random.choice(worst_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt with the objective that has the highest relative improvement potential\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    obj_weights = np.array([obj1, obj2, obj3])\n    obj_weights = obj_weights / np.sum(obj_weights)  # Normalize weights\n\n    # Choose the objective with the highest weight for the 2-opt operation\n    chosen_obj = np.random.choice(3, p=obj_weights)\n\n    # Perform 2-opt on the chosen objective's distance matrix\n    if chosen_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif chosen_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the best 2-opt move\n    best_improvement = 0\n    best_i, best_j = -1, -1\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            a, b = new_solution[i], new_solution[i + 1]\n            c, d = new_solution[j], new_solution[j + 1] if j + 1 < n else new_solution[0]\n\n            # Calculate the change in cost for the chosen objective\n            delta = (dist_matrix[b, c] + dist_matrix[a, d]) - (dist_matrix[a, b] + dist_matrix[c, d])\n\n            if delta < best_improvement:\n                best_improvement = delta\n                best_i, best_j = i, j\n\n    # Apply the best move if it improves the chosen objective\n    if best_i != -1 and best_j != -1:\n        new_solution[best_i + 1:best_j + 1] = new_solution[best_i + 1:best_j + 1][::-1]\n\n    # Additional: perform a random swap to diversify the search\n    if np.random.rand() < 0.3:  # 30% chance of additional swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6128069284795448,
            2.7947320222854612
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (e.g., those with the worst objectives)\n    objectives = [obj for _, obj in archive]\n    worst_indices = np.argsort([sum(obj) for obj in objectives])[-min(5, len(archive)):]  # Top 5 worst solutions\n    selected_idx = np.random.choice(worst_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt with the objective that has the highest relative improvement potential\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    obj_weights = np.array([obj1, obj2, obj3])\n    obj_weights = obj_weights / np.sum(obj_weights)  # Normalize weights\n\n    # Choose the objective with the highest weight for the 2-opt operation\n    chosen_obj = np.random.choice(3, p=obj_weights)\n\n    # Perform 2-opt on the chosen objective's distance matrix\n    if chosen_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif chosen_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the best 2-opt move\n    best_improvement = 0\n    best_i, best_j = -1, -1\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            a, b = new_solution[i], new_solution[i + 1]\n            c, d = new_solution[j], new_solution[j + 1] if j + 1 < n else new_solution[0]\n\n            # Calculate the change in cost for the chosen objective\n            delta = (dist_matrix[b, c] + dist_matrix[a, d]) - (dist_matrix[a, b] + dist_matrix[c, d])\n\n            if delta < best_improvement:\n                best_improvement = delta\n                best_i, best_j = i, j\n\n    # Apply the best move if it improves the chosen objective\n    if best_i != -1 and best_j != -1:\n        new_solution[best_i + 1:best_j + 1] = new_solution[best_i + 1:best_j + 1][::-1]\n\n    # Additional: perform a random swap to diversify the search\n    if np.random.rand() < 0.3:  # 30% chance of additional swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 69,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending) to find less optimal solutions\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the middle range to balance exploration and exploitation\n        candidate_indices = range(len(archive_sorted) // 3, 2 * len(archive_sorted) // 3)\n        selected_idx = random.choice(candidate_indices)\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt and objective-aware swaps\n    n_nodes = len(new_solution)\n    if n_nodes < 3:\n        return new_solution  # No improvement possible\n\n    # 1. Perform a 2-opt move (standard local search)\n    i, j = sorted(random.sample(range(n_nodes), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # 2. Objective-aware swap: identify the worst edge in any objective space and try to fix it\n    # Calculate current tour lengths in each objective space\n    def calculate_tour_length(solution, distance_matrix):\n        total = 0\n        for i in range(len(solution) - 1):\n            total += distance_matrix[solution[i], solution[i+1]]\n        total += distance_matrix[solution[-1], solution[0]]  # Return to start\n        return total\n\n    current_lengths = (\n        calculate_tour_length(new_solution, distance_matrix_1),\n        calculate_tour_length(new_solution, distance_matrix_2),\n        calculate_tour_length(new_solution, distance_matrix_3)\n    )\n\n    # Find the worst objective (highest length)\n    worst_obj = np.argmax(current_lengths)\n\n    # Identify the worst edge in the worst objective space\n    worst_edge_length = -1\n    worst_edge_indices = (0, 1)\n    for i in range(len(new_solution) - 1):\n        edge_length = distance_matrix_1[new_solution[i], new_solution[i+1]] if worst_obj == 0 else \\\n                      distance_matrix_2[new_solution[i], new_solution[i+1]] if worst_obj == 1 else \\\n                      distance_matrix_3[new_solution[i], new_solution[i+1]]\n        if edge_length > worst_edge_length:\n            worst_edge_length = edge_length\n            worst_edge_indices = (i, i+1)\n\n    # Try to swap nodes to improve the worst edge\n    if worst_edge_length > 0:\n        a, b = worst_edge_indices\n        # Find nodes not in the current edge\n        candidates = [i for i in range(n_nodes) if i != a and i != b]\n        if len(candidates) >= 2:\n            # Select two random nodes to swap\n            swap_a, swap_b = random.sample(candidates, 2)\n            new_solution[swap_a], new_solution[swap_b] = new_solution[swap_b], new_solution[swap_a]\n\n    return new_solution\n\n",
        "score": [
            -0.7315489097044469,
            1.1534336924552917
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending) to find less optimal solutions\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the middle range to balance exploration and exploitation\n        candidate_indices = range(len(archive_sorted) // 3, 2 * len(archive_sorted) // 3)\n        selected_idx = random.choice(candidate_indices)\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt and objective-aware swaps\n    n_nodes = len(new_solution)\n    if n_nodes < 3:\n        return new_solution  # No improvement possible\n\n    # 1. Perform a 2-opt move (standard local search)\n    i, j = sorted(random.sample(range(n_nodes), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # 2. Objective-aware swap: identify the worst edge in any objective space and try to fix it\n    # Calculate current tour lengths in each objective space\n    def calculate_tour_length(solution, distance_matrix):\n        total = 0\n        for i in range(len(solution) - 1):\n            total += distance_matrix[solution[i], solution[i+1]]\n        total += distance_matrix[solution[-1], solution[0]]  # Return to start\n        return total\n\n    current_lengths = (\n        calculate_tour_length(new_solution, distance_matrix_1),\n        calculate_tour_length(new_solution, distance_matrix_2),\n        calculate_tour_length(new_solution, distance_matrix_3)\n    )\n\n    # Find the worst objective (highest length)\n    worst_obj = np.argmax(current_lengths)\n\n    # Identify the worst edge in the worst objective space\n    worst_edge_length = -1\n    worst_edge_indices = (0, 1)\n    for i in range(len(new_solution) - 1):\n        edge_length = distance_matrix_1[new_solution[i], new_solution[i+1]] if worst_obj == 0 else \\\n                      distance_matrix_2[new_solution[i], new_solution[i+1]] if worst_obj == 1 else \\\n                      distance_matrix_3[new_solution[i], new_solution[i+1]]\n        if edge_length > worst_edge_length:\n            worst_edge_length = edge_length\n            worst_edge_indices = (i, i+1)\n\n    # Try to swap nodes to improve the worst edge\n    if worst_edge_length > 0:\n        a, b = worst_edge_indices\n        # Find nodes not in the current edge\n        candidates = [i for i in range(n_nodes) if i != a and i != b]\n        if len(candidates) >= 2:\n            # Select two random nodes to swap\n            swap_a, swap_b = random.sample(candidates, 2)\n            new_solution[swap_a], new_solution[swap_b] = new_solution[swap_b], new_solution[swap_a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 70,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement by choosing the one with the highest total cost\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n    total_costs = [sum(obj) for obj in archive_objectives]\n\n    # Prioritize solutions with higher total cost (more room for improvement)\n    selected_idx = np.argmax(total_costs)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search strategy: combine 2-opt with a multi-objective aware swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move to reduce the total cost\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, perform a multi-objective aware swap to balance the three objectives\n    if n > 2:\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        if k != l:\n            # Calculate the change in total cost for the swap\n            delta = (distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]] -\n                     distance_matrix_1[new_solution[k-1], new_solution[k]] - distance_matrix_1[new_solution[l-1], new_solution[l]])\n            delta += (distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]] -\n                      distance_matrix_2[new_solution[k-1], new_solution[k]] - distance_matrix_2[new_solution[l-1], new_solution[l]])\n            delta += (distance_matrix_3[new_solution[k-1], new_solution[l]] + distance_matrix_3[new_solution[l-1], new_solution[k]] -\n                      distance_matrix_3[new_solution[k-1], new_solution[k]] - distance_matrix_3[new_solution[l-1], new_solution[l]])\n\n            # Accept the swap if it improves the total cost or if it's a small worsening\n            if delta <= 0 or np.random.rand() < 0.1:  # Small probability to escape local optima\n                new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.621228071203024,
            1.2974851727485657
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement by choosing the one with the highest total cost\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n    total_costs = [sum(obj) for obj in archive_objectives]\n\n    # Prioritize solutions with higher total cost (more room for improvement)\n    selected_idx = np.argmax(total_costs)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search strategy: combine 2-opt with a multi-objective aware swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move to reduce the total cost\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, perform a multi-objective aware swap to balance the three objectives\n    if n > 2:\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        if k != l:\n            # Calculate the change in total cost for the swap\n            delta = (distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]] -\n                     distance_matrix_1[new_solution[k-1], new_solution[k]] - distance_matrix_1[new_solution[l-1], new_solution[l]])\n            delta += (distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]] -\n                      distance_matrix_2[new_solution[k-1], new_solution[k]] - distance_matrix_2[new_solution[l-1], new_solution[l]])\n            delta += (distance_matrix_3[new_solution[k-1], new_solution[l]] + distance_matrix_3[new_solution[l-1], new_solution[k]] -\n                      distance_matrix_3[new_solution[k-1], new_solution[k]] - distance_matrix_3[new_solution[l-1], new_solution[l]])\n\n            # Accept the swap if it improves the total cost or if it's a small worsening\n            if delta <= 0 or np.random.rand() < 0.1:  # Small probability to escape local optima\n                new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 71,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = sorted(archive, key=lambda x: min(x[1]))\n    selected = random.choice(candidates[:max(1, len(candidates) // 4)])[0].copy()\n\n    # Apply hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # First, perform 2-opt to improve connectivity\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform objective-aware swaps\n    for _ in range(min(3, n // 2)):\n        # Select two nodes based on their contribution to each objective\n        a, b = random.sample(range(n), 2)\n        node_a, node_b = new_solution[a], new_solution[b]\n\n        # Calculate current and potential costs for each objective\n        current_costs = [\n            distance_matrix_1[node_a, new_solution[(a-1)%n]] + distance_matrix_1[new_solution[(a+1)%n], node_a] +\n            distance_matrix_1[node_b, new_solution[(b-1)%n]] + distance_matrix_1[new_solution[(b+1)%n], node_b],\n            distance_matrix_2[node_a, new_solution[(a-1)%n]] + distance_matrix_2[new_solution[(a+1)%n], node_a] +\n            distance_matrix_2[node_b, new_solution[(b-1)%n]] + distance_matrix_2[new_solution[(b+1)%n], node_b],\n            distance_matrix_3[node_a, new_solution[(a-1)%n]] + distance_matrix_3[new_solution[(a+1)%n], node_a] +\n            distance_matrix_3[node_b, new_solution[(b-1)%n]] + distance_matrix_3[new_solution[(b+1)%n], node_b]\n        ]\n\n        potential_costs = [\n            distance_matrix_1[node_b, new_solution[(a-1)%n]] + distance_matrix_1[new_solution[(a+1)%n], node_b] +\n            distance_matrix_1[node_a, new_solution[(b-1)%n]] + distance_matrix_1[new_solution[(b+1)%n], node_a],\n            distance_matrix_2[node_b, new_solution[(a-1)%n]] + distance_matrix_2[new_solution[(a+1)%n], node_b] +\n            distance_matrix_2[node_a, new_solution[(b-1)%n]] + distance_matrix_2[new_solution[(b+1)%n], node_a],\n            distance_matrix_3[node_b, new_solution[(a-1)%n]] + distance_matrix_3[new_solution[(a+1)%n], node_b] +\n            distance_matrix_3[node_a, new_solution[(b-1)%n]] + distance_matrix_3[new_solution[(b+1)%n], node_a]\n        ]\n\n        # Accept swap if it improves at least one objective\n        if any(potential < current for potential, current in zip(potential_costs, current_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.5426489375011423,
            1.1977668523788452
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = sorted(archive, key=lambda x: min(x[1]))\n    selected = random.choice(candidates[:max(1, len(candidates) // 4)])[0].copy()\n\n    # Apply hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # First, perform 2-opt to improve connectivity\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform objective-aware swaps\n    for _ in range(min(3, n // 2)):\n        # Select two nodes based on their contribution to each objective\n        a, b = random.sample(range(n), 2)\n        node_a, node_b = new_solution[a], new_solution[b]\n\n        # Calculate current and potential costs for each objective\n        current_costs = [\n            distance_matrix_1[node_a, new_solution[(a-1)%n]] + distance_matrix_1[new_solution[(a+1)%n], node_a] +\n            distance_matrix_1[node_b, new_solution[(b-1)%n]] + distance_matrix_1[new_solution[(b+1)%n], node_b],\n            distance_matrix_2[node_a, new_solution[(a-1)%n]] + distance_matrix_2[new_solution[(a+1)%n], node_a] +\n            distance_matrix_2[node_b, new_solution[(b-1)%n]] + distance_matrix_2[new_solution[(b+1)%n], node_b],\n            distance_matrix_3[node_a, new_solution[(a-1)%n]] + distance_matrix_3[new_solution[(a+1)%n], node_a] +\n            distance_matrix_3[node_b, new_solution[(b-1)%n]] + distance_matrix_3[new_solution[(b+1)%n], node_b]\n        ]\n\n        potential_costs = [\n            distance_matrix_1[node_b, new_solution[(a-1)%n]] + distance_matrix_1[new_solution[(a+1)%n], node_b] +\n            distance_matrix_1[node_a, new_solution[(b-1)%n]] + distance_matrix_1[new_solution[(b+1)%n], node_a],\n            distance_matrix_2[node_b, new_solution[(a-1)%n]] + distance_matrix_2[new_solution[(a+1)%n], node_b] +\n            distance_matrix_2[node_a, new_solution[(b-1)%n]] + distance_matrix_2[new_solution[(b+1)%n], node_a],\n            distance_matrix_3[node_b, new_solution[(a-1)%n]] + distance_matrix_3[new_solution[(a+1)%n], node_b] +\n            distance_matrix_3[node_a, new_solution[(b-1)%n]] + distance_matrix_3[new_solution[(b+1)%n], node_a]\n        ]\n\n        # Accept swap if it improves at least one objective\n        if any(potential < current for potential, current in zip(potential_costs, current_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 72,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (higher sum indicates higher potential)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Randomly select from top 30% of solutions\n        selected_index = random.randint(0, max(1, len(archive) // 3) - 1)\n        base_solution = sorted_archive[selected_index][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    if random.random() < 0.7:  # 70% chance for 2-opt\n        # Perform 2-opt on a random segment\n        n = len(new_solution)\n        a, b = sorted(random.sample(range(n), 2))\n        if b - a > 1:  # Ensure there are at least 2 nodes between a and b\n            new_solution[a:b] = new_solution[a:b][::-1]\n    else:  # 30% chance for objective-aware swap\n        # Find the worst edge in any of the three objective spaces\n        worst_obj = -1\n        worst_edge = None\n\n        for i in range(len(new_solution)):\n            node_a = new_solution[i]\n            node_b = new_solution[(i + 1) % len(new_solution)]\n\n            # Calculate edge costs in all three objectives\n            cost1 = distance_matrix_1[node_a, node_b]\n            cost2 = distance_matrix_2[node_a, node_b]\n            cost3 = distance_matrix_3[node_a, node_b]\n\n            # Find the maximum cost among the three objectives\n            max_cost = max(cost1, cost2, cost3)\n\n            if max_cost > worst_obj:\n                worst_obj = max_cost\n                worst_edge = i\n\n        if worst_edge is not None:\n            # Swap nodes to potentially improve the worst edge\n            swap_pos = (worst_edge + 1) % len(new_solution)\n            new_solution[worst_edge], new_solution[swap_pos] = new_solution[swap_pos], new_solution[worst_edge]\n\n    return new_solution\n\n",
        "score": [
            -0.5291357326504149,
            1.2949096441268921
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (higher sum indicates higher potential)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Randomly select from top 30% of solutions\n        selected_index = random.randint(0, max(1, len(archive) // 3) - 1)\n        base_solution = sorted_archive[selected_index][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    if random.random() < 0.7:  # 70% chance for 2-opt\n        # Perform 2-opt on a random segment\n        n = len(new_solution)\n        a, b = sorted(random.sample(range(n), 2))\n        if b - a > 1:  # Ensure there are at least 2 nodes between a and b\n            new_solution[a:b] = new_solution[a:b][::-1]\n    else:  # 30% chance for objective-aware swap\n        # Find the worst edge in any of the three objective spaces\n        worst_obj = -1\n        worst_edge = None\n\n        for i in range(len(new_solution)):\n            node_a = new_solution[i]\n            node_b = new_solution[(i + 1) % len(new_solution)]\n\n            # Calculate edge costs in all three objectives\n            cost1 = distance_matrix_1[node_a, node_b]\n            cost2 = distance_matrix_2[node_a, node_b]\n            cost3 = distance_matrix_3[node_a, node_b]\n\n            # Find the maximum cost among the three objectives\n            max_cost = max(cost1, cost2, cost3)\n\n            if max_cost > worst_obj:\n                worst_obj = max_cost\n                worst_edge = i\n\n        if worst_edge is not None:\n            # Swap nodes to potentially improve the worst edge\n            swap_pos = (worst_edge + 1) % len(new_solution)\n            new_solution[worst_edge], new_solution[swap_pos] = new_solution[swap_pos], new_solution[worst_edge]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 73,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low crowding distance (promising for improvement)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware edge swapping\n    n_nodes = len(base_solution)\n    i, j = sorted(np.random.choice(n_nodes, 2, replace=False))\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware edge swapping: evaluate edges in all three objectives\n    def evaluate_edge_swap(solution, a, b):\n        # Original edges: (a-1 -> a) and (b -> b+1)\n        # New edges: (a-1 -> b) and (a -> b+1)\n        a_prev = solution[a-1]\n        a_next = solution[(a+1)%n_nodes]\n        b_prev = solution[b-1]\n        b_next = solution[(b+1)%n_nodes]\n\n        # Calculate changes in all three objectives\n        delta1 = (distance_matrix_1[a_prev, b] + distance_matrix_1[a, b_next] -\n                 (distance_matrix_1[a_prev, a] + distance_matrix_1[b, b_next]))\n        delta2 = (distance_matrix_2[a_prev, b] + distance_matrix_2[a, b_next] -\n                 (distance_matrix_2[a_prev, a] + distance_matrix_2[b, b_next]))\n        delta3 = (distance_matrix_3[a_prev, b] + distance_matrix_3[a, b_next] -\n                 (distance_matrix_3[a_prev, a] + distance_matrix_3[b, b_next]))\n\n        return delta1, delta2, delta3\n\n    # Try to find an edge swap that improves at least one objective\n    best_deltas = (float('inf'), float('inf'), float('inf'))\n    best_swap = None\n\n    for a in range(n_nodes):\n        for b in range(a+2, n_nodes):\n            deltas = evaluate_edge_swap(new_solution, a, b)\n            if any(d < 0 for d in deltas):  # If any objective improves\n                if sum(deltas) < sum(best_deltas):  # Prefer solutions with better overall improvement\n                    best_deltas = deltas\n                    best_swap = (a, b)\n\n    if best_swap:\n        a, b = best_swap\n        # Perform the edge swap\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.776810028556668,
            3.8673390984535216
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low crowding distance (promising for improvement)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware edge swapping\n    n_nodes = len(base_solution)\n    i, j = sorted(np.random.choice(n_nodes, 2, replace=False))\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware edge swapping: evaluate edges in all three objectives\n    def evaluate_edge_swap(solution, a, b):\n        # Original edges: (a-1 -> a) and (b -> b+1)\n        # New edges: (a-1 -> b) and (a -> b+1)\n        a_prev = solution[a-1]\n        a_next = solution[(a+1)%n_nodes]\n        b_prev = solution[b-1]\n        b_next = solution[(b+1)%n_nodes]\n\n        # Calculate changes in all three objectives\n        delta1 = (distance_matrix_1[a_prev, b] + distance_matrix_1[a, b_next] -\n                 (distance_matrix_1[a_prev, a] + distance_matrix_1[b, b_next]))\n        delta2 = (distance_matrix_2[a_prev, b] + distance_matrix_2[a, b_next] -\n                 (distance_matrix_2[a_prev, a] + distance_matrix_2[b, b_next]))\n        delta3 = (distance_matrix_3[a_prev, b] + distance_matrix_3[a, b_next] -\n                 (distance_matrix_3[a_prev, a] + distance_matrix_3[b, b_next]))\n\n        return delta1, delta2, delta3\n\n    # Try to find an edge swap that improves at least one objective\n    best_deltas = (float('inf'), float('inf'), float('inf'))\n    best_swap = None\n\n    for a in range(n_nodes):\n        for b in range(a+2, n_nodes):\n            deltas = evaluate_edge_swap(new_solution, a, b)\n            if any(d < 0 for d in deltas):  # If any objective improves\n                if sum(deltas) < sum(best_deltas):  # Prefer solutions with better overall improvement\n                    best_deltas = deltas\n                    best_swap = (a, b)\n\n    if best_swap:\n        a, b = best_swap\n        # Perform the edge swap\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 74,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (lower is better)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select from top 20% of solutions\n        top_solutions = archive_sorted[:max(1, len(archive) // 5)]\n        selected = random.choice(top_solutions)[0].copy()\n    else:\n        selected = archive[0][0].copy()\n\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    operator = random.choice(['swap', '2opt', 'insert', 'reverse'])\n\n    if operator == 'swap':\n        # Swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    elif operator == '2opt':\n        # 2-opt move\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == 'insert':\n        # Insert a node in a different position\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    elif operator == 'reverse':\n        # Reverse a segment of the tour\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains valid (all nodes visited exactly once)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.73930688502812,
            1.522495186328888
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (lower is better)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select from top 20% of solutions\n        top_solutions = archive_sorted[:max(1, len(archive) // 5)]\n        selected = random.choice(top_solutions)[0].copy()\n    else:\n        selected = archive[0][0].copy()\n\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    operator = random.choice(['swap', '2opt', 'insert', 'reverse'])\n\n    if operator == 'swap':\n        # Swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    elif operator == '2opt':\n        # 2-opt move\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == 'insert':\n        # Insert a node in a different position\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    elif operator == 'reverse':\n        # Reverse a segment of the tour\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains valid (all nodes visited exactly once)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 75,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with lower total cost across all objectives\n    weights = np.array([sum(obj) for _, obj in archive])\n    weights = 1 / (weights + 1e-6)  # Inverse to prefer lower costs\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # 1. Apply 2-opt with multi-objective edge selection\n    i, j = sorted(random.sample(range(n), 2))\n    if i != j:\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # 2. Apply a novel three-objective aware swap operator\n    for _ in range(3):  # Number of swaps\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            # Calculate the change in all three objectives\n            delta1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                      distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] -\n                      distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                      distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n\n            delta2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                      distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] -\n                      distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                      distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n\n            delta3 = (distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                      distance_matrix_3[new_solution[b], new_solution[(a+1)%n]] -\n                      distance_matrix_3[new_solution[a-1], new_solution[a]] -\n                      distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n            # Accept the swap if it improves at least one objective\n            if delta1 < 0 or delta2 < 0 or delta3 < 0:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains valid\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.7466662813992855,
            1.4593160271644592
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with lower total cost across all objectives\n    weights = np.array([sum(obj) for _, obj in archive])\n    weights = 1 / (weights + 1e-6)  # Inverse to prefer lower costs\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # 1. Apply 2-opt with multi-objective edge selection\n    i, j = sorted(random.sample(range(n), 2))\n    if i != j:\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # 2. Apply a novel three-objective aware swap operator\n    for _ in range(3):  # Number of swaps\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            # Calculate the change in all three objectives\n            delta1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                      distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] -\n                      distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                      distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n\n            delta2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                      distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] -\n                      distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                      distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n\n            delta3 = (distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                      distance_matrix_3[new_solution[b], new_solution[(a+1)%n]] -\n                      distance_matrix_3[new_solution[a-1], new_solution[a]] -\n                      distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n            # Accept the swap if it improves at least one objective\n            if delta1 < 0 or delta2 < 0 or delta3 < 0:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains valid\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 76,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on the objective values\n    # Here, we select the solution with the lowest sum of objectives (could be replaced with more sophisticated criteria)\n    selected_solution, _ = min(archive, key=lambda x: sum(x[1]))\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator: a combination of 2-opt and edge exchange\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Randomly select two distinct edges to break and reconnect\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Ensure we have four distinct indices\n    while len({i, j, k, l}) < 4:\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n    # Perform the edge exchange (a type of 2-opt with two distinct edges)\n    new_solution[[i, j, k, l]] = new_solution[[i, k, j, l]]\n\n    # Verify the solution remains valid (no duplicates, all nodes visited)\n    if len(set(new_solution)) == n:\n        return new_solution\n    else:\n        return selected_solution  # Fallback to original if invalid\n\n",
        "score": [
            -0.6554497920800847,
            1.2852946758270263
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on the objective values\n    # Here, we select the solution with the lowest sum of objectives (could be replaced with more sophisticated criteria)\n    selected_solution, _ = min(archive, key=lambda x: sum(x[1]))\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator: a combination of 2-opt and edge exchange\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Randomly select two distinct edges to break and reconnect\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Ensure we have four distinct indices\n    while len({i, j, k, l}) < 4:\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n    # Perform the edge exchange (a type of 2-opt with two distinct edges)\n    new_solution[[i, j, k, l]] = new_solution[[i, k, j, l]]\n\n    # Verify the solution remains valid (no duplicates, all nodes visited)\n    if len(set(new_solution)) == n:\n        return new_solution\n    else:\n        return selected_solution  # Fallback to original if invalid\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 77,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 2:\n        # Sort solutions by a combined objective score (sum of normalized objectives)\n        objectives = np.array([obj for _, obj in archive])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n        combined_scores = normalized.sum(axis=1)\n        # Select the middle solution (not the best or worst)\n        selected_idx = np.argsort(combined_scores)[len(archive)//2]\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and edge exchange\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    k, l = np.random.choice(n, size=2, replace=False)\n\n    # Ensure i < j and k < l\n    i, j = min(i, j), max(i, j)\n    k, l = min(k, l), max(k, l)\n\n    # Apply 2-opt if segments are not overlapping\n    if not (i <= k <= j or i <= l <= j):\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Apply edge exchange if segments overlap\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap\n        new_solution = base_solution.copy()\n        a, b = np.random.choice(n, size=2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7114344779224206,
            1.7524020195007324
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 2:\n        # Sort solutions by a combined objective score (sum of normalized objectives)\n        objectives = np.array([obj for _, obj in archive])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n        combined_scores = normalized.sum(axis=1)\n        # Select the middle solution (not the best or worst)\n        selected_idx = np.argsort(combined_scores)[len(archive)//2]\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and edge exchange\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    k, l = np.random.choice(n, size=2, replace=False)\n\n    # Ensure i < j and k < l\n    i, j = min(i, j), max(i, j)\n    k, l = min(k, l), max(k, l)\n\n    # Apply 2-opt if segments are not overlapping\n    if not (i <= k <= j or i <= l <= j):\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Apply edge exchange if segments overlap\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap\n        new_solution = base_solution.copy()\n        a, b = np.random.choice(n, size=2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 78,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective values)\n    weights = [1.0 / (obj[0] + obj[1] + obj[2] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt swap for one objective\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware swap to improve all three objectives\n    # Find the worst edge in terms of combined distance\n    max_diff = -1\n    best_i, best_j = 0, 0\n    for i in range(n):\n        for j in range(i+1, n):\n            # Calculate current and potential new distances for all three objectives\n            current_dist = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                           distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n            new_dist = (distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                       distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n                       distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            diff = current_dist - new_dist\n            if diff > max_diff:\n                max_diff = diff\n                best_i, best_j = i, j\n\n    if max_diff > 0:\n        new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If infeasible, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.743639867149593,
            2.9562211990356446
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective values)\n    weights = [1.0 / (obj[0] + obj[1] + obj[2] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt swap for one objective\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware swap to improve all three objectives\n    # Find the worst edge in terms of combined distance\n    max_diff = -1\n    best_i, best_j = 0, 0\n    for i in range(n):\n        for j in range(i+1, n):\n            # Calculate current and potential new distances for all three objectives\n            current_dist = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                           distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n            new_dist = (distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                       distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n                       distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            diff = current_dist - new_dist\n            if diff > max_diff:\n                max_diff = diff\n                best_i, best_j = i, j\n\n    if max_diff > 0:\n        new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If infeasible, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 79,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (prioritize those with higher costs)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select from top 30% of solutions\n        selected_idx = random.randint(0, max(0, min(2, len(archive_sorted) - 1)))\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly choose between 3 local search operators\n    operator = random.choice(['2-opt', 'inversion', 'swap'])\n\n    if operator == '2-opt':\n        # 2-opt: Swap two edges to potentially reduce tour length\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'inversion':\n        # Inversion: Reverse a segment of the tour\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == 'swap':\n        # Swap: Exchange two nodes\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains valid (visits each node exactly once)\n    assert len(np.unique(new_solution)) == len(new_solution), \"Invalid solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.7323127639005799,
            1.5781735897064209
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (prioritize those with higher costs)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select from top 30% of solutions\n        selected_idx = random.randint(0, max(0, min(2, len(archive_sorted) - 1)))\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly choose between 3 local search operators\n    operator = random.choice(['2-opt', 'inversion', 'swap'])\n\n    if operator == '2-opt':\n        # 2-opt: Swap two edges to potentially reduce tour length\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'inversion':\n        # Inversion: Reverse a segment of the tour\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == 'swap':\n        # Swap: Exchange two nodes\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains valid (visits each node exactly once)\n    assert len(np.unique(new_solution)) == len(new_solution), \"Invalid solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 80,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity = normalized_obj.std(axis=0).sum()\n    selected_idx = np.argmax(diversity)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move to improve all objectives\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform objective-aware swaps to balance improvement across objectives\n    for _ in range(2):  # Perform 2 swaps\n        # Calculate current objective values\n        current_obj = (\n            sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        )\n\n        # Find the worst objective to improve\n        worst_obj = np.argmax(current_obj)\n\n        # Select edges to swap based on the worst objective\n        if worst_obj == 0:\n            dist_matrix = distance_matrix_1\n        elif worst_obj == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Find edges with high potential for improvement\n        edge_costs = [dist_matrix[new_solution[k], new_solution[(k+1)%n]] for k in range(n)]\n        sorted_edges = np.argsort(edge_costs)[::-1]  # Highest cost edges first\n\n        # Try swapping nodes to improve the worst objective\n        improved = False\n        for edge_idx in sorted_edges[:3]:  # Try top 3 worst edges\n            a, b = edge_idx, (edge_idx + 1) % n\n            # Try swapping nodes a and b with their neighbors\n            for swap_idx in [a-1, a+1, b-1, b+1]:\n                swap_idx = swap_idx % n\n                if swap_idx == a or swap_idx == b:\n                    continue\n\n                # Create candidate solution\n                candidate = new_solution.copy()\n                candidate[a], candidate[swap_idx] = candidate[swap_idx], candidate[a]\n\n                # Calculate new objective\n                new_obj = (\n                    sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n)),\n                    sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n)),\n                    sum(distance_matrix_3[candidate[k], candidate[(k+1)%n]] for k in range(n))\n                )\n\n                # Check if improvement in worst objective\n                if new_obj[worst_obj] < current_obj[worst_obj]:\n                    new_solution = candidate\n                    improved = True\n                    break\n\n            if improved:\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.6196300761166416,
            2.619168722629547
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity = normalized_obj.std(axis=0).sum()\n    selected_idx = np.argmax(diversity)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move to improve all objectives\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform objective-aware swaps to balance improvement across objectives\n    for _ in range(2):  # Perform 2 swaps\n        # Calculate current objective values\n        current_obj = (\n            sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        )\n\n        # Find the worst objective to improve\n        worst_obj = np.argmax(current_obj)\n\n        # Select edges to swap based on the worst objective\n        if worst_obj == 0:\n            dist_matrix = distance_matrix_1\n        elif worst_obj == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Find edges with high potential for improvement\n        edge_costs = [dist_matrix[new_solution[k], new_solution[(k+1)%n]] for k in range(n)]\n        sorted_edges = np.argsort(edge_costs)[::-1]  # Highest cost edges first\n\n        # Try swapping nodes to improve the worst objective\n        improved = False\n        for edge_idx in sorted_edges[:3]:  # Try top 3 worst edges\n            a, b = edge_idx, (edge_idx + 1) % n\n            # Try swapping nodes a and b with their neighbors\n            for swap_idx in [a-1, a+1, b-1, b+1]:\n                swap_idx = swap_idx % n\n                if swap_idx == a or swap_idx == b:\n                    continue\n\n                # Create candidate solution\n                candidate = new_solution.copy()\n                candidate[a], candidate[swap_idx] = candidate[swap_idx], candidate[a]\n\n                # Calculate new objective\n                new_obj = (\n                    sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n)),\n                    sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n)),\n                    sum(distance_matrix_3[candidate[k], candidate[(k+1)%n]] for k in range(n))\n                )\n\n                # Check if improvement in worst objective\n                if new_obj[worst_obj] < current_obj[worst_obj]:\n                    new_solution = candidate\n                    improved = True\n                    break\n\n            if improved:\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 81,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select from top 30% of solutions\n        selection_pool = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        base_solution, _ = random.choice(selection_pool)\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operator\n\n    # Select two edges to modify based on which objectives they contribute to\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Calculate the current and potential costs for each objective\n    current_costs = [\n        distance_matrix_1[new_solution[i-1], new_solution[i]] +\n        distance_matrix_1[new_solution[j-1], new_solution[j]],\n        distance_matrix_2[new_solution[i-1], new_solution[i]] +\n        distance_matrix_2[new_solution[j-1], new_solution[j]],\n        distance_matrix_3[new_solution[i-1], new_solution[i]] +\n        distance_matrix_3[new_solution[j-1], new_solution[j]]\n    ]\n\n    potential_costs = [\n        distance_matrix_1[new_solution[i-1], new_solution[j]] +\n        distance_matrix_1[new_solution[j-1], new_solution[i]],\n        distance_matrix_2[new_solution[i-1], new_solution[j]] +\n        distance_matrix_2[new_solution[j-1], new_solution[i]],\n        distance_matrix_3[new_solution[i-1], new_solution[j]] +\n        distance_matrix_3[new_solution[j-1], new_solution[i]]\n    ]\n\n    # Apply the move if it improves at least one objective\n    if any(p < c for p, c in zip(potential_costs, current_costs)):\n        # Perform 2-opt move\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Additional: Try a 3-opt move if the solution is large enough\n    if n >= 6:\n        a, b, c = sorted(random.sample(range(n), 3))\n        current_costs_3opt = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] +\n            distance_matrix_1[new_solution[b-1], new_solution[b]] +\n            distance_matrix_1[new_solution[c-1], new_solution[c]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] +\n            distance_matrix_2[new_solution[b-1], new_solution[b]] +\n            distance_matrix_2[new_solution[c-1], new_solution[c]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] +\n            distance_matrix_3[new_solution[b-1], new_solution[b]] +\n            distance_matrix_3[new_solution[c-1], new_solution[c]]\n        ]\n\n        # Reconnect the three segments in a different order\n        new_solution_3opt = new_solution.copy()\n        new_solution_3opt[a:b] = new_solution_3opt[a:b][::-1]\n        new_solution_3opt[b:c] = new_solution_3opt[b:c][::-1]\n\n        potential_costs_3opt = [\n            distance_matrix_1[new_solution_3opt[a-1], new_solution_3opt[a]] +\n            distance_matrix_1[new_solution_3opt[b-1], new_solution_3opt[b]] +\n            distance_matrix_1[new_solution_3opt[c-1], new_solution_3opt[c]],\n            distance_matrix_2[new_solution_3opt[a-1], new_solution_3opt[a]] +\n            distance_matrix_2[new_solution_3opt[b-1], new_solution_3opt[b]] +\n            distance_matrix_2[new_solution_3opt[c-1], new_solution_3opt[c]],\n            distance_matrix_3[new_solution_3opt[a-1], new_solution_3opt[a]] +\n            distance_matrix_3[new_solution_3opt[b-1], new_solution_3opt[b]] +\n            distance_matrix_3[new_solution_3opt[c-1], new_solution_3opt[c]]\n        ]\n\n        if any(p < c for p, c in zip(potential_costs_3opt, current_costs_3opt)):\n            new_solution = new_solution_3opt\n\n    return new_solution\n\n",
        "score": [
            -0.7289463434071604,
            2.3601572036743166
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select from top 30% of solutions\n        selection_pool = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        base_solution, _ = random.choice(selection_pool)\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operator\n\n    # Select two edges to modify based on which objectives they contribute to\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Calculate the current and potential costs for each objective\n    current_costs = [\n        distance_matrix_1[new_solution[i-1], new_solution[i]] +\n        distance_matrix_1[new_solution[j-1], new_solution[j]],\n        distance_matrix_2[new_solution[i-1], new_solution[i]] +\n        distance_matrix_2[new_solution[j-1], new_solution[j]],\n        distance_matrix_3[new_solution[i-1], new_solution[i]] +\n        distance_matrix_3[new_solution[j-1], new_solution[j]]\n    ]\n\n    potential_costs = [\n        distance_matrix_1[new_solution[i-1], new_solution[j]] +\n        distance_matrix_1[new_solution[j-1], new_solution[i]],\n        distance_matrix_2[new_solution[i-1], new_solution[j]] +\n        distance_matrix_2[new_solution[j-1], new_solution[i]],\n        distance_matrix_3[new_solution[i-1], new_solution[j]] +\n        distance_matrix_3[new_solution[j-1], new_solution[i]]\n    ]\n\n    # Apply the move if it improves at least one objective\n    if any(p < c for p, c in zip(potential_costs, current_costs)):\n        # Perform 2-opt move\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Additional: Try a 3-opt move if the solution is large enough\n    if n >= 6:\n        a, b, c = sorted(random.sample(range(n), 3))\n        current_costs_3opt = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] +\n            distance_matrix_1[new_solution[b-1], new_solution[b]] +\n            distance_matrix_1[new_solution[c-1], new_solution[c]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] +\n            distance_matrix_2[new_solution[b-1], new_solution[b]] +\n            distance_matrix_2[new_solution[c-1], new_solution[c]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] +\n            distance_matrix_3[new_solution[b-1], new_solution[b]] +\n            distance_matrix_3[new_solution[c-1], new_solution[c]]\n        ]\n\n        # Reconnect the three segments in a different order\n        new_solution_3opt = new_solution.copy()\n        new_solution_3opt[a:b] = new_solution_3opt[a:b][::-1]\n        new_solution_3opt[b:c] = new_solution_3opt[b:c][::-1]\n\n        potential_costs_3opt = [\n            distance_matrix_1[new_solution_3opt[a-1], new_solution_3opt[a]] +\n            distance_matrix_1[new_solution_3opt[b-1], new_solution_3opt[b]] +\n            distance_matrix_1[new_solution_3opt[c-1], new_solution_3opt[c]],\n            distance_matrix_2[new_solution_3opt[a-1], new_solution_3opt[a]] +\n            distance_matrix_2[new_solution_3opt[b-1], new_solution_3opt[b]] +\n            distance_matrix_2[new_solution_3opt[c-1], new_solution_3opt[c]],\n            distance_matrix_3[new_solution_3opt[a-1], new_solution_3opt[a]] +\n            distance_matrix_3[new_solution_3opt[b-1], new_solution_3opt[b]] +\n            distance_matrix_3[new_solution_3opt[c-1], new_solution_3opt[c]]\n        ]\n\n        if any(p < c for p, c in zip(potential_costs_3opt, current_costs_3opt)):\n            new_solution = new_solution_3opt\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 82,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best trade-off across objectives using a weighted sum approach\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]  # Random weights for objectives\n    scores = [sum(w * obj for w, obj in zip(weights, objectives)) for _, objectives in archive]\n    selected_idx = np.argmin(scores)  # Select the solution with the best weighted score\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt and 3-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and 3-opt\n    if np.random.rand() < 0.5:\n        # 2-opt: reverse a random segment\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # 3-opt: more complex rearrangement\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        # Apply a 3-opt move (one of several possible rearrangements)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Objective-aware swap: swap nodes that have high cost in at least one objective\n    for _ in range(3):  # Perform a few objective-aware swaps\n        # Find nodes with high cost in any objective\n        costs = []\n        for idx in range(n):\n            prev = new_solution[idx-1]\n            curr = new_solution[idx]\n            next_node = new_solution[(idx+1) % n]\n            cost1 = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]\n            cost2 = distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n            cost3 = distance_matrix_3[prev, curr] + distance_matrix_3[curr, next_node]\n            costs.append(max(cost1, cost2, cost3))  # Use max to find worst-offending nodes\n\n        # Select the worst node to swap\n        worst_idx = np.argmax(costs)\n        swap_candidate = np.random.randint(n)\n        # Ensure the swap keeps the tour valid (no duplicates)\n        if new_solution[worst_idx] != new_solution[swap_candidate]:\n            new_solution[worst_idx], new_solution[swap_candidate] = new_solution[swap_candidate], new_solution[worst_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7442165334911779,
            1.8077308773994445
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best trade-off across objectives using a weighted sum approach\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]  # Random weights for objectives\n    scores = [sum(w * obj for w, obj in zip(weights, objectives)) for _, objectives in archive]\n    selected_idx = np.argmin(scores)  # Select the solution with the best weighted score\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt and 3-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and 3-opt\n    if np.random.rand() < 0.5:\n        # 2-opt: reverse a random segment\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # 3-opt: more complex rearrangement\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        # Apply a 3-opt move (one of several possible rearrangements)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Objective-aware swap: swap nodes that have high cost in at least one objective\n    for _ in range(3):  # Perform a few objective-aware swaps\n        # Find nodes with high cost in any objective\n        costs = []\n        for idx in range(n):\n            prev = new_solution[idx-1]\n            curr = new_solution[idx]\n            next_node = new_solution[(idx+1) % n]\n            cost1 = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]\n            cost2 = distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n            cost3 = distance_matrix_3[prev, curr] + distance_matrix_3[curr, next_node]\n            costs.append(max(cost1, cost2, cost3))  # Use max to find worst-offending nodes\n\n        # Select the worst node to swap\n        worst_idx = np.argmax(costs)\n        swap_candidate = np.random.randint(n)\n        # Ensure the swap keeps the tour valid (no duplicates)\n        if new_solution[worst_idx] != new_solution[swap_candidate]:\n            new_solution[worst_idx], new_solution[swap_candidate] = new_solution[swap_candidate], new_solution[worst_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 83,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.argmax([np.sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a multi-objective aware perturbation\n    n = len(base_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt to the selected segment\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective aware perturbation: swap nodes that are critical in one objective but not in others\n    for _ in range(2):  # Limit the number of perturbations to maintain solution quality\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        # Evaluate the impact on all three objectives\n        obj1_before = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        obj1_after = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n        delta_obj1 = obj1_after - obj1_before\n\n        obj2_before = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        obj2_after = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n        delta_obj2 = obj2_after - obj2_before\n\n        obj3_before = distance_matrix_3[new_solution[k-1], new_solution[k]] + distance_matrix_3[new_solution[l-1], new_solution[l]]\n        obj3_after = distance_matrix_3[new_solution[k-1], new_solution[l]] + distance_matrix_3[new_solution[l-1], new_solution[k]]\n        delta_obj3 = obj3_after - obj3_before\n\n        # Accept the swap if it improves at least one objective without worsening others too much\n        if (delta_obj1 <= 0 or delta_obj2 <= 0 or delta_obj3 <= 0) and not (delta_obj1 > 0 and delta_obj2 > 0 and delta_obj3 > 0):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.6072587381901222,
            2.533467984199524
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.argmax([np.sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a multi-objective aware perturbation\n    n = len(base_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt to the selected segment\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective aware perturbation: swap nodes that are critical in one objective but not in others\n    for _ in range(2):  # Limit the number of perturbations to maintain solution quality\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        # Evaluate the impact on all three objectives\n        obj1_before = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        obj1_after = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n        delta_obj1 = obj1_after - obj1_before\n\n        obj2_before = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        obj2_after = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n        delta_obj2 = obj2_after - obj2_before\n\n        obj3_before = distance_matrix_3[new_solution[k-1], new_solution[k]] + distance_matrix_3[new_solution[l-1], new_solution[l]]\n        obj3_after = distance_matrix_3[new_solution[k-1], new_solution[l]] + distance_matrix_3[new_solution[l-1], new_solution[k]]\n        delta_obj3 = obj3_after - obj3_before\n\n        # Accept the swap if it improves at least one objective without worsening others too much\n        if (delta_obj1 <= 0 or delta_obj2 <= 0 or delta_obj3 <= 0) and not (delta_obj1 > 0 and delta_obj2 > 0 and delta_obj3 > 0):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 84,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    weights = [1.0 / (obj[0] + obj[1] + obj[2] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt, 3-opt, and objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose a local search operator based on the objectives\n    obj_weights = archive[selected_idx][1]\n    total_obj = sum(obj_weights)\n    obj_probs = [obj / total_obj for obj in obj_weights]\n\n    # 2-opt with probability based on objective weights\n    if random.random() < 0.5 + obj_probs[0] * 0.3:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # 3-opt with probability based on objective weights\n    elif random.random() < 0.5 + obj_probs[1] * 0.3:\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n        new_solution[i:k+1] = np.concatenate([segment1[::-1], segment2[::-1]])\n\n    # Objective-aware swap: swap nodes that are close in one objective but far in others\n    else:\n        i, j = random.sample(range(n), 2)\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        # Calculate distance differences\n        dist1_diff = distance_matrix_1[node_i, node_j] - (distance_matrix_1[new_solution[(i-1)%n], node_i] + distance_matrix_1[node_i, new_solution[(i+1)%n]])\n        dist2_diff = distance_matrix_2[node_i, node_j] - (distance_matrix_2[new_solution[(i-1)%n], node_i] + distance_matrix_2[node_i, new_solution[(i+1)%n]])\n        dist3_diff = distance_matrix_3[node_i, node_j] - (distance_matrix_3[new_solution[(i-1)%n], node_i] + distance_matrix_3[node_i, new_solution[(i+1)%n]])\n\n        # Accept swap if it improves at least one objective\n        if (dist1_diff < 0 and obj_probs[0] > 0.3) or \\\n           (dist2_diff < 0 and obj_probs[1] > 0.3) or \\\n           (dist3_diff < 0 and obj_probs[2] > 0.3):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8274868131448876,
            1.6353044033050537
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    weights = [1.0 / (obj[0] + obj[1] + obj[2] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt, 3-opt, and objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose a local search operator based on the objectives\n    obj_weights = archive[selected_idx][1]\n    total_obj = sum(obj_weights)\n    obj_probs = [obj / total_obj for obj in obj_weights]\n\n    # 2-opt with probability based on objective weights\n    if random.random() < 0.5 + obj_probs[0] * 0.3:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # 3-opt with probability based on objective weights\n    elif random.random() < 0.5 + obj_probs[1] * 0.3:\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n        new_solution[i:k+1] = np.concatenate([segment1[::-1], segment2[::-1]])\n\n    # Objective-aware swap: swap nodes that are close in one objective but far in others\n    else:\n        i, j = random.sample(range(n), 2)\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        # Calculate distance differences\n        dist1_diff = distance_matrix_1[node_i, node_j] - (distance_matrix_1[new_solution[(i-1)%n], node_i] + distance_matrix_1[node_i, new_solution[(i+1)%n]])\n        dist2_diff = distance_matrix_2[node_i, node_j] - (distance_matrix_2[new_solution[(i-1)%n], node_i] + distance_matrix_2[node_i, new_solution[(i+1)%n]])\n        dist3_diff = distance_matrix_3[node_i, node_j] - (distance_matrix_3[new_solution[(i-1)%n], node_i] + distance_matrix_3[node_i, new_solution[(i+1)%n]])\n\n        # Accept swap if it improves at least one objective\n        if (dist1_diff < 0 and obj_probs[0] > 0.3) or \\\n           (dist2_diff < 0 and obj_probs[1] > 0.3) or \\\n           (dist3_diff < 0 and obj_probs[2] > 0.3):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 85,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives (promising for further improvement)\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    diversity_weighted_scores = np.sum(objectives * diversity_scores, axis=1)\n\n    # Select top 3 solutions with highest diversity-weighted scores\n    top_indices = np.argsort(diversity_weighted_scores)[-3:]\n    selected_idx = np.random.choice(top_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt and node insertion with objective-aware selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt with objective-aware edge selection\n    for _ in range(5):  # Limited iterations for efficiency\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if j - i > 1:  # Ensure we have at least one node between i and j\n            # Calculate improvement in all three objectives\n            orig_edges = [\n                (new_solution[i], new_solution[(i+1)%n]),\n                (new_solution[j], new_solution[(j+1)%n])\n            ]\n            new_edges = [\n                (new_solution[i], new_solution[j]),\n                (new_solution[(i+1)%n], new_solution[(j+1)%n])\n            ]\n\n            orig_costs = [\n                distance_matrix_1[orig_edges[0][0], orig_edges[0][1]] + distance_matrix_1[orig_edges[1][0], orig_edges[1][1]],\n                distance_matrix_2[orig_edges[0][0], orig_edges[0][1]] + distance_matrix_2[orig_edges[1][0], orig_edges[1][1]],\n                distance_matrix_3[orig_edges[0][0], orig_edges[0][1]] + distance_matrix_3[orig_edges[1][0], orig_edges[1][1]]\n            ]\n\n            new_costs = [\n                distance_matrix_1[new_edges[0][0], new_edges[0][1]] + distance_matrix_1[new_edges[1][0], new_edges[1][1]],\n                distance_matrix_2[new_edges[0][0], new_edges[0][1]] + distance_matrix_2[new_edges[1][0], new_edges[1][1]],\n                distance_matrix_3[new_edges[0][0], new_edges[0][1]] + distance_matrix_3[new_edges[1][0], new_edges[1][1]]\n            ]\n\n            # Accept if at least one objective improves\n            if any(new_cost < orig_cost for new_cost, orig_cost in zip(new_costs, orig_costs)):\n                new_solution[i+1:j+1] = new_solution[j:i:-1]\n\n    # Node insertion with objective-aware selection\n    for _ in range(3):  # Limited iterations for efficiency\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n\n            # Find insertion point that improves the most in any objective\n            best_pos = j\n            best_improvement = -np.inf\n\n            for pos in range(n-1):\n                if pos == i:\n                    continue\n\n                # Calculate cost before and after insertion\n                prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n                next_node = new_solution[pos]\n\n                orig_costs = [\n                    distance_matrix_1[prev_node, next_node],\n                    distance_matrix_2[prev_node, next_node],\n                    distance_matrix_3[prev_node, next_node]\n                ]\n\n                new_costs = [\n                    distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node],\n                    distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node],\n                    distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node]\n                ]\n\n                improvement = sum(new_cost - orig_cost for new_cost, orig_cost in zip(new_costs, orig_costs))\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_pos = pos\n\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7113890786930073,
            3.0221588253974914
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives (promising for further improvement)\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    diversity_weighted_scores = np.sum(objectives * diversity_scores, axis=1)\n\n    # Select top 3 solutions with highest diversity-weighted scores\n    top_indices = np.argsort(diversity_weighted_scores)[-3:]\n    selected_idx = np.random.choice(top_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt and node insertion with objective-aware selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt with objective-aware edge selection\n    for _ in range(5):  # Limited iterations for efficiency\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if j - i > 1:  # Ensure we have at least one node between i and j\n            # Calculate improvement in all three objectives\n            orig_edges = [\n                (new_solution[i], new_solution[(i+1)%n]),\n                (new_solution[j], new_solution[(j+1)%n])\n            ]\n            new_edges = [\n                (new_solution[i], new_solution[j]),\n                (new_solution[(i+1)%n], new_solution[(j+1)%n])\n            ]\n\n            orig_costs = [\n                distance_matrix_1[orig_edges[0][0], orig_edges[0][1]] + distance_matrix_1[orig_edges[1][0], orig_edges[1][1]],\n                distance_matrix_2[orig_edges[0][0], orig_edges[0][1]] + distance_matrix_2[orig_edges[1][0], orig_edges[1][1]],\n                distance_matrix_3[orig_edges[0][0], orig_edges[0][1]] + distance_matrix_3[orig_edges[1][0], orig_edges[1][1]]\n            ]\n\n            new_costs = [\n                distance_matrix_1[new_edges[0][0], new_edges[0][1]] + distance_matrix_1[new_edges[1][0], new_edges[1][1]],\n                distance_matrix_2[new_edges[0][0], new_edges[0][1]] + distance_matrix_2[new_edges[1][0], new_edges[1][1]],\n                distance_matrix_3[new_edges[0][0], new_edges[0][1]] + distance_matrix_3[new_edges[1][0], new_edges[1][1]]\n            ]\n\n            # Accept if at least one objective improves\n            if any(new_cost < orig_cost for new_cost, orig_cost in zip(new_costs, orig_costs)):\n                new_solution[i+1:j+1] = new_solution[j:i:-1]\n\n    # Node insertion with objective-aware selection\n    for _ in range(3):  # Limited iterations for efficiency\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n\n            # Find insertion point that improves the most in any objective\n            best_pos = j\n            best_improvement = -np.inf\n\n            for pos in range(n-1):\n                if pos == i:\n                    continue\n\n                # Calculate cost before and after insertion\n                prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n                next_node = new_solution[pos]\n\n                orig_costs = [\n                    distance_matrix_1[prev_node, next_node],\n                    distance_matrix_2[prev_node, next_node],\n                    distance_matrix_3[prev_node, next_node]\n                ]\n\n                new_costs = [\n                    distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node],\n                    distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node],\n                    distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node]\n                ]\n\n                improvement = sum(new_cost - orig_cost for new_cost, orig_cost in zip(new_costs, orig_costs))\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_pos = pos\n\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 86,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability of being non-dominated and having potential for improvement\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (i + 1) for i in range(len(archive))], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel multi-objective perturbation\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # 2-opt move with multi-objective consideration\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        new_segment = segment[::-1]  # Reverse the segment\n\n        # Calculate the change in all three objectives\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_segment[0]] + distance_matrix_1[new_segment[-1], new_solution[(j+1)%n]]\n\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_segment[0]] + distance_matrix_2[new_segment[-1], new_solution[(j+1)%n]]\n\n        old_cost3 = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        new_cost3 = distance_matrix_3[new_solution[i-1], new_segment[0]] + distance_matrix_3[new_segment[-1], new_solution[(j+1)%n]]\n\n        # Accept the move if it improves at least one objective\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2) or (new_cost3 < old_cost3):\n            new_solution[i:j+1] = new_segment\n\n        # Additional multi-objective perturbation: swap nodes based on their position in different objectives\n        if random.random() < 0.3:  # 30% chance to apply this perturbation\n            # Select nodes based on their relative positions in different objectives\n            node_a = random.choice(new_solution)\n            node_b = random.choice(new_solution)\n\n            # Calculate the relative positions in each objective space\n            pos_a1 = np.where(base_solution == node_a)[0][0]\n            pos_b1 = np.where(base_solution == node_b)[0][0]\n\n            pos_a2 = np.where(np.argsort(instance[:, 2] + instance[:, 3]) == node_a)[0][0]\n            pos_b2 = np.where(np.argsort(instance[:, 2] + instance[:, 3]) == node_b)[0][0]\n\n            pos_a3 = np.where(np.argsort(instance[:, 4] + instance[:, 5]) == node_a)[0][0]\n            pos_b3 = np.where(np.argsort(instance[:, 4] + instance[:, 5]) == node_b)[0][0]\n\n            # If nodes are in similar positions in all objectives, swap them\n            if abs(pos_a1 - pos_b1) < 3 and abs(pos_a2 - pos_b2) < 3 and abs(pos_a3 - pos_b3) < 3:\n                a_idx = np.where(new_solution == node_a)[0][0]\n                b_idx = np.where(new_solution == node_b)[0][0]\n                new_solution[a_idx], new_solution[b_idx] = new_solution[b_idx], new_solution[a_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7464836558326455,
            1.9046377182006835
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability of being non-dominated and having potential for improvement\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (i + 1) for i in range(len(archive))], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel multi-objective perturbation\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # 2-opt move with multi-objective consideration\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        new_segment = segment[::-1]  # Reverse the segment\n\n        # Calculate the change in all three objectives\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_segment[0]] + distance_matrix_1[new_segment[-1], new_solution[(j+1)%n]]\n\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_segment[0]] + distance_matrix_2[new_segment[-1], new_solution[(j+1)%n]]\n\n        old_cost3 = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        new_cost3 = distance_matrix_3[new_solution[i-1], new_segment[0]] + distance_matrix_3[new_segment[-1], new_solution[(j+1)%n]]\n\n        # Accept the move if it improves at least one objective\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2) or (new_cost3 < old_cost3):\n            new_solution[i:j+1] = new_segment\n\n        # Additional multi-objective perturbation: swap nodes based on their position in different objectives\n        if random.random() < 0.3:  # 30% chance to apply this perturbation\n            # Select nodes based on their relative positions in different objectives\n            node_a = random.choice(new_solution)\n            node_b = random.choice(new_solution)\n\n            # Calculate the relative positions in each objective space\n            pos_a1 = np.where(base_solution == node_a)[0][0]\n            pos_b1 = np.where(base_solution == node_b)[0][0]\n\n            pos_a2 = np.where(np.argsort(instance[:, 2] + instance[:, 3]) == node_a)[0][0]\n            pos_b2 = np.where(np.argsort(instance[:, 2] + instance[:, 3]) == node_b)[0][0]\n\n            pos_a3 = np.where(np.argsort(instance[:, 4] + instance[:, 5]) == node_a)[0][0]\n            pos_b3 = np.where(np.argsort(instance[:, 4] + instance[:, 5]) == node_b)[0][0]\n\n            # If nodes are in similar positions in all objectives, swap them\n            if abs(pos_a1 - pos_b1) < 3 and abs(pos_a2 - pos_b2) < 3 and abs(pos_a3 - pos_b3) < 3:\n                a_idx = np.where(new_solution == node_a)[0][0]\n                b_idx = np.where(new_solution == node_b)[0][0]\n                new_solution[a_idx], new_solution[b_idx] = new_solution[b_idx], new_solution[a_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 87,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too good in all objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = normalized_objectives.mean(axis=1)  # Solutions with balanced objectives are more promising\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt and objective-aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move (standard local search)\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware edge swap\n    # Select edges from different objectives to swap\n    obj_weights = np.array([1.0, 1.0, 1.0])  # Equal weights for simplicity\n    obj_weights /= obj_weights.sum()\n\n    # Calculate edge costs in each objective\n    def get_edge_costs(sol):\n        cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return np.array([cost1, cost2, cost3])\n\n    current_costs = get_edge_costs(new_solution)\n\n    # Find the worst objective to improve\n    worst_obj = np.argmax(current_costs)\n\n    # Select edges to swap based on the worst objective\n    if worst_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the most expensive edge in the worst objective\n    max_edge_cost = -1\n    max_edge_idx = -1\n    for i in range(n-1):\n        cost = dist_matrix[new_solution[i], new_solution[i+1]]\n        if cost > max_edge_cost:\n            max_edge_cost = cost\n            max_edge_idx = i\n    cost = dist_matrix[new_solution[-1], new_solution[0]]\n    if cost > max_edge_cost:\n        max_edge_idx = n-1\n\n    # Try to replace this edge with a better one\n    if max_edge_idx == n-1:\n        a, b = new_solution[-1], new_solution[0]\n    else:\n        a, b = new_solution[max_edge_idx], new_solution[max_edge_idx+1]\n\n    # Find the closest node to 'a' that's not 'b' and not already adjacent\n    min_dist = float('inf')\n    best_node = -1\n    for i in range(n):\n        node = new_solution[i]\n        if node == a or node == b:\n            continue\n        dist = dist_matrix[a, node]\n        if dist < min_dist and node not in [new_solution[(max_edge_idx-1)%n], new_solution[(max_edge_idx+1)%n]]:\n            min_dist = dist\n            best_node = node\n\n    if best_node != -1:\n        # Find the position of best_node in the solution\n        best_pos = np.where(new_solution == best_node)[0][0]\n        # Perform the swap\n        if max_edge_idx == n-1:\n            new_solution[best_pos] = new_solution[0]\n            new_solution[0] = best_node\n        else:\n            new_solution[best_pos] = new_solution[max_edge_idx+1]\n            new_solution[max_edge_idx+1] = best_node\n\n    return new_solution\n\n",
        "score": [
            -0.6293763865697757,
            2.0491365432739257
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too good in all objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = normalized_objectives.mean(axis=1)  # Solutions with balanced objectives are more promising\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt and objective-aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move (standard local search)\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware edge swap\n    # Select edges from different objectives to swap\n    obj_weights = np.array([1.0, 1.0, 1.0])  # Equal weights for simplicity\n    obj_weights /= obj_weights.sum()\n\n    # Calculate edge costs in each objective\n    def get_edge_costs(sol):\n        cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return np.array([cost1, cost2, cost3])\n\n    current_costs = get_edge_costs(new_solution)\n\n    # Find the worst objective to improve\n    worst_obj = np.argmax(current_costs)\n\n    # Select edges to swap based on the worst objective\n    if worst_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the most expensive edge in the worst objective\n    max_edge_cost = -1\n    max_edge_idx = -1\n    for i in range(n-1):\n        cost = dist_matrix[new_solution[i], new_solution[i+1]]\n        if cost > max_edge_cost:\n            max_edge_cost = cost\n            max_edge_idx = i\n    cost = dist_matrix[new_solution[-1], new_solution[0]]\n    if cost > max_edge_cost:\n        max_edge_idx = n-1\n\n    # Try to replace this edge with a better one\n    if max_edge_idx == n-1:\n        a, b = new_solution[-1], new_solution[0]\n    else:\n        a, b = new_solution[max_edge_idx], new_solution[max_edge_idx+1]\n\n    # Find the closest node to 'a' that's not 'b' and not already adjacent\n    min_dist = float('inf')\n    best_node = -1\n    for i in range(n):\n        node = new_solution[i]\n        if node == a or node == b:\n            continue\n        dist = dist_matrix[a, node]\n        if dist < min_dist and node not in [new_solution[(max_edge_idx-1)%n], new_solution[(max_edge_idx+1)%n]]:\n            min_dist = dist\n            best_node = node\n\n    if best_node != -1:\n        # Find the position of best_node in the solution\n        best_pos = np.where(new_solution == best_node)[0][0]\n        # Perform the swap\n        if max_edge_idx == n-1:\n            new_solution[best_pos] = new_solution[0]\n            new_solution[0] = best_node\n        else:\n            new_solution[best_pos] = new_solution[max_edge_idx+1]\n            new_solution[max_edge_idx+1] = best_node\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 88,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement by considering the diversity of objectives\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: apply a combination of 2-opt and insertion moves\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    k = np.random.choice(n)\n\n    # Apply 2-opt move\n    if i > j:\n        i, j = j, i\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply insertion move\n    if k > i and k < j:\n        # Avoid invalid insertion by adjusting k\n        k = j if k < n-1 else j-1\n    node = new_solution[k]\n    new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains valid (no duplicates and all nodes are visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7297261598168586,
            1.2588977575302125
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement by considering the diversity of objectives\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: apply a combination of 2-opt and insertion moves\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    k = np.random.choice(n)\n\n    # Apply 2-opt move\n    if i > j:\n        i, j = j, i\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply insertion move\n    if k > i and k < j:\n        # Avoid invalid insertion by adjusting k\n        k = j if k < n-1 else j-1\n    node = new_solution[k]\n    new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains valid (no duplicates and all nodes are visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 89,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or low objective values to encourage diversity and improvement\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()  # Simple selection heuristic\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search operator\n    operator_choice = random.choice(['2opt', 'insertion', 'swap'])\n\n    if operator_choice == '2opt':\n        # 2-opt: Randomly select two edges and reverse the segment between them\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator_choice == 'insertion':\n        # Insertion: Randomly select a node and insert it into a new position\n        node = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    elif operator_choice == 'swap':\n        # Swap: Randomly select two nodes and swap their positions\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (visits each node exactly once)\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.7236740846447789,
            1.573954212665558
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or low objective values to encourage diversity and improvement\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()  # Simple selection heuristic\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search operator\n    operator_choice = random.choice(['2opt', 'insertion', 'swap'])\n\n    if operator_choice == '2opt':\n        # 2-opt: Randomly select two edges and reverse the segment between them\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator_choice == 'insertion':\n        # Insertion: Randomly select a node and insert it into a new position\n        node = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    elif operator_choice == 'swap':\n        # Swap: Randomly select two nodes and swap their positions\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (visits each node exactly once)\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 90,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low crowding distance (promising for improvement)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt to the segment\n    segment = new_solution[i:j+1]\n    segment_reversed = segment[::-1]\n    new_solution[i:j+1] = segment_reversed\n\n    # Objective-aware swap: find the best node to swap with another based on all three objectives\n    if n > 2:\n        # Evaluate all possible 1-swaps in the segment\n        best_improvement = 0\n        best_swap = None\n\n        for k in range(i, j+1):\n            for l in range(n):\n                if l < i or l > j:\n                    # Calculate change in all three objectives\n                    delta1 = (distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                              distance_matrix_1[new_solution[l], new_solution[(k+1)%n]]) - \\\n                             (distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                              distance_matrix_1[new_solution[k], new_solution[(k+1)%n]])\n\n                    delta2 = (distance_matrix_2[new_solution[k-1], new_solution[l]] +\n                              distance_matrix_2[new_solution[l], new_solution[(k+1)%n]]) - \\\n                             (distance_matrix_2[new_solution[k-1], new_solution[k]] +\n                              distance_matrix_2[new_solution[k], new_solution[(k+1)%n]])\n\n                    delta3 = (distance_matrix_3[new_solution[k-1], new_solution[l]] +\n                              distance_matrix_3[new_solution[l], new_solution[(k+1)%n]]) - \\\n                             (distance_matrix_3[new_solution[k-1], new_solution[k]] +\n                              distance_matrix_3[new_solution[k], new_solution[(k+1)%n]])\n\n                    # Simple improvement measure (sum of improvements)\n                    improvement = -delta1 - delta2 - delta3\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_swap = (k, l)\n\n        if best_swap is not None:\n            k, l = best_swap\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.822874541897342,
            3.278119444847107
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low crowding distance (promising for improvement)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt to the segment\n    segment = new_solution[i:j+1]\n    segment_reversed = segment[::-1]\n    new_solution[i:j+1] = segment_reversed\n\n    # Objective-aware swap: find the best node to swap with another based on all three objectives\n    if n > 2:\n        # Evaluate all possible 1-swaps in the segment\n        best_improvement = 0\n        best_swap = None\n\n        for k in range(i, j+1):\n            for l in range(n):\n                if l < i or l > j:\n                    # Calculate change in all three objectives\n                    delta1 = (distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                              distance_matrix_1[new_solution[l], new_solution[(k+1)%n]]) - \\\n                             (distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                              distance_matrix_1[new_solution[k], new_solution[(k+1)%n]])\n\n                    delta2 = (distance_matrix_2[new_solution[k-1], new_solution[l]] +\n                              distance_matrix_2[new_solution[l], new_solution[(k+1)%n]]) - \\\n                             (distance_matrix_2[new_solution[k-1], new_solution[k]] +\n                              distance_matrix_2[new_solution[k], new_solution[(k+1)%n]])\n\n                    delta3 = (distance_matrix_3[new_solution[k-1], new_solution[l]] +\n                              distance_matrix_3[new_solution[l], new_solution[(k+1)%n]]) - \\\n                             (distance_matrix_3[new_solution[k-1], new_solution[k]] +\n                              distance_matrix_3[new_solution[k], new_solution[(k+1)%n]])\n\n                    # Simple improvement measure (sum of improvements)\n                    improvement = -delta1 - delta2 - delta3\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_swap = (k, l)\n\n        if best_swap is not None:\n            k, l = best_swap\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 91,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (not just the first one)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful changes\n\n    # First perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then perform an objective-aware swap\n    # Calculate current objectives\n    current_obj1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    current_obj2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    current_obj3 = sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n    # Find the worst objective\n    objectives = [current_obj1, current_obj2, current_obj3]\n    worst_obj_idx = np.argmax(objectives)\n\n    # Swap nodes to improve the worst objective\n    if worst_obj_idx == 0:\n        # For first objective, find the pair with highest distance\n        max_dist = -1\n        best_i, best_j = 0, 0\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = distance_matrix_1[base_solution[i], base_solution[j]]\n                if dist > max_dist:\n                    max_dist = dist\n                    best_i, best_j = i, j\n        # Swap these nodes\n        new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n    elif worst_obj_idx == 1:\n        # For second objective, find the pair with highest distance\n        max_dist = -1\n        best_i, best_j = 0, 0\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = distance_matrix_2[base_solution[i], base_solution[j]]\n                if dist > max_dist:\n                    max_dist = dist\n                    best_i, best_j = i, j\n        # Swap these nodes\n        new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n    else:\n        # For third objective, find the pair with highest distance\n        max_dist = -1\n        best_i, best_j = 0, 0\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = distance_matrix_3[base_solution[i], base_solution[j]]\n                if dist > max_dist:\n                    max_dist = dist\n                    best_i, best_j = i, j\n        # Swap these nodes\n        new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    return new_solution\n\n",
        "score": [
            -0.6786200492439142,
            2.567291867733002
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (not just the first one)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful changes\n\n    # First perform a 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then perform an objective-aware swap\n    # Calculate current objectives\n    current_obj1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    current_obj2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    current_obj3 = sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n    # Find the worst objective\n    objectives = [current_obj1, current_obj2, current_obj3]\n    worst_obj_idx = np.argmax(objectives)\n\n    # Swap nodes to improve the worst objective\n    if worst_obj_idx == 0:\n        # For first objective, find the pair with highest distance\n        max_dist = -1\n        best_i, best_j = 0, 0\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = distance_matrix_1[base_solution[i], base_solution[j]]\n                if dist > max_dist:\n                    max_dist = dist\n                    best_i, best_j = i, j\n        # Swap these nodes\n        new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n    elif worst_obj_idx == 1:\n        # For second objective, find the pair with highest distance\n        max_dist = -1\n        best_i, best_j = 0, 0\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = distance_matrix_2[base_solution[i], base_solution[j]]\n                if dist > max_dist:\n                    max_dist = dist\n                    best_i, best_j = i, j\n        # Swap these nodes\n        new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n    else:\n        # For third objective, find the pair with highest distance\n        max_dist = -1\n        best_i, best_j = 0, 0\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = distance_matrix_3[base_solution[i], base_solution[j]]\n                if dist > max_dist:\n                    max_dist = dist\n                    best_i, best_j = i, j\n        # Swap these nodes\n        new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 92,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with the highest total distance in at least one objective)\n    objectives = np.array([obj for _, obj in archive])\n    total_distances = np.sum(objectives, axis=1)\n    candidate_indices = np.argsort(total_distances)[-max(3, len(archive)//2):]  # Top 3 or half of archive\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between 2-opt and 3-opt with equal probability\n    if np.random.rand() < 0.5:\n        # 2-opt local search\n        i, j = np.random.choice(n, size=2, replace=False)\n        i, j = min(i, j), max(i, j)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # 3-opt local search\n        i, j, k = np.random.choice(n, size=3, replace=False)\n        i, j, k = sorted([i, j, k])\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if 3-opt fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        i, j = min(i, j), max(i, j)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6122905477855082,
            1.8360503673553468
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with the highest total distance in at least one objective)\n    objectives = np.array([obj for _, obj in archive])\n    total_distances = np.sum(objectives, axis=1)\n    candidate_indices = np.argsort(total_distances)[-max(3, len(archive)//2):]  # Top 3 or half of archive\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between 2-opt and 3-opt with equal probability\n    if np.random.rand() < 0.5:\n        # 2-opt local search\n        i, j = np.random.choice(n, size=2, replace=False)\n        i, j = min(i, j), max(i, j)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # 3-opt local search\n        i, j, k = np.random.choice(n, size=3, replace=False)\n        i, j, k = sorted([i, j, k])\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if 3-opt fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        i, j = min(i, j), max(i, j)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 93,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (lower is better)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Randomly select from top 30% of solutions\n        selection_pool = archive_sorted[:max(1, int(0.3 * len(archive)))]\n        selected = random.choice(selection_pool)\n    else:\n        selected = archive[0]\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Determine which objective to prioritize based on the current solution's performance\n        obj_values = selected[1]\n        worst_obj = np.argmax(obj_values)\n\n        # Apply different operators based on the worst objective\n        if worst_obj == 0:\n            # For worst objective 1, apply 2-opt with distance_matrix_1\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif worst_obj == 1:\n            # For worst objective 2, apply a combination of 2-opt and node insertion\n            # First perform 2-opt on distance_matrix_2\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            # Then perform node insertion based on distance_matrix_1\n            k = random.randint(0, n-1)\n            node = new_solution[k]\n            new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n            insert_pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n        else:\n            # For worst objective 3, apply a 3-opt operation\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution[i:k+1] = np.concatenate([segment2, segment1])\n\n    return new_solution\n\n",
        "score": [
            -0.7617284939058976,
            1.3653062105178833
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (lower is better)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Randomly select from top 30% of solutions\n        selection_pool = archive_sorted[:max(1, int(0.3 * len(archive)))]\n        selected = random.choice(selection_pool)\n    else:\n        selected = archive[0]\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Determine which objective to prioritize based on the current solution's performance\n        obj_values = selected[1]\n        worst_obj = np.argmax(obj_values)\n\n        # Apply different operators based on the worst objective\n        if worst_obj == 0:\n            # For worst objective 1, apply 2-opt with distance_matrix_1\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif worst_obj == 1:\n            # For worst objective 2, apply a combination of 2-opt and node insertion\n            # First perform 2-opt on distance_matrix_2\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            # Then perform node insertion based on distance_matrix_1\n            k = random.randint(0, n-1)\n            node = new_solution[k]\n            new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n            insert_pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n        else:\n            # For worst objective 3, apply a 3-opt operation\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution[i:k+1] = np.concatenate([segment2, segment1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 94,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already well-optimized in all objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search strategy:\n    # 1. Perform a 2-opt move based on the objective with the highest current cost\n    # 2. If no improvement, perform a 3-opt move\n    # 3. If still no improvement, perform a random swap\n\n    def calculate_total_cost(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(len(solution)-1)) + distance_matrix_1[solution[-1], solution[0]]\n        cost2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(len(solution)-1)) + distance_matrix_2[solution[-1], solution[0]]\n        cost3 = sum(distance_matrix_3[solution[i], solution[i+1]] for i in range(len(solution)-1)) + distance_matrix_3[solution[-1], solution[0]]\n        return (cost1, cost2, cost3)\n\n    original_cost = calculate_total_cost(selected_solution)\n    improved = False\n\n    # 1. 2-opt move based on the worst objective\n    worst_obj = np.argmax(original_cost)\n    if worst_obj == 0:\n        d_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        d_matrix = distance_matrix_2\n    else:\n        d_matrix = distance_matrix_3\n\n    n = len(selected_solution)\n    for i in range(n - 1):\n        for j in range(i + 2, n):\n            # Try reversing the segment between i and j\n            new_solution = selected_solution.copy()\n            new_solution[i+1:j+1] = selected_solution[j:i:-1]\n\n            # Check if the new solution is better\n            new_cost = calculate_total_cost(new_solution)\n            if new_cost[worst_obj] < original_cost[worst_obj]:\n                selected_solution = new_solution\n                original_cost = new_cost\n                improved = True\n                break\n        if improved:\n            break\n\n    if not improved:\n        # 2. Try 3-opt move if 2-opt didn't improve\n        for i in range(n - 5):\n            for j in range(i + 2, n - 3):\n                for k in range(j + 2, n - 1):\n                    # Try different 3-opt configurations\n                    for config in [\n                        (i, j, k), (i, k, j), (j, i, k),\n                        (j, k, i), (k, i, j), (k, j, i)\n                    ]:\n                        a, b, c = config\n                        new_solution = selected_solution.copy()\n                        new_solution[a+1:b+1] = selected_solution[b:a:-1]\n                        new_solution[b+1:c+1] = selected_solution[c:b:-1]\n\n                        new_cost = calculate_total_cost(new_solution)\n                        if any(new_cost[obj] < original_cost[obj] for obj in range(3)):\n                            selected_solution = new_solution\n                            original_cost = new_cost\n                            improved = True\n                            break\n                    if improved:\n                        break\n                if improved:\n                    break\n            if improved:\n                break\n\n    if not improved:\n        # 3. Random swap if no improvement found\n        i, j = np.random.choice(n, size=2, replace=False)\n        selected_solution[i], selected_solution[j] = selected_solution[j], selected_solution[i]\n\n    return selected_solution\n\n",
        "score": [
            -0.6672578195728153,
            1.1935244441032409
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already well-optimized in all objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search strategy:\n    # 1. Perform a 2-opt move based on the objective with the highest current cost\n    # 2. If no improvement, perform a 3-opt move\n    # 3. If still no improvement, perform a random swap\n\n    def calculate_total_cost(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(len(solution)-1)) + distance_matrix_1[solution[-1], solution[0]]\n        cost2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(len(solution)-1)) + distance_matrix_2[solution[-1], solution[0]]\n        cost3 = sum(distance_matrix_3[solution[i], solution[i+1]] for i in range(len(solution)-1)) + distance_matrix_3[solution[-1], solution[0]]\n        return (cost1, cost2, cost3)\n\n    original_cost = calculate_total_cost(selected_solution)\n    improved = False\n\n    # 1. 2-opt move based on the worst objective\n    worst_obj = np.argmax(original_cost)\n    if worst_obj == 0:\n        d_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        d_matrix = distance_matrix_2\n    else:\n        d_matrix = distance_matrix_3\n\n    n = len(selected_solution)\n    for i in range(n - 1):\n        for j in range(i + 2, n):\n            # Try reversing the segment between i and j\n            new_solution = selected_solution.copy()\n            new_solution[i+1:j+1] = selected_solution[j:i:-1]\n\n            # Check if the new solution is better\n            new_cost = calculate_total_cost(new_solution)\n            if new_cost[worst_obj] < original_cost[worst_obj]:\n                selected_solution = new_solution\n                original_cost = new_cost\n                improved = True\n                break\n        if improved:\n            break\n\n    if not improved:\n        # 2. Try 3-opt move if 2-opt didn't improve\n        for i in range(n - 5):\n            for j in range(i + 2, n - 3):\n                for k in range(j + 2, n - 1):\n                    # Try different 3-opt configurations\n                    for config in [\n                        (i, j, k), (i, k, j), (j, i, k),\n                        (j, k, i), (k, i, j), (k, j, i)\n                    ]:\n                        a, b, c = config\n                        new_solution = selected_solution.copy()\n                        new_solution[a+1:b+1] = selected_solution[b:a:-1]\n                        new_solution[b+1:c+1] = selected_solution[c:b:-1]\n\n                        new_cost = calculate_total_cost(new_solution)\n                        if any(new_cost[obj] < original_cost[obj] for obj in range(3)):\n                            selected_solution = new_solution\n                            original_cost = new_cost\n                            improved = True\n                            break\n                    if improved:\n                        break\n                if improved:\n                    break\n            if improved:\n                break\n\n    if not improved:\n        # 3. Random swap if no improvement found\n        i, j = np.random.choice(n, size=2, replace=False)\n        selected_solution[i], selected_solution[j] = selected_solution[j], selected_solution[i]\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 95,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with the worst objective but good diversity)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware segment reversal\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # 2-opt swap\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware segment reversal: reverse a segment if it improves at least one objective\n    segment = new_solution[i:j]\n    reversed_segment = segment[::-1]\n\n    # Calculate cost before and after reversal\n    def calculate_cost(solution, distance_matrix):\n        cost = 0\n        for k in range(len(solution) - 1):\n            cost += distance_matrix[solution[k], solution[k+1]]\n        cost += distance_matrix[solution[-1], solution[0]]  # complete the tour\n        return cost\n\n    original_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    original_cost2 = calculate_cost(new_solution, distance_matrix_2)\n    original_cost3 = calculate_cost(new_solution, distance_matrix_3)\n\n    # Try reversing the segment\n    temp_solution = new_solution.copy()\n    temp_solution[i:j] = reversed_segment\n    reversed_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    reversed_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n    reversed_cost3 = calculate_cost(temp_solution, distance_matrix_3)\n\n    # Accept if at least one objective improves\n    if (reversed_cost1 < original_cost1) or (reversed_cost2 < original_cost2) or (reversed_cost3 < original_cost3):\n        new_solution = temp_solution\n\n    # Additional: try inserting a node in a different position if it improves multiple objectives\n    if random.random() < 0.3:  # 30% chance for this operation\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n\n        # Find the best insertion position that improves at least two objectives\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos == k or pos == (k-1) % n:\n                continue\n\n            temp_solution = new_solution.copy()\n            temp_solution = np.roll(temp_solution, -k)\n            temp_solution = np.roll(temp_solution, pos)\n\n            cost1 = calculate_cost(temp_solution, distance_matrix_1)\n            cost2 = calculate_cost(temp_solution, distance_matrix_2)\n            cost3 = calculate_cost(temp_solution, distance_matrix_3)\n\n            improvement = (min(original_cost1 - cost1, 0) + min(original_cost2 - cost2, 0) + min(original_cost3 - cost3, 0))\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = new_solution.copy()\n            new_solution = np.roll(new_solution, -k)\n            new_solution = np.roll(new_solution, best_pos)\n\n    return new_solution\n\n",
        "score": [
            -0.7509046883468744,
            2.9096324920654295
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with the worst objective but good diversity)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware segment reversal\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # 2-opt swap\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware segment reversal: reverse a segment if it improves at least one objective\n    segment = new_solution[i:j]\n    reversed_segment = segment[::-1]\n\n    # Calculate cost before and after reversal\n    def calculate_cost(solution, distance_matrix):\n        cost = 0\n        for k in range(len(solution) - 1):\n            cost += distance_matrix[solution[k], solution[k+1]]\n        cost += distance_matrix[solution[-1], solution[0]]  # complete the tour\n        return cost\n\n    original_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    original_cost2 = calculate_cost(new_solution, distance_matrix_2)\n    original_cost3 = calculate_cost(new_solution, distance_matrix_3)\n\n    # Try reversing the segment\n    temp_solution = new_solution.copy()\n    temp_solution[i:j] = reversed_segment\n    reversed_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    reversed_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n    reversed_cost3 = calculate_cost(temp_solution, distance_matrix_3)\n\n    # Accept if at least one objective improves\n    if (reversed_cost1 < original_cost1) or (reversed_cost2 < original_cost2) or (reversed_cost3 < original_cost3):\n        new_solution = temp_solution\n\n    # Additional: try inserting a node in a different position if it improves multiple objectives\n    if random.random() < 0.3:  # 30% chance for this operation\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n\n        # Find the best insertion position that improves at least two objectives\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos == k or pos == (k-1) % n:\n                continue\n\n            temp_solution = new_solution.copy()\n            temp_solution = np.roll(temp_solution, -k)\n            temp_solution = np.roll(temp_solution, pos)\n\n            cost1 = calculate_cost(temp_solution, distance_matrix_1)\n            cost2 = calculate_cost(temp_solution, distance_matrix_2)\n            cost3 = calculate_cost(temp_solution, distance_matrix_3)\n\n            improvement = (min(original_cost1 - cost1, 0) + min(original_cost2 - cost2, 0) + min(original_cost3 - cost3, 0))\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = new_solution.copy()\n            new_solution = np.roll(new_solution, -k)\n            new_solution = np.roll(new_solution, best_pos)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 96,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low crowding distance in the archive\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with multi-objective aware perturbation\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n\n    # Apply 2-opt to reverse a segment of the tour\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate the change in objectives\n    def calculate_objective(solution):\n        total_1 = sum(distance_matrix_1[solution[k-1], solution[k]] for k in range(n))\n        total_2 = sum(distance_matrix_2[solution[k-1], solution[k]] for k in range(n))\n        total_3 = sum(distance_matrix_3[solution[k-1], solution[k]] for k in range(n))\n        return (total_1, total_2, total_3)\n\n    original_obj = calculate_objective(base_solution)\n    new_obj = calculate_objective(new_solution)\n\n    # If the new solution is worse, apply a multi-objective aware perturbation\n    if any(new_o > orig_o for new_o, orig_o in zip(new_obj, original_obj)):\n        # Perturb the solution by swapping two random nodes\n        k, l = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7361359756213479,
            1.9446423172950744
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low crowding distance in the archive\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with multi-objective aware perturbation\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n\n    # Apply 2-opt to reverse a segment of the tour\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Calculate the change in objectives\n    def calculate_objective(solution):\n        total_1 = sum(distance_matrix_1[solution[k-1], solution[k]] for k in range(n))\n        total_2 = sum(distance_matrix_2[solution[k-1], solution[k]] for k in range(n))\n        total_3 = sum(distance_matrix_3[solution[k-1], solution[k]] for k in range(n))\n        return (total_1, total_2, total_3)\n\n    original_obj = calculate_objective(base_solution)\n    new_obj = calculate_objective(new_solution)\n\n    # If the new solution is worse, apply a multi-objective aware perturbation\n    if any(new_o > orig_o for new_o, orig_o in zip(new_obj, original_obj)):\n        # Perturb the solution by swapping two random nodes\n        k, l = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 97,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with high crowding distance)\n    # Here we use a simple heuristic: select the solution with the highest sum of objectives\n    objectives = [obj for sol, obj in archive]\n    max_obj_index = np.argmax([sum(obj) for obj in objectives])\n    base_solution = archive[max_obj_index][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, use a simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # For larger tours, use a combination of 2-opt and multi-objective edge swaps\n        # First perform a 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Then perform a multi-objective edge swap\n        # Select two random edges and attempt to swap them\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                  distance_matrix_1[new_solution[c-1], new_solution[d]] -\n                  distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                  distance_matrix_1[new_solution[c-1], new_solution[c]])\n\n        delta2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                  distance_matrix_2[new_solution[c-1], new_solution[d]] -\n                  distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                  distance_matrix_2[new_solution[c-1], new_solution[c]])\n\n        delta3 = (distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                  distance_matrix_3[new_solution[c-1], new_solution[d]] -\n                  distance_matrix_3[new_solution[a-1], new_solution[a]] -\n                  distance_matrix_3[new_solution[c-1], new_solution[c]])\n\n        # If the swap improves at least one objective, perform it\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            # Perform the swap\n            new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.5422685580301279,
            1.7941309928894043
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with high crowding distance)\n    # Here we use a simple heuristic: select the solution with the highest sum of objectives\n    objectives = [obj for sol, obj in archive]\n    max_obj_index = np.argmax([sum(obj) for obj in objectives])\n    base_solution = archive[max_obj_index][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, use a simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # For larger tours, use a combination of 2-opt and multi-objective edge swaps\n        # First perform a 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Then perform a multi-objective edge swap\n        # Select two random edges and attempt to swap them\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                  distance_matrix_1[new_solution[c-1], new_solution[d]] -\n                  distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                  distance_matrix_1[new_solution[c-1], new_solution[c]])\n\n        delta2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                  distance_matrix_2[new_solution[c-1], new_solution[d]] -\n                  distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                  distance_matrix_2[new_solution[c-1], new_solution[c]])\n\n        delta3 = (distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                  distance_matrix_3[new_solution[c-1], new_solution[d]] -\n                  distance_matrix_3[new_solution[a-1], new_solution[a]] -\n                  distance_matrix_3[new_solution[c-1], new_solution[c]])\n\n        # If the swap improves at least one objective, perform it\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            # Perform the swap\n            new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 98,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # Here, we select a solution with the highest sum of objectives (as a proxy for worse solutions)\n    objectives = [obj for _, obj in archive]\n    max_obj_sum = max(sum(obj) for obj in objectives)\n    candidates = [sol for sol, obj in archive if sum(obj) == max_obj_sum]\n\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n\n    base_solution = random.choice(candidates).copy()\n\n    # Hybrid local search operator: combination of 2-opt and node insertion\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Apply 2-opt with a probability of 0.7\n    if random.random() < 0.7:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply node insertion with a probability of 0.5\n    if random.random() < 0.5:\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7628262623397934,
            1.614314329624176
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # Here, we select a solution with the highest sum of objectives (as a proxy for worse solutions)\n    objectives = [obj for _, obj in archive]\n    max_obj_sum = max(sum(obj) for obj in objectives)\n    candidates = [sol for sol, obj in archive if sum(obj) == max_obj_sum]\n\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n\n    base_solution = random.choice(candidates).copy()\n\n    # Hybrid local search operator: combination of 2-opt and node insertion\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Apply 2-opt with a probability of 0.7\n    if random.random() < 0.7:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply node insertion with a probability of 0.5\n    if random.random() < 0.5:\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 99,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate the standard deviation of each objective across the archive\n        objectives = np.array([obj for (sol, obj) in archive])\n        std_devs = np.std(objectives, axis=0)\n\n        # Select solutions with high variance in any objective (potential for improvement)\n        candidate_indices = [i for i in range(len(archive)) if any(std_devs > 0.1 * np.mean(objectives, axis=0))]\n        if candidate_indices:\n            selected_idx = np.random.choice(candidate_indices)\n            base_solution = archive[selected_idx][0].copy()\n        else:\n            selected_idx = np.random.choice(len(archive))\n            base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: apply a combination of 2-opt and edge insertion\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    k = np.random.randint(0, n)\n\n    # Apply 2-opt swap\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Apply edge insertion: move the segment between k and j to position after i\n    if k < i:\n        segment = new_solution[k:i]\n        new_solution = np.concatenate([new_solution[:k], new_solution[i:], segment])\n    else:\n        segment = new_solution[i:k]\n        new_solution = np.concatenate([new_solution[:i], new_solution[k:], segment])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.76353678242298,
            4.44341938495636
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate the standard deviation of each objective across the archive\n        objectives = np.array([obj for (sol, obj) in archive])\n        std_devs = np.std(objectives, axis=0)\n\n        # Select solutions with high variance in any objective (potential for improvement)\n        candidate_indices = [i for i in range(len(archive)) if any(std_devs > 0.1 * np.mean(objectives, axis=0))]\n        if candidate_indices:\n            selected_idx = np.random.choice(candidate_indices)\n            base_solution = archive[selected_idx][0].copy()\n        else:\n            selected_idx = np.random.choice(len(archive))\n            base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: apply a combination of 2-opt and edge insertion\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    k = np.random.randint(0, n)\n\n    # Apply 2-opt swap\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Apply edge insertion: move the segment between k and j to position after i\n    if k < i:\n        segment = new_solution[k:i]\n        new_solution = np.concatenate([new_solution[:k], new_solution[i:], segment])\n    else:\n        segment = new_solution[i:k]\n        new_solution = np.concatenate([new_solution[:i], new_solution[k:], segment])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 100,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (not just the first one)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(1, 0.1, len(archive)) / np.linspace(1, 0.1, len(archive)).sum())\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware edge swaps\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(np.arange(n), size=2, replace=False))\n\n    # Perform 2-opt swap\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware edge selection: choose the best edge to swap based on all three objectives\n    for _ in range(3):  # Try multiple times to find an improving move\n        a, b = sorted(np.random.choice(np.arange(n), size=2, replace=False))\n\n        # Calculate current and potential costs for all three objectives\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] +\n            distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] +\n            distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] +\n            distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n\n        potential_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] +\n            distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] +\n            distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] +\n            distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        # If the swap improves at least one objective without worsening others too much\n        if (any(p < c for p, c in zip(potential_costs, current_costs)) and\n            not any(p > 1.1 * c for p, c in zip(potential_costs, current_costs))):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7262503442328341,
            2.003393089771271
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (not just the first one)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(1, 0.1, len(archive)) / np.linspace(1, 0.1, len(archive)).sum())\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware edge swaps\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(np.arange(n), size=2, replace=False))\n\n    # Perform 2-opt swap\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware edge selection: choose the best edge to swap based on all three objectives\n    for _ in range(3):  # Try multiple times to find an improving move\n        a, b = sorted(np.random.choice(np.arange(n), size=2, replace=False))\n\n        # Calculate current and potential costs for all three objectives\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] +\n            distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] +\n            distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] +\n            distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n\n        potential_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] +\n            distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] +\n            distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] +\n            distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        # If the swap improves at least one objective without worsening others too much\n        if (any(p < c for p, c in zip(potential_costs, current_costs)) and\n            not any(p > 1.1 * c for p, c in zip(potential_costs, current_costs))):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 101,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = []\n    for sol, obj in archive:\n        # Calculate diversity metric (e.g., number of unique segments)\n        diversity = len(set(zip(sol[:-1], sol[1:])))\n        # Combine diversity and objective values for selection\n        score = diversity + sum(obj)  # Simple weighted combination\n        candidates.append((score, sol))\n\n    # Sort by score and select top 10% candidates\n    candidates.sort(key=lambda x: x[0])\n    top_candidates = candidates[:max(1, len(candidates) // 10)]\n\n    # Randomly select a base solution from top candidates\n    base_solution = random.choice(top_candidates)[1].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # For larger tours, apply a more sophisticated operator\n        operator = random.choice(['2-opt', 'swap', 'inversion'])\n\n        if operator == '2-opt':\n            # 2-opt for one of the objectives\n            obj_idx = random.choice([0, 1, 2])\n            if obj_idx == 0:\n                dm = distance_matrix_1\n            elif obj_idx == 1:\n                dm = distance_matrix_2\n            else:\n                dm = distance_matrix_3\n\n            i, j = sorted(random.sample(range(n), 2))\n            if j > i + 1:\n                # Reverse the segment between i and j\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n        elif operator == 'swap':\n            # Swap two nodes\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        elif operator == 'inversion':\n            # Invert a random segment\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7102853892941517,
            3.205739688873291
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = []\n    for sol, obj in archive:\n        # Calculate diversity metric (e.g., number of unique segments)\n        diversity = len(set(zip(sol[:-1], sol[1:])))\n        # Combine diversity and objective values for selection\n        score = diversity + sum(obj)  # Simple weighted combination\n        candidates.append((score, sol))\n\n    # Sort by score and select top 10% candidates\n    candidates.sort(key=lambda x: x[0])\n    top_candidates = candidates[:max(1, len(candidates) // 10)]\n\n    # Randomly select a base solution from top candidates\n    base_solution = random.choice(top_candidates)[1].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # For larger tours, apply a more sophisticated operator\n        operator = random.choice(['2-opt', 'swap', 'inversion'])\n\n        if operator == '2-opt':\n            # 2-opt for one of the objectives\n            obj_idx = random.choice([0, 1, 2])\n            if obj_idx == 0:\n                dm = distance_matrix_1\n            elif obj_idx == 1:\n                dm = distance_matrix_2\n            else:\n                dm = distance_matrix_3\n\n            i, j = sorted(random.sample(range(n), 2))\n            if j > i + 1:\n                # Reverse the segment between i and j\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n        elif operator == 'swap':\n            # Swap two nodes\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        elif operator == 'inversion':\n            # Invert a random segment\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 102,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest sum of normalized objectives (more room for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized_obj.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with multi-objective edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select two random edges to break\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Calculate potential improvement for all possible reconnections\n    improvements = []\n    for k in range(i+1, j):\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[k]] +\n                  distance_matrix_1[new_solution[j], new_solution[(k+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[j]] -\n                  distance_matrix_1[new_solution[k], new_solution[(k+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[k]] +\n                  distance_matrix_2[new_solution[j], new_solution[(k+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[j]] -\n                  distance_matrix_2[new_solution[k], new_solution[(k+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[k]] +\n                  distance_matrix_3[new_solution[j], new_solution[(k+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[j]] -\n                  distance_matrix_3[new_solution[k], new_solution[(k+1)%n]])\n\n        # Combine improvements using a weighted sum (could be adaptive)\n        total_improvement = 0.33 * delta1 + 0.33 * delta2 + 0.33 * delta3\n        improvements.append((total_improvement, k))\n\n    if improvements:\n        # Select the reconnection with the best improvement\n        best_improvement, best_k = max(improvements, key=lambda x: x[0])\n        # Perform the 2-opt move\n        new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    return new_solution\n\n",
        "score": [
            -0.5984846958061292,
            2.0201921343803404
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest sum of normalized objectives (more room for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized_obj.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with multi-objective edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select two random edges to break\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Calculate potential improvement for all possible reconnections\n    improvements = []\n    for k in range(i+1, j):\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[k]] +\n                  distance_matrix_1[new_solution[j], new_solution[(k+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[j]] -\n                  distance_matrix_1[new_solution[k], new_solution[(k+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[k]] +\n                  distance_matrix_2[new_solution[j], new_solution[(k+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[j]] -\n                  distance_matrix_2[new_solution[k], new_solution[(k+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[k]] +\n                  distance_matrix_3[new_solution[j], new_solution[(k+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[j]] -\n                  distance_matrix_3[new_solution[k], new_solution[(k+1)%n]])\n\n        # Combine improvements using a weighted sum (could be adaptive)\n        total_improvement = 0.33 * delta1 + 0.33 * delta2 + 0.33 * delta3\n        improvements.append((total_improvement, k))\n\n    if improvements:\n        # Select the reconnection with the best improvement\n        best_improvement, best_k = max(improvements, key=lambda x: x[0])\n        # Perform the 2-opt move\n        new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 103,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest crowding distance in the objective space\n    def crowding_distance(obj_values):\n        obj_values = np.array(obj_values)\n        distances = np.zeros(len(obj_values))\n        for m in range(obj_values.shape[1]):\n            sorted_indices = np.argsort(obj_values[:, m])\n            sorted_obj = obj_values[sorted_indices, m]\n            distances[sorted_indices[0]] = np.inf\n            distances[sorted_indices[-1]] = np.inf\n            for i in range(1, len(sorted_obj) - 1):\n                distances[sorted_indices[i]] += (sorted_obj[i+1] - sorted_obj[i-1]) / (sorted_obj[-1] - sorted_obj[0] + 1e-10)\n        return distances\n\n    objectives = np.array([obj for (sol, obj) in archive])\n    distances = crowding_distance(objectives)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt move\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: find the best swap to improve at least one objective\n    best_improvement = 0\n    best_swap = None\n\n    for _ in range(min(10, n)):  # Limit number of swaps to explore\n        a, b = sorted(np.random.choice(range(n), 2, replace=False))\n        if a == b:\n            continue\n\n        # Calculate current and new costs for all three objectives\n        current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n\n        current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n        current_cost3 = distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        new_cost3 = distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n\n        # Calculate improvement (negative if worse)\n        improvement = (new_cost1 - current_cost1) + (new_cost2 - current_cost2) + (new_cost3 - current_cost3)\n\n        if improvement < best_improvement:\n            best_improvement = improvement\n            best_swap = (a, b)\n\n    if best_swap is not None:\n        a, b = best_swap\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7362052122656465,
            3.6113330841064455
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest crowding distance in the objective space\n    def crowding_distance(obj_values):\n        obj_values = np.array(obj_values)\n        distances = np.zeros(len(obj_values))\n        for m in range(obj_values.shape[1]):\n            sorted_indices = np.argsort(obj_values[:, m])\n            sorted_obj = obj_values[sorted_indices, m]\n            distances[sorted_indices[0]] = np.inf\n            distances[sorted_indices[-1]] = np.inf\n            for i in range(1, len(sorted_obj) - 1):\n                distances[sorted_indices[i]] += (sorted_obj[i+1] - sorted_obj[i-1]) / (sorted_obj[-1] - sorted_obj[0] + 1e-10)\n        return distances\n\n    objectives = np.array([obj for (sol, obj) in archive])\n    distances = crowding_distance(objectives)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt move\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: find the best swap to improve at least one objective\n    best_improvement = 0\n    best_swap = None\n\n    for _ in range(min(10, n)):  # Limit number of swaps to explore\n        a, b = sorted(np.random.choice(range(n), 2, replace=False))\n        if a == b:\n            continue\n\n        # Calculate current and new costs for all three objectives\n        current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n\n        current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n        current_cost3 = distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]]\n        new_cost3 = distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]\n\n        # Calculate improvement (negative if worse)\n        improvement = (new_cost1 - current_cost1) + (new_cost2 - current_cost2) + (new_cost3 - current_cost3)\n\n        if improvement < best_improvement:\n            best_improvement = improvement\n            best_swap = (a, b)\n\n    if best_swap is not None:\n        a, b = best_swap\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 104,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized_obj = max_obj - objectives  # Higher values are better\n    weights = np.sum(normalized_obj, axis=1)\n    weights = weights / np.sum(weights) if np.sum(weights) > 0 else np.ones(len(weights)) / len(weights)\n\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware perturbations\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, apply an objective-aware perturbation based on the worst objective\n    obj_values = archive[selected_idx][1]\n    worst_obj_idx = np.argmax(obj_values)\n\n    if worst_obj_idx == 0:\n        distance_matrix = distance_matrix_1\n    elif worst_obj_idx == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Find the most critical edge in the worst objective space\n    max_edge_length = -1\n    max_i, max_j = 0, 0\n    for i in range(n):\n        j = (i + 1) % n\n        edge_length = distance_matrix[new_solution[i], new_solution[j]]\n        if edge_length > max_edge_length:\n            max_edge_length = edge_length\n            max_i, max_j = i, j\n\n    # Reconnect the tour to improve the worst objective\n    if max_i != max_j:\n        # Try to find a better connection in the worst objective space\n        candidates = []\n        for k in range(n):\n            if k != max_i and k != max_j and k != (max_i + 1) % n and k != (max_j - 1) % n:\n                new_length = distance_matrix[new_solution[max_i], new_solution[k]] + distance_matrix[new_solution[k], new_solution[max_j]]\n                improvement = max_edge_length - new_length\n                if improvement > 0:\n                    candidates.append((k, improvement))\n\n        if candidates:\n            # Select the candidate with the best improvement\n            best_k, _ = max(candidates, key=lambda x: x[1])\n            # Perform the reconnection\n            if max_i < max_j:\n                new_solution = np.concatenate([new_solution[:max_i+1], new_solution[max_i+1:max_j+1][::-1], new_solution[max_j+1:]])\n            else:\n                # Handle the wrap-around case\n                segment = new_solution[max_i:] + new_solution[:max_j+1]\n                segment = segment[::-1]\n                new_solution = np.concatenate([segment[-max_j-1:], new_solution[max_j+1:max_i]])\n\n    return new_solution\n\n",
        "score": [
            -0.7653329731517186,
            1.5251604199409485
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized_obj = max_obj - objectives  # Higher values are better\n    weights = np.sum(normalized_obj, axis=1)\n    weights = weights / np.sum(weights) if np.sum(weights) > 0 else np.ones(len(weights)) / len(weights)\n\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware perturbations\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, apply an objective-aware perturbation based on the worst objective\n    obj_values = archive[selected_idx][1]\n    worst_obj_idx = np.argmax(obj_values)\n\n    if worst_obj_idx == 0:\n        distance_matrix = distance_matrix_1\n    elif worst_obj_idx == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Find the most critical edge in the worst objective space\n    max_edge_length = -1\n    max_i, max_j = 0, 0\n    for i in range(n):\n        j = (i + 1) % n\n        edge_length = distance_matrix[new_solution[i], new_solution[j]]\n        if edge_length > max_edge_length:\n            max_edge_length = edge_length\n            max_i, max_j = i, j\n\n    # Reconnect the tour to improve the worst objective\n    if max_i != max_j:\n        # Try to find a better connection in the worst objective space\n        candidates = []\n        for k in range(n):\n            if k != max_i and k != max_j and k != (max_i + 1) % n and k != (max_j - 1) % n:\n                new_length = distance_matrix[new_solution[max_i], new_solution[k]] + distance_matrix[new_solution[k], new_solution[max_j]]\n                improvement = max_edge_length - new_length\n                if improvement > 0:\n                    candidates.append((k, improvement))\n\n        if candidates:\n            # Select the candidate with the best improvement\n            best_k, _ = max(candidates, key=lambda x: x[1])\n            # Perform the reconnection\n            if max_i < max_j:\n                new_solution = np.concatenate([new_solution[:max_i+1], new_solution[max_i+1:max_j+1][::-1], new_solution[max_j+1:]])\n            else:\n                # Handle the wrap-around case\n                segment = new_solution[max_i:] + new_solution[:max_j+1]\n                segment = segment[::-1]\n                new_solution = np.concatenate([segment[-max_j-1:], new_solution[max_j+1:max_i]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 105,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    best_obj = np.min(objectives, axis=0)\n    dist_to_best = np.sum(np.abs(objectives - best_obj), axis=1)\n    candidates = [i for i, d in enumerate(dist_to_best) if d > 0]  # Exclude solutions too close to the best\n\n    if not candidates:\n        candidates = list(range(len(archive)))\n\n    selected_idx = np.random.choice(candidates)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt and insertion for multi-objective optimization\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Randomly choose between 2-opt and insertion\n    if np.random.random() < 0.5:\n        # 2-opt: randomly select two edges and reverse the segment between them\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Insertion: randomly select a node and insert it at a different position\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7981855419257893,
            1.9281998515129088
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    best_obj = np.min(objectives, axis=0)\n    dist_to_best = np.sum(np.abs(objectives - best_obj), axis=1)\n    candidates = [i for i, d in enumerate(dist_to_best) if d > 0]  # Exclude solutions too close to the best\n\n    if not candidates:\n        candidates = list(range(len(archive)))\n\n    selected_idx = np.random.choice(candidates)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt and insertion for multi-objective optimization\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Randomly choose between 2-opt and insertion\n    if np.random.random() < 0.5:\n        # 2-opt: randomly select two edges and reverse the segment between them\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Insertion: randomly select a node and insert it at a different position\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 106,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest objective values)\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search operator: 2-opt with multi-objective consideration\n    for _ in range(10):  # Number of iterations can be adjusted\n        i, j = sorted(random.sample(range(n), 2))\n        if i == 0 and j == n-1:\n            continue  # Avoid reversing the entire tour\n\n        # Evaluate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if any objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7044630086281787,
            1.0118667364120484
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest objective values)\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search operator: 2-opt with multi-objective consideration\n    for _ in range(10):  # Number of iterations can be adjusted\n        i, j = sorted(random.sample(range(n), 2))\n        if i == 0 and j == n-1:\n            continue  # Avoid reversing the entire tour\n\n        # Evaluate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if any objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 106,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest objective values)\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search operator: 2-opt with multi-objective consideration\n    for _ in range(10):  # Number of iterations can be adjusted\n        i, j = sorted(random.sample(range(n), 2))\n        if i == 0 and j == n-1:\n            continue  # Avoid reversing the entire tour\n\n        # Evaluate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if any objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7044630086281787,
            1.0118667364120484
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest objective values)\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search operator: 2-opt with multi-objective consideration\n    for _ in range(10):  # Number of iterations can be adjusted\n        i, j = sorted(random.sample(range(n), 2))\n        if i == 0 and j == n-1:\n            continue  # Avoid reversing the entire tour\n\n        # Evaluate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if any objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 107,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        return archive[0][0].copy()\n\n    # Calculate improvement potential: solutions with higher current costs are more likely to improve\n    costs = [sum(obj) for _, obj in archive]\n    max_cost = max(costs)\n    weights = [cost / max_cost for cost in costs] if max_cost > 0 else [1.0 / len(costs)] * len(costs)\n    selected_idx = random.choices(range(len(archive_solutions)), weights=weights, k=1)[0]\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search operator: combine 2-opt and 3-opt with objective-aware selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between 2-opt and 3-opt based on the current solution's characteristics\n    if random.random() < 0.7:  # Higher chance for 2-opt\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # 3-opt local search (more disruptive)\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Apply 3-opt move: reverse segments and reconnect\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment1[::-1], segment2[::-1]])\n\n    # Ensure feasibility (valid TSP tour)\n    if not np.array_equal(np.unique(new_solution), np.arange(n)):\n        # If invalid, revert to base solution with a small perturbation\n        new_solution = base_solution.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8238421925986019,
            1.552372682094574
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        return archive[0][0].copy()\n\n    # Calculate improvement potential: solutions with higher current costs are more likely to improve\n    costs = [sum(obj) for _, obj in archive]\n    max_cost = max(costs)\n    weights = [cost / max_cost for cost in costs] if max_cost > 0 else [1.0 / len(costs)] * len(costs)\n    selected_idx = random.choices(range(len(archive_solutions)), weights=weights, k=1)[0]\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search operator: combine 2-opt and 3-opt with objective-aware selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between 2-opt and 3-opt based on the current solution's characteristics\n    if random.random() < 0.7:  # Higher chance for 2-opt\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # 3-opt local search (more disruptive)\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Apply 3-opt move: reverse segments and reconnect\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment1[::-1], segment2[::-1]])\n\n    # Ensure feasibility (valid TSP tour)\n    if not np.array_equal(np.unique(new_solution), np.arange(n)):\n        # If invalid, revert to base solution with a small perturbation\n        new_solution = base_solution.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 108,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low objective values for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # 2-opt move\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Objective-aware swap: identify worst edges in any objective space\n        worst_edge = -1\n        max_diff = -1\n        for k in range(n):\n            node1 = new_solution[k]\n            node2 = new_solution[(k+1)%n]\n            # Calculate improvement potential across all objectives\n            diff1 = distance_matrix_1[node1, node2]\n            diff2 = distance_matrix_2[node1, node2]\n            diff3 = distance_matrix_3[node1, node2]\n            total_diff = diff1 + diff2 + diff3\n            if total_diff > max_diff:\n                max_diff = total_diff\n                worst_edge = k\n\n        if worst_edge != -1:\n            # Swap nodes to improve the worst edge\n            swap_pos = np.random.choice(n)\n            new_solution[worst_edge], new_solution[swap_pos] = new_solution[swap_pos], new_solution[worst_edge]\n\n    return new_solution\n\n",
        "score": [
            -0.7174409643559276,
            3.0302674889564516
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low objective values for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # 2-opt move\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Objective-aware swap: identify worst edges in any objective space\n        worst_edge = -1\n        max_diff = -1\n        for k in range(n):\n            node1 = new_solution[k]\n            node2 = new_solution[(k+1)%n]\n            # Calculate improvement potential across all objectives\n            diff1 = distance_matrix_1[node1, node2]\n            diff2 = distance_matrix_2[node1, node2]\n            diff3 = distance_matrix_3[node1, node2]\n            total_diff = diff1 + diff2 + diff3\n            if total_diff > max_diff:\n                max_diff = total_diff\n                worst_edge = k\n\n        if worst_edge != -1:\n            # Swap nodes to improve the worst edge\n            swap_pos = np.random.choice(n)\n            new_solution[worst_edge], new_solution[swap_pos] = new_solution[swap_pos], new_solution[worst_edge]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 109,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy combining 2-opt, 3-opt, and objective-aware swaps\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just reverse the order\n        new_solution = new_solution[::-1]\n    else:\n        # Perform a combination of operations\n        # 1. 2-opt swap (standard local search)\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # 2. 3-opt swap (more complex local search)\n        if n >= 6:\n            a, b, c = np.random.choice(n, size=3, replace=False)\n            a, b, c = sorted([a, b, c])\n            segment1 = new_solution[a:b+1]\n            segment2 = new_solution[b+1:c+1]\n            new_solution[a:c+1] = np.concatenate([segment2, segment1])\n\n        # 3. Objective-aware swap (considering all three objectives)\n        # Find the edge with the highest total cost across all objectives\n        total_costs = np.zeros(n)\n        for k in range(n):\n            node1 = new_solution[k]\n            node2 = new_solution[(k+1)%n]\n            total_costs[k] = (distance_matrix_1[node1, node2] +\n                             distance_matrix_2[node1, node2] +\n                             distance_matrix_3[node1, node2])\n\n        worst_edge = np.argmax(total_costs)\n        # Perform a swap that might reduce the total cost\n        new_solution[worst_edge], new_solution[(worst_edge+1)%n] = new_solution[(worst_edge+1)%n], new_solution[worst_edge]\n\n    return new_solution\n\n",
        "score": [
            -0.734603666044247,
            1.0119550824165344
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy combining 2-opt, 3-opt, and objective-aware swaps\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just reverse the order\n        new_solution = new_solution[::-1]\n    else:\n        # Perform a combination of operations\n        # 1. 2-opt swap (standard local search)\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # 2. 3-opt swap (more complex local search)\n        if n >= 6:\n            a, b, c = np.random.choice(n, size=3, replace=False)\n            a, b, c = sorted([a, b, c])\n            segment1 = new_solution[a:b+1]\n            segment2 = new_solution[b+1:c+1]\n            new_solution[a:c+1] = np.concatenate([segment2, segment1])\n\n        # 3. Objective-aware swap (considering all three objectives)\n        # Find the edge with the highest total cost across all objectives\n        total_costs = np.zeros(n)\n        for k in range(n):\n            node1 = new_solution[k]\n            node2 = new_solution[(k+1)%n]\n            total_costs[k] = (distance_matrix_1[node1, node2] +\n                             distance_matrix_2[node1, node2] +\n                             distance_matrix_3[node1, node2])\n\n        worst_edge = np.argmax(total_costs)\n        # Perform a swap that might reduce the total cost\n        new_solution[worst_edge], new_solution[(worst_edge+1)%n] = new_solution[(worst_edge+1)%n], new_solution[worst_edge]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 110,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (can be replaced with a more sophisticated metric)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select the middle solution to balance exploration and exploitation\n        selected_idx = len(archive_sorted) // 2\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: combination of 2-opt and insertion\n    if n > 3:\n        # Perform 2-opt with a probability of 0.7\n        if random.random() < 0.7:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Perform insertion with a probability of 0.3\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    assert len(new_solution) == len(np.unique(new_solution)), \"Invalid solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.6534996846849089,
            1.6042404413223266
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (can be replaced with a more sophisticated metric)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select the middle solution to balance exploration and exploitation\n        selected_idx = len(archive_sorted) // 2\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: combination of 2-opt and insertion\n    if n > 3:\n        # Perform 2-opt with a probability of 0.7\n        if random.random() < 0.7:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Perform insertion with a probability of 0.3\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    assert len(new_solution) == len(np.unique(new_solution)), \"Invalid solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 111,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly biased towards those with higher objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    weights = np.sum(normalized_objectives, axis=1)\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move to improve the most crowded objective\n    obj_values = archive[selected_idx][1]\n    most_crowded_obj = np.argmax(obj_values)\n\n    # Select two random edges to swap\n    i, j = sorted(random.sample(range(1, n), 2))\n    k, l = sorted(random.sample(range(1, n), 2))\n\n    # Perform 2-opt swap\n    if random.random() < 0.5:\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Then perform an objective-aware swap (swap nodes that are far apart in multiple objectives)\n    if random.random() < 0.3:  # 30% chance to perform this additional move\n        for _ in range(3):  # Try up to 3 swaps\n            a, b = random.sample(range(n), 2)\n            node_a = new_solution[a]\n            node_b = new_solution[b]\n\n            # Calculate distance improvement in all three objectives\n            current_dist = (distance_matrix_1[node_a, new_solution[(a-1)%n]] + distance_matrix_1[new_solution[(a+1)%n], node_a] +\n                           distance_matrix_1[node_b, new_solution[(b-1)%n]] + distance_matrix_1[new_solution[(b+1)%n], node_b])\n            new_dist = (distance_matrix_1[node_b, new_solution[(a-1)%n]] + distance_matrix_1[new_solution[(a+1)%n], node_b] +\n                        distance_matrix_1[node_a, new_solution[(b-1)%n]] + distance_matrix_1[new_solution[(b+1)%n], node_a])\n\n            if new_dist < current_dist:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n                break\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n        # Perform a simple swap as fallback\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7648607501807484,
            1.9625109553337097
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly biased towards those with higher objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    weights = np.sum(normalized_objectives, axis=1)\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move to improve the most crowded objective\n    obj_values = archive[selected_idx][1]\n    most_crowded_obj = np.argmax(obj_values)\n\n    # Select two random edges to swap\n    i, j = sorted(random.sample(range(1, n), 2))\n    k, l = sorted(random.sample(range(1, n), 2))\n\n    # Perform 2-opt swap\n    if random.random() < 0.5:\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Then perform an objective-aware swap (swap nodes that are far apart in multiple objectives)\n    if random.random() < 0.3:  # 30% chance to perform this additional move\n        for _ in range(3):  # Try up to 3 swaps\n            a, b = random.sample(range(n), 2)\n            node_a = new_solution[a]\n            node_b = new_solution[b]\n\n            # Calculate distance improvement in all three objectives\n            current_dist = (distance_matrix_1[node_a, new_solution[(a-1)%n]] + distance_matrix_1[new_solution[(a+1)%n], node_a] +\n                           distance_matrix_1[node_b, new_solution[(b-1)%n]] + distance_matrix_1[new_solution[(b+1)%n], node_b])\n            new_dist = (distance_matrix_1[node_b, new_solution[(a-1)%n]] + distance_matrix_1[new_solution[(a+1)%n], node_b] +\n                        distance_matrix_1[node_a, new_solution[(b-1)%n]] + distance_matrix_1[new_solution[(b+1)%n], node_a])\n\n            if new_dist < current_dist:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n                break\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n        # Perform a simple swap as fallback\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 112,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    import numpy as np\n\n    # Select a solution with high potential for improvement (e.g., those with high objective values)\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (higher sum indicates more potential for improvement)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select top 20% of solutions for consideration\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 5)]\n        # Randomly select one from the top solutions\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and random edge swap\n    n = len(new_solution)\n    if n > 3:\n        # Choose between 2-opt or random edge swap based on the solution's potential\n        if random.random() < 0.7:  # Higher probability for 2-opt as it's more structured\n            # 2-opt local search: select two random edges and reverse the segment between them\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Random edge swap: swap two random edges\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (valid tour)\n    # Verify no node is skipped or revisited\n    if len(np.unique(new_solution)) != len(new_solution):\n        # If invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.554028531541056,
            1.4112019896507264
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    import numpy as np\n\n    # Select a solution with high potential for improvement (e.g., those with high objective values)\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (higher sum indicates more potential for improvement)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select top 20% of solutions for consideration\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 5)]\n        # Randomly select one from the top solutions\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and random edge swap\n    n = len(new_solution)\n    if n > 3:\n        # Choose between 2-opt or random edge swap based on the solution's potential\n        if random.random() < 0.7:  # Higher probability for 2-opt as it's more structured\n            # 2-opt local search: select two random edges and reverse the segment between them\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Random edge swap: swap two random edges\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (valid tour)\n    # Verify no node is skipped or revisited\n    if len(np.unique(new_solution)) != len(new_solution):\n        # If invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 113,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    # Calculate the spread of each solution (difference between max and min objectives)\n    spreads = [max(obj) - min(obj) for obj in objectives]\n    # Prioritize solutions with higher spread (more room for improvement)\n    selected_idx = np.argmax(spreads)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt and edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    start = np.random.randint(0, n-1)\n    end = np.random.randint(start+1, n)\n\n    # Reverse the selected segment (2-opt)\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge exchange: swap two edges that are not adjacent\n    i = np.random.randint(0, n-2)\n    j = np.random.randint(i+2, n)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains valid\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        # If invalid, revert to original\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5646668641079583,
            1.5746451139450073
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    # Calculate the spread of each solution (difference between max and min objectives)\n    spreads = [max(obj) - min(obj) for obj in objectives]\n    # Prioritize solutions with higher spread (more room for improvement)\n    selected_idx = np.argmax(spreads)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt and edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    start = np.random.randint(0, n-1)\n    end = np.random.randint(start+1, n)\n\n    # Reverse the selected segment (2-opt)\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge exchange: swap two edges that are not adjacent\n    i = np.random.randint(0, n-2)\n    j = np.random.randint(i+2, n)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains valid\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        # If invalid, revert to original\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 114,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate total cost for each solution (sum of all three objectives)\n    costs = [sum(obj) for _, obj in archive]\n    min_cost = min(costs)\n    max_cost = max(costs)\n    normalized_costs = [(max_cost - cost) / (max_cost - min_cost) if max_cost != min_cost else 1.0 for cost in costs]\n\n    # Select a solution with probability proportional to its normalized cost\n    selected_idx = np.random.choice(len(archive), p=np.array(normalized_costs) / sum(normalized_costs))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select two distinct edges to swap (i, i+1) and (j, j+1)\n    i = np.random.randint(0, n - 1)\n    j = np.random.randint(0, n - 1)\n    while abs(i - j) < 2:  # Ensure edges are not adjacent\n        j = np.random.randint(0, n - 1)\n\n    # Determine the better edge swap based on the three objectives\n    # Calculate the cost difference for each objective\n    def get_cost_diff(a, b, c, d, matrix):\n        return (matrix[a, b] + matrix[c, d]) - (matrix[a, c] + matrix[b, d])\n\n    cost_diff_1 = get_cost_diff(new_solution[i], new_solution[i+1], new_solution[j], new_solution[(j+1)%n], distance_matrix_1)\n    cost_diff_2 = get_cost_diff(new_solution[i], new_solution[i+1], new_solution[j], new_solution[(j+1)%n], distance_matrix_2)\n    cost_diff_3 = get_cost_diff(new_solution[i], new_solution[i+1], new_solution[j], new_solution[(j+1)%n], distance_matrix_3)\n\n    # If the swap improves at least one objective, perform it\n    if cost_diff_1 < 0 or cost_diff_2 < 0 or cost_diff_3 < 0:\n        # Perform 2-opt swap\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Also consider a node insertion to further diversify the search\n    if np.random.random() < 0.3:  # 30% chance for insertion\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while k == l:\n            l = np.random.randint(0, n)\n        new_solution = np.insert(new_solution, k, new_solution[l])\n        new_solution = np.delete(new_solution, l + (1 if l > k else 0))\n\n    return new_solution\n\n",
        "score": [
            -0.7061211447409866,
            2.717364716529846
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate total cost for each solution (sum of all three objectives)\n    costs = [sum(obj) for _, obj in archive]\n    min_cost = min(costs)\n    max_cost = max(costs)\n    normalized_costs = [(max_cost - cost) / (max_cost - min_cost) if max_cost != min_cost else 1.0 for cost in costs]\n\n    # Select a solution with probability proportional to its normalized cost\n    selected_idx = np.random.choice(len(archive), p=np.array(normalized_costs) / sum(normalized_costs))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select two distinct edges to swap (i, i+1) and (j, j+1)\n    i = np.random.randint(0, n - 1)\n    j = np.random.randint(0, n - 1)\n    while abs(i - j) < 2:  # Ensure edges are not adjacent\n        j = np.random.randint(0, n - 1)\n\n    # Determine the better edge swap based on the three objectives\n    # Calculate the cost difference for each objective\n    def get_cost_diff(a, b, c, d, matrix):\n        return (matrix[a, b] + matrix[c, d]) - (matrix[a, c] + matrix[b, d])\n\n    cost_diff_1 = get_cost_diff(new_solution[i], new_solution[i+1], new_solution[j], new_solution[(j+1)%n], distance_matrix_1)\n    cost_diff_2 = get_cost_diff(new_solution[i], new_solution[i+1], new_solution[j], new_solution[(j+1)%n], distance_matrix_2)\n    cost_diff_3 = get_cost_diff(new_solution[i], new_solution[i+1], new_solution[j], new_solution[(j+1)%n], distance_matrix_3)\n\n    # If the swap improves at least one objective, perform it\n    if cost_diff_1 < 0 or cost_diff_2 < 0 or cost_diff_3 < 0:\n        # Perform 2-opt swap\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Also consider a node insertion to further diversify the search\n    if np.random.random() < 0.3:  # 30% chance for insertion\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while k == l:\n            l = np.random.randint(0, n)\n        new_solution = np.insert(new_solution, k, new_solution[l])\n        new_solution = np.delete(new_solution, l + (1 if l > k else 0))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 115,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n_nodes = len(new_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Randomly select two distinct positions\n        i, j = random.sample(range(n_nodes), 2)\n        if i > j:\n            i, j = j, i\n\n        # Calculate current and potential costs for each objective\n        current_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j], new_solution[(j+1)%n_nodes]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j], new_solution[(j+1)%n_nodes]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j], new_solution[(j+1)%n_nodes]]\n        )\n\n        potential_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_1[new_solution[i], new_solution[(j+1)%n_nodes]],\n            distance_matrix_2[new_solution[i-1], new_solution[j]] +\n            distance_matrix_2[new_solution[i], new_solution[(j+1)%n_nodes]],\n            distance_matrix_3[new_solution[i-1], new_solution[j]] +\n            distance_matrix_3[new_solution[i], new_solution[(j+1)%n_nodes]]\n        )\n\n        # Check if the swap improves at least one objective\n        if any(p < c for p, c in zip(potential_cost, current_cost)):\n            # Perform the swap\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7472475482513934,
            1.3800105094909667
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n_nodes = len(new_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Randomly select two distinct positions\n        i, j = random.sample(range(n_nodes), 2)\n        if i > j:\n            i, j = j, i\n\n        # Calculate current and potential costs for each objective\n        current_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j], new_solution[(j+1)%n_nodes]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j], new_solution[(j+1)%n_nodes]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j], new_solution[(j+1)%n_nodes]]\n        )\n\n        potential_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_1[new_solution[i], new_solution[(j+1)%n_nodes]],\n            distance_matrix_2[new_solution[i-1], new_solution[j]] +\n            distance_matrix_2[new_solution[i], new_solution[(j+1)%n_nodes]],\n            distance_matrix_3[new_solution[i-1], new_solution[j]] +\n            distance_matrix_3[new_solution[i], new_solution[(j+1)%n_nodes]]\n        )\n\n        # Check if the swap improves at least one objective\n        if any(p < c for p, c in zip(potential_cost, current_cost)):\n            # Perform the swap\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 116,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (higher sum = more potential for improvement)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select top 20% of solutions with the highest sum of objectives\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 5)]\n        # Randomly select one from the top solutions\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy\n    if len(base_solution) > 3:\n        # Select a random segment of the tour\n        start = random.randint(0, len(base_solution) - 3)\n        end = random.randint(start + 1, min(start + 3, len(base_solution) - 1))\n\n        # Choose one of three possible local search operators\n        operator = random.choice(['2-opt', 'swap', 'inverse'])\n\n        if operator == '2-opt':\n            # Apply 2-opt on the selected segment\n            i = random.randint(0, len(base_solution) - 2)\n            j = random.randint(i + 1, len(base_solution) - 1)\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif operator == 'swap':\n            # Swap two nodes in the selected segment\n            i = random.randint(0, len(base_solution) - 1)\n            j = random.randint(0, len(base_solution) - 1)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        elif operator == 'inverse':\n            # Inverse a segment of the tour\n            i = random.randint(0, len(base_solution) - 2)\n            j = random.randint(i + 1, len(base_solution) - 1)\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != len(instance):\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5615626433539072,
            1.4669207334518433
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (higher sum = more potential for improvement)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select top 20% of solutions with the highest sum of objectives\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 5)]\n        # Randomly select one from the top solutions\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy\n    if len(base_solution) > 3:\n        # Select a random segment of the tour\n        start = random.randint(0, len(base_solution) - 3)\n        end = random.randint(start + 1, min(start + 3, len(base_solution) - 1))\n\n        # Choose one of three possible local search operators\n        operator = random.choice(['2-opt', 'swap', 'inverse'])\n\n        if operator == '2-opt':\n            # Apply 2-opt on the selected segment\n            i = random.randint(0, len(base_solution) - 2)\n            j = random.randint(i + 1, len(base_solution) - 1)\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif operator == 'swap':\n            # Swap two nodes in the selected segment\n            i = random.randint(0, len(base_solution) - 1)\n            j = random.randint(0, len(base_solution) - 1)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        elif operator == 'inverse':\n            # Inverse a segment of the tour\n            i = random.randint(0, len(base_solution) - 2)\n            j = random.randint(i + 1, len(base_solution) - 1)\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != len(instance):\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 117,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending)\n        sorted_solutions = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the middle of the archive (not best, not worst)\n        base_solution = sorted_solutions[max(1, len(archive) // 3)][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    # 1. Randomly choose between 2-opt or 3-opt move\n    move_type = random.choice(['2opt', '3opt'])\n\n    if move_type == '2opt':\n        # Perform 2-opt move\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Perform 3-opt move (simplified version)\n        i, j, k = sorted(random.sample(range(len(new_solution)), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        segment3 = new_solution[k:]\n        new_solution = np.concatenate([segment1, segment2[::-1], segment3])\n\n    # Ensure the solution is valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != len(instance):\n        # If invalid, revert to 2-opt move as fallback\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7100016980587905,
            1.103322720527649
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending)\n        sorted_solutions = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the middle of the archive (not best, not worst)\n        base_solution = sorted_solutions[max(1, len(archive) // 3)][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    # 1. Randomly choose between 2-opt or 3-opt move\n    move_type = random.choice(['2opt', '3opt'])\n\n    if move_type == '2opt':\n        # Perform 2-opt move\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Perform 3-opt move (simplified version)\n        i, j, k = sorted(random.sample(range(len(new_solution)), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        segment3 = new_solution[k:]\n        new_solution = np.concatenate([segment1, segment2[::-1], segment3])\n\n    # Ensure the solution is valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != len(instance):\n        # If invalid, revert to 2-opt move as fallback\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 118,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations for better exploration\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate potential improvements for all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_1[new_solution[j], new_solution[i]] -\n                 distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_1[new_solution[j], new_solution[j+1] if j+1 < n else 0])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_2[new_solution[j], new_solution[i]] -\n                 distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_2[new_solution[j], new_solution[j+1] if j+1 < n else 0])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_3[new_solution[j], new_solution[i]] -\n                 distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_3[new_solution[j], new_solution[j+1] if j+1 < n else 0])\n\n        # Calculate combined improvement (weighted sum)\n        combined_improvement = -delta1 - delta2 - delta3\n\n        if combined_improvement > 0:\n            # Perform the swap\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Objective-aware swap\n        if np.random.rand() < 0.3:  # 30% chance for objective-aware operation\n            # Select the worst objective to improve\n            worst_obj = np.argmax(objectives)\n            if worst_obj == 0:\n                delta = delta1\n            elif worst_obj == 1:\n                delta = delta2\n            else:\n                delta = delta3\n\n            if delta < 0:  # If it improves the worst objective\n                new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.8073671289680332,
            3.009084141254425
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations for better exploration\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate potential improvements for all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_1[new_solution[j], new_solution[i]] -\n                 distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_1[new_solution[j], new_solution[j+1] if j+1 < n else 0])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_2[new_solution[j], new_solution[i]] -\n                 distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_2[new_solution[j], new_solution[j+1] if j+1 < n else 0])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_3[new_solution[j], new_solution[i]] -\n                 distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_3[new_solution[j], new_solution[j+1] if j+1 < n else 0])\n\n        # Calculate combined improvement (weighted sum)\n        combined_improvement = -delta1 - delta2 - delta3\n\n        if combined_improvement > 0:\n            # Perform the swap\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Objective-aware swap\n        if np.random.rand() < 0.3:  # 30% chance for objective-aware operation\n            # Select the worst objective to improve\n            worst_obj = np.argmax(objectives)\n            if worst_obj == 0:\n                delta = delta1\n            elif worst_obj == 1:\n                delta = delta2\n            else:\n                delta = delta3\n\n            if delta < 0:  # If it improves the worst objective\n                new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 119,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best in all objectives)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and objective-aware edge swaps\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Standard 2-opt move\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware edge swap\n    if np.random.rand() < 0.5:  # 50% chance to apply objective-aware swap\n        obj1 = archive[selected_idx][1][0]\n        obj2 = archive[selected_idx][1][1]\n        obj3 = archive[selected_idx][1][2]\n\n        # Calculate potential improvement for each objective\n        def calculate_improvement(solution):\n            total1 = sum(distance_matrix_1[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n            total2 = sum(distance_matrix_2[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n            total3 = sum(distance_matrix_3[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_3[solution[-1], solution[0]]\n            return (total1, total2, total3)\n\n        # Try swapping edges that might improve the worst objective\n        worst_obj = np.argmax([obj1, obj2, obj3])\n        if worst_obj == 0:\n            mat = distance_matrix_1\n        elif worst_obj == 1:\n            mat = distance_matrix_2\n        else:\n            mat = distance_matrix_3\n\n        # Find edges with potential for improvement\n        for k in range(n-1):\n            for l in range(k+1, n):\n                if mat[new_solution[k], new_solution[k+1]] + mat[new_solution[l], new_solution[(l+1)%n]] > \\\n                   mat[new_solution[k], new_solution[l]] + mat[new_solution[k+1], new_solution[(l+1)%n]]:\n                    # Perform the swap\n                    new_solution[k+1:l+1] = new_solution[k+1:l+1][::-1]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7813745234538346,
            2.0639844298362733
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best in all objectives)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and objective-aware edge swaps\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Standard 2-opt move\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware edge swap\n    if np.random.rand() < 0.5:  # 50% chance to apply objective-aware swap\n        obj1 = archive[selected_idx][1][0]\n        obj2 = archive[selected_idx][1][1]\n        obj3 = archive[selected_idx][1][2]\n\n        # Calculate potential improvement for each objective\n        def calculate_improvement(solution):\n            total1 = sum(distance_matrix_1[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n            total2 = sum(distance_matrix_2[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n            total3 = sum(distance_matrix_3[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_3[solution[-1], solution[0]]\n            return (total1, total2, total3)\n\n        # Try swapping edges that might improve the worst objective\n        worst_obj = np.argmax([obj1, obj2, obj3])\n        if worst_obj == 0:\n            mat = distance_matrix_1\n        elif worst_obj == 1:\n            mat = distance_matrix_2\n        else:\n            mat = distance_matrix_3\n\n        # Find edges with potential for improvement\n        for k in range(n-1):\n            for l in range(k+1, n):\n                if mat[new_solution[k], new_solution[k+1]] + mat[new_solution[l], new_solution[(l+1)%n]] > \\\n                   mat[new_solution[k], new_solution[l]] + mat[new_solution[k+1], new_solution[(l+1)%n]]:\n                    # Perform the swap\n                    new_solution[k+1:l+1] = new_solution[k+1:l+1][::-1]\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 120,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = []\n    for sol, obj in archive:\n        # Consider solutions that are not the best in all objectives (have room for improvement)\n        if not all(obj[i] == min([o[i] for _, o in archive]) for i in range(3)):\n            candidates.append((sol, obj))\n\n    if not candidates:\n        # If no such solutions, pick a random one\n        base_solution, _ = random.choice(archive)\n    else:\n        # Select a candidate with high diversity (e.g., not too similar to the best solutions)\n        best_obj = [min([o[i] for _, o in archive]) for i in range(3)]\n        # Sort by distance to the ideal point (in objective space) and pick a diverse one\n        candidates.sort(key=lambda x: sum((x[1][i] - best_obj[i])**2 for i in range(3)), reverse=True)\n        base_solution, _ = random.choice(candidates[:max(1, len(candidates)//2)])\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt and node insertion\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # With 70% probability, perform 2-opt\n        if random.random() < 0.7:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # With 30% probability, perform node insertion\n            i = random.randint(0, n-1)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            j = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains valid (no duplicates, all nodes included)\n    assert len(new_solution) == len(np.unique(new_solution)), \"Invalid solution generated (duplicates)\"\n    assert set(new_solution) == set(base_solution), \"Invalid solution generated (missing nodes)\"\n\n    return new_solution\n\n",
        "score": [
            -0.7054215429916766,
            4.075415766239166
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = []\n    for sol, obj in archive:\n        # Consider solutions that are not the best in all objectives (have room for improvement)\n        if not all(obj[i] == min([o[i] for _, o in archive]) for i in range(3)):\n            candidates.append((sol, obj))\n\n    if not candidates:\n        # If no such solutions, pick a random one\n        base_solution, _ = random.choice(archive)\n    else:\n        # Select a candidate with high diversity (e.g., not too similar to the best solutions)\n        best_obj = [min([o[i] for _, o in archive]) for i in range(3)]\n        # Sort by distance to the ideal point (in objective space) and pick a diverse one\n        candidates.sort(key=lambda x: sum((x[1][i] - best_obj[i])**2 for i in range(3)), reverse=True)\n        base_solution, _ = random.choice(candidates[:max(1, len(candidates)//2)])\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt and node insertion\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # With 70% probability, perform 2-opt\n        if random.random() < 0.7:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # With 30% probability, perform node insertion\n            i = random.randint(0, n-1)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            j = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains valid (no duplicates, all nodes included)\n    assert len(new_solution) == len(np.unique(new_solution)), \"Invalid solution generated (duplicates)\"\n    assert set(new_solution) == set(base_solution), \"Invalid solution generated (missing nodes)\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 121,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by a combined objective value (sum of all objectives)\n        sorted_solutions = sorted(archive, key=lambda x: sum(x[1]))\n        # Select the middle solution to avoid extreme cases\n        base_solution = sorted_solutions[len(sorted_solutions) // 2][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt and random segment inversion\n    n = len(new_solution)\n    if n < 4:\n        # For very small tours, just swap two random nodes\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # With 70% probability, apply 2-opt to the worst objective\n        if np.random.rand() < 0.7:\n            # Calculate the cost of each edge in all three objectives\n            costs = np.zeros((n, 3))\n            for i in range(n):\n                prev_node = new_solution[i-1]\n                curr_node = new_solution[i]\n                next_node = new_solution[(i+1)%n]\n                # Calculate costs for the current edge (prev->curr->next)\n                costs[i, 0] = distance_matrix_1[prev_node, curr_node] + distance_matrix_1[curr_node, next_node]\n                costs[i, 1] = distance_matrix_2[prev_node, curr_node] + distance_matrix_2[curr_node, next_node]\n                costs[i, 2] = distance_matrix_3[prev_node, curr_node] + distance_matrix_3[curr_node, next_node]\n\n            # Identify the objective with the highest total cost\n            worst_obj = np.argmax(np.sum(costs, axis=0))\n\n            # Apply 2-opt to improve the worst objective\n            i, j = np.random.choice(n, 2, replace=False)\n            i, j = min(i, j), max(i, j)\n            if j - i > 1:  # Ensure we have at least two edges to flip\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        else:\n            # With 30% probability, apply random segment inversion\n            i, j = np.random.choice(n, 2, replace=False)\n            i, j = min(i, j), max(i, j)\n            if j - i > 1:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6885754945449671,
            2.000481605529785
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by a combined objective value (sum of all objectives)\n        sorted_solutions = sorted(archive, key=lambda x: sum(x[1]))\n        # Select the middle solution to avoid extreme cases\n        base_solution = sorted_solutions[len(sorted_solutions) // 2][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt and random segment inversion\n    n = len(new_solution)\n    if n < 4:\n        # For very small tours, just swap two random nodes\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # With 70% probability, apply 2-opt to the worst objective\n        if np.random.rand() < 0.7:\n            # Calculate the cost of each edge in all three objectives\n            costs = np.zeros((n, 3))\n            for i in range(n):\n                prev_node = new_solution[i-1]\n                curr_node = new_solution[i]\n                next_node = new_solution[(i+1)%n]\n                # Calculate costs for the current edge (prev->curr->next)\n                costs[i, 0] = distance_matrix_1[prev_node, curr_node] + distance_matrix_1[curr_node, next_node]\n                costs[i, 1] = distance_matrix_2[prev_node, curr_node] + distance_matrix_2[curr_node, next_node]\n                costs[i, 2] = distance_matrix_3[prev_node, curr_node] + distance_matrix_3[curr_node, next_node]\n\n            # Identify the objective with the highest total cost\n            worst_obj = np.argmax(np.sum(costs, axis=0))\n\n            # Apply 2-opt to improve the worst objective\n            i, j = np.random.choice(n, 2, replace=False)\n            i, j = min(i, j), max(i, j)\n            if j - i > 1:  # Ensure we have at least two edges to flip\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        else:\n            # With 30% probability, apply random segment inversion\n            i, j = np.random.choice(n, 2, replace=False)\n            i, j = min(i, j), max(i, j)\n            if j - i > 1:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 122,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def potential_score(solution, objectives):\n        # Calculate the sum of normalized objective values (lower is better)\n        normalized = [obj / (sum(objectives) + 1e-10) for obj in objectives]\n        return sum(normalized)\n\n    # Sort solutions by potential score (ascending order)\n    scored_solutions = [(potential_score(obj, obj), sol) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: x[0])\n    best_solutions = [sol for _, sol in scored_solutions[:max(3, len(archive)//5)]]\n\n    # Randomly select one of the top solutions\n    base_solution = random.choice(best_solutions).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and objective-aware edge swaps\n    n = len(base_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # 2-opt move (standard local search)\n    if j - i > 1:\n        new_solution[i:j] = base_solution[i:j][::-1]\n\n    # Objective-aware edge swap: try to improve the worst objective\n    def calculate_objectives(sol):\n        obj1 = sum(distance_matrix_1[sol[k], sol[(k+1)%n]] for k in range(n))\n        obj2 = sum(distance_matrix_2[sol[k], sol[(k+1)%n]] for k in range(n))\n        obj3 = sum(distance_matrix_3[sol[k], sol[(k+1)%n]] for k in range(n))\n        return (obj1, obj2, obj3)\n\n    current_obj = calculate_objectives(base_solution)\n    new_obj = calculate_objectives(new_solution)\n\n    # If the 2-opt move didn't improve the worst objective, try a targeted swap\n    if max(new_obj) > max(current_obj):\n        # Find the worst objective index\n        worst_idx = np.argmax(current_obj)\n\n        # Try to find a better edge swap for the worst objective\n        for _ in range(10):  # Limited attempts to prevent excessive computation\n            a, b = sorted(random.sample(range(n), 2))\n            if b - a > 1:\n                temp_sol = new_solution.copy()\n                temp_sol[a:b] = new_solution[a:b][::-1]\n                temp_obj = calculate_objectives(temp_sol)\n\n                if temp_obj[worst_idx] < new_obj[worst_idx]:\n                    new_solution = temp_sol\n                    new_obj = temp_obj\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.6991285221589689,
            3.2949835419654847
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def potential_score(solution, objectives):\n        # Calculate the sum of normalized objective values (lower is better)\n        normalized = [obj / (sum(objectives) + 1e-10) for obj in objectives]\n        return sum(normalized)\n\n    # Sort solutions by potential score (ascending order)\n    scored_solutions = [(potential_score(obj, obj), sol) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: x[0])\n    best_solutions = [sol for _, sol in scored_solutions[:max(3, len(archive)//5)]]\n\n    # Randomly select one of the top solutions\n    base_solution = random.choice(best_solutions).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and objective-aware edge swaps\n    n = len(base_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # 2-opt move (standard local search)\n    if j - i > 1:\n        new_solution[i:j] = base_solution[i:j][::-1]\n\n    # Objective-aware edge swap: try to improve the worst objective\n    def calculate_objectives(sol):\n        obj1 = sum(distance_matrix_1[sol[k], sol[(k+1)%n]] for k in range(n))\n        obj2 = sum(distance_matrix_2[sol[k], sol[(k+1)%n]] for k in range(n))\n        obj3 = sum(distance_matrix_3[sol[k], sol[(k+1)%n]] for k in range(n))\n        return (obj1, obj2, obj3)\n\n    current_obj = calculate_objectives(base_solution)\n    new_obj = calculate_objectives(new_solution)\n\n    # If the 2-opt move didn't improve the worst objective, try a targeted swap\n    if max(new_obj) > max(current_obj):\n        # Find the worst objective index\n        worst_idx = np.argmax(current_obj)\n\n        # Try to find a better edge swap for the worst objective\n        for _ in range(10):  # Limited attempts to prevent excessive computation\n            a, b = sorted(random.sample(range(n), 2))\n            if b - a > 1:\n                temp_sol = new_solution.copy()\n                temp_sol[a:b] = new_solution[a:b][::-1]\n                temp_obj = calculate_objectives(temp_sol)\n\n                if temp_obj[worst_idx] < new_obj[worst_idx]:\n                    new_solution = temp_sol\n                    new_obj = temp_obj\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 123,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest cost)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate the total cost for each solution\n    total_costs = [sum(obj) for obj in archive_objectives]\n\n    # Select the solution with the lowest total cost (most promising)\n    selected_idx = np.argmin(total_costs)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search: apply a combination of 2-opt and random swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and random swap\n    if np.random.rand() < 0.5:\n        # 2-opt local search\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Random swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    assert len(set(new_solution)) == n, \"Generated solution is invalid (duplicates or missing nodes)\"\n\n    return new_solution\n\n",
        "score": [
            -0.6512993802748167,
            1.5962369322776795
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest cost)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate the total cost for each solution\n    total_costs = [sum(obj) for obj in archive_objectives]\n\n    # Select the solution with the lowest total cost (most promising)\n    selected_idx = np.argmin(total_costs)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search: apply a combination of 2-opt and random swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and random swap\n    if np.random.rand() < 0.5:\n        # 2-opt local search\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Random swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    assert len(set(new_solution)) == n, \"Generated solution is invalid (duplicates or missing nodes)\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 124,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their objective values (sum of all objectives)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select from the middle 50% to avoid extremes\n        selection_pool = archive_sorted[len(archive_sorted)//4 : 3*len(archive_sorted)//4]\n        selected_solution = random.choice(selection_pool)[0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Apply hybrid local search: combination of 2-opt and random swap\n    n = len(new_solution)\n    if n > 3:\n        # Randomly choose between 2-opt and random swap\n        if random.random() < 0.7:  # 70% chance for 2-opt\n            # 2-opt local search\n            i, j = sorted(random.sample(range(1, n-1), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Random swap\n            i, j = random.sample(range(1, n-1), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7452897429781223,
            1.752642858028412
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their objective values (sum of all objectives)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select from the middle 50% to avoid extremes\n        selection_pool = archive_sorted[len(archive_sorted)//4 : 3*len(archive_sorted)//4]\n        selected_solution = random.choice(selection_pool)[0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Apply hybrid local search: combination of 2-opt and random swap\n    n = len(new_solution)\n    if n > 3:\n        # Randomly choose between 2-opt and random swap\n        if random.random() < 0.7:  # 70% chance for 2-opt\n            # 2-opt local search\n            i, j = sorted(random.sample(range(1, n-1), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Random swap\n            i, j = random.sample(range(1, n-1), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 125,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Rank solutions by their objective values (lower is better)\n        ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a random solution from the top 30% of the archive\n        selection_pool = ranked_solutions[:max(1, len(archive) // 3)]\n        base_solution, _ = random.choice(selection_pool)\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Perform a 2-opt move (standard local search)\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware swap: identify the worst edge in terms of all three objectives\n    def calculate_edge_cost(a, b):\n        return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n    # Find the edge with the highest combined cost\n    max_cost = -1\n    worst_edge = None\n    for k in range(n):\n        a, b = new_solution[k], new_solution[(k+1)%n]\n        cost = sum(calculate_edge_cost(a, b))\n        if cost > max_cost:\n            max_cost = cost\n            worst_edge = k\n\n    if worst_edge is not None:\n        # Try to replace the worst edge with a better one\n        candidates = [k for k in range(n) if k != worst_edge and k != (worst_edge+1)%n]\n        if candidates:\n            candidate = random.choice(candidates)\n            # Swap nodes to improve the worst edge\n            new_solution[worst_edge], new_solution[candidate] = new_solution[candidate], new_solution[worst_edge]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == len(base_solution), \"Invalid neighbor solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.744406222681868,
            1.7198320150375366
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Rank solutions by their objective values (lower is better)\n        ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a random solution from the top 30% of the archive\n        selection_pool = ranked_solutions[:max(1, len(archive) // 3)]\n        base_solution, _ = random.choice(selection_pool)\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Perform a 2-opt move (standard local search)\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware swap: identify the worst edge in terms of all three objectives\n    def calculate_edge_cost(a, b):\n        return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n    # Find the edge with the highest combined cost\n    max_cost = -1\n    worst_edge = None\n    for k in range(n):\n        a, b = new_solution[k], new_solution[(k+1)%n]\n        cost = sum(calculate_edge_cost(a, b))\n        if cost > max_cost:\n            max_cost = cost\n            worst_edge = k\n\n    if worst_edge is not None:\n        # Try to replace the worst edge with a better one\n        candidates = [k for k in range(n) if k != worst_edge and k != (worst_edge+1)%n]\n        if candidates:\n            candidate = random.choice(candidates)\n            # Swap nodes to improve the worst edge\n            new_solution[worst_edge], new_solution[candidate] = new_solution[candidate], new_solution[worst_edge]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == len(base_solution), \"Invalid neighbor solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 126,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., low objective values but not dominated)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    objectives = archive[selected_idx][1]\n\n    # Hybrid local search strategy combining:\n    # 1. 2-opt for the objective with the highest value\n    # 2. Or-opt for the other objectives\n    # 3. Randomly choose between 2-opt and 3-opt for diversity\n\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # Determine which objective has the highest value\n    max_obj_idx = np.argmax(objectives)\n\n    if np.random.random() < 0.5:  # 50% chance to apply 2-opt\n        # Apply 2-opt on the objective with highest value\n        i, j = sorted(np.random.choice(n_nodes, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    elif np.random.random() < 0.75:  # 25% chance to apply Or-opt\n        # Apply Or-opt on a randomly selected segment\n        i, j = sorted(np.random.choice(n_nodes, 2, replace=False))\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    else:  # 25% chance to apply 3-opt\n        # Apply 3-opt for more complex local search\n        i, j, k = sorted(np.random.choice(n_nodes, 3, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7921393671096684,
            1.4310926914215087
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., low objective values but not dominated)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    objectives = archive[selected_idx][1]\n\n    # Hybrid local search strategy combining:\n    # 1. 2-opt for the objective with the highest value\n    # 2. Or-opt for the other objectives\n    # 3. Randomly choose between 2-opt and 3-opt for diversity\n\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # Determine which objective has the highest value\n    max_obj_idx = np.argmax(objectives)\n\n    if np.random.random() < 0.5:  # 50% chance to apply 2-opt\n        # Apply 2-opt on the objective with highest value\n        i, j = sorted(np.random.choice(n_nodes, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    elif np.random.random() < 0.75:  # 25% chance to apply Or-opt\n        # Apply Or-opt on a randomly selected segment\n        i, j = sorted(np.random.choice(n_nodes, 2, replace=False))\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n    else:  # 25% chance to apply 3-opt\n        # Apply 3-opt for more complex local search\n        i, j, k = sorted(np.random.choice(n_nodes, 3, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 127,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution: prioritize those with high diversity in objectives\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    weights = diversity / np.sum(diversity) if np.sum(diversity) != 0 else np.ones(3) / 3\n\n    # Score each solution based on objective diversity\n    scores = np.array([np.dot(obj, weights) for _, obj in archive])\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    for _ in range(10):  # Number of local search iterations\n        # 1. Apply 2-opt with objective-aware edge selection\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i != j:\n            # Evaluate the impact on all three objectives\n            delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n                     (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n                     (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]) - \\\n                     (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            # Weighted acceptance probability based on objective improvements\n            total_delta = weights[0]*delta1 + weights[1]*delta2 + weights[2]*delta3\n            if total_delta < 0 or np.random.rand() < 0.1:  # Accept worse solutions with small probability\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # 2. Apply edge insertion with objective-aware selection\n        if n > 3:\n            k = np.random.randint(0, n)\n            l = np.random.randint(0, n)\n            if k != l:\n                # Evaluate the impact on all three objectives\n                delta1 = (distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                          distance_matrix_1[new_solution[k], new_solution[(l+1)%n]]) - \\\n                         (distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                          distance_matrix_1[new_solution[l], new_solution[(l+1)%n]])\n\n                delta2 = (distance_matrix_2[new_solution[k-1], new_solution[l]] +\n                          distance_matrix_2[new_solution[k], new_solution[(l+1)%n]]) - \\\n                         (distance_matrix_2[new_solution[k-1], new_solution[k]] +\n                          distance_matrix_2[new_solution[l], new_solution[(l+1)%n]])\n\n                delta3 = (distance_matrix_3[new_solution[k-1], new_solution[l]] +\n                          distance_matrix_3[new_solution[k], new_solution[(l+1)%n]]) - \\\n                         (distance_matrix_3[new_solution[k-1], new_solution[k]] +\n                          distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n                total_delta = weights[0]*delta1 + weights[1]*delta2 + weights[2]*delta3\n                if total_delta < 0 or np.random.rand() < 0.1:\n                    new_solution = np.concatenate([new_solution[:k], new_solution[k+1:l+1], [new_solution[k]], new_solution[l+1:]])\n\n        # 3. Apply objective-aware node swap\n        if n > 2:\n            m = np.random.randint(0, n)\n            p = np.random.randint(0, n)\n            if m != p:\n                # Evaluate the impact on all three objectives\n                delta1 = (distance_matrix_1[new_solution[m-1], new_solution[p]] +\n                          distance_matrix_1[new_solution[m], new_solution[p-1]] +\n                          distance_matrix_1[new_solution[p], new_solution[(m+1)%n]] +\n                          distance_matrix_1[new_solution[(p+1)%n], new_solution[m]]) - \\\n                         (distance_matrix_1[new_solution[m-1], new_solution[m]] +\n                          distance_matrix_1[new_solution[m], new_solution[(m+1)%n]] +\n                          distance_matrix_1[new_solution[p-1], new_solution[p]] +\n                          distance_matrix_1[new_solution[p], new_solution[(p+1)%n]])\n\n                delta2 = (distance_matrix_2[new_solution[m-1], new_solution[p]] +\n                          distance_matrix_2[new_solution[m], new_solution[p-1]] +\n                          distance_matrix_2[new_solution[p], new_solution[(m+1)%n]] +\n                          distance_matrix_2[new_solution[(p+1)%n], new_solution[m]]) - \\\n                         (distance_matrix_2[new_solution[m-1], new_solution[m]] +\n                          distance_matrix_2[new_solution[m], new_solution[(m+1)%n]] +\n                          distance_matrix_2[new_solution[p-1], new_solution[p]] +\n                          distance_matrix_2[new_solution[p], new_solution[(p+1)%n]])\n\n                delta3 = (distance_matrix_3[new_solution[m-1], new_solution[p]] +\n                          distance_matrix_3[new_solution[m], new_solution[p-1]] +\n                          distance_matrix_3[new_solution[p], new_solution[(m+1)%n]] +\n                          distance_matrix_3[new_solution[(p+1)%n], new_solution[m]]) - \\\n                         (distance_matrix_3[new_solution[m-1], new_solution[m]] +\n                          distance_matrix_3[new_solution[m], new_solution[(m+1)%n]] +\n                          distance_matrix_3[new_solution[p-1], new_solution[p]] +\n                          distance_matrix_3[new_solution[p], new_solution[(p+1)%n]])\n\n                total_delta = weights[0]*delta1 + weights[1]*delta2 + weights[2]*delta3\n                if total_delta < 0 or np.random.rand() < 0.1:\n                    new_solution[m], new_solution[p] = new_solution[p], new_solution[m]\n\n    return new_solution\n\n",
        "score": [
            -0.6392063825465584,
            3.3513777375221254
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution: prioritize those with high diversity in objectives\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    weights = diversity / np.sum(diversity) if np.sum(diversity) != 0 else np.ones(3) / 3\n\n    # Score each solution based on objective diversity\n    scores = np.array([np.dot(obj, weights) for _, obj in archive])\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    for _ in range(10):  # Number of local search iterations\n        # 1. Apply 2-opt with objective-aware edge selection\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i != j:\n            # Evaluate the impact on all three objectives\n            delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n                     (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n                     (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]) - \\\n                     (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            # Weighted acceptance probability based on objective improvements\n            total_delta = weights[0]*delta1 + weights[1]*delta2 + weights[2]*delta3\n            if total_delta < 0 or np.random.rand() < 0.1:  # Accept worse solutions with small probability\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # 2. Apply edge insertion with objective-aware selection\n        if n > 3:\n            k = np.random.randint(0, n)\n            l = np.random.randint(0, n)\n            if k != l:\n                # Evaluate the impact on all three objectives\n                delta1 = (distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                          distance_matrix_1[new_solution[k], new_solution[(l+1)%n]]) - \\\n                         (distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                          distance_matrix_1[new_solution[l], new_solution[(l+1)%n]])\n\n                delta2 = (distance_matrix_2[new_solution[k-1], new_solution[l]] +\n                          distance_matrix_2[new_solution[k], new_solution[(l+1)%n]]) - \\\n                         (distance_matrix_2[new_solution[k-1], new_solution[k]] +\n                          distance_matrix_2[new_solution[l], new_solution[(l+1)%n]])\n\n                delta3 = (distance_matrix_3[new_solution[k-1], new_solution[l]] +\n                          distance_matrix_3[new_solution[k], new_solution[(l+1)%n]]) - \\\n                         (distance_matrix_3[new_solution[k-1], new_solution[k]] +\n                          distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n                total_delta = weights[0]*delta1 + weights[1]*delta2 + weights[2]*delta3\n                if total_delta < 0 or np.random.rand() < 0.1:\n                    new_solution = np.concatenate([new_solution[:k], new_solution[k+1:l+1], [new_solution[k]], new_solution[l+1:]])\n\n        # 3. Apply objective-aware node swap\n        if n > 2:\n            m = np.random.randint(0, n)\n            p = np.random.randint(0, n)\n            if m != p:\n                # Evaluate the impact on all three objectives\n                delta1 = (distance_matrix_1[new_solution[m-1], new_solution[p]] +\n                          distance_matrix_1[new_solution[m], new_solution[p-1]] +\n                          distance_matrix_1[new_solution[p], new_solution[(m+1)%n]] +\n                          distance_matrix_1[new_solution[(p+1)%n], new_solution[m]]) - \\\n                         (distance_matrix_1[new_solution[m-1], new_solution[m]] +\n                          distance_matrix_1[new_solution[m], new_solution[(m+1)%n]] +\n                          distance_matrix_1[new_solution[p-1], new_solution[p]] +\n                          distance_matrix_1[new_solution[p], new_solution[(p+1)%n]])\n\n                delta2 = (distance_matrix_2[new_solution[m-1], new_solution[p]] +\n                          distance_matrix_2[new_solution[m], new_solution[p-1]] +\n                          distance_matrix_2[new_solution[p], new_solution[(m+1)%n]] +\n                          distance_matrix_2[new_solution[(p+1)%n], new_solution[m]]) - \\\n                         (distance_matrix_2[new_solution[m-1], new_solution[m]] +\n                          distance_matrix_2[new_solution[m], new_solution[(m+1)%n]] +\n                          distance_matrix_2[new_solution[p-1], new_solution[p]] +\n                          distance_matrix_2[new_solution[p], new_solution[(p+1)%n]])\n\n                delta3 = (distance_matrix_3[new_solution[m-1], new_solution[p]] +\n                          distance_matrix_3[new_solution[m], new_solution[p-1]] +\n                          distance_matrix_3[new_solution[p], new_solution[(m+1)%n]] +\n                          distance_matrix_3[new_solution[(p+1)%n], new_solution[m]]) - \\\n                         (distance_matrix_3[new_solution[m-1], new_solution[m]] +\n                          distance_matrix_3[new_solution[m], new_solution[(m+1)%n]] +\n                          distance_matrix_3[new_solution[p-1], new_solution[p]] +\n                          distance_matrix_3[new_solution[p], new_solution[(p+1)%n]])\n\n                total_delta = weights[0]*delta1 + weights[1]*delta2 + weights[2]*delta3\n                if total_delta < 0 or np.random.rand() < 0.1:\n                    new_solution[m], new_solution[p] = new_solution[p], new_solution[m]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 128,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement\n    # We define potential as the solution with the highest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    potential_scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy:\n    # 1. Apply 2-opt with highest improvement in any objective\n    # 2. If no improvement, apply 3-opt with the most balanced improvement across objectives\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # 2-opt with highest improvement in any objective\n    improved = False\n    for i in range(n - 1):\n        for j in range(i + 2, n):\n            if j == n - 1 and i == 0:\n                continue  # skip circular case\n\n            # Create candidate solution\n            candidate = new_solution.copy()\n            candidate[i+1:j+1] = candidate[i+1:j+1][::-1]\n\n            # Calculate objective values\n            obj1 = sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            obj2 = sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            obj3 = sum(distance_matrix_3[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n\n            # Check if any objective improves\n            current_obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            current_obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n            current_obj3 = sum(distance_matrix_3[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n\n            if (obj1 < current_obj1 or obj2 < current_obj2 or obj3 < current_obj3):\n                new_solution = candidate\n                improved = True\n                break\n        if improved:\n            break\n\n    # If no improvement with 2-opt, try 3-opt with balanced improvement\n    if not improved:\n        for i in range(n - 2):\n            for j in range(i + 2, n - 1):\n                for k in range(j + 2, n):\n                    if (k == n - 1 and i == 0) or (k == n - 1 and j == n - 2):\n                        continue  # skip circular cases\n\n                    # Create candidate solution\n                    candidate = new_solution.copy()\n                    # Reverse segments between i-j, j-k, and k-i\n                    candidate[i+1:j+1] = candidate[i+1:j+1][::-1]\n                    candidate[j+1:k+1] = candidate[j+1:k+1][::-1]\n                    candidate[i+1:k+1] = candidate[i+1:k+1][::-1]\n\n                    # Calculate objective values\n                    obj1 = sum(distance_matrix_1[candidate[l], candidate[l+1]] for l in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n                    obj2 = sum(distance_matrix_2[candidate[l], candidate[l+1]] for l in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n                    obj3 = sum(distance_matrix_3[candidate[l], candidate[l+1]] for l in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n\n                    # Check for balanced improvement across objectives\n                    current_obj1 = sum(distance_matrix_1[new_solution[l], new_solution[l+1]] for l in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n                    current_obj2 = sum(distance_matrix_2[new_solution[l], new_solution[l+1]] for l in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n                    current_obj3 = sum(distance_matrix_3[new_solution[l], new_solution[l+1]] for l in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n\n                    improvements = [\n                        (current_obj1 - obj1) / (current_obj1 + 1e-10),\n                        (current_obj2 - obj2) / (current_obj2 + 1e-10),\n                        (current_obj3 - obj3) / (current_obj3 + 1e-10)\n                    ]\n\n                    if all(imp > 0 for imp in improvements) and sum(imp > 0.05 for imp in improvements) >= 2:\n                        new_solution = candidate\n                        improved = True\n                        break\n                if improved:\n                    break\n            if improved:\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.5894242625119119,
            2.203677749633789
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement\n    # We define potential as the solution with the highest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    potential_scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy:\n    # 1. Apply 2-opt with highest improvement in any objective\n    # 2. If no improvement, apply 3-opt with the most balanced improvement across objectives\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # 2-opt with highest improvement in any objective\n    improved = False\n    for i in range(n - 1):\n        for j in range(i + 2, n):\n            if j == n - 1 and i == 0:\n                continue  # skip circular case\n\n            # Create candidate solution\n            candidate = new_solution.copy()\n            candidate[i+1:j+1] = candidate[i+1:j+1][::-1]\n\n            # Calculate objective values\n            obj1 = sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            obj2 = sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            obj3 = sum(distance_matrix_3[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n\n            # Check if any objective improves\n            current_obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            current_obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n            current_obj3 = sum(distance_matrix_3[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n\n            if (obj1 < current_obj1 or obj2 < current_obj2 or obj3 < current_obj3):\n                new_solution = candidate\n                improved = True\n                break\n        if improved:\n            break\n\n    # If no improvement with 2-opt, try 3-opt with balanced improvement\n    if not improved:\n        for i in range(n - 2):\n            for j in range(i + 2, n - 1):\n                for k in range(j + 2, n):\n                    if (k == n - 1 and i == 0) or (k == n - 1 and j == n - 2):\n                        continue  # skip circular cases\n\n                    # Create candidate solution\n                    candidate = new_solution.copy()\n                    # Reverse segments between i-j, j-k, and k-i\n                    candidate[i+1:j+1] = candidate[i+1:j+1][::-1]\n                    candidate[j+1:k+1] = candidate[j+1:k+1][::-1]\n                    candidate[i+1:k+1] = candidate[i+1:k+1][::-1]\n\n                    # Calculate objective values\n                    obj1 = sum(distance_matrix_1[candidate[l], candidate[l+1]] for l in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n                    obj2 = sum(distance_matrix_2[candidate[l], candidate[l+1]] for l in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n                    obj3 = sum(distance_matrix_3[candidate[l], candidate[l+1]] for l in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n\n                    # Check for balanced improvement across objectives\n                    current_obj1 = sum(distance_matrix_1[new_solution[l], new_solution[l+1]] for l in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n                    current_obj2 = sum(distance_matrix_2[new_solution[l], new_solution[l+1]] for l in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n                    current_obj3 = sum(distance_matrix_3[new_solution[l], new_solution[l+1]] for l in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n\n                    improvements = [\n                        (current_obj1 - obj1) / (current_obj1 + 1e-10),\n                        (current_obj2 - obj2) / (current_obj2 + 1e-10),\n                        (current_obj3 - obj3) / (current_obj3 + 1e-10)\n                    ]\n\n                    if all(imp > 0 for imp in improvements) and sum(imp > 0.05 for imp in improvements) >= 2:\n                        new_solution = candidate\n                        improved = True\n                        break\n                if improved:\n                    break\n            if improved:\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 129,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too diverse)\n    selected_idx = np.argmin([np.sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy combining 2-opt and edge exchange\n    n = len(base_solution)\n    i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n    k, l = sorted(np.random.choice(range(n), size=2, replace=False))\n\n    # 2-opt move for one objective (randomly selected)\n    obj_choice = np.random.choice([0, 1, 2])\n    if obj_choice == 0:\n        # 2-opt in space 1\n        new_solution[i:j+1] = base_solution[i:j+1][::-1]\n    elif obj_choice == 1:\n        # 2-opt in space 2\n        new_solution[k:l+1] = base_solution[k:l+1][::-1]\n    else:\n        # Edge exchange between spaces (hybrid move)\n        temp = new_solution[i]\n        new_solution[i] = new_solution[k]\n        new_solution[k] = temp\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        a, b = np.random.choice(range(n), size=2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.6384103347549254,
            3.870274615287781
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too diverse)\n    selected_idx = np.argmin([np.sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy combining 2-opt and edge exchange\n    n = len(base_solution)\n    i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n    k, l = sorted(np.random.choice(range(n), size=2, replace=False))\n\n    # 2-opt move for one objective (randomly selected)\n    obj_choice = np.random.choice([0, 1, 2])\n    if obj_choice == 0:\n        # 2-opt in space 1\n        new_solution[i:j+1] = base_solution[i:j+1][::-1]\n    elif obj_choice == 1:\n        # 2-opt in space 2\n        new_solution[k:l+1] = base_solution[k:l+1][::-1]\n    else:\n        # Edge exchange between spaces (hybrid move)\n        temp = new_solution[i]\n        new_solution[i] = new_solution[k]\n        new_solution[k] = temp\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        a, b = np.random.choice(range(n), size=2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 130,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (e.g., one with the highest total distance)\n    archive_with_metrics = []\n    for sol, obj in archive:\n        total_distance = obj[0] + obj[1] + obj[2]\n        archive_with_metrics.append((sol, obj, total_distance))\n\n    # Sort by total distance in descending order to prioritize solutions with higher potential\n    archive_with_metrics.sort(key=lambda x: -x[2])\n    selected_solution = archive_with_metrics[0][0].copy()\n\n    # Apply hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Reverse the segment (2-opt move)\n    reversed_segment = segment[::-1]\n    new_solution[i:j+1] = reversed_segment\n\n    # Further refine by selecting edges that improve the worst objective\n    for _ in range(2):  # Limit the number of refinements\n        # Calculate current objectives\n        current_obj1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))\n        current_obj2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n        current_obj3 = sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n\n        worst_obj = max(current_obj1, current_obj2, current_obj3)\n\n        # Find edges that could improve the worst objective\n        improved = False\n        for k in range(n):\n            for l in range(k+2, n):\n                # Try swapping edges to improve the worst objective\n                candidate = new_solution.copy()\n                candidate[k], candidate[l] = candidate[l], candidate[k]\n\n                # Calculate new objectives\n                new_obj1 = sum(distance_matrix_1[candidate[m-1], candidate[m]] for m in range(n))\n                new_obj2 = sum(distance_matrix_2[candidate[m-1], candidate[m]] for m in range(n))\n                new_obj3 = sum(distance_matrix_3[candidate[m-1], candidate[m]] for m in range(n))\n\n                new_worst_obj = max(new_obj1, new_obj2, new_obj3)\n\n                if new_worst_obj < worst_obj:\n                    new_solution = candidate\n                    improved = True\n                    break\n            if improved:\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.6176268135577574,
            2.0303780913352965
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (e.g., one with the highest total distance)\n    archive_with_metrics = []\n    for sol, obj in archive:\n        total_distance = obj[0] + obj[1] + obj[2]\n        archive_with_metrics.append((sol, obj, total_distance))\n\n    # Sort by total distance in descending order to prioritize solutions with higher potential\n    archive_with_metrics.sort(key=lambda x: -x[2])\n    selected_solution = archive_with_metrics[0][0].copy()\n\n    # Apply hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Reverse the segment (2-opt move)\n    reversed_segment = segment[::-1]\n    new_solution[i:j+1] = reversed_segment\n\n    # Further refine by selecting edges that improve the worst objective\n    for _ in range(2):  # Limit the number of refinements\n        # Calculate current objectives\n        current_obj1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))\n        current_obj2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n        current_obj3 = sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n\n        worst_obj = max(current_obj1, current_obj2, current_obj3)\n\n        # Find edges that could improve the worst objective\n        improved = False\n        for k in range(n):\n            for l in range(k+2, n):\n                # Try swapping edges to improve the worst objective\n                candidate = new_solution.copy()\n                candidate[k], candidate[l] = candidate[l], candidate[k]\n\n                # Calculate new objectives\n                new_obj1 = sum(distance_matrix_1[candidate[m-1], candidate[m]] for m in range(n))\n                new_obj2 = sum(distance_matrix_2[candidate[m-1], candidate[m]] for m in range(n))\n                new_obj3 = sum(distance_matrix_3[candidate[m-1], candidate[m]] for m in range(n))\n\n                new_worst_obj = max(new_obj1, new_obj2, new_obj3)\n\n                if new_worst_obj < worst_obj:\n                    new_solution = candidate\n                    improved = True\n                    break\n            if improved:\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 131,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest diversity (sum of objectives) to encourage exploration\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.sum(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy:\n    # 1. Perform a random 2-opt move (standard local search)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # 2. Apply a multi-objective aware insertion (considering all three objectives)\n    # Select a random segment and reinsert it in a position that improves at least one objective\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1].copy()\n\n    best_insert_pos = a\n    best_improvement = 0\n\n    # Evaluate possible insertion positions\n    for pos in range(n - len(segment) + 1):\n        if pos >= a and pos <= b:  # Skip positions within the original segment\n            continue\n\n        # Try inserting the segment at this position\n        temp_solution = np.concatenate([\n            new_solution[:pos],\n            segment,\n            new_solution[pos:]\n        ])\n\n        # Calculate the change in all three objectives\n        old_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n        old_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n        old_cost3 = sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))\n\n        new_cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n))\n        new_cost3 = sum(distance_matrix_3[temp_solution[i-1], temp_solution[i]] for i in range(n))\n\n        # Calculate improvement (sum of improvements across all objectives)\n        improvement = (old_cost1 - new_cost1) + (old_cost2 - new_cost2) + (old_cost3 - new_cost3)\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_insert_pos = pos\n\n    # Apply the best insertion found\n    if best_improvement > 0:\n        segment = new_solution[a:b+1].copy()\n        new_solution = np.concatenate([\n            new_solution[:best_insert_pos],\n            segment,\n            new_solution[best_insert_pos:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -0.6898916949770315,
            2.7444928526878356
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest diversity (sum of objectives) to encourage exploration\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.sum(objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy:\n    # 1. Perform a random 2-opt move (standard local search)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # 2. Apply a multi-objective aware insertion (considering all three objectives)\n    # Select a random segment and reinsert it in a position that improves at least one objective\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1].copy()\n\n    best_insert_pos = a\n    best_improvement = 0\n\n    # Evaluate possible insertion positions\n    for pos in range(n - len(segment) + 1):\n        if pos >= a and pos <= b:  # Skip positions within the original segment\n            continue\n\n        # Try inserting the segment at this position\n        temp_solution = np.concatenate([\n            new_solution[:pos],\n            segment,\n            new_solution[pos:]\n        ])\n\n        # Calculate the change in all three objectives\n        old_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n        old_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n        old_cost3 = sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))\n\n        new_cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n))\n        new_cost3 = sum(distance_matrix_3[temp_solution[i-1], temp_solution[i]] for i in range(n))\n\n        # Calculate improvement (sum of improvements across all objectives)\n        improvement = (old_cost1 - new_cost1) + (old_cost2 - new_cost2) + (old_cost3 - new_cost3)\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_insert_pos = pos\n\n    # Apply the best insertion found\n    if best_improvement > 0:\n        segment = new_solution[a:b+1].copy()\n        new_solution = np.concatenate([\n            new_solution[:best_insert_pos],\n            segment,\n            new_solution[best_insert_pos:]\n        ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 132,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel multi-objective operator\n    n = len(new_solution)\n    a, b = np.random.choice(n, 2, replace=False)\n    c, d = np.random.choice(n, 2, replace=False)\n\n    # Perform 2-opt swap\n    if a < b and c < d:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Multi-objective operator: swap segments based on objective dominance\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    if np.random.rand() < 0.5:  # 50% chance to apply multi-objective operator\n        # Identify the worst objective and focus on improving it\n        worst_obj = np.argmax([obj1, obj2, obj3])\n        if worst_obj == 0:\n            # Improve first objective by swapping edges with lower distance in space 1\n            for i in range(n):\n                for j in range(i+1, n):\n                    if distance_matrix_1[new_solution[i], new_solution[j]] < distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        elif worst_obj == 1:\n            # Improve second objective by swapping edges with lower distance in space 2\n            for i in range(n):\n                for j in range(i+1, n):\n                    if distance_matrix_2[new_solution[i], new_solution[j]] < distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Improve third objective by swapping edges with lower distance in space 3\n            for i in range(n):\n                for j in range(i+1, n):\n                    if distance_matrix_3[new_solution[i], new_solution[j]] < distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]]:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.5953377423834002,
            1.8841741561889649
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel multi-objective operator\n    n = len(new_solution)\n    a, b = np.random.choice(n, 2, replace=False)\n    c, d = np.random.choice(n, 2, replace=False)\n\n    # Perform 2-opt swap\n    if a < b and c < d:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Multi-objective operator: swap segments based on objective dominance\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    if np.random.rand() < 0.5:  # 50% chance to apply multi-objective operator\n        # Identify the worst objective and focus on improving it\n        worst_obj = np.argmax([obj1, obj2, obj3])\n        if worst_obj == 0:\n            # Improve first objective by swapping edges with lower distance in space 1\n            for i in range(n):\n                for j in range(i+1, n):\n                    if distance_matrix_1[new_solution[i], new_solution[j]] < distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        elif worst_obj == 1:\n            # Improve second objective by swapping edges with lower distance in space 2\n            for i in range(n):\n                for j in range(i+1, n):\n                    if distance_matrix_2[new_solution[i], new_solution[j]] < distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Improve third objective by swapping edges with lower distance in space 3\n            for i in range(n):\n                for j in range(i+1, n):\n                    if distance_matrix_3[new_solution[i], new_solution[j]] < distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]]:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 133,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest total cost)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(3, len(archive) - 1)  # Select from top 3 solutions\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: 2-opt with objective-aware swaps\n    n = len(new_solution)\n    improved = False\n\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        i, j = sorted(random.sample(range(1, n), 2))  # Ensure i < j\n\n        # Calculate current and potential costs\n        current_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        )\n\n        potential_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n            distance_matrix_2[new_solution[i-1], new_solution[j]] +\n            distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] +\n            distance_matrix_3[new_solution[i-1], new_solution[j]] +\n            distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]\n        )\n\n        # Accept if any objective improves or if total cost improves\n        if potential_cost < current_cost:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            improved = True\n\n    if not improved:\n        # If no improvement, perform a random 2-opt to maintain diversity\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6733551940918463,
            1.8293796539306642
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest total cost)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(3, len(archive) - 1)  # Select from top 3 solutions\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: 2-opt with objective-aware swaps\n    n = len(new_solution)\n    improved = False\n\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        i, j = sorted(random.sample(range(1, n), 2))  # Ensure i < j\n\n        # Calculate current and potential costs\n        current_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        )\n\n        potential_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n            distance_matrix_2[new_solution[i-1], new_solution[j]] +\n            distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] +\n            distance_matrix_3[new_solution[i-1], new_solution[j]] +\n            distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]\n        )\n\n        # Accept if any objective improves or if total cost improves\n        if potential_cost < current_cost:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            improved = True\n\n    if not improved:\n        # If no improvement, perform a random 2-opt to maintain diversity\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 134,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its objective value\n    objectives = [obj for _, obj in archive]\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n\n    # Normalize objectives and compute a score (lower is better)\n    normalized_obj = [(max_obj - obj) / (max_obj - min_obj + 1e-10) for obj in objectives]\n    scores = [np.sum(norm_obj) for norm_obj in normalized_obj]\n\n    # Select a solution with probability proportional to its score (higher score = more promising)\n    selected_idx = random.choices(range(len(archive)), weights=scores, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt and swap operations\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt or swap operation\n    if random.random() < 0.5:\n        # 2-opt operation (for TSP)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Swap operation (for multi-objective optimization)\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible\n    assert len(set(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            -0.7832826872120624,
            3.969214582443237
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its objective value\n    objectives = [obj for _, obj in archive]\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n\n    # Normalize objectives and compute a score (lower is better)\n    normalized_obj = [(max_obj - obj) / (max_obj - min_obj + 1e-10) for obj in objectives]\n    scores = [np.sum(norm_obj) for norm_obj in normalized_obj]\n\n    # Select a solution with probability proportional to its score (higher score = more promising)\n    selected_idx = random.choices(range(len(archive)), weights=scores, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt and swap operations\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt or swap operation\n    if random.random() < 0.5:\n        # 2-opt operation (for TSP)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Swap operation (for multi-objective optimization)\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible\n    assert len(set(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 135,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    from scipy.spatial import distance\n\n    # Select a solution with potential for improvement\n    if len(archive) > 1:\n        # Sort by the sum of objectives to prioritize solutions with higher total cost (more potential for improvement)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select top 20% of solutions\n        top_solutions = archive_sorted[:max(1, len(archive_sorted) // 5)]\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    if random.random() < 0.7:  # 70% chance for 2-opt\n        # 2-opt local search\n        i, j = sorted(random.sample(range(len(base_solution)), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:  # 30% chance for objective-specific operation\n        # Choose the objective with the highest variance in distances\n        obj_distances = []\n        for obj in [distance_matrix_1, distance_matrix_2, distance_matrix_3]:\n            tour_length = sum(obj[base_solution[i], base_solution[i+1]] for i in range(len(base_solution)-1))\n            tour_length += obj[base_solution[-1], base_solution[0]]  # complete the tour\n            obj_distances.append(tour_length)\n\n        # Find the objective with the highest variance\n        variances = []\n        for obj in [distance_matrix_1, distance_matrix_2, distance_matrix_3]:\n            distances = [obj[base_solution[i], base_solution[i+1]] for i in range(len(base_solution)-1)]\n            distances.append(obj[base_solution[-1], base_solution[0]])\n            variances.append(np.var(distances))\n\n        worst_obj = np.argmax(variances)\n\n        # Perform a 2-opt on the worst objective's worst segment\n        if worst_obj == 0:\n            obj_matrix = distance_matrix_1\n        elif worst_obj == 1:\n            obj_matrix = distance_matrix_2\n        else:\n            obj_matrix = distance_matrix_3\n\n        # Find the worst segment in this objective\n        worst_segment = None\n        max_diff = -float('inf')\n        for i in range(len(base_solution)-1):\n            diff = obj_matrix[base_solution[i], base_solution[i+1]] - np.mean([obj_matrix[base_solution[i], base_solution[j]] for j in range(len(base_solution)) if j != i])\n            if diff > max_diff:\n                max_diff = diff\n                worst_segment = i\n\n        if worst_segment is not None:\n            # Perform 2-opt on this segment\n            i = worst_segment\n            j = (i + 1) % len(base_solution)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6330601851455736,
            1.8767067193984985
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    from scipy.spatial import distance\n\n    # Select a solution with potential for improvement\n    if len(archive) > 1:\n        # Sort by the sum of objectives to prioritize solutions with higher total cost (more potential for improvement)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select top 20% of solutions\n        top_solutions = archive_sorted[:max(1, len(archive_sorted) // 5)]\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    if random.random() < 0.7:  # 70% chance for 2-opt\n        # 2-opt local search\n        i, j = sorted(random.sample(range(len(base_solution)), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:  # 30% chance for objective-specific operation\n        # Choose the objective with the highest variance in distances\n        obj_distances = []\n        for obj in [distance_matrix_1, distance_matrix_2, distance_matrix_3]:\n            tour_length = sum(obj[base_solution[i], base_solution[i+1]] for i in range(len(base_solution)-1))\n            tour_length += obj[base_solution[-1], base_solution[0]]  # complete the tour\n            obj_distances.append(tour_length)\n\n        # Find the objective with the highest variance\n        variances = []\n        for obj in [distance_matrix_1, distance_matrix_2, distance_matrix_3]:\n            distances = [obj[base_solution[i], base_solution[i+1]] for i in range(len(base_solution)-1)]\n            distances.append(obj[base_solution[-1], base_solution[0]])\n            variances.append(np.var(distances))\n\n        worst_obj = np.argmax(variances)\n\n        # Perform a 2-opt on the worst objective's worst segment\n        if worst_obj == 0:\n            obj_matrix = distance_matrix_1\n        elif worst_obj == 1:\n            obj_matrix = distance_matrix_2\n        else:\n            obj_matrix = distance_matrix_3\n\n        # Find the worst segment in this objective\n        worst_segment = None\n        max_diff = -float('inf')\n        for i in range(len(base_solution)-1):\n            diff = obj_matrix[base_solution[i], base_solution[i+1]] - np.mean([obj_matrix[base_solution[i], base_solution[j]] for j in range(len(base_solution)) if j != i])\n            if diff > max_diff:\n                max_diff = diff\n                worst_segment = i\n\n        if worst_segment is not None:\n            # Perform 2-opt on this segment\n            i = worst_segment\n            j = (i + 1) % len(base_solution)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 136,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate objective diversity scores (higher score means more potential for improvement)\n    diversity_scores = []\n    for sol, obj in archive:\n        # Calculate the standard deviation of the three objectives\n        std_dev = np.std(obj)\n        diversity_scores.append(std_dev)\n\n    # Normalize scores to form a probability distribution\n    total = sum(diversity_scores)\n    if total == 0:\n        prob_dist = [1.0 / len(archive) for _ in range(len(archive))]\n    else:\n        prob_dist = [score / total for score in diversity_scores]\n\n    # Select a solution based on the probability distribution\n    selected_idx = np.random.choice(len(archive), p=prob_dist)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt local search to improve tour structure\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(random.sample(range(n), 2))\n        if i == j:\n            continue\n\n        # Try reversing the segment between i and j\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n\n        # Calculate the change in total distance for all three objectives\n        delta1 = (distance_matrix_1[candidate[i-1], candidate[i]] + distance_matrix_1[candidate[j], candidate[(j+1)%n]] -\n                 (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]))\n        delta2 = (distance_matrix_2[candidate[i-1], candidate[i]] + distance_matrix_2[candidate[j], candidate[(j+1)%n]] -\n                 (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]))\n        delta3 = (distance_matrix_3[candidate[i-1], candidate[i]] + distance_matrix_3[candidate[j], candidate[(j+1)%n]] -\n                 (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]))\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution = candidate\n\n    # Second, perform objective-aware edge swaps\n    for _ in range(5):  # Limit iterations\n        # Select a random edge to swap\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i == j:\n            continue\n\n        # Try swapping nodes i and j\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        # Calculate the change in total distance for all three objectives\n        delta1 = (distance_matrix_1[candidate[i-1], candidate[i]] + distance_matrix_1[candidate[i], candidate[(i+1)%n]] +\n                 distance_matrix_1[candidate[j-1], candidate[j]] + distance_matrix_1[candidate[j], candidate[(j+1)%n]] -\n                 (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                  distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]))\n        delta2 = (distance_matrix_2[candidate[i-1], candidate[i]] + distance_matrix_2[candidate[i], candidate[(i+1)%n]] +\n                 distance_matrix_2[candidate[j-1], candidate[j]] + distance_matrix_2[candidate[j], candidate[(j+1)%n]] -\n                 (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                  distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]))\n        delta3 = (distance_matrix_3[candidate[i-1], candidate[i]] + distance_matrix_3[candidate[i], candidate[(i+1)%n]] +\n                 distance_matrix_3[candidate[j-1], candidate[j]] + distance_matrix_3[candidate[j], candidate[(j+1)%n]] -\n                 (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                  distance_matrix_3[new_solution[j-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]))\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.6977983910602242,
            4.082624053955078
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate objective diversity scores (higher score means more potential for improvement)\n    diversity_scores = []\n    for sol, obj in archive:\n        # Calculate the standard deviation of the three objectives\n        std_dev = np.std(obj)\n        diversity_scores.append(std_dev)\n\n    # Normalize scores to form a probability distribution\n    total = sum(diversity_scores)\n    if total == 0:\n        prob_dist = [1.0 / len(archive) for _ in range(len(archive))]\n    else:\n        prob_dist = [score / total for score in diversity_scores]\n\n    # Select a solution based on the probability distribution\n    selected_idx = np.random.choice(len(archive), p=prob_dist)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt local search to improve tour structure\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(random.sample(range(n), 2))\n        if i == j:\n            continue\n\n        # Try reversing the segment between i and j\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n\n        # Calculate the change in total distance for all three objectives\n        delta1 = (distance_matrix_1[candidate[i-1], candidate[i]] + distance_matrix_1[candidate[j], candidate[(j+1)%n]] -\n                 (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]))\n        delta2 = (distance_matrix_2[candidate[i-1], candidate[i]] + distance_matrix_2[candidate[j], candidate[(j+1)%n]] -\n                 (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]))\n        delta3 = (distance_matrix_3[candidate[i-1], candidate[i]] + distance_matrix_3[candidate[j], candidate[(j+1)%n]] -\n                 (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]))\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution = candidate\n\n    # Second, perform objective-aware edge swaps\n    for _ in range(5):  # Limit iterations\n        # Select a random edge to swap\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i == j:\n            continue\n\n        # Try swapping nodes i and j\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        # Calculate the change in total distance for all three objectives\n        delta1 = (distance_matrix_1[candidate[i-1], candidate[i]] + distance_matrix_1[candidate[i], candidate[(i+1)%n]] +\n                 distance_matrix_1[candidate[j-1], candidate[j]] + distance_matrix_1[candidate[j], candidate[(j+1)%n]] -\n                 (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                  distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]))\n        delta2 = (distance_matrix_2[candidate[i-1], candidate[i]] + distance_matrix_2[candidate[i], candidate[(i+1)%n]] +\n                 distance_matrix_2[candidate[j-1], candidate[j]] + distance_matrix_2[candidate[j], candidate[(j+1)%n]] -\n                 (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                  distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]))\n        delta3 = (distance_matrix_3[candidate[i-1], candidate[i]] + distance_matrix_3[candidate[i], candidate[(i+1)%n]] +\n                 distance_matrix_3[candidate[j-1], candidate[j]] + distance_matrix_3[candidate[j], candidate[(j+1)%n]] -\n                 (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                  distance_matrix_3[new_solution[j-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]))\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 137,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (not just the first one)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Apply 2-opt move (standard for TSP)\n    # 2. Apply a multi-objective aware swap (swap nodes that improve at least one objective)\n    n = len(new_solution)\n\n    # 2-opt move\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective aware swap\n    for _ in range(5):  # Limit the number of attempts to balance exploration/exploitation\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n\n        # Calculate current and new distances for all three objectives\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] +\n            distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] +\n            distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] +\n            distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] +\n            distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] +\n            distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] +\n            distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        # Accept if at least one objective improves\n        if any(new_cost < current_cost for new_cost, current_cost in zip(new_costs, current_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == len(instance), \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.6489200439765987,
            1.9664137363433838
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (not just the first one)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Apply 2-opt move (standard for TSP)\n    # 2. Apply a multi-objective aware swap (swap nodes that improve at least one objective)\n    n = len(new_solution)\n\n    # 2-opt move\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective aware swap\n    for _ in range(5):  # Limit the number of attempts to balance exploration/exploitation\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n\n        # Calculate current and new distances for all three objectives\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] +\n            distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] +\n            distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] +\n            distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] +\n            distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] +\n            distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] +\n            distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n\n        # Accept if at least one objective improves\n        if any(new_cost < current_cost for new_cost, current_cost in zip(new_costs, current_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == len(instance), \"Generated solution is invalid\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 138,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1 / (1 + obj[0] + obj[1] + obj[2]) for _, obj in archive],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt and node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct positions\n    i, j = random.sample(range(n), 2)\n    i, j = min(i, j), max(i, j)\n\n    # Apply 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select another position and insert a node\n    if n > 2:\n        k = random.randint(0, n-1)\n        if k != i and k != j:\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            insert_pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.802244103627111,
            1.2857075214385987
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1 / (1 + obj[0] + obj[1] + obj[2]) for _, obj in archive],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt and node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct positions\n    i, j = random.sample(range(n), 2)\n    i, j = min(i, j), max(i, j)\n\n    # Apply 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select another position and insert a node\n    if n > 2:\n        k = random.randint(0, n-1)\n        if k != i and k != j:\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            insert_pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 139,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal)\n    # Here, we select a solution that is not already in the archive (simplified approach)\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-specific swaps\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt or objective-specific swap\n    if random.random() < 0.5:\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Objective-specific swap: identify edges that are critical in any objective\n        # and perform a swap that improves at least one objective\n        best_improvement = 0\n        best_swap = None\n\n        for _ in range(10):  # Limit the number of attempts to keep it efficient\n            i, j = sorted(random.sample(range(n), 2))\n\n            # Calculate current and potential costs\n            current_costs = [\n                distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n                distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n                distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n            ]\n\n            new_costs = [\n                distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                distance_matrix_1[new_solution[i], new_solution[(j+1)%n]],\n                distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                distance_matrix_2[new_solution[i], new_solution[(j+1)%n]],\n                distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]\n            ]\n\n            # Calculate improvement (negative means better)\n            improvement = sum(new - current for new, current in zip(new_costs, current_costs))\n\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_swap = (i, j)\n\n        if best_swap is not None:\n            i, j = best_swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8734774840543308,
            1.656248676776886
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal)\n    # Here, we select a solution that is not already in the archive (simplified approach)\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-specific swaps\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt or objective-specific swap\n    if random.random() < 0.5:\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Objective-specific swap: identify edges that are critical in any objective\n        # and perform a swap that improves at least one objective\n        best_improvement = 0\n        best_swap = None\n\n        for _ in range(10):  # Limit the number of attempts to keep it efficient\n            i, j = sorted(random.sample(range(n), 2))\n\n            # Calculate current and potential costs\n            current_costs = [\n                distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n                distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n                distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n            ]\n\n            new_costs = [\n                distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                distance_matrix_1[new_solution[i], new_solution[(j+1)%n]],\n                distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                distance_matrix_2[new_solution[i], new_solution[(j+1)%n]],\n                distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]\n            ]\n\n            # Calculate improvement (negative means better)\n            improvement = sum(new - current for new, current in zip(new_costs, current_costs))\n\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_swap = (i, j)\n\n        if best_swap is not None:\n            i, j = best_swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 140,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity potential (not just the first one)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.linspace(0.1, 0.9, len(archive)).sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with edge exchange\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Randomly select two non-adjacent edges to break\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while abs(i - j) <= 1:\n        j = np.random.randint(0, n)\n\n    # Perform 2-opt swap\n    if i > j:\n        i, j = j, i\n    new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # With probability 0.3, perform an additional edge exchange for multi-objective optimization\n    if np.random.random() < 0.3:\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while abs(k - l) <= 1:\n            l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains feasible\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.7740963996299329,
            1.8230592489242554
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity potential (not just the first one)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.linspace(0.1, 0.9, len(archive)).sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with edge exchange\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Randomly select two non-adjacent edges to break\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while abs(i - j) <= 1:\n        j = np.random.randint(0, n)\n\n    # Perform 2-opt swap\n    if i > j:\n        i, j = j, i\n    new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # With probability 0.3, perform an additional edge exchange for multi-objective optimization\n    if np.random.random() < 0.3:\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while abs(k - l) <= 1:\n            l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains feasible\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 141,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives to find those with higher potential\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select from the top 50% solutions with the highest potential\n        selected = archive_sorted[int(len(archive_sorted) * 0.5):]\n        # Randomly select one solution from the top candidates\n        base_solution, _ = random.choice(selected)\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and objective-based edge swapping\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Perform 2-opt move\n    if j - i > 1:\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-based edge swapping\n    for _ in range(2):  # Perform a few swaps to diversify\n        k = random.randint(0, n-1)\n        l = (k + random.randint(1, n-1)) % n\n\n        # Calculate current and potential costs for all three objectives\n        current_costs = [\n            distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]],\n            distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]],\n            distance_matrix_3[new_solution[k-1], new_solution[k]] + distance_matrix_3[new_solution[l-1], new_solution[l]]\n        ]\n\n        potential_costs = [\n            distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]],\n            distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]],\n            distance_matrix_3[new_solution[k-1], new_solution[l]] + distance_matrix_3[new_solution[l-1], new_solution[k]]\n        ]\n\n        # Accept the swap if it improves at least one objective\n        if any(p < c for p, c in zip(potential_costs, current_costs)):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7133016827028538,
            1.426776123046875
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives to find those with higher potential\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select from the top 50% solutions with the highest potential\n        selected = archive_sorted[int(len(archive_sorted) * 0.5):]\n        # Randomly select one solution from the top candidates\n        base_solution, _ = random.choice(selected)\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and objective-based edge swapping\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Perform 2-opt move\n    if j - i > 1:\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-based edge swapping\n    for _ in range(2):  # Perform a few swaps to diversify\n        k = random.randint(0, n-1)\n        l = (k + random.randint(1, n-1)) % n\n\n        # Calculate current and potential costs for all three objectives\n        current_costs = [\n            distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]],\n            distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]],\n            distance_matrix_3[new_solution[k-1], new_solution[k]] + distance_matrix_3[new_solution[l-1], new_solution[l]]\n        ]\n\n        potential_costs = [\n            distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]],\n            distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]],\n            distance_matrix_3[new_solution[k-1], new_solution[l]] + distance_matrix_3[new_solution[l-1], new_solution[k]]\n        ]\n\n        # Accept the swap if it improves at least one objective\n        if any(p < c for p, c in zip(potential_costs, current_costs)):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 142,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions based on a combination of objective values (e.g., sum of normalized objectives)\n        objectives = np.array([obj for _, obj in archive])\n        normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-6)\n        scores = normalized_objectives.sum(axis=1)\n        # Select top 20% of solutions\n        top_indices = np.argsort(scores)[-max(1, len(scores) // 5):]\n        selected_index = random.choice(top_indices)\n        base_solution = archive[selected_index][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and random swap\n    n = len(new_solution)\n    if n < 2:\n        return new_solution\n\n    # 2-opt move (for one objective space)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Random swap (for another objective space)\n    k, l = random.sample(range(n), 2)\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains feasible\n    assert len(new_solution) == len(set(new_solution)), \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            -0.6692399734848504,
            1.7710950255393982
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions based on a combination of objective values (e.g., sum of normalized objectives)\n        objectives = np.array([obj for _, obj in archive])\n        normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-6)\n        scores = normalized_objectives.sum(axis=1)\n        # Select top 20% of solutions\n        top_indices = np.argsort(scores)[-max(1, len(scores) // 5):]\n        selected_index = random.choice(top_indices)\n        base_solution = archive[selected_index][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and random swap\n    n = len(new_solution)\n    if n < 2:\n        return new_solution\n\n    # 2-opt move (for one objective space)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Random swap (for another objective space)\n    k, l = random.sample(range(n), 2)\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains feasible\n    assert len(new_solution) == len(set(new_solution)), \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 143,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their objective values (sum of all objectives)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the middle of the archive (not too good, not too bad)\n        candidate_index = min(len(archive) // 2, len(archive) - 1)\n        base_solution = sorted_archive[candidate_index][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and edge exchange\n    n = len(new_solution)\n    i, j = np.random.randint(0, n, size=2)\n    k, l = np.random.randint(0, n, size=2)\n\n    # Ensure valid indices and different positions\n    if i != j and k != l and i < j and k < l:\n        # Apply 2-opt to the first segment (i to j)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Apply edge exchange to the second segment (k to l)\n        if k < l and l < n:\n            temp = new_solution[k]\n            new_solution[k] = new_solution[l]\n            new_solution[l] = temp\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.unique(new_solution), np.unique(base_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.65128716318733,
            2.2130271315574648
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their objective values (sum of all objectives)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the middle of the archive (not too good, not too bad)\n        candidate_index = min(len(archive) // 2, len(archive) - 1)\n        base_solution = sorted_archive[candidate_index][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and edge exchange\n    n = len(new_solution)\n    i, j = np.random.randint(0, n, size=2)\n    k, l = np.random.randint(0, n, size=2)\n\n    # Ensure valid indices and different positions\n    if i != j and k != l and i < j and k < l:\n        # Apply 2-opt to the first segment (i to j)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Apply edge exchange to the second segment (k to l)\n        if k < l and l < n:\n            temp = new_solution[k]\n            new_solution[k] = new_solution[l]\n            new_solution[l] = temp\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.unique(new_solution), np.unique(base_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 144,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability of being non-dominated and having potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operators\n\n    # Objective-aware selection of segments to modify\n    # Calculate the relative improvement potential for each objective\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    prob_obj1 = obj1 / total_obj\n    prob_obj2 = obj2 / total_obj\n    prob_obj3 = obj3 / total_obj\n\n    # Choose which objective to prioritize for the local search\n    r = random.random()\n    if r < prob_obj1:\n        # Prioritize first objective space\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]  # 2-opt swap\n    elif r < prob_obj1 + prob_obj2:\n        # Prioritize second objective space\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]  # 2-opt swap\n        # Additional swap to potentially improve second objective\n        k, l = sorted(random.sample(range(n), 2))\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n    else:\n        # Prioritize third objective space\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]  # 2-opt swap\n        # Additional 2-opt swap to potentially improve third objective\n        k, l = sorted(random.sample(range(n), 2))\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure the solution remains feasible (no duplicate nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by inserting missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n            new_solution = new_solution[:n]  # Ensure correct length\n\n    return new_solution\n\n",
        "score": [
            -0.7238688049341543,
            1.4222692608833314
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability of being non-dominated and having potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operators\n\n    # Objective-aware selection of segments to modify\n    # Calculate the relative improvement potential for each objective\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n    prob_obj1 = obj1 / total_obj\n    prob_obj2 = obj2 / total_obj\n    prob_obj3 = obj3 / total_obj\n\n    # Choose which objective to prioritize for the local search\n    r = random.random()\n    if r < prob_obj1:\n        # Prioritize first objective space\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]  # 2-opt swap\n    elif r < prob_obj1 + prob_obj2:\n        # Prioritize second objective space\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]  # 2-opt swap\n        # Additional swap to potentially improve second objective\n        k, l = sorted(random.sample(range(n), 2))\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n    else:\n        # Prioritize third objective space\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]  # 2-opt swap\n        # Additional 2-opt swap to potentially improve third objective\n        k, l = sorted(random.sample(range(n), 2))\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure the solution remains feasible (no duplicate nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by inserting missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n            new_solution = new_solution[:n]  # Ensure correct length\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 145,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with probability proportional to its \"potential\" for improvement\n    potentials = []\n    for sol, obj in archive:\n        # Calculate potential as the sum of normalized objectives (higher is better)\n        # Inverse of objectives since we want to minimize\n        potential = sum(1.0 / (o + 1e-6) for o in obj)  # Add small epsilon to avoid division by zero\n        potentials.append(potential)\n\n    # Normalize potentials to form a probability distribution\n    total_potential = sum(potentials)\n    if total_potential == 0:\n        probabilities = [1.0 / len(archive)] * len(archive)\n    else:\n        probabilities = [p / total_potential for p in potentials]\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(base_solution)\n    if n < 2:\n        return new_solution\n\n    # Choose between 2-opt or objective-aware swap with 50% probability\n    if random.random() < 0.5:\n        # 2-opt move\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Objective-aware swap: choose nodes based on their contribution to the objectives\n        # Calculate the \"cost\" of each node in the tour in each objective space\n        node_costs = np.zeros(n)\n        for k in range(n):\n            prev = base_solution[k-1]\n            curr = base_solution[k]\n            next_node = base_solution[(k+1) % n]\n\n            # Calculate the contribution of this node to the total cost in each objective space\n            cost1 = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]\n            cost2 = distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n            cost3 = distance_matrix_3[prev, curr] + distance_matrix_3[curr, next_node]\n\n            # Combine costs across objectives (simple weighted sum)\n            node_costs[k] = cost1 + cost2 + cost3\n\n        # Identify nodes with high cost (potential for improvement)\n        high_cost_indices = np.where(node_costs > np.mean(node_costs))[0]\n\n        if len(high_cost_indices) >= 2:\n            # Swap two high-cost nodes\n            i, j = random.sample(list(high_cost_indices), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.795913248833101,
            1.917958152294159
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with probability proportional to its \"potential\" for improvement\n    potentials = []\n    for sol, obj in archive:\n        # Calculate potential as the sum of normalized objectives (higher is better)\n        # Inverse of objectives since we want to minimize\n        potential = sum(1.0 / (o + 1e-6) for o in obj)  # Add small epsilon to avoid division by zero\n        potentials.append(potential)\n\n    # Normalize potentials to form a probability distribution\n    total_potential = sum(potentials)\n    if total_potential == 0:\n        probabilities = [1.0 / len(archive)] * len(archive)\n    else:\n        probabilities = [p / total_potential for p in potentials]\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(base_solution)\n    if n < 2:\n        return new_solution\n\n    # Choose between 2-opt or objective-aware swap with 50% probability\n    if random.random() < 0.5:\n        # 2-opt move\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Objective-aware swap: choose nodes based on their contribution to the objectives\n        # Calculate the \"cost\" of each node in the tour in each objective space\n        node_costs = np.zeros(n)\n        for k in range(n):\n            prev = base_solution[k-1]\n            curr = base_solution[k]\n            next_node = base_solution[(k+1) % n]\n\n            # Calculate the contribution of this node to the total cost in each objective space\n            cost1 = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]\n            cost2 = distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n            cost3 = distance_matrix_3[prev, curr] + distance_matrix_3[curr, next_node]\n\n            # Combine costs across objectives (simple weighted sum)\n            node_costs[k] = cost1 + cost2 + cost3\n\n        # Identify nodes with high cost (potential for improvement)\n        high_cost_indices = np.where(node_costs > np.mean(node_costs))[0]\n\n        if len(high_cost_indices) >= 2:\n            # Swap two high-cost nodes\n            i, j = random.sample(list(high_cost_indices), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 146,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy combining 2-opt and edge insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful changes\n\n    # Randomly select a segment to modify\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b]\n\n    # Apply 2-opt within the segment\n    if len(segment) >= 2:\n        i, j = np.random.choice(len(segment), 2, replace=False)\n        segment[i], segment[j] = segment[j], segment[i]\n\n    # Randomly insert a node from elsewhere\n    if n > b:\n        insert_pos = np.random.randint(a, b)\n        node_to_insert = np.random.choice(new_solution[b:])\n        new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_insert)[0][1])\n\n    # Ensure the solution remains a valid tour\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by removing them and adding missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n        # Remove duplicates while preserving order\n        _, unique_indices = np.unique(new_solution, return_index=True)\n        new_solution = new_solution[np.sort(unique_indices)]\n\n    return new_solution\n\n",
        "score": [
            -0.8333271444505005,
            2.225062668323517
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy combining 2-opt and edge insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful changes\n\n    # Randomly select a segment to modify\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b]\n\n    # Apply 2-opt within the segment\n    if len(segment) >= 2:\n        i, j = np.random.choice(len(segment), 2, replace=False)\n        segment[i], segment[j] = segment[j], segment[i]\n\n    # Randomly insert a node from elsewhere\n    if n > b:\n        insert_pos = np.random.randint(a, b)\n        node_to_insert = np.random.choice(new_solution[b:])\n        new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_insert)[0][1])\n\n    # Ensure the solution remains a valid tour\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by removing them and adding missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n        # Remove duplicates while preserving order\n        _, unique_indices = np.unique(new_solution, return_index=True)\n        new_solution = new_solution[np.sort(unique_indices)]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 147,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their combined objective values (sum of all three objectives)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select the middle solution to balance exploration and exploitation\n        selected_idx = len(sorted_archive) // 2\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: combine 2-opt with objective-aware edge selection\n    for _ in range(10):  # Perform multiple attempts to find a good neighbor\n        # Select two distinct random edges to modify\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n        # Create candidate solution\n        candidate = new_solution.copy()\n        candidate[a:b+1] = np.flip(candidate[a:b+1])\n        candidate[c:d+1] = np.flip(candidate[c:d+1])\n\n        # Evaluate the candidate solution across all three objectives\n        def calculate_objective(sol, dist_matrix):\n            total = 0\n            for i in range(n):\n                total += dist_matrix[sol[i], sol[(i+1)%n]]\n            return total\n\n        obj1 = calculate_objective(candidate, distance_matrix_1)\n        obj2 = calculate_objective(candidate, distance_matrix_2)\n        obj3 = calculate_objective(candidate, distance_matrix_3)\n\n        # Accept the candidate if it improves at least one objective\n        current_obj1 = calculate_objective(new_solution, distance_matrix_1)\n        current_obj2 = calculate_objective(new_solution, distance_matrix_2)\n        current_obj3 = calculate_objective(new_solution, distance_matrix_3)\n\n        if (obj1 < current_obj1) or (obj2 < current_obj2) or (obj3 < current_obj3):\n            new_solution = candidate.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7834646445770069,
            4.258671271800995
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their combined objective values (sum of all three objectives)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select the middle solution to balance exploration and exploitation\n        selected_idx = len(sorted_archive) // 2\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: combine 2-opt with objective-aware edge selection\n    for _ in range(10):  # Perform multiple attempts to find a good neighbor\n        # Select two distinct random edges to modify\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n        # Create candidate solution\n        candidate = new_solution.copy()\n        candidate[a:b+1] = np.flip(candidate[a:b+1])\n        candidate[c:d+1] = np.flip(candidate[c:d+1])\n\n        # Evaluate the candidate solution across all three objectives\n        def calculate_objective(sol, dist_matrix):\n            total = 0\n            for i in range(n):\n                total += dist_matrix[sol[i], sol[(i+1)%n]]\n            return total\n\n        obj1 = calculate_objective(candidate, distance_matrix_1)\n        obj2 = calculate_objective(candidate, distance_matrix_2)\n        obj3 = calculate_objective(candidate, distance_matrix_3)\n\n        # Accept the candidate if it improves at least one objective\n        current_obj1 = calculate_objective(new_solution, distance_matrix_1)\n        current_obj2 = calculate_objective(new_solution, distance_matrix_2)\n        current_obj3 = calculate_objective(new_solution, distance_matrix_3)\n\n        if (obj1 < current_obj1) or (obj2 < current_obj2) or (obj3 < current_obj3):\n            new_solution = candidate.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 148,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate diversity as the sum of differences in objectives\n        diversity = [sum(abs(archive[i][1][j] - archive[i+1][1][j]) for j in range(3))\n                     for i in range(len(archive)-1)]\n        max_diversity_idx = np.argmax(diversity)\n        base_solution = archive[max_diversity_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel 3-way edge swap\n    n = len(new_solution)\n    if n <= 3:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Choose between 2-opt or 3-way swap based on a probability\n    if random.random() < 0.7:  # Higher probability for 2-opt\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Novel 3-way edge swap: select 3 distinct edges and reconnect them\n        a, b, c = sorted(random.sample(range(n), 3))\n        # Create a new segment by combining parts of the tour\n        segment = np.concatenate([\n            new_solution[a:b],\n            new_solution[c:],\n            new_solution[b:c]\n        ])\n        new_solution[a:] = segment\n\n    return new_solution\n\n",
        "score": [
            -0.5884056456014883,
            1.9626352429389953
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate diversity as the sum of differences in objectives\n        diversity = [sum(abs(archive[i][1][j] - archive[i+1][1][j]) for j in range(3))\n                     for i in range(len(archive)-1)]\n        max_diversity_idx = np.argmax(diversity)\n        base_solution = archive[max_diversity_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel 3-way edge swap\n    n = len(new_solution)\n    if n <= 3:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Choose between 2-opt or 3-way swap based on a probability\n    if random.random() < 0.7:  # Higher probability for 2-opt\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Novel 3-way edge swap: select 3 distinct edges and reconnect them\n        a, b, c = sorted(random.sample(range(n), 3))\n        # Create a new segment by combining parts of the tour\n        segment = np.concatenate([\n            new_solution[a:b],\n            new_solution[c:],\n            new_solution[b:c]\n        ])\n        new_solution[a:] = segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 149,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value (sum of all three objectives)\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0]\n    new_solution = best_solution.copy()\n\n    # Apply a hybrid local search strategy combining 2-opt and node insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select a segment to perturb\n    i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Reverse the segment (2-opt-like move)\n    reversed_segment = segment[::-1]\n    new_solution[i:j+1] = reversed_segment\n\n    # Randomly select a node to reinsert elsewhere (node insertion)\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    l = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, l, node)\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != len(instance):\n        # Fallback to a simple swap if the solution becomes invalid\n        m, n = np.random.choice(range(len(new_solution)), size=2, replace=False)\n        new_solution[m], new_solution[n] = new_solution[n], new_solution[m]\n\n    return new_solution\n\n",
        "score": [
            -0.6913451982050672,
            1.7761735916137695
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value (sum of all three objectives)\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0]\n    new_solution = best_solution.copy()\n\n    # Apply a hybrid local search strategy combining 2-opt and node insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select a segment to perturb\n    i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Reverse the segment (2-opt-like move)\n    reversed_segment = segment[::-1]\n    new_solution[i:j+1] = reversed_segment\n\n    # Randomly select a node to reinsert elsewhere (node insertion)\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    l = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, l, node)\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != len(instance):\n        # Fallback to a simple swap if the solution becomes invalid\n        m, n = np.random.choice(range(len(new_solution)), size=2, replace=False)\n        new_solution[m], new_solution[n] = new_solution[n], new_solution[m]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 150,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions, objectives = zip(*archive)\n    objectives = np.array(objectives)\n    improvements = np.sum(np.abs(objectives - np.min(objectives, axis=0)), axis=1)\n    probabilities = improvements / np.sum(improvements)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and 3-opt with objective-aware selection\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful local search\n\n    # Choose between 2-opt and 3-opt based on current solution's diversity in objectives\n    obj_diversity = np.std(objectives[selected_idx])\n    if obj_diversity > 0.5 * np.mean(np.std(objectives, axis=0)):\n        # Use 3-opt for more complex improvements\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Apply 3-opt move\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n    else:\n        # Use 2-opt for simpler improvements\n        i, j = sorted(random.sample(range(n), 2))\n        # Apply 2-opt move\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7677506418384061,
            2.0826523423194887
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions, objectives = zip(*archive)\n    objectives = np.array(objectives)\n    improvements = np.sum(np.abs(objectives - np.min(objectives, axis=0)), axis=1)\n    probabilities = improvements / np.sum(improvements)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and 3-opt with objective-aware selection\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful local search\n\n    # Choose between 2-opt and 3-opt based on current solution's diversity in objectives\n    obj_diversity = np.std(objectives[selected_idx])\n    if obj_diversity > 0.5 * np.mean(np.std(objectives, axis=0)):\n        # Use 3-opt for more complex improvements\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Apply 3-opt move\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n    else:\n        # Use 2-opt for simpler improvements\n        i, j = sorted(random.sample(range(n), 2))\n        # Apply 2-opt move\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 151,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]) / 3)\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Apply a hybrid local search operator\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly choose between two local search strategies\n    if random.random() < 0.5:\n        # 2-opt local search (intra-route optimization)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Objective-aware swap (inter-route optimization)\n        # Find the node with the highest sum of distances across objectives\n        max_node = None\n        max_dist = -1\n        for i in range(n):\n            node = selected_solution[i]\n            prev_node = selected_solution[i-1]\n            next_node = selected_solution[(i+1) % n]\n            total_dist = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                          distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] +\n                          distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node])\n            if total_dist > max_dist:\n                max_dist = total_dist\n                max_node = i\n\n        # Swap with a random node that improves the worst objective\n        if max_node is not None:\n            worst_obj = np.argmax(archive_sorted[0][1])\n            candidate_nodes = list(range(n))\n            candidate_nodes.remove(max_node)\n\n            best_improvement = 0\n            best_swap = None\n\n            for j in candidate_nodes:\n                # Calculate improvement for each objective\n                original_dist = (\n                    distance_matrix_1[selected_solution[max_node-1], selected_solution[max_node]] +\n                    distance_matrix_1[selected_solution[max_node], selected_solution[(max_node+1)%n]] +\n                    distance_matrix_2[selected_solution[max_node-1], selected_solution[max_node]] +\n                    distance_matrix_2[selected_solution[max_node], selected_solution[(max_node+1)%n]] +\n                    distance_matrix_3[selected_solution[max_node-1], selected_solution[max_node]] +\n                    distance_matrix_3[selected_solution[max_node], selected_solution[(max_node+1)%n]]\n                )\n\n                new_dist = (\n                    distance_matrix_1[selected_solution[max_node-1], selected_solution[j]] +\n                    distance_matrix_1[selected_solution[j], selected_solution[(max_node+1)%n]] +\n                    distance_matrix_2[selected_solution[max_node-1], selected_solution[j]] +\n                    distance_matrix_2[selected_solution[j], selected_solution[(max_node+1)%n]] +\n                    distance_matrix_3[selected_solution[max_node-1], selected_solution[j]] +\n                    distance_matrix_3[selected_solution[j], selected_solution[(max_node+1)%n]]\n                )\n\n                improvement = original_dist - new_dist\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_swap = j\n\n            if best_swap is not None:\n                new_solution[max_node], new_solution[best_swap] = new_solution[best_swap], new_solution[max_node]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n    return new_solution\n\n",
        "score": [
            -0.6221527986328381,
            2.1917679071426392
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]) / 3)\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Apply a hybrid local search operator\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly choose between two local search strategies\n    if random.random() < 0.5:\n        # 2-opt local search (intra-route optimization)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Objective-aware swap (inter-route optimization)\n        # Find the node with the highest sum of distances across objectives\n        max_node = None\n        max_dist = -1\n        for i in range(n):\n            node = selected_solution[i]\n            prev_node = selected_solution[i-1]\n            next_node = selected_solution[(i+1) % n]\n            total_dist = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                          distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] +\n                          distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node])\n            if total_dist > max_dist:\n                max_dist = total_dist\n                max_node = i\n\n        # Swap with a random node that improves the worst objective\n        if max_node is not None:\n            worst_obj = np.argmax(archive_sorted[0][1])\n            candidate_nodes = list(range(n))\n            candidate_nodes.remove(max_node)\n\n            best_improvement = 0\n            best_swap = None\n\n            for j in candidate_nodes:\n                # Calculate improvement for each objective\n                original_dist = (\n                    distance_matrix_1[selected_solution[max_node-1], selected_solution[max_node]] +\n                    distance_matrix_1[selected_solution[max_node], selected_solution[(max_node+1)%n]] +\n                    distance_matrix_2[selected_solution[max_node-1], selected_solution[max_node]] +\n                    distance_matrix_2[selected_solution[max_node], selected_solution[(max_node+1)%n]] +\n                    distance_matrix_3[selected_solution[max_node-1], selected_solution[max_node]] +\n                    distance_matrix_3[selected_solution[max_node], selected_solution[(max_node+1)%n]]\n                )\n\n                new_dist = (\n                    distance_matrix_1[selected_solution[max_node-1], selected_solution[j]] +\n                    distance_matrix_1[selected_solution[j], selected_solution[(max_node+1)%n]] +\n                    distance_matrix_2[selected_solution[max_node-1], selected_solution[j]] +\n                    distance_matrix_2[selected_solution[j], selected_solution[(max_node+1)%n]] +\n                    distance_matrix_3[selected_solution[max_node-1], selected_solution[j]] +\n                    distance_matrix_3[selected_solution[j], selected_solution[(max_node+1)%n]]\n                )\n\n                improvement = original_dist - new_dist\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_swap = j\n\n            if best_swap is not None:\n                new_solution[max_node], new_solution[best_swap] = new_solution[best_swap], new_solution[max_node]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 152,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with the highest diversity or worst objective)\n    # Here, we select a solution with the highest sum of objectives (indicating potential for improvement)\n    objectives = [obj for _, obj in archive]\n    objective_sums = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(objective_sums)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt and 3-opt with a probabilistic approach\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and 3-opt\n    if random.random() < 0.7:  # 70% chance for 2-opt\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # 3-opt local search\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Ensure the solution remains a valid tour (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6619356955909993,
            1.7174083948135377
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with the highest diversity or worst objective)\n    # Here, we select a solution with the highest sum of objectives (indicating potential for improvement)\n    objectives = [obj for _, obj in archive]\n    objective_sums = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(objective_sums)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt and 3-opt with a probabilistic approach\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and 3-opt\n    if random.random() < 0.7:  # 70% chance for 2-opt\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # 3-opt local search\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Ensure the solution remains a valid tour (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 153,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate potential improvement score for each solution\n    scores = []\n    for sol, obj in archive:\n        # Calculate the total distance for each objective\n        total_dist = sum(obj)\n        # Calculate the average distance per node\n        avg_dist = total_dist / len(sol)\n        # Score is inversely proportional to the average distance (lower is better)\n        scores.append(1 / (avg_dist + 1e-10))  # Avoid division by zero\n\n    # Normalize scores to get probabilities\n    scores = np.array(scores)\n    probabilities = scores / np.sum(scores)\n\n    # Select a solution based on the probabilities\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using a hybrid local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between two types of moves with equal probability\n    if np.random.rand() < 0.5:\n        # 2-opt move (for one objective)\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Hybrid 3-opt move (for all three objectives)\n        i, j, k = np.random.choice(n, 3, replace=False)\n        # Sort the indices\n        i, j, k = sorted([i, j, k])\n        # Perform a 3-opt move by rearranging the segment\n        segment = new_solution[i:k+1]\n        # Split into three parts and rearrange\n        part1 = segment[:j-i]\n        part2 = segment[j-i:k-i]\n        part3 = segment[k-i:]\n        # Recombine in a different order\n        new_segment = np.concatenate([part1, part3, part2])\n        new_solution[i:k+1] = new_segment\n\n    # Ensure the solution remains valid (visits each node exactly once)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.7313209982478062,
            1.664195704460144
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate potential improvement score for each solution\n    scores = []\n    for sol, obj in archive:\n        # Calculate the total distance for each objective\n        total_dist = sum(obj)\n        # Calculate the average distance per node\n        avg_dist = total_dist / len(sol)\n        # Score is inversely proportional to the average distance (lower is better)\n        scores.append(1 / (avg_dist + 1e-10))  # Avoid division by zero\n\n    # Normalize scores to get probabilities\n    scores = np.array(scores)\n    probabilities = scores / np.sum(scores)\n\n    # Select a solution based on the probabilities\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using a hybrid local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between two types of moves with equal probability\n    if np.random.rand() < 0.5:\n        # 2-opt move (for one objective)\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Hybrid 3-opt move (for all three objectives)\n        i, j, k = np.random.choice(n, 3, replace=False)\n        # Sort the indices\n        i, j, k = sorted([i, j, k])\n        # Perform a 3-opt move by rearranging the segment\n        segment = new_solution[i:k+1]\n        # Split into three parts and rearrange\n        part1 = segment[:j-i]\n        part2 = segment[j-i:k-i]\n        part3 = segment[k-i:]\n        # Recombine in a different order\n        new_segment = np.concatenate([part1, part3, part2])\n        new_solution[i:k+1] = new_segment\n\n    # Ensure the solution remains valid (visits each node exactly once)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 154,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (lower is better)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the top 30% of the archive\n        selected_idx = np.random.randint(0, max(1, int(len(archive_sorted) * 0.3)))\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and objective-aware swaps\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform 2-opt move\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: swap nodes that are far apart in one objective but close in others\n    if n > 3:\n        # Select two nodes that are far apart in one objective but close in others\n        obj1_distances = np.array([distance_matrix_1[new_solution[i], new_solution[j]] for i in range(n) for j in range(i+1, n)])\n        obj2_distances = np.array([distance_matrix_2[new_solution[i], new_solution[j]] for i in range(n) for j in range(i+1, n)])\n        obj3_distances = np.array([distance_matrix_3[new_solution[i], new_solution[j]] for i in range(n) for j in range(i+1, n)])\n\n        # Find pairs that are far in one objective but close in others\n        far_in_one_close_in_others = (obj1_distances > np.percentile(obj1_distances, 75)) & \\\n                                    (obj2_distances < np.percentile(obj2_distances, 25)) & \\\n                                    (obj3_distances < np.percentile(obj3_distances, 25))\n        if np.any(far_in_one_close_in_others):\n            pairs = np.where(far_in_one_close_in_others)[0]\n            pair_idx = np.random.choice(pairs)\n            # Convert linear index to 2D indices\n            k = 0\n            for i in range(n):\n                for j in range(i+1, n):\n                    if k == pair_idx:\n                        # Perform swap\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        break\n                    k += 1\n                else:\n                    continue\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.7077882988180859,
            2.8957092642784117
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (lower is better)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the top 30% of the archive\n        selected_idx = np.random.randint(0, max(1, int(len(archive_sorted) * 0.3)))\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and objective-aware swaps\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Perform 2-opt move\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: swap nodes that are far apart in one objective but close in others\n    if n > 3:\n        # Select two nodes that are far apart in one objective but close in others\n        obj1_distances = np.array([distance_matrix_1[new_solution[i], new_solution[j]] for i in range(n) for j in range(i+1, n)])\n        obj2_distances = np.array([distance_matrix_2[new_solution[i], new_solution[j]] for i in range(n) for j in range(i+1, n)])\n        obj3_distances = np.array([distance_matrix_3[new_solution[i], new_solution[j]] for i in range(n) for j in range(i+1, n)])\n\n        # Find pairs that are far in one objective but close in others\n        far_in_one_close_in_others = (obj1_distances > np.percentile(obj1_distances, 75)) & \\\n                                    (obj2_distances < np.percentile(obj2_distances, 25)) & \\\n                                    (obj3_distances < np.percentile(obj3_distances, 25))\n        if np.any(far_in_one_close_in_others):\n            pairs = np.where(far_in_one_close_in_others)[0]\n            pair_idx = np.random.choice(pairs)\n            # Convert linear index to 2D indices\n            k = 0\n            for i in range(n):\n                for j in range(i+1, n):\n                    if k == pair_idx:\n                        # Perform swap\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        break\n                    k += 1\n                else:\n                    continue\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 155,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    def potential_score(solution, objective):\n        # Higher score for solutions with better diversity in objectives\n        return (objective[0] + objective[1] + objective[2]) * np.random.uniform(0.8, 1.2)\n\n    # Sort solutions by potential score\n    scored_solutions = [(potential_score(sol, obj), sol) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: x[0], reverse=True)\n\n    # Select top 20% or at least 1 solution\n    top_k = max(1, int(0.2 * len(scored_solutions)))\n    selected_solutions = [sol for _, sol in scored_solutions[:top_k]]\n\n    # Randomly select one from top candidates\n    base_solution = random.choice(selected_solutions).copy()\n\n    # Hybrid local search operator\n    def apply_hybrid_search(solution):\n        new_solution = solution.copy()\n        n = len(new_solution)\n\n        # Randomly select two non-adjacent edges to swap\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while abs(i - j) <= 1 or abs(i - j) >= n-1:\n            j = random.randint(0, n-1)\n\n        # Perform 2-opt swap\n        if i > j:\n            i, j = j, i\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n        # Apply a third objective-aware perturbation\n        # Select a random segment and reverse it if it improves the third objective\n        k = random.randint(0, n-1)\n        l = random.randint(0, n-1)\n        if k > l:\n            k, l = l, k\n\n        segment = new_solution[k:l+1]\n        reversed_segment = segment[::-1]\n\n        # Calculate cost difference for third objective\n        cost_before = sum(distance_matrix_3[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        cost_after = sum(distance_matrix_3[reversed_segment[i-1], reversed_segment[i]] for i in range(1, len(reversed_segment)))\n\n        if cost_after < cost_before:\n            new_solution[k:l+1] = reversed_segment\n\n        return new_solution\n\n    new_solution = apply_hybrid_search(base_solution)\n\n    # Ensure the solution remains feasible\n    assert len(new_solution) == len(base_solution), \"Invalid solution length\"\n    assert len(np.unique(new_solution)) == len(base_solution), \"Duplicate nodes in solution\"\n\n    return new_solution\n\n",
        "score": [
            -0.6856313989396173,
            2.673375833034515
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    def potential_score(solution, objective):\n        # Higher score for solutions with better diversity in objectives\n        return (objective[0] + objective[1] + objective[2]) * np.random.uniform(0.8, 1.2)\n\n    # Sort solutions by potential score\n    scored_solutions = [(potential_score(sol, obj), sol) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: x[0], reverse=True)\n\n    # Select top 20% or at least 1 solution\n    top_k = max(1, int(0.2 * len(scored_solutions)))\n    selected_solutions = [sol for _, sol in scored_solutions[:top_k]]\n\n    # Randomly select one from top candidates\n    base_solution = random.choice(selected_solutions).copy()\n\n    # Hybrid local search operator\n    def apply_hybrid_search(solution):\n        new_solution = solution.copy()\n        n = len(new_solution)\n\n        # Randomly select two non-adjacent edges to swap\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while abs(i - j) <= 1 or abs(i - j) >= n-1:\n            j = random.randint(0, n-1)\n\n        # Perform 2-opt swap\n        if i > j:\n            i, j = j, i\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n        # Apply a third objective-aware perturbation\n        # Select a random segment and reverse it if it improves the third objective\n        k = random.randint(0, n-1)\n        l = random.randint(0, n-1)\n        if k > l:\n            k, l = l, k\n\n        segment = new_solution[k:l+1]\n        reversed_segment = segment[::-1]\n\n        # Calculate cost difference for third objective\n        cost_before = sum(distance_matrix_3[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        cost_after = sum(distance_matrix_3[reversed_segment[i-1], reversed_segment[i]] for i in range(1, len(reversed_segment)))\n\n        if cost_after < cost_before:\n            new_solution[k:l+1] = reversed_segment\n\n        return new_solution\n\n    new_solution = apply_hybrid_search(base_solution)\n\n    # Ensure the solution remains feasible\n    assert len(new_solution) == len(base_solution), \"Invalid solution length\"\n    assert len(np.unique(new_solution)) == len(base_solution), \"Duplicate nodes in solution\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 156,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their total objective value (sum of all three objectives)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select from top 30% of solutions\n        candidate_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        selected_idx = random.randint(0, len(candidate_solutions) - 1)\n        base_solution = candidate_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    if random.random() < 0.7:  # 70% chance for 2-opt\n        # Perform 2-opt with objective-aware edge selection\n        i, j = sorted(random.sample(range(n), 2))\n        # Select edges to reverse based on their contribution to each objective\n        edge1 = (new_solution[i-1], new_solution[i])\n        edge2 = (new_solution[j-1], new_solution[j])\n        edge_contributions = [\n            (distance_matrix_1[edge1[0], edge1[1]] + distance_matrix_1[edge2[0], edge2[1]],\n             distance_matrix_2[edge1[0], edge1[1]] + distance_matrix_2[edge2[0], edge2[1]],\n             distance_matrix_3[edge1[0], edge1[1]] + distance_matrix_3[edge2[0], edge2[1]])\n        ]\n        # Reverse the edges if they improve at least one objective\n        if any(edge_contributions[0][k] > distance_matrix_1[new_solution[i-1], new_solution[j]] +\n               distance_matrix_1[new_solution[j-1], new_solution[i]] for k in range(3)):\n            new_solution[i:j] = new_solution[i:j][::-1]\n    else:  # 30% chance for objective-aware perturbation\n        # Select a node and find its best position in the tour based on all three objectives\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        # Calculate insertion cost for all possible positions\n        insertion_costs = []\n        for pos in range(n):\n            if pos == node_idx or pos == (node_idx + 1) % n:\n                continue\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n            cost = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node],\n                    distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node],\n                    distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node] - distance_matrix_3[prev_node, next_node])\n            insertion_costs.append((pos, cost))\n        # Find positions that improve at least one objective\n        improving_positions = [pos for pos, cost in insertion_costs if any(cost[k] < 0 for k in range(3))]\n        if improving_positions:\n            # Select the position that improves the most in any objective\n            best_pos = min(improving_positions, key=lambda pos: min(insertion_costs[pos][1]))\n            # Remove node from current position and insert at best_pos\n            new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.5594288245171729,
            3.789598250389099
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their total objective value (sum of all three objectives)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select from top 30% of solutions\n        candidate_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        selected_idx = random.randint(0, len(candidate_solutions) - 1)\n        base_solution = candidate_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    if random.random() < 0.7:  # 70% chance for 2-opt\n        # Perform 2-opt with objective-aware edge selection\n        i, j = sorted(random.sample(range(n), 2))\n        # Select edges to reverse based on their contribution to each objective\n        edge1 = (new_solution[i-1], new_solution[i])\n        edge2 = (new_solution[j-1], new_solution[j])\n        edge_contributions = [\n            (distance_matrix_1[edge1[0], edge1[1]] + distance_matrix_1[edge2[0], edge2[1]],\n             distance_matrix_2[edge1[0], edge1[1]] + distance_matrix_2[edge2[0], edge2[1]],\n             distance_matrix_3[edge1[0], edge1[1]] + distance_matrix_3[edge2[0], edge2[1]])\n        ]\n        # Reverse the edges if they improve at least one objective\n        if any(edge_contributions[0][k] > distance_matrix_1[new_solution[i-1], new_solution[j]] +\n               distance_matrix_1[new_solution[j-1], new_solution[i]] for k in range(3)):\n            new_solution[i:j] = new_solution[i:j][::-1]\n    else:  # 30% chance for objective-aware perturbation\n        # Select a node and find its best position in the tour based on all three objectives\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        # Calculate insertion cost for all possible positions\n        insertion_costs = []\n        for pos in range(n):\n            if pos == node_idx or pos == (node_idx + 1) % n:\n                continue\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n            cost = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node],\n                    distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node],\n                    distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node] - distance_matrix_3[prev_node, next_node])\n            insertion_costs.append((pos, cost))\n        # Find positions that improve at least one objective\n        improving_positions = [pos for pos, cost in insertion_costs if any(cost[k] < 0 for k in range(3))]\n        if improving_positions:\n            # Select the position that improves the most in any objective\n            best_pos = min(improving_positions, key=lambda pos: min(insertion_costs[pos][1]))\n            # Remove node from current position and insert at best_pos\n            new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 157,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly from top 30% of the archive)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selection_pool = sorted_archive[:max(1, len(sorted_archive) // 3)]\n    selected_idx = random.randint(0, len(selection_pool) - 1)\n    base_solution = selection_pool[selected_idx][0].copy()\n\n    # Choose a random local search operator\n    operator = random.choice(['2opt', '3opt', 'objective_aware_swap'])\n\n    new_solution = base_solution.copy()\n\n    if operator == '2opt':\n        # 2-opt local search\n        n = len(new_solution)\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == '3opt':\n        # 3-opt local search\n        n = len(new_solution)\n        i, j, k = sorted(random.sample(range(1, n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    elif operator == 'objective_aware_swap':\n        # Novel objective-aware segment swap\n        n = len(new_solution)\n        # Select a segment to swap based on the objectives\n        segment_length = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate the improvement potential for each objective\n        def calculate_improvement(sol):\n            total_dist = 0\n            for obj, dist_matrix in zip([distance_matrix_1, distance_matrix_2, distance_matrix_3], [distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n                dist = 0\n                for i in range(len(sol)):\n                    dist += dist_matrix[sol[i-1], sol[i]]\n                total_dist += dist\n            return total_dist\n\n        current_dist = calculate_improvement(new_solution)\n\n        # Try all possible positions for the segment\n        best_solution = new_solution.copy()\n        best_dist = current_dist\n\n        for pos in range(n - segment_length + 1):\n            if pos == start:\n                continue\n            temp_solution = np.concatenate([\n                new_solution[:pos],\n                segment,\n                np.delete(new_solution, np.arange(start, start+segment_length)),\n                new_solution[start+segment_length:]\n            ])\n            temp_dist = calculate_improvement(temp_solution)\n            if temp_dist < best_dist:\n                best_dist = temp_dist\n                best_solution = temp_solution\n\n        new_solution = best_solution\n\n    return new_solution\n\n",
        "score": [
            -0.6588034777347579,
            3.6168243288993835
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly from top 30% of the archive)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selection_pool = sorted_archive[:max(1, len(sorted_archive) // 3)]\n    selected_idx = random.randint(0, len(selection_pool) - 1)\n    base_solution = selection_pool[selected_idx][0].copy()\n\n    # Choose a random local search operator\n    operator = random.choice(['2opt', '3opt', 'objective_aware_swap'])\n\n    new_solution = base_solution.copy()\n\n    if operator == '2opt':\n        # 2-opt local search\n        n = len(new_solution)\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == '3opt':\n        # 3-opt local search\n        n = len(new_solution)\n        i, j, k = sorted(random.sample(range(1, n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    elif operator == 'objective_aware_swap':\n        # Novel objective-aware segment swap\n        n = len(new_solution)\n        # Select a segment to swap based on the objectives\n        segment_length = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate the improvement potential for each objective\n        def calculate_improvement(sol):\n            total_dist = 0\n            for obj, dist_matrix in zip([distance_matrix_1, distance_matrix_2, distance_matrix_3], [distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n                dist = 0\n                for i in range(len(sol)):\n                    dist += dist_matrix[sol[i-1], sol[i]]\n                total_dist += dist\n            return total_dist\n\n        current_dist = calculate_improvement(new_solution)\n\n        # Try all possible positions for the segment\n        best_solution = new_solution.copy()\n        best_dist = current_dist\n\n        for pos in range(n - segment_length + 1):\n            if pos == start:\n                continue\n            temp_solution = np.concatenate([\n                new_solution[:pos],\n                segment,\n                np.delete(new_solution, np.arange(start, start+segment_length)),\n                new_solution[start+segment_length:]\n            ])\n            temp_dist = calculate_improvement(temp_solution)\n            if temp_dist < best_dist:\n                best_dist = temp_dist\n                best_solution = temp_solution\n\n        new_solution = best_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 158,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    obj_variance = np.var(objectives, axis=0)\n    weighted_scores = np.dot(objectives, obj_variance)\n    probabilities = weighted_scores / np.sum(weighted_scores)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of three local search operators\n    operator = random.choice(['2-opt', 'swap', 'insert'])\n\n    if operator == '2-opt':\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'swap':\n        # Swap two nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    elif operator == 'insert':\n        # Insert a node at a different position\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains valid (no duplicates, all nodes present)\n    assert len(new_solution) == len(base_solution) and len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.80171207865565,
            1.788631761074066
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    obj_variance = np.var(objectives, axis=0)\n    weighted_scores = np.dot(objectives, obj_variance)\n    probabilities = weighted_scores / np.sum(weighted_scores)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of three local search operators\n    operator = random.choice(['2-opt', 'swap', 'insert'])\n\n    if operator == '2-opt':\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'swap':\n        # Swap two nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    elif operator == 'insert':\n        # Insert a node at a different position\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains valid (no duplicates, all nodes present)\n    assert len(new_solution) == len(base_solution) and len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 159,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # Here, we select the solution with the highest sum of objectives (indicating worse solutions)\n    # which are likely to have room for improvement\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Apply 2-opt with the objective that has the highest current cost\n    # 2. If no improvement, apply 3-opt\n    # 3. If still no improvement, apply a random swap\n\n    # Calculate current objectives\n    def calculate_objectives(sol):\n        obj1 = sum(distance_matrix_1[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n        obj2 = sum(distance_matrix_2[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n        obj3 = sum(distance_matrix_3[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n        return (obj1, obj2, obj3)\n\n    current_obj = calculate_objectives(base_solution)\n    improved = False\n\n    # 1. 2-opt with the worst objective\n    worst_obj_idx = np.argmax(current_obj)\n    if worst_obj_idx == 0:\n        dm = distance_matrix_1\n    elif worst_obj_idx == 1:\n        dm = distance_matrix_2\n    else:\n        dm = distance_matrix_3\n\n    n = len(new_solution)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if j == i + 1:\n                continue  # adjacent nodes, skip\n            # Reverse the segment between i and j\n            temp_sol = new_solution.copy()\n            temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n            new_obj = calculate_objectives(temp_sol)\n\n            if new_obj[worst_obj_idx] < current_obj[worst_obj_idx]:\n                new_solution = temp_sol\n                current_obj = new_obj\n                improved = True\n                break\n        if improved:\n            break\n\n    if not improved:\n        # 2. 3-opt if 2-opt didn't improve\n        for i in range(n - 2):\n            for j in range(i + 2, n):\n                for k in range(j + 2, n):\n                    # Try all possible 3-opt moves\n                    for move in [\n                        lambda x: np.concatenate([x[:i], x[i:j][::-1], x[j:k][::-1], x[k:]]),\n                        lambda x: np.concatenate([x[:i], x[j:k], x[i:j], x[k:]]),\n                        lambda x: np.concatenate([x[:i], x[j:k][::-1], x[i:j], x[k:]]),\n                        lambda x: np.concatenate([x[:i], x[i:j], x[k:], x[j:k][::-1]]),\n                        lambda x: np.concatenate([x[:i], x[k:], x[j:k][::-1], x[i:j]]),\n                        lambda x: np.concatenate([x[:i], x[k:], x[i:j], x[j:k][::-1]]),\n                        lambda x: np.concatenate([x[:i], x[j:k], x[k:], x[i:j][::-1]]),\n                    ]:\n                        temp_sol = move(new_solution.copy())\n                        new_obj = calculate_objectives(temp_sol)\n\n                        if any(new_obj[o] < current_obj[o] for o in range(3)):\n                            new_solution = temp_sol\n                            current_obj = new_obj\n                            improved = True\n                            break\n                    if improved:\n                        break\n                if improved:\n                    break\n            if improved:\n                break\n\n    if not improved:\n        # 3. Random swap if no improvement\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7173835774217048,
            1.771494495868683
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # Here, we select the solution with the highest sum of objectives (indicating worse solutions)\n    # which are likely to have room for improvement\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Apply 2-opt with the objective that has the highest current cost\n    # 2. If no improvement, apply 3-opt\n    # 3. If still no improvement, apply a random swap\n\n    # Calculate current objectives\n    def calculate_objectives(sol):\n        obj1 = sum(distance_matrix_1[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n        obj2 = sum(distance_matrix_2[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n        obj3 = sum(distance_matrix_3[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n        return (obj1, obj2, obj3)\n\n    current_obj = calculate_objectives(base_solution)\n    improved = False\n\n    # 1. 2-opt with the worst objective\n    worst_obj_idx = np.argmax(current_obj)\n    if worst_obj_idx == 0:\n        dm = distance_matrix_1\n    elif worst_obj_idx == 1:\n        dm = distance_matrix_2\n    else:\n        dm = distance_matrix_3\n\n    n = len(new_solution)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if j == i + 1:\n                continue  # adjacent nodes, skip\n            # Reverse the segment between i and j\n            temp_sol = new_solution.copy()\n            temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n            new_obj = calculate_objectives(temp_sol)\n\n            if new_obj[worst_obj_idx] < current_obj[worst_obj_idx]:\n                new_solution = temp_sol\n                current_obj = new_obj\n                improved = True\n                break\n        if improved:\n            break\n\n    if not improved:\n        # 2. 3-opt if 2-opt didn't improve\n        for i in range(n - 2):\n            for j in range(i + 2, n):\n                for k in range(j + 2, n):\n                    # Try all possible 3-opt moves\n                    for move in [\n                        lambda x: np.concatenate([x[:i], x[i:j][::-1], x[j:k][::-1], x[k:]]),\n                        lambda x: np.concatenate([x[:i], x[j:k], x[i:j], x[k:]]),\n                        lambda x: np.concatenate([x[:i], x[j:k][::-1], x[i:j], x[k:]]),\n                        lambda x: np.concatenate([x[:i], x[i:j], x[k:], x[j:k][::-1]]),\n                        lambda x: np.concatenate([x[:i], x[k:], x[j:k][::-1], x[i:j]]),\n                        lambda x: np.concatenate([x[:i], x[k:], x[i:j], x[j:k][::-1]]),\n                        lambda x: np.concatenate([x[:i], x[j:k], x[k:], x[i:j][::-1]]),\n                    ]:\n                        temp_sol = move(new_solution.copy())\n                        new_obj = calculate_objectives(temp_sol)\n\n                        if any(new_obj[o] < current_obj[o] for o in range(3)):\n                            new_solution = temp_sol\n                            current_obj = new_obj\n                            improved = True\n                            break\n                    if improved:\n                        break\n                if improved:\n                    break\n            if improved:\n                break\n\n    if not improved:\n        # 3. Random swap if no improvement\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 160,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on the worst objective (diversification)\n    objectives = [obj for _, obj in archive]\n    worst_obj_idx = np.argmax([max(obj) for obj in objectives])\n    base_solution = archive[worst_obj_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments for exchange\n    i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n    k, l = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n\n    # Perform edge exchange (similar to 2-opt but with two segments)\n    if i < k < j < l:\n        # Reverse the middle segment\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[k:l] = new_solution[k:l][::-1]\n    else:\n        # Perform a more complex exchange\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[k:l]\n        new_solution = np.concatenate([\n            new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]\n        ])\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple 2-opt if exchange fails\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.5065638272384579,
            0.9568776607513427
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on the worst objective (diversification)\n    objectives = [obj for _, obj in archive]\n    worst_obj_idx = np.argmax([max(obj) for obj in objectives])\n    base_solution = archive[worst_obj_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments for exchange\n    i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n    k, l = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n\n    # Perform edge exchange (similar to 2-opt but with two segments)\n    if i < k < j < l:\n        # Reverse the middle segment\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[k:l] = new_solution[k:l][::-1]\n    else:\n        # Perform a more complex exchange\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[k:l]\n        new_solution = np.concatenate([\n            new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]\n        ])\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple 2-opt if exchange fails\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 160,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on the worst objective (diversification)\n    objectives = [obj for _, obj in archive]\n    worst_obj_idx = np.argmax([max(obj) for obj in objectives])\n    base_solution = archive[worst_obj_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments for exchange\n    i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n    k, l = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n\n    # Perform edge exchange (similar to 2-opt but with two segments)\n    if i < k < j < l:\n        # Reverse the middle segment\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[k:l] = new_solution[k:l][::-1]\n    else:\n        # Perform a more complex exchange\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[k:l]\n        new_solution = np.concatenate([\n            new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]\n        ])\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple 2-opt if exchange fails\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.5065638272384579,
            0.9568776607513427
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on the worst objective (diversification)\n    objectives = [obj for _, obj in archive]\n    worst_obj_idx = np.argmax([max(obj) for obj in objectives])\n    base_solution = archive[worst_obj_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments for exchange\n    i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n    k, l = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n\n    # Perform edge exchange (similar to 2-opt but with two segments)\n    if i < k < j < l:\n        # Reverse the middle segment\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[k:l] = new_solution[k:l][::-1]\n    else:\n        # Perform a more complex exchange\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[k:l]\n        new_solution = np.concatenate([\n            new_solution[:i], segment2, new_solution[j:k], segment1, new_solution[l:]\n        ])\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple 2-opt if exchange fails\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 161,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: apply a combination of 2-opt and node swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and node swap with 50% probability\n    if random.random() < 0.5:\n        # 2-opt local search: randomly select two edges and reverse the segment between them\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Node swap: randomly select two nodes and swap their positions\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7044658636067482,
            1.80080726146698
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: apply a combination of 2-opt and node swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and node swap with 50% probability\n    if random.random() < 0.5:\n        # 2-opt local search: randomly select two edges and reverse the segment between them\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Node swap: randomly select two nodes and swap their positions\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 162,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1, len(archive)) / np.linspace(0.1, 1, len(archive)).sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Randomly select two distinct segments\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Perform 2-opt swap on the first segment\n        if i != j:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Perform 2-opt swap on the second segment\n        if k != l:\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Objective-aware swap: swap nodes that improve at least one objective\n        if i != k and j != l:\n            # Calculate current and potential costs\n            current_costs = [\n                distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n                distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n                distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n            ]\n\n            potential_costs = [\n                distance_matrix_1[new_solution[i-1], new_solution[k]] +\n                distance_matrix_1[new_solution[l], new_solution[(j+1)%n]],\n                distance_matrix_2[new_solution[i-1], new_solution[k]] +\n                distance_matrix_2[new_solution[l], new_solution[(j+1)%n]],\n                distance_matrix_3[new_solution[i-1], new_solution[k]] +\n                distance_matrix_3[new_solution[l], new_solution[(j+1)%n]]\n            ]\n\n            # If at least one objective improves, perform the swap\n            if any(p < c for p, c in zip(potential_costs, current_costs)):\n                new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n                new_solution[j], new_solution[l] = new_solution[l], new_solution[j]\n\n    return new_solution\n\n",
        "score": [
            -0.7549534297943962,
            3.451111602783203
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1, len(archive)) / np.linspace(0.1, 1, len(archive)).sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Randomly select two distinct segments\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Perform 2-opt swap on the first segment\n        if i != j:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Perform 2-opt swap on the second segment\n        if k != l:\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Objective-aware swap: swap nodes that improve at least one objective\n        if i != k and j != l:\n            # Calculate current and potential costs\n            current_costs = [\n                distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n                distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n                distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n            ]\n\n            potential_costs = [\n                distance_matrix_1[new_solution[i-1], new_solution[k]] +\n                distance_matrix_1[new_solution[l], new_solution[(j+1)%n]],\n                distance_matrix_2[new_solution[i-1], new_solution[k]] +\n                distance_matrix_2[new_solution[l], new_solution[(j+1)%n]],\n                distance_matrix_3[new_solution[i-1], new_solution[k]] +\n                distance_matrix_3[new_solution[l], new_solution[(j+1)%n]]\n            ]\n\n            # If at least one objective improves, perform the swap\n            if any(p < c for p, c in zip(potential_costs, current_costs)):\n                new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n                new_solution[j], new_solution[l] = new_solution[l], new_solution[j]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 163,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives to prioritize those that are not Pareto-optimal\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution that is not the best in any objective\n        selected_solution = archive_sorted[min(len(archive_sorted) // 2, len(archive_sorted) - 1)][0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a multi-objective aware perturbation\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Choose a random segment to modify\n    i = np.random.randint(0, n - 2)\n    j = np.random.randint(i + 1, n)\n\n    # Apply 2-opt to the selected segment\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective aware perturbation: swap nodes if it improves the worst objective\n    for _ in range(3):  # Try a few perturbations\n        a, b = np.random.choice(n, 2, replace=False)\n        temp_solution = new_solution.copy()\n        temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n        # Calculate the new objectives\n        obj1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        obj2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        obj3 = sum(distance_matrix_3[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Calculate the current objectives\n        current_obj1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        current_obj2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        current_obj3 = sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n        # Accept if at least one objective improves\n        if (obj1 < current_obj1) or (obj2 < current_obj2) or (obj3 < current_obj3):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7551736889013582,
            2.393259048461914
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives to prioritize those that are not Pareto-optimal\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution that is not the best in any objective\n        selected_solution = archive_sorted[min(len(archive_sorted) // 2, len(archive_sorted) - 1)][0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a multi-objective aware perturbation\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Choose a random segment to modify\n    i = np.random.randint(0, n - 2)\n    j = np.random.randint(i + 1, n)\n\n    # Apply 2-opt to the selected segment\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective aware perturbation: swap nodes if it improves the worst objective\n    for _ in range(3):  # Try a few perturbations\n        a, b = np.random.choice(n, 2, replace=False)\n        temp_solution = new_solution.copy()\n        temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n        # Calculate the new objectives\n        obj1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        obj2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        obj3 = sum(distance_matrix_3[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Calculate the current objectives\n        current_obj1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        current_obj2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        current_obj3 = sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n        # Accept if at least one objective improves\n        if (obj1 < current_obj1) or (obj2 < current_obj2) or (obj3 < current_obj3):\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 164,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising base solution (top 20% of archive)\n    num_candidates = max(1, len(archive) // 5)\n    candidates = sorted(archive, key=lambda x: sum(x[1]))[:num_candidates]\n    base_solution, objectives = candidates[np.random.randint(len(candidates))]\n\n    # Step 2: Determine which objective space has highest variance\n    obj_values = np.array([obj for _, obj in archive])\n    variances = np.var(obj_values, axis=0)\n    worst_obj_idx = np.argmax(variances)\n\n    # Step 3: Apply hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-swap operation (2-opt or 3-opt) based on worst objective\n    if worst_obj_idx == 0:\n        # For first objective, perform 3-opt\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n    else:\n        # For other objectives, perform 2-opt\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Node insertion heuristic to improve worst objective\n    insertion_point = np.random.randint(n)\n    node_to_move = new_solution[np.random.randint(n)]\n    new_solution = np.concatenate([\n        new_solution[:insertion_point],\n        [node_to_move],\n        new_solution[insertion_point:-1]\n    ])\n\n    # Ensure solution remains valid\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6884679721697575,
            0.48657950162887575
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising base solution (top 20% of archive)\n    num_candidates = max(1, len(archive) // 5)\n    candidates = sorted(archive, key=lambda x: sum(x[1]))[:num_candidates]\n    base_solution, objectives = candidates[np.random.randint(len(candidates))]\n\n    # Step 2: Determine which objective space has highest variance\n    obj_values = np.array([obj for _, obj in archive])\n    variances = np.var(obj_values, axis=0)\n    worst_obj_idx = np.argmax(variances)\n\n    # Step 3: Apply hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-swap operation (2-opt or 3-opt) based on worst objective\n    if worst_obj_idx == 0:\n        # For first objective, perform 3-opt\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n    else:\n        # For other objectives, perform 2-opt\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Node insertion heuristic to improve worst objective\n    insertion_point = np.random.randint(n)\n    node_to_move = new_solution[np.random.randint(n)]\n    new_solution = np.concatenate([\n        new_solution[:insertion_point],\n        [node_to_move],\n        new_solution[insertion_point:-1]\n    ])\n\n    # Ensure solution remains valid\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 164,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising base solution (top 20% of archive)\n    num_candidates = max(1, len(archive) // 5)\n    candidates = sorted(archive, key=lambda x: sum(x[1]))[:num_candidates]\n    base_solution, objectives = candidates[np.random.randint(len(candidates))]\n\n    # Step 2: Determine which objective space has highest variance\n    obj_values = np.array([obj for _, obj in archive])\n    variances = np.var(obj_values, axis=0)\n    worst_obj_idx = np.argmax(variances)\n\n    # Step 3: Apply hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-swap operation (2-opt or 3-opt) based on worst objective\n    if worst_obj_idx == 0:\n        # For first objective, perform 3-opt\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n    else:\n        # For other objectives, perform 2-opt\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Node insertion heuristic to improve worst objective\n    insertion_point = np.random.randint(n)\n    node_to_move = new_solution[np.random.randint(n)]\n    new_solution = np.concatenate([\n        new_solution[:insertion_point],\n        [node_to_move],\n        new_solution[insertion_point:-1]\n    ])\n\n    # Ensure solution remains valid\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6884679721697575,
            0.48657950162887575
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising base solution (top 20% of archive)\n    num_candidates = max(1, len(archive) // 5)\n    candidates = sorted(archive, key=lambda x: sum(x[1]))[:num_candidates]\n    base_solution, objectives = candidates[np.random.randint(len(candidates))]\n\n    # Step 2: Determine which objective space has highest variance\n    obj_values = np.array([obj for _, obj in archive])\n    variances = np.var(obj_values, axis=0)\n    worst_obj_idx = np.argmax(variances)\n\n    # Step 3: Apply hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-swap operation (2-opt or 3-opt) based on worst objective\n    if worst_obj_idx == 0:\n        # For first objective, perform 3-opt\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n    else:\n        # For other objectives, perform 2-opt\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Node insertion heuristic to improve worst objective\n    insertion_point = np.random.randint(n)\n    node_to_move = new_solution[np.random.randint(n)]\n    new_solution = np.concatenate([\n        new_solution[:insertion_point],\n        [node_to_move],\n        new_solution[insertion_point:-1]\n    ])\n\n    # Ensure solution remains valid\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 165,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution, _ = archive[selected_idx]\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy combining:\n    # 1. Random 2-opt for one objective\n    # 2. Random 3-opt for another objective\n    # 3. Random swap for the third objective\n\n    # Determine which objective to prioritize for each operation\n    obj_to_optimize = random.choice([0, 1, 2])\n\n    if obj_to_optimize == 0:\n        # 2-opt for first objective\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    elif obj_to_optimize == 1:\n        # 3-opt for second objective\n        i, j, k = sorted(random.sample(range(len(new_solution)), 3))\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n        new_solution[i:k+1] = np.concatenate([segment2, segment1])\n    else:\n        # Random swap for third objective\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains valid (no duplicates, all nodes present)\n    if len(set(new_solution)) != len(instance):\n        # If invalid, revert to original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7482888938863994,
            1.2993115544319154
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution, _ = archive[selected_idx]\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy combining:\n    # 1. Random 2-opt for one objective\n    # 2. Random 3-opt for another objective\n    # 3. Random swap for the third objective\n\n    # Determine which objective to prioritize for each operation\n    obj_to_optimize = random.choice([0, 1, 2])\n\n    if obj_to_optimize == 0:\n        # 2-opt for first objective\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    elif obj_to_optimize == 1:\n        # 3-opt for second objective\n        i, j, k = sorted(random.sample(range(len(new_solution)), 3))\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n        new_solution[i:k+1] = np.concatenate([segment2, segment1])\n    else:\n        # Random swap for third objective\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains valid (no duplicates, all nodes present)\n    if len(set(new_solution)) != len(instance):\n        # If invalid, revert to original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 166,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low dominance count (promising potential)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform a 2-opt move (standard local search)\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: identify critical segments based on all three objectives\n    # Calculate edge costs in all three spaces\n    def calculate_edge_costs(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n        cost2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n        cost3 = sum(distance_matrix_3[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_3[solution[-1], solution[0]]\n        return cost1, cost2, cost3\n\n    # Find the most \"critical\" edges (highest cost in any objective)\n    current_costs = calculate_edge_costs(new_solution)\n    max_cost = max(current_costs)\n\n    # Identify segments with high cost in any objective\n    critical_edges = []\n    for i in range(n-1):\n        edge_costs = (\n            distance_matrix_1[new_solution[i], new_solution[i+1]],\n            distance_matrix_2[new_solution[i], new_solution[i+1]],\n            distance_matrix_3[new_solution[i], new_solution[i+1]]\n        )\n        if any(c > 0.9 * max_cost for c in edge_costs):\n            critical_edges.append(i)\n\n    if critical_edges:\n        # Perform a targeted swap to improve the worst objective\n        k = np.random.choice(critical_edges)\n        l = np.random.choice([i for i in range(n) if i != k and i != (k+1)%n])\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7781334270796137,
            1.9811740040779113
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low dominance count (promising potential)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform a 2-opt move (standard local search)\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: identify critical segments based on all three objectives\n    # Calculate edge costs in all three spaces\n    def calculate_edge_costs(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n        cost2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n        cost3 = sum(distance_matrix_3[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_3[solution[-1], solution[0]]\n        return cost1, cost2, cost3\n\n    # Find the most \"critical\" edges (highest cost in any objective)\n    current_costs = calculate_edge_costs(new_solution)\n    max_cost = max(current_costs)\n\n    # Identify segments with high cost in any objective\n    critical_edges = []\n    for i in range(n-1):\n        edge_costs = (\n            distance_matrix_1[new_solution[i], new_solution[i+1]],\n            distance_matrix_2[new_solution[i], new_solution[i+1]],\n            distance_matrix_3[new_solution[i], new_solution[i+1]]\n        )\n        if any(c > 0.9 * max_cost for c in edge_costs):\n            critical_edges.append(i)\n\n    if critical_edges:\n        # Perform a targeted swap to improve the worst objective\n        k = np.random.choice(critical_edges)\n        l = np.random.choice([i for i in range(n) if i != k and i != (k+1)%n])\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 167,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distance for each solution\n        objectives = np.array([obj for _, obj in archive])\n        crowding_distances = np.zeros(len(archive))\n\n        for m in range(3):  # For each objective\n            sorted_indices = np.argsort(objectives[:, m])\n            sorted_obj = objectives[sorted_indices, m]\n            crowding_distances[sorted_indices[0]] = np.inf\n            crowding_distances[sorted_indices[-1]] = np.inf\n\n            for i in range(1, len(archive) - 1):\n                crowding_distances[sorted_indices[i]] += (sorted_obj[i + 1] - sorted_obj[i - 1])\n\n        # Select the solution with the highest crowding distance\n        selected_index = np.argmax(crowding_distances)\n        base_solution = archive[selected_index][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and edge insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt between i and j\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply edge insertion for the third objective\n    if np.random.rand() < 0.5:  # 50% chance to apply edge insertion\n        k = np.random.randint(0, n)\n        if k != i and k != j:\n            # Remove node at k and reinsert it elsewhere\n            removed_node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            new_pos = np.random.randint(0, n - 1)\n            new_solution = np.insert(new_solution, new_pos, removed_node)\n\n    return new_solution\n\n",
        "score": [
            -0.5834447720090777,
            2.256511855125427
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distance for each solution\n        objectives = np.array([obj for _, obj in archive])\n        crowding_distances = np.zeros(len(archive))\n\n        for m in range(3):  # For each objective\n            sorted_indices = np.argsort(objectives[:, m])\n            sorted_obj = objectives[sorted_indices, m]\n            crowding_distances[sorted_indices[0]] = np.inf\n            crowding_distances[sorted_indices[-1]] = np.inf\n\n            for i in range(1, len(archive) - 1):\n                crowding_distances[sorted_indices[i]] += (sorted_obj[i + 1] - sorted_obj[i - 1])\n\n        # Select the solution with the highest crowding distance\n        selected_index = np.argmax(crowding_distances)\n        base_solution = archive[selected_index][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and edge insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt between i and j\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply edge insertion for the third objective\n    if np.random.rand() < 0.5:  # 50% chance to apply edge insertion\n        k = np.random.randint(0, n)\n        if k != i and k != j:\n            # Remove node at k and reinsert it elsewhere\n            removed_node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            new_pos = np.random.randint(0, n - 1)\n            new_solution = np.insert(new_solution, new_pos, removed_node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 168,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive\n    # Here we select the solution with the best combined objective value\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate the sum of normalized objectives for each solution\n    normalized_objectives = np.array(archive_objectives)\n    min_obj = np.min(normalized_objectives, axis=0)\n    max_obj = np.max(normalized_objectives, axis=0)\n    normalized_objectives = (normalized_objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    combined_scores = np.sum(normalized_objectives, axis=1)\n\n    # Select the solution with the best combined score\n    best_idx = np.argmin(combined_scores)\n    base_solution = archive_solutions[best_idx].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Apply different local search operators based on the objective space\n    if np.random.rand() < 0.5:\n        # 2-opt local search\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Insertion-based local search\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Ensure the solution remains feasible\n    # Verify that all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        # If not feasible, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5891455537713166,
            3.3482173681259155
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive\n    # Here we select the solution with the best combined objective value\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate the sum of normalized objectives for each solution\n    normalized_objectives = np.array(archive_objectives)\n    min_obj = np.min(normalized_objectives, axis=0)\n    max_obj = np.max(normalized_objectives, axis=0)\n    normalized_objectives = (normalized_objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    combined_scores = np.sum(normalized_objectives, axis=1)\n\n    # Select the solution with the best combined score\n    best_idx = np.argmin(combined_scores)\n    base_solution = archive_solutions[best_idx].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Apply different local search operators based on the objective space\n    if np.random.rand() < 0.5:\n        # 2-opt local search\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Insertion-based local search\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Ensure the solution remains feasible\n    # Verify that all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        # If not feasible, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 169,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest total objective value)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with multi-objective perturbation\n    n = len(new_solution)\n    for _ in range(10):  # Number of perturbation attempts\n        # Randomly select two distinct edges to swap (2-opt)\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Multi-objective perturbation: swap nodes based on objective dominance\n        if np.random.random() < 0.3:  # 30% chance of additional perturbation\n            # Identify nodes with high marginal improvement potential\n            marginal_improvements = []\n            for k in range(n):\n                # Calculate improvement if we move node k to position i\n                old_cost = (distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                            distance_matrix_2[new_solution[k-1], new_solution[k]] +\n                            distance_matrix_3[new_solution[k-1], new_solution[k]])\n                new_cost = (distance_matrix_1[new_solution[k-1], new_solution[i]] +\n                            distance_matrix_2[new_solution[k-1], new_solution[i]] +\n                            distance_matrix_3[new_solution[k-1], new_solution[i]])\n                marginal_improvements.append(old_cost - new_cost)\n\n            # Select node with highest marginal improvement\n            best_k = np.argmax(marginal_improvements)\n            # Insert node at position i\n            node_to_move = new_solution[best_k]\n            new_solution = np.concatenate([new_solution[:i], [node_to_move], new_solution[i:best_k], new_solution[best_k+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.737219145720293,
            3.0226804852485656
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest total objective value)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with multi-objective perturbation\n    n = len(new_solution)\n    for _ in range(10):  # Number of perturbation attempts\n        # Randomly select two distinct edges to swap (2-opt)\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Multi-objective perturbation: swap nodes based on objective dominance\n        if np.random.random() < 0.3:  # 30% chance of additional perturbation\n            # Identify nodes with high marginal improvement potential\n            marginal_improvements = []\n            for k in range(n):\n                # Calculate improvement if we move node k to position i\n                old_cost = (distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                            distance_matrix_2[new_solution[k-1], new_solution[k]] +\n                            distance_matrix_3[new_solution[k-1], new_solution[k]])\n                new_cost = (distance_matrix_1[new_solution[k-1], new_solution[i]] +\n                            distance_matrix_2[new_solution[k-1], new_solution[i]] +\n                            distance_matrix_3[new_solution[k-1], new_solution[i]])\n                marginal_improvements.append(old_cost - new_cost)\n\n            # Select node with highest marginal improvement\n            best_k = np.argmax(marginal_improvements)\n            # Insert node at position i\n            node_to_move = new_solution[best_k]\n            new_solution = np.concatenate([new_solution[:i], [node_to_move], new_solution[i:best_k], new_solution[best_k+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 170,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (lower is better)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 20% or at least 1 solution\n        top_k = max(1, int(0.2 * len(archive_sorted)))\n        selected = random.choice(archive_sorted[:top_k])\n        base_solution = selected[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple attempts\n        # Randomly select two distinct edges to modify\n        i, j = sorted(random.sample(range(n), 2))\n\n        # 2-opt move (reverse a segment)\n        if random.random() < 0.7:  # Higher probability for 2-opt\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:  # Objective-aware swap\n            # Calculate the change in objectives for the swap\n            original_cost = (\n                distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n                distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n            )\n\n            new_cost = (\n                distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] +\n                distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]\n            )\n\n            # Only perform swap if it improves at least one objective\n            if new_cost < original_cost:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7618838928186507,
            0.9319159626960755
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (lower is better)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 20% or at least 1 solution\n        top_k = max(1, int(0.2 * len(archive_sorted)))\n        selected = random.choice(archive_sorted[:top_k])\n        base_solution = selected[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple attempts\n        # Randomly select two distinct edges to modify\n        i, j = sorted(random.sample(range(n), 2))\n\n        # 2-opt move (reverse a segment)\n        if random.random() < 0.7:  # Higher probability for 2-opt\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:  # Objective-aware swap\n            # Calculate the change in objectives for the swap\n            original_cost = (\n                distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n                distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n            )\n\n            new_cost = (\n                distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] +\n                distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]\n            )\n\n            # Only perform swap if it improves at least one objective\n            if new_cost < original_cost:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 171,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest objective values)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = random.randint(0, candidate_indices - 1)\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy combining 2-opt and edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt move in the objective space with the highest current cost\n    objectives = sorted_archive[selected_idx][1]\n    max_obj_idx = np.argmax(objectives)\n\n    if max_obj_idx == 0:\n        distance_matrix = distance_matrix_1\n    elif max_obj_idx == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Find the worst edge in the selected objective space\n    worst_edge = None\n    worst_edge_length = -1\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i + 1) % n]\n        edge_length = distance_matrix[u, v]\n        if edge_length > worst_edge_length:\n            worst_edge_length = edge_length\n            worst_edge = (i, (i + 1) % n)\n\n    if worst_edge is not None:\n        i, j = worst_edge\n        # Try to replace the worst edge with a better one\n        for k in range(n):\n            if k == i or k == j or (k + 1) % n == i or (k + 1) % n == j:\n                continue\n            # Calculate potential improvement\n            u, v = new_solution[i], new_solution[j]\n            x, y = new_solution[k], new_solution[(k + 1) % n]\n            old_length = distance_matrix[u, v] + distance_matrix[x, y]\n            new_length = distance_matrix[u, x] + distance_matrix[v, y]\n            if new_length < old_length:\n                # Perform the 2-opt move\n                new_solution = np.concatenate([\n                    new_solution[:i+1],\n                    new_solution[k::-1],\n                    new_solution[(k+1):j],\n                    new_solution[i+1:k+1][::-1],\n                    new_solution[j+1:]\n                ])\n                break\n\n    # Perform edge exchange across objectives to balance improvements\n    if random.random() < 0.5:  # 50% chance to perform edge exchange\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        # Try to exchange edges between objectives\n        for obj_idx in range(3):\n            if obj_idx == 0:\n                dm = distance_matrix_1\n            elif obj_idx == 1:\n                dm = distance_matrix_2\n            else:\n                dm = distance_matrix_3\n\n            u, v = new_solution[i], new_solution[(i + 1) % n]\n            x, y = new_solution[j], new_solution[(j + 1) % n]\n\n            old_length = dm[u, v] + dm[x, y]\n            new_length = dm[u, x] + dm[v, y]\n\n            if new_length < old_length:\n                # Perform the edge exchange\n                new_solution = np.concatenate([\n                    new_solution[:i+1],\n                    new_solution[j:j+1],\n                    new_solution[(i+1):j],\n                    new_solution[i:i+1],\n                    new_solution[j+1:]\n                ])\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.7171342366001333,
            0.390398895740509
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest objective values)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = random.randint(0, candidate_indices - 1)\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy combining 2-opt and edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt move in the objective space with the highest current cost\n    objectives = sorted_archive[selected_idx][1]\n    max_obj_idx = np.argmax(objectives)\n\n    if max_obj_idx == 0:\n        distance_matrix = distance_matrix_1\n    elif max_obj_idx == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Find the worst edge in the selected objective space\n    worst_edge = None\n    worst_edge_length = -1\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i + 1) % n]\n        edge_length = distance_matrix[u, v]\n        if edge_length > worst_edge_length:\n            worst_edge_length = edge_length\n            worst_edge = (i, (i + 1) % n)\n\n    if worst_edge is not None:\n        i, j = worst_edge\n        # Try to replace the worst edge with a better one\n        for k in range(n):\n            if k == i or k == j or (k + 1) % n == i or (k + 1) % n == j:\n                continue\n            # Calculate potential improvement\n            u, v = new_solution[i], new_solution[j]\n            x, y = new_solution[k], new_solution[(k + 1) % n]\n            old_length = distance_matrix[u, v] + distance_matrix[x, y]\n            new_length = distance_matrix[u, x] + distance_matrix[v, y]\n            if new_length < old_length:\n                # Perform the 2-opt move\n                new_solution = np.concatenate([\n                    new_solution[:i+1],\n                    new_solution[k::-1],\n                    new_solution[(k+1):j],\n                    new_solution[i+1:k+1][::-1],\n                    new_solution[j+1:]\n                ])\n                break\n\n    # Perform edge exchange across objectives to balance improvements\n    if random.random() < 0.5:  # 50% chance to perform edge exchange\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        # Try to exchange edges between objectives\n        for obj_idx in range(3):\n            if obj_idx == 0:\n                dm = distance_matrix_1\n            elif obj_idx == 1:\n                dm = distance_matrix_2\n            else:\n                dm = distance_matrix_3\n\n            u, v = new_solution[i], new_solution[(i + 1) % n]\n            x, y = new_solution[j], new_solution[(j + 1) % n]\n\n            old_length = dm[u, v] + dm[x, y]\n            new_length = dm[u, x] + dm[v, y]\n\n            if new_length < old_length:\n                # Perform the edge exchange\n                new_solution = np.concatenate([\n                    new_solution[:i+1],\n                    new_solution[j:j+1],\n                    new_solution[(i+1):j],\n                    new_solution[i:i+1],\n                    new_solution[j+1:]\n                ])\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 171,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest objective values)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = random.randint(0, candidate_indices - 1)\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy combining 2-opt and edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt move in the objective space with the highest current cost\n    objectives = sorted_archive[selected_idx][1]\n    max_obj_idx = np.argmax(objectives)\n\n    if max_obj_idx == 0:\n        distance_matrix = distance_matrix_1\n    elif max_obj_idx == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Find the worst edge in the selected objective space\n    worst_edge = None\n    worst_edge_length = -1\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i + 1) % n]\n        edge_length = distance_matrix[u, v]\n        if edge_length > worst_edge_length:\n            worst_edge_length = edge_length\n            worst_edge = (i, (i + 1) % n)\n\n    if worst_edge is not None:\n        i, j = worst_edge\n        # Try to replace the worst edge with a better one\n        for k in range(n):\n            if k == i or k == j or (k + 1) % n == i or (k + 1) % n == j:\n                continue\n            # Calculate potential improvement\n            u, v = new_solution[i], new_solution[j]\n            x, y = new_solution[k], new_solution[(k + 1) % n]\n            old_length = distance_matrix[u, v] + distance_matrix[x, y]\n            new_length = distance_matrix[u, x] + distance_matrix[v, y]\n            if new_length < old_length:\n                # Perform the 2-opt move\n                new_solution = np.concatenate([\n                    new_solution[:i+1],\n                    new_solution[k::-1],\n                    new_solution[(k+1):j],\n                    new_solution[i+1:k+1][::-1],\n                    new_solution[j+1:]\n                ])\n                break\n\n    # Perform edge exchange across objectives to balance improvements\n    if random.random() < 0.5:  # 50% chance to perform edge exchange\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        # Try to exchange edges between objectives\n        for obj_idx in range(3):\n            if obj_idx == 0:\n                dm = distance_matrix_1\n            elif obj_idx == 1:\n                dm = distance_matrix_2\n            else:\n                dm = distance_matrix_3\n\n            u, v = new_solution[i], new_solution[(i + 1) % n]\n            x, y = new_solution[j], new_solution[(j + 1) % n]\n\n            old_length = dm[u, v] + dm[x, y]\n            new_length = dm[u, x] + dm[v, y]\n\n            if new_length < old_length:\n                # Perform the edge exchange\n                new_solution = np.concatenate([\n                    new_solution[:i+1],\n                    new_solution[j:j+1],\n                    new_solution[(i+1):j],\n                    new_solution[i:i+1],\n                    new_solution[j+1:]\n                ])\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.7171342366001333,
            0.390398895740509
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest objective values)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = random.randint(0, candidate_indices - 1)\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy combining 2-opt and edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt move in the objective space with the highest current cost\n    objectives = sorted_archive[selected_idx][1]\n    max_obj_idx = np.argmax(objectives)\n\n    if max_obj_idx == 0:\n        distance_matrix = distance_matrix_1\n    elif max_obj_idx == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Find the worst edge in the selected objective space\n    worst_edge = None\n    worst_edge_length = -1\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i + 1) % n]\n        edge_length = distance_matrix[u, v]\n        if edge_length > worst_edge_length:\n            worst_edge_length = edge_length\n            worst_edge = (i, (i + 1) % n)\n\n    if worst_edge is not None:\n        i, j = worst_edge\n        # Try to replace the worst edge with a better one\n        for k in range(n):\n            if k == i or k == j or (k + 1) % n == i or (k + 1) % n == j:\n                continue\n            # Calculate potential improvement\n            u, v = new_solution[i], new_solution[j]\n            x, y = new_solution[k], new_solution[(k + 1) % n]\n            old_length = distance_matrix[u, v] + distance_matrix[x, y]\n            new_length = distance_matrix[u, x] + distance_matrix[v, y]\n            if new_length < old_length:\n                # Perform the 2-opt move\n                new_solution = np.concatenate([\n                    new_solution[:i+1],\n                    new_solution[k::-1],\n                    new_solution[(k+1):j],\n                    new_solution[i+1:k+1][::-1],\n                    new_solution[j+1:]\n                ])\n                break\n\n    # Perform edge exchange across objectives to balance improvements\n    if random.random() < 0.5:  # 50% chance to perform edge exchange\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        # Try to exchange edges between objectives\n        for obj_idx in range(3):\n            if obj_idx == 0:\n                dm = distance_matrix_1\n            elif obj_idx == 1:\n                dm = distance_matrix_2\n            else:\n                dm = distance_matrix_3\n\n            u, v = new_solution[i], new_solution[(i + 1) % n]\n            x, y = new_solution[j], new_solution[(j + 1) % n]\n\n            old_length = dm[u, v] + dm[x, y]\n            new_length = dm[u, x] + dm[v, y]\n\n            if new_length < old_length:\n                # Perform the edge exchange\n                new_solution = np.concatenate([\n                    new_solution[:i+1],\n                    new_solution[j:j+1],\n                    new_solution[(i+1):j],\n                    new_solution[i:i+1],\n                    new_solution[j+1:]\n                ])\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 172,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with multi-objective edge selection\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Randomly select two non-adjacent edges to reverse\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate potential improvement across all three objectives\n    def calculate_improvement(sol, i, j):\n        # Current edges\n        a, b = sol[i], sol[i+1]\n        c, d = sol[j], sol[j+1]\n\n        # New edges\n        a_new, b_new = sol[i], sol[j]\n        c_new, d_new = sol[i+1], sol[j+1]\n\n        # Calculate changes in all three objectives\n        delta1 = (distance_matrix_1[a, b] + distance_matrix_1[c, d] -\n                 (distance_matrix_1[a_new, b_new] + distance_matrix_1[c_new, d_new]))\n        delta2 = (distance_matrix_2[a, b] + distance_matrix_2[c, d] -\n                 (distance_matrix_2[a_new, b_new] + distance_matrix_2[c_new, d_new]))\n        delta3 = (distance_matrix_3[a, b] + distance_matrix_3[c, d] -\n                 (distance_matrix_3[a_new, b_new] + distance_matrix_3[c_new, d_new]))\n\n        return delta1, delta2, delta3\n\n    delta1, delta2, delta3 = calculate_improvement(new_solution, i, j)\n\n    # Apply the move if it improves at least one objective\n    if delta1 < 0 or delta2 < 0 or delta3 < 0:\n        # Reverse the segment between i+1 and j\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Additional multi-objective optimization: try to improve the worst objective\n    worst_obj = np.argmax(archive[selected_idx][1])\n    if worst_obj == 0:\n        # Try to improve the first objective\n        for _ in range(5):  # Limited attempts\n            i = random.randint(0, n - 4)\n            j = random.randint(i + 2, n - 2)\n            delta1, _, _ = calculate_improvement(new_solution, i, j)\n            if delta1 < 0:\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n                break\n    elif worst_obj == 1:\n        # Try to improve the second objective\n        for _ in range(5):\n            i = random.randint(0, n - 4)\n            j = random.randint(i + 2, n - 2)\n            _, delta2, _ = calculate_improvement(new_solution, i, j)\n            if delta2 < 0:\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n                break\n    else:\n        # Try to improve the third objective\n        for _ in range(5):\n            i = random.randint(0, n - 4)\n            j = random.randint(i + 2, n - 2)\n            _, _, delta3 = calculate_improvement(new_solution, i, j)\n            if delta3 < 0:\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.7845384895771271,
            1.0665650010108947
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with multi-objective edge selection\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Randomly select two non-adjacent edges to reverse\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate potential improvement across all three objectives\n    def calculate_improvement(sol, i, j):\n        # Current edges\n        a, b = sol[i], sol[i+1]\n        c, d = sol[j], sol[j+1]\n\n        # New edges\n        a_new, b_new = sol[i], sol[j]\n        c_new, d_new = sol[i+1], sol[j+1]\n\n        # Calculate changes in all three objectives\n        delta1 = (distance_matrix_1[a, b] + distance_matrix_1[c, d] -\n                 (distance_matrix_1[a_new, b_new] + distance_matrix_1[c_new, d_new]))\n        delta2 = (distance_matrix_2[a, b] + distance_matrix_2[c, d] -\n                 (distance_matrix_2[a_new, b_new] + distance_matrix_2[c_new, d_new]))\n        delta3 = (distance_matrix_3[a, b] + distance_matrix_3[c, d] -\n                 (distance_matrix_3[a_new, b_new] + distance_matrix_3[c_new, d_new]))\n\n        return delta1, delta2, delta3\n\n    delta1, delta2, delta3 = calculate_improvement(new_solution, i, j)\n\n    # Apply the move if it improves at least one objective\n    if delta1 < 0 or delta2 < 0 or delta3 < 0:\n        # Reverse the segment between i+1 and j\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Additional multi-objective optimization: try to improve the worst objective\n    worst_obj = np.argmax(archive[selected_idx][1])\n    if worst_obj == 0:\n        # Try to improve the first objective\n        for _ in range(5):  # Limited attempts\n            i = random.randint(0, n - 4)\n            j = random.randint(i + 2, n - 2)\n            delta1, _, _ = calculate_improvement(new_solution, i, j)\n            if delta1 < 0:\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n                break\n    elif worst_obj == 1:\n        # Try to improve the second objective\n        for _ in range(5):\n            i = random.randint(0, n - 4)\n            j = random.randint(i + 2, n - 2)\n            _, delta2, _ = calculate_improvement(new_solution, i, j)\n            if delta2 < 0:\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n                break\n    else:\n        # Try to improve the third objective\n        for _ in range(5):\n            i = random.randint(0, n - 4)\n            j = random.randint(i + 2, n - 2)\n            _, _, delta3 = calculate_improvement(new_solution, i, j)\n            if delta3 < 0:\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 173,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement by considering the worst objective\n    objectives = [obj for (sol, obj) in archive]\n    worst_objective_indices = [np.argmax(obj) for obj in objectives]\n    worst_objective_counts = np.bincount(worst_objective_indices, minlength=3)\n    target_objective = np.argmax(worst_objective_counts)\n\n    # Filter solutions that have the worst performance in the target objective\n    candidates = [sol for (sol, obj) in archive if np.argmax(obj) == target_objective]\n\n    if not candidates:\n        # Fallback: select a random solution if no candidates found\n        base_solution = np.random.choice([sol for (sol, _) in archive])\n    else:\n        # Select the best candidate in the other two objectives\n        candidate_objectives = [obj for (sol, obj) in archive if np.argmax(obj) == target_objective]\n        candidate_scores = [sum(obj[i] for i in range(3) if i != target_objective) for obj in candidate_objectives]\n        best_candidate_idx = np.argmin(candidate_scores)\n        base_solution = candidates[best_candidate_idx]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: apply a combination of 2-opt and edge exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt swap\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply edge exchange\n    if k != i and l != j:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility by checking for duplicates and repairing if needed\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or np.any(counts > 1):\n        # Repair by inserting missing nodes and removing duplicates\n        missing = np.setdiff1d(np.arange(n), new_solution)\n        duplicates = new_solution[np.where(counts > 1)[0][0]] if np.any(counts > 1) else None\n\n        if duplicates is not None:\n            # Replace duplicate with missing node if available\n            if len(missing) > 0:\n                idx = np.where(new_solution == duplicates)[0][0]\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n        # Insert remaining missing nodes at random positions\n        for node in missing:\n            pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, pos, node)\n\n        # Truncate to original length\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.6141195989874157,
            3.4304882764816282
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement by considering the worst objective\n    objectives = [obj for (sol, obj) in archive]\n    worst_objective_indices = [np.argmax(obj) for obj in objectives]\n    worst_objective_counts = np.bincount(worst_objective_indices, minlength=3)\n    target_objective = np.argmax(worst_objective_counts)\n\n    # Filter solutions that have the worst performance in the target objective\n    candidates = [sol for (sol, obj) in archive if np.argmax(obj) == target_objective]\n\n    if not candidates:\n        # Fallback: select a random solution if no candidates found\n        base_solution = np.random.choice([sol for (sol, _) in archive])\n    else:\n        # Select the best candidate in the other two objectives\n        candidate_objectives = [obj for (sol, obj) in archive if np.argmax(obj) == target_objective]\n        candidate_scores = [sum(obj[i] for i in range(3) if i != target_objective) for obj in candidate_objectives]\n        best_candidate_idx = np.argmin(candidate_scores)\n        base_solution = candidates[best_candidate_idx]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: apply a combination of 2-opt and edge exchange\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt swap\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply edge exchange\n    if k != i and l != j:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility by checking for duplicates and repairing if needed\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or np.any(counts > 1):\n        # Repair by inserting missing nodes and removing duplicates\n        missing = np.setdiff1d(np.arange(n), new_solution)\n        duplicates = new_solution[np.where(counts > 1)[0][0]] if np.any(counts > 1) else None\n\n        if duplicates is not None:\n            # Replace duplicate with missing node if available\n            if len(missing) > 0:\n                idx = np.where(new_solution == duplicates)[0][0]\n                new_solution[idx] = missing[0]\n                missing = missing[1:]\n\n        # Insert remaining missing nodes at random positions\n        for node in missing:\n            pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, pos, node)\n\n        # Truncate to original length\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 174,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest objective values)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(int(len(archive) * 0.2), len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine 2-opt and random segment reversal\n    if n > 3:\n        # 2-opt for one objective (randomly chosen)\n        obj_choice = np.random.choice([0, 1, 2])\n        if obj_choice == 0:\n            dmat = distance_matrix_1\n        elif obj_choice == 1:\n            dmat = distance_matrix_2\n        else:\n            dmat = distance_matrix_3\n\n        # Find the best 2-opt move\n        best_improvement = 0\n        best_i, best_j = -1, -1\n\n        for i in range(n - 1):\n            for j in range(i + 2, n):\n                a, b = new_solution[i], new_solution[i+1]\n                c, d = new_solution[j], new_solution[(j+1)%n]\n\n                current_cost = dmat[a, b] + dmat[c, d]\n                new_cost = dmat[a, c] + dmat[b, d]\n\n                if new_cost < current_cost and (current_cost - new_cost) > best_improvement:\n                    best_improvement = current_cost - new_cost\n                    best_i, best_j = i, j\n\n        if best_i != -1:\n            # Apply the 2-opt move\n            new_solution[best_i+1:best_j+1] = np.flip(new_solution[best_i+1:best_j+1])\n            return new_solution\n\n        # If no improvement, try random segment reversal\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    return new_solution\n\n",
        "score": [
            -0.45454770246387943,
            3.4248491764068603
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest objective values)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(int(len(archive) * 0.2), len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine 2-opt and random segment reversal\n    if n > 3:\n        # 2-opt for one objective (randomly chosen)\n        obj_choice = np.random.choice([0, 1, 2])\n        if obj_choice == 0:\n            dmat = distance_matrix_1\n        elif obj_choice == 1:\n            dmat = distance_matrix_2\n        else:\n            dmat = distance_matrix_3\n\n        # Find the best 2-opt move\n        best_improvement = 0\n        best_i, best_j = -1, -1\n\n        for i in range(n - 1):\n            for j in range(i + 2, n):\n                a, b = new_solution[i], new_solution[i+1]\n                c, d = new_solution[j], new_solution[(j+1)%n]\n\n                current_cost = dmat[a, b] + dmat[c, d]\n                new_cost = dmat[a, c] + dmat[b, d]\n\n                if new_cost < current_cost and (current_cost - new_cost) > best_improvement:\n                    best_improvement = current_cost - new_cost\n                    best_i, best_j = i, j\n\n        if best_i != -1:\n            # Apply the 2-opt move\n            new_solution[best_i+1:best_j+1] = np.flip(new_solution[best_i+1:best_j+1])\n            return new_solution\n\n        # If no improvement, try random segment reversal\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 175,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest objective values)\n    # We prioritize solutions that are not too large to avoid excessive computation\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=False)\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with a multi-objective aware move\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move to improve the tour structure\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, apply a multi-objective aware perturbation\n    # Select a segment to reverse based on the combined distance improvement\n    best_improvement = 0\n    best_move = None\n\n    for _ in range(min(10, n)):  # Limit the number of trials to balance exploration and computation\n        a, b = sorted(random.sample(range(n), 2))\n        candidate = new_solution.copy()\n        candidate[a:b+1] = candidate[a:b+1][::-1]\n\n        # Calculate the total improvement across all objectives\n        def compute_total_cost(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n            cost3 = sum(distance_matrix_3[sol[i], sol[(i+1)%n]] for i in range(n))\n            return cost1 + cost2 + cost3\n\n        current_cost = compute_total_cost(new_solution)\n        candidate_cost = compute_total_cost(candidate)\n        improvement = current_cost - candidate_cost\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_move = (a, b)\n\n    if best_move is not None:\n        a, b = best_move\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6565744128535566,
            4.300559759140015
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest objective values)\n    # We prioritize solutions that are not too large to avoid excessive computation\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=False)\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with a multi-objective aware move\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move to improve the tour structure\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, apply a multi-objective aware perturbation\n    # Select a segment to reverse based on the combined distance improvement\n    best_improvement = 0\n    best_move = None\n\n    for _ in range(min(10, n)):  # Limit the number of trials to balance exploration and computation\n        a, b = sorted(random.sample(range(n), 2))\n        candidate = new_solution.copy()\n        candidate[a:b+1] = candidate[a:b+1][::-1]\n\n        # Calculate the total improvement across all objectives\n        def compute_total_cost(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n            cost3 = sum(distance_matrix_3[sol[i], sol[(i+1)%n]] for i in range(n))\n            return cost1 + cost2 + cost3\n\n        current_cost = compute_total_cost(new_solution)\n        candidate_cost = compute_total_cost(candidate)\n        improvement = current_cost - candidate_cost\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_move = (a, b)\n\n    if best_move is not None:\n        a, b = best_move\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 176,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (ascending) to prioritize better solutions\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select from the top 30% of solutions to balance exploration and exploitation\n        selected_idx = random.randint(0, max(0, int(0.3 * len(archive_sorted)) - 1))\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search strategy\n    if random.random() < 0.5:  # 50% chance for 2-opt\n        # Perform 2-opt on the solution with the worst objective (to diversify)\n        worst_obj_idx = np.argmax([sum(archive[i][1]) for i in range(len(archive))])\n        worst_solution = archive[worst_obj_idx][0].copy()\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = worst_solution[i:j][::-1]\n    else:\n        # Apply a random segment reversal or swap based on objective differences\n        i, j = sorted(random.sample(range(n), 2))\n        if random.random() < 0.7:  # 70% chance for segment reversal\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:  # 30% chance for objective-aware swap\n            # Swap nodes that are far apart in at least one objective space\n            node1, node2 = new_solution[i], new_solution[j]\n            dist1 = distance_matrix_1[node1, node2]\n            dist2 = distance_matrix_2[node1, node2]\n            dist3 = distance_matrix_3[node1, node2]\n            if max(dist1, dist2, dist3) > np.mean([distance_matrix_1.mean(), distance_matrix_2.mean(), distance_matrix_3.mean()]):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6712364515182967,
            1.1364849090576172
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (ascending) to prioritize better solutions\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select from the top 30% of solutions to balance exploration and exploitation\n        selected_idx = random.randint(0, max(0, int(0.3 * len(archive_sorted)) - 1))\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search strategy\n    if random.random() < 0.5:  # 50% chance for 2-opt\n        # Perform 2-opt on the solution with the worst objective (to diversify)\n        worst_obj_idx = np.argmax([sum(archive[i][1]) for i in range(len(archive))])\n        worst_solution = archive[worst_obj_idx][0].copy()\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = worst_solution[i:j][::-1]\n    else:\n        # Apply a random segment reversal or swap based on objective differences\n        i, j = sorted(random.sample(range(n), 2))\n        if random.random() < 0.7:  # 70% chance for segment reversal\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:  # 30% chance for objective-aware swap\n            # Swap nodes that are far apart in at least one objective space\n            node1, node2 = new_solution[i], new_solution[j]\n            dist1 = distance_matrix_1[node1, node2]\n            dist2 = distance_matrix_2[node1, node2]\n            dist3 = distance_matrix_3[node1, node2]\n            if max(dist1, dist2, dist3) > np.mean([distance_matrix_1.mean(), distance_matrix_2.mean(), distance_matrix_3.mean()]):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 177,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest objective values)\n    # We prioritize solutions that are not too close to the Pareto front\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate a score based on the sum of objectives (lower is better)\n    scores = [sum(obj) for obj in archive_objectives]\n    selected_idx = np.argmin(scores)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search strategy:\n    # 1. Apply 2-opt with a probability weighted by objective improvement\n    # 2. Apply a multi-objective specific operator (swap segments based on objective diversity)\n    # 3. Apply a random swap if no improvement is found\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # 1. 2-opt with probability based on objective improvement\n    if np.random.random() < 0.7:  # Higher probability for 2-opt\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # 2. Multi-objective specific operator: swap segments based on objective diversity\n    if np.random.random() < 0.4:\n        # Find segments with high diversity in objectives\n        segment_length = max(2, n // 5)\n        a, b = np.random.choice(n - segment_length, 2, replace=False)\n        segment1 = base_solution[a:a+segment_length]\n        segment2 = base_solution[b:b+segment_length]\n\n        # Calculate diversity in objectives for each segment\n        def segment_objective(segment):\n            obj1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n            obj2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n            obj3 = sum(distance_matrix_3[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n            return (obj1, obj2, obj3)\n\n        obj1 = segment_objective(segment1)\n        obj2 = segment_objective(segment2)\n\n        # Swap if segments have different objective profiles\n        if sum(abs(o1 - o2) for o1, o2 in zip(obj1, obj2)) > 0.1 * (sum(obj1) + sum(obj2)):\n            new_solution[a:a+segment_length] = segment2\n            new_solution[b:b+segment_length] = segment1\n\n    # 3. Random swap if no improvement found\n    if np.random.random() < 0.2:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains valid (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution with a small perturbation\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6518206192081661,
            2.568285310268402
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest objective values)\n    # We prioritize solutions that are not too close to the Pareto front\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate a score based on the sum of objectives (lower is better)\n    scores = [sum(obj) for obj in archive_objectives]\n    selected_idx = np.argmin(scores)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search strategy:\n    # 1. Apply 2-opt with a probability weighted by objective improvement\n    # 2. Apply a multi-objective specific operator (swap segments based on objective diversity)\n    # 3. Apply a random swap if no improvement is found\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # 1. 2-opt with probability based on objective improvement\n    if np.random.random() < 0.7:  # Higher probability for 2-opt\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # 2. Multi-objective specific operator: swap segments based on objective diversity\n    if np.random.random() < 0.4:\n        # Find segments with high diversity in objectives\n        segment_length = max(2, n // 5)\n        a, b = np.random.choice(n - segment_length, 2, replace=False)\n        segment1 = base_solution[a:a+segment_length]\n        segment2 = base_solution[b:b+segment_length]\n\n        # Calculate diversity in objectives for each segment\n        def segment_objective(segment):\n            obj1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n            obj2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n            obj3 = sum(distance_matrix_3[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n            return (obj1, obj2, obj3)\n\n        obj1 = segment_objective(segment1)\n        obj2 = segment_objective(segment2)\n\n        # Swap if segments have different objective profiles\n        if sum(abs(o1 - o2) for o1, o2 in zip(obj1, obj2)) > 0.1 * (sum(obj1) + sum(obj2)):\n            new_solution[a:a+segment_length] = segment2\n            new_solution[b:b+segment_length] = segment1\n\n    # 3. Random swap if no improvement found\n    if np.random.random() < 0.2:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains valid (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution with a small perturbation\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 178,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Calculate diversity scores (normalized objective differences)\n        objectives = np.array([obj for _, obj in archive])\n        mean_obj = np.mean(objectives, axis=0)\n        std_obj = np.std(objectives, axis=0)\n        diversity_scores = np.sum(np.abs(objectives - mean_obj) / (std_obj + 1e-8), axis=1)\n        probabilities = diversity_scores / np.sum(diversity_scores)\n        selected_idx = np.random.choice(len(archive), p=probabilities)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: combination of 2-opt and segment relocation\n    # First, perform a 2-opt move on two random edges\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform a segment relocation (move a random segment to another position)\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    remaining = np.concatenate([new_solution[:a], new_solution[b+1:]])\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure the solution remains a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simpler 2-opt move if invalid\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7257065710276155,
            1.8539510369300842
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Calculate diversity scores (normalized objective differences)\n        objectives = np.array([obj for _, obj in archive])\n        mean_obj = np.mean(objectives, axis=0)\n        std_obj = np.std(objectives, axis=0)\n        diversity_scores = np.sum(np.abs(objectives - mean_obj) / (std_obj + 1e-8), axis=1)\n        probabilities = diversity_scores / np.sum(diversity_scores)\n        selected_idx = np.random.choice(len(archive), p=probabilities)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: combination of 2-opt and segment relocation\n    # First, perform a 2-opt move on two random edges\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform a segment relocation (move a random segment to another position)\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    remaining = np.concatenate([new_solution[:a], new_solution[b+1:]])\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure the solution remains a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simpler 2-opt move if invalid\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 179,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest objective values)\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_idx = min(3, len(archive) - 1)  # Select among top 3 or all available\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of 2-opt and objective-aware swaps\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful changes\n\n    # First, perform a random 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then perform an objective-aware swap (considering all three objectives)\n    # Calculate the current total cost for each objective\n    def calculate_cost(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1))\n        cost1 += distance_matrix_1[solution[-1], solution[0]]  # complete the tour\n        cost2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1))\n        cost2 += distance_matrix_2[solution[-1], solution[0]]\n        cost3 = sum(distance_matrix_3[solution[i], solution[i+1]] for i in range(n-1))\n        cost3 += distance_matrix_3[solution[-1], solution[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Try swapping nodes that are far apart in at least one objective space\n    for _ in range(5):  # Limited attempts to keep it efficient\n        i, j = random.sample(range(n), 2)\n        if i == j:\n            continue\n\n        # Create a temporary solution with the swap\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n        temp_cost = calculate_cost(temp_solution)\n\n        # Accept the swap if it improves at least one objective\n        if any(temp_cost[k] < current_cost[k] for k in range(3)):\n            new_solution = temp_solution\n            current_cost = temp_cost\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.737802884315748,
            1.737642753124237
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest objective values)\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_idx = min(3, len(archive) - 1)  # Select among top 3 or all available\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of 2-opt and objective-aware swaps\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful changes\n\n    # First, perform a random 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then perform an objective-aware swap (considering all three objectives)\n    # Calculate the current total cost for each objective\n    def calculate_cost(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1))\n        cost1 += distance_matrix_1[solution[-1], solution[0]]  # complete the tour\n        cost2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1))\n        cost2 += distance_matrix_2[solution[-1], solution[0]]\n        cost3 = sum(distance_matrix_3[solution[i], solution[i+1]] for i in range(n-1))\n        cost3 += distance_matrix_3[solution[-1], solution[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Try swapping nodes that are far apart in at least one objective space\n    for _ in range(5):  # Limited attempts to keep it efficient\n        i, j = random.sample(range(n), 2)\n        if i == j:\n            continue\n\n        # Create a temporary solution with the swap\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n        temp_cost = calculate_cost(temp_solution)\n\n        # Accept the swap if it improves at least one objective\n        if any(temp_cost[k] < current_cost[k] for k in range(3)):\n            new_solution = temp_solution\n            current_cost = temp_cost\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 180,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (e.g., not already optimal in all objectives)\n    candidate_indices = [\n        i for i, (sol, obj) in enumerate(archive)\n        if not (obj[0] <= min(o[0] for _, o in archive) and\n                obj[1] <= min(o[1] for _, o in archive) and\n                obj[2] <= min(o[2] for _, o in archive))\n    ]\n\n    if not candidate_indices:\n        candidate_indices = list(range(len(archive)))\n\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: apply a combination of 2-opt and 3-opt moves\n    # Select a random segment to perturb\n    n = len(new_solution)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c = np.random.randint(0, n)\n\n    # Apply 2-opt (swap edges)\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply 3-opt (reconnect three edges)\n    if c > b:\n        new_solution[b+1:c+1] = new_solution[b+1:c+1][::-1]\n    elif c < a:\n        new_solution[c:a] = new_solution[c:a][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != len(new_solution):\n        # If invalid, revert to a simpler 2-opt move\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7613316916912588,
            3.1196493268013
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (e.g., not already optimal in all objectives)\n    candidate_indices = [\n        i for i, (sol, obj) in enumerate(archive)\n        if not (obj[0] <= min(o[0] for _, o in archive) and\n                obj[1] <= min(o[1] for _, o in archive) and\n                obj[2] <= min(o[2] for _, o in archive))\n    ]\n\n    if not candidate_indices:\n        candidate_indices = list(range(len(archive)))\n\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: apply a combination of 2-opt and 3-opt moves\n    # Select a random segment to perturb\n    n = len(new_solution)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c = np.random.randint(0, n)\n\n    # Apply 2-opt (swap edges)\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply 3-opt (reconnect three edges)\n    if c > b:\n        new_solution[b+1:c+1] = new_solution[b+1:c+1][::-1]\n    elif c < a:\n        new_solution[c:a] = new_solution[c:a][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != len(new_solution):\n        # If invalid, revert to a simpler 2-opt move\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 181,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate the crowding distance for each solution in the archive\n        crowding_distances = []\n        objectives = np.array([obj for _, obj in archive])\n        for i in range(3):  # For each objective\n            sorted_indices = np.argsort(objectives[:, i])\n            crowding = np.zeros(len(archive))\n            crowding[sorted_indices[0]] = np.inf\n            crowding[sorted_indices[-1]] = np.inf\n            for j in range(1, len(archive) - 1):\n                crowding[sorted_indices[j]] = objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i]\n            crowding_distances.append(crowding)\n\n        # Combine crowding distances across objectives\n        total_crowding = np.sum(np.array(crowding_distances), axis=0)\n        # Select solutions with high crowding distance (potential for improvement)\n        selected_indices = np.where(total_crowding > np.percentile(total_crowding, 75))[0]\n        if len(selected_indices) > 0:\n            selected_index = np.random.choice(selected_indices)\n            base_solution = archive[selected_index][0].copy()\n        else:\n            base_solution = archive[np.random.randint(0, len(archive))][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel 3-objective-aware swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, perform a novel 3-objective-aware swap\n    if n > 2:\n        # Select two nodes that are likely to improve at least one objective\n        k = random.randint(0, n-1)\n        l = random.randint(0, n-1)\n        while l == k:\n            l = random.randint(0, n-1)\n\n        # Calculate the change in objectives\n        original_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        original_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        original_cost3 = distance_matrix_3[new_solution[k-1], new_solution[k]] + distance_matrix_3[new_solution[l-1], new_solution[l]]\n\n        swapped_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n        swapped_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n        swapped_cost3 = distance_matrix_3[new_solution[k-1], new_solution[l]] + distance_matrix_3[new_solution[l-1], new_solution[k]]\n\n        # Accept the swap if it improves at least one objective\n        if (swapped_cost1 < original_cost1) or (swapped_cost2 < original_cost2) or (swapped_cost3 < original_cost3):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7973850892953548,
            3.1524664998054504
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate the crowding distance for each solution in the archive\n        crowding_distances = []\n        objectives = np.array([obj for _, obj in archive])\n        for i in range(3):  # For each objective\n            sorted_indices = np.argsort(objectives[:, i])\n            crowding = np.zeros(len(archive))\n            crowding[sorted_indices[0]] = np.inf\n            crowding[sorted_indices[-1]] = np.inf\n            for j in range(1, len(archive) - 1):\n                crowding[sorted_indices[j]] = objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i]\n            crowding_distances.append(crowding)\n\n        # Combine crowding distances across objectives\n        total_crowding = np.sum(np.array(crowding_distances), axis=0)\n        # Select solutions with high crowding distance (potential for improvement)\n        selected_indices = np.where(total_crowding > np.percentile(total_crowding, 75))[0]\n        if len(selected_indices) > 0:\n            selected_index = np.random.choice(selected_indices)\n            base_solution = archive[selected_index][0].copy()\n        else:\n            base_solution = archive[np.random.randint(0, len(archive))][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel 3-objective-aware swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, perform a novel 3-objective-aware swap\n    if n > 2:\n        # Select two nodes that are likely to improve at least one objective\n        k = random.randint(0, n-1)\n        l = random.randint(0, n-1)\n        while l == k:\n            l = random.randint(0, n-1)\n\n        # Calculate the change in objectives\n        original_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        original_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        original_cost3 = distance_matrix_3[new_solution[k-1], new_solution[k]] + distance_matrix_3[new_solution[l-1], new_solution[l]]\n\n        swapped_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n        swapped_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n        swapped_cost3 = distance_matrix_3[new_solution[k-1], new_solution[l]] + distance_matrix_3[new_solution[l-1], new_solution[k]]\n\n        # Accept the swap if it improves at least one objective\n        if (swapped_cost1 < original_cost1) or (swapped_cost2 < original_cost2) or (swapped_cost3 < original_cost3):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 182,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate the diversity of each solution's objectives\n    objectives = np.array([obj for (sol, obj) in archive])\n    diversity = np.std(objectives, axis=0)\n\n    # Select the solution with the highest diversity (most balanced objectives)\n    selected_idx = np.argmax(np.sum(diversity))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt and 3-opt moves with objective-aware selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and 3-opt\n    if np.random.rand() < 0.7:  # 70% chance for 2-opt\n        # 2-opt local search with objective-aware edge selection\n        i, j = np.random.randint(0, n, size=2)\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta_obj1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n                     (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta_obj2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n                     (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta_obj3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]) - \\\n                     (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept the move if it improves at least one objective\n        if delta_obj1 < 0 or delta_obj2 < 0 or delta_obj3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:  # 3-opt move\n        # Select three distinct edges to reverse\n        i, j, k = np.random.choice(n, size=3, replace=False)\n        i, j, k = sorted([i, j, k])\n\n        # Create three possible configurations and evaluate them\n        configs = [\n            np.concatenate([new_solution[:i], new_solution[j:k][::-1], new_solution[i:j][::-1], new_solution[k:]]),\n            np.concatenate([new_solution[:i], new_solution[i:j][::-1], new_solution[j:k][::-1], new_solution[k:]]),\n            np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j][::-1], new_solution[k:]])\n        ]\n\n        # Evaluate each configuration across all three objectives\n        best_config = new_solution.copy()\n        best_improvement = 0\n\n        for config in configs:\n            total_delta1 = sum(distance_matrix_1[config[i-1], config[i]] for i in range(n))\n            total_delta2 = sum(distance_matrix_2[config[i-1], config[i]] for i in range(n))\n            total_delta3 = sum(distance_matrix_3[config[i-1], config[i]] for i in range(n))\n\n            current_delta1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n            current_delta2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n            current_delta3 = sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))\n\n            delta1 = total_delta1 - current_delta1\n            delta2 = total_delta2 - current_delta2\n            delta3 = total_delta3 - current_delta3\n\n            # Count how many objectives are improved\n            improvement_count = sum(1 for delta in [delta1, delta2, delta3] if delta < 0)\n\n            if improvement_count > best_improvement:\n                best_improvement = improvement_count\n                best_config = config.copy()\n\n        new_solution = best_config\n\n    return new_solution\n\n",
        "score": [
            -0.6524924970102944,
            2.1698437571525573
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate the diversity of each solution's objectives\n    objectives = np.array([obj for (sol, obj) in archive])\n    diversity = np.std(objectives, axis=0)\n\n    # Select the solution with the highest diversity (most balanced objectives)\n    selected_idx = np.argmax(np.sum(diversity))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt and 3-opt moves with objective-aware selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and 3-opt\n    if np.random.rand() < 0.7:  # 70% chance for 2-opt\n        # 2-opt local search with objective-aware edge selection\n        i, j = np.random.randint(0, n, size=2)\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta_obj1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n                     (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta_obj2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n                     (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta_obj3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]) - \\\n                     (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept the move if it improves at least one objective\n        if delta_obj1 < 0 or delta_obj2 < 0 or delta_obj3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:  # 3-opt move\n        # Select three distinct edges to reverse\n        i, j, k = np.random.choice(n, size=3, replace=False)\n        i, j, k = sorted([i, j, k])\n\n        # Create three possible configurations and evaluate them\n        configs = [\n            np.concatenate([new_solution[:i], new_solution[j:k][::-1], new_solution[i:j][::-1], new_solution[k:]]),\n            np.concatenate([new_solution[:i], new_solution[i:j][::-1], new_solution[j:k][::-1], new_solution[k:]]),\n            np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j][::-1], new_solution[k:]])\n        ]\n\n        # Evaluate each configuration across all three objectives\n        best_config = new_solution.copy()\n        best_improvement = 0\n\n        for config in configs:\n            total_delta1 = sum(distance_matrix_1[config[i-1], config[i]] for i in range(n))\n            total_delta2 = sum(distance_matrix_2[config[i-1], config[i]] for i in range(n))\n            total_delta3 = sum(distance_matrix_3[config[i-1], config[i]] for i in range(n))\n\n            current_delta1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n            current_delta2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n            current_delta3 = sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n))\n\n            delta1 = total_delta1 - current_delta1\n            delta2 = total_delta2 - current_delta2\n            delta3 = total_delta3 - current_delta3\n\n            # Count how many objectives are improved\n            improvement_count = sum(1 for delta in [delta1, delta2, delta3] if delta < 0)\n\n            if improvement_count > best_improvement:\n                best_improvement = improvement_count\n                best_config = config.copy()\n\n        new_solution = best_config\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 183,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Apply a hybrid local search strategy combining 2-opt and edge insertion\n    n = len(new_solution)\n    for _ in range(5):  # Perform multiple perturbations\n        # Randomly select two distinct edges to break\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n        # Perform 2-opt swap\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Insert the second edge at a random position\n        if k != l:\n            node = new_solution[l]\n            new_solution = np.concatenate([new_solution[:k], [node], new_solution[k:]])\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        extra = set(unique_nodes) - set(range(n))\n        for node in missing:\n            for i in range(n):\n                if new_solution[i] in extra:\n                    new_solution[i] = node\n                    extra.remove(new_solution[i])\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.631039607732218,
            0.48224626779556273
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Apply a hybrid local search strategy combining 2-opt and edge insertion\n    n = len(new_solution)\n    for _ in range(5):  # Perform multiple perturbations\n        # Randomly select two distinct edges to break\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n        # Perform 2-opt swap\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Insert the second edge at a random position\n        if k != l:\n            node = new_solution[l]\n            new_solution = np.concatenate([new_solution[:k], [node], new_solution[k:]])\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        extra = set(unique_nodes) - set(range(n))\n        for node in missing:\n            for i in range(n):\n                if new_solution[i] in extra:\n                    new_solution[i] = node\n                    extra.remove(new_solution[i])\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 184,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with promising potential for improvement\n    # We prioritize solutions that are not too similar to others in the archive\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and node insertion\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Choose between 2-opt or node insertion based on current solution quality\n        if random.random() < 0.7:  # 70% chance for 2-opt\n            # 2-opt local search\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Node insertion with objective-aware selection\n            # Select a node to remove and reinsert\n            remove_idx = random.randint(0, n-1)\n            node_to_move = new_solution[remove_idx]\n            new_solution = np.delete(new_solution, remove_idx)\n\n            # Evaluate potential insertion points based on all three objectives\n            best_insert_pos = 0\n            best_improvement = 0\n\n            for insert_pos in range(n-1):\n                # Calculate the change in all three objectives\n                prev_node = new_solution[insert_pos-1] if insert_pos > 0 else new_solution[-1]\n                next_node = new_solution[insert_pos]\n\n                # Original connections\n                original_cost1 = distance_matrix_1[prev_node, node_to_move] + distance_matrix_1[node_to_move, next_node]\n                original_cost2 = distance_matrix_2[prev_node, node_to_move] + distance_matrix_2[node_to_move, next_node]\n                original_cost3 = distance_matrix_3[prev_node, node_to_move] + distance_matrix_3[node_to_move, next_node]\n\n                # New connections\n                new_cost1 = distance_matrix_1[prev_node, next_node]\n                new_cost2 = distance_matrix_2[prev_node, next_node]\n                new_cost3 = distance_matrix_3[prev_node, next_node]\n\n                # Improvement calculation (we want to minimize all objectives)\n                improvement = (original_cost1 - new_cost1) + (original_cost2 - new_cost2) + (original_cost3 - new_cost3)\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_insert_pos = insert_pos\n\n            # Insert the node at the best position\n            new_solution = np.insert(new_solution, best_insert_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.808630989850565,
            1.298573338985443
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with promising potential for improvement\n    # We prioritize solutions that are not too similar to others in the archive\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and node insertion\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Choose between 2-opt or node insertion based on current solution quality\n        if random.random() < 0.7:  # 70% chance for 2-opt\n            # 2-opt local search\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Node insertion with objective-aware selection\n            # Select a node to remove and reinsert\n            remove_idx = random.randint(0, n-1)\n            node_to_move = new_solution[remove_idx]\n            new_solution = np.delete(new_solution, remove_idx)\n\n            # Evaluate potential insertion points based on all three objectives\n            best_insert_pos = 0\n            best_improvement = 0\n\n            for insert_pos in range(n-1):\n                # Calculate the change in all three objectives\n                prev_node = new_solution[insert_pos-1] if insert_pos > 0 else new_solution[-1]\n                next_node = new_solution[insert_pos]\n\n                # Original connections\n                original_cost1 = distance_matrix_1[prev_node, node_to_move] + distance_matrix_1[node_to_move, next_node]\n                original_cost2 = distance_matrix_2[prev_node, node_to_move] + distance_matrix_2[node_to_move, next_node]\n                original_cost3 = distance_matrix_3[prev_node, node_to_move] + distance_matrix_3[node_to_move, next_node]\n\n                # New connections\n                new_cost1 = distance_matrix_1[prev_node, next_node]\n                new_cost2 = distance_matrix_2[prev_node, next_node]\n                new_cost3 = distance_matrix_3[prev_node, next_node]\n\n                # Improvement calculation (we want to minimize all objectives)\n                improvement = (original_cost1 - new_cost1) + (original_cost2 - new_cost2) + (original_cost3 - new_cost3)\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_insert_pos = insert_pos\n\n            # Insert the node at the best position\n            new_solution = np.insert(new_solution, best_insert_pos, node_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 185,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by a combined objective score (sum of normalized objectives)\n        objectives = np.array([obj for _, obj in archive])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n        combined_scores = normalized.sum(axis=1)\n        # Select the solution with the highest combined score (most promising for improvement)\n        selected_idx = np.argmax(combined_scores)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a multi-objective local search operator\n    n_nodes = len(new_solution)\n    if n_nodes < 4:\n        # For small instances, just swap two random nodes\n        i, j = random.sample(range(n_nodes), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # For larger instances, use a more sophisticated operator\n        # Select a segment to move (2-4 nodes)\n        segment_length = random.randint(2, min(4, n_nodes // 2))\n        start = random.randint(0, n_nodes - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Evaluate potential insertion points considering all three objectives\n        best_insert_pos = start\n        best_improvement = 0\n\n        # Calculate current total distance for all three objectives\n        def calculate_total_distance(solution):\n            dist1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n_nodes-1))\n            dist1 += distance_matrix_1[solution[-1], solution[0]]\n            dist2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n_nodes-1))\n            dist2 += distance_matrix_2[solution[-1], solution[0]]\n            dist3 = sum(distance_matrix_3[solution[i], solution[i+1]] for i in range(n_nodes-1))\n            dist3 += distance_matrix_3[solution[-1], solution[0]]\n            return (dist1, dist2, dist3)\n\n        current_dist = calculate_total_distance(new_solution)\n\n        # Try moving the segment to different positions\n        for pos in range(n_nodes - segment_length + 1):\n            if pos == start:\n                continue\n\n            # Create a candidate solution\n            candidate = np.concatenate([\n                new_solution[:start],\n                new_solution[start+segment_length:],\n                segment\n            ])\n\n            if pos < start:\n                candidate = np.concatenate([\n                    candidate[:pos],\n                    segment,\n                    candidate[pos:]\n                ])\n            else:\n                candidate = np.concatenate([\n                    candidate[:pos-segment_length],\n                    segment,\n                    candidate[pos-segment_length:]\n                ])\n\n            # Calculate new distances\n            new_dist = calculate_total_distance(candidate)\n\n            # Calculate improvement (sum of normalized improvements)\n            improvement = sum([\n                (current_dist[0] - new_dist[0]) / (current_dist[0] + 1e-10),\n                (current_dist[1] - new_dist[1]) / (current_dist[1] + 1e-10),\n                (current_dist[2] - new_dist[2]) / (current_dist[2] + 1e-10)\n            ])\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_insert_pos = pos\n\n        # Apply the best move\n        if best_insert_pos != start:\n            segment = new_solution[start:start+segment_length]\n            new_solution = np.concatenate([\n                new_solution[:start],\n                new_solution[start+segment_length:],\n                segment\n            ])\n\n            if best_insert_pos < start:\n                new_solution = np.concatenate([\n                    new_solution[:best_insert_pos],\n                    segment,\n                    new_solution[best_insert_pos:]\n                ])\n            else:\n                new_solution = np.concatenate([\n                    new_solution[:best_insert_pos-segment_length],\n                    segment,\n                    new_solution[best_insert_pos-segment_length:]\n                ])\n\n    return new_solution\n\n",
        "score": [
            -0.6975582208885465,
            3.133490562438965
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by a combined objective score (sum of normalized objectives)\n        objectives = np.array([obj for _, obj in archive])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n        combined_scores = normalized.sum(axis=1)\n        # Select the solution with the highest combined score (most promising for improvement)\n        selected_idx = np.argmax(combined_scores)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a multi-objective local search operator\n    n_nodes = len(new_solution)\n    if n_nodes < 4:\n        # For small instances, just swap two random nodes\n        i, j = random.sample(range(n_nodes), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # For larger instances, use a more sophisticated operator\n        # Select a segment to move (2-4 nodes)\n        segment_length = random.randint(2, min(4, n_nodes // 2))\n        start = random.randint(0, n_nodes - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Evaluate potential insertion points considering all three objectives\n        best_insert_pos = start\n        best_improvement = 0\n\n        # Calculate current total distance for all three objectives\n        def calculate_total_distance(solution):\n            dist1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n_nodes-1))\n            dist1 += distance_matrix_1[solution[-1], solution[0]]\n            dist2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n_nodes-1))\n            dist2 += distance_matrix_2[solution[-1], solution[0]]\n            dist3 = sum(distance_matrix_3[solution[i], solution[i+1]] for i in range(n_nodes-1))\n            dist3 += distance_matrix_3[solution[-1], solution[0]]\n            return (dist1, dist2, dist3)\n\n        current_dist = calculate_total_distance(new_solution)\n\n        # Try moving the segment to different positions\n        for pos in range(n_nodes - segment_length + 1):\n            if pos == start:\n                continue\n\n            # Create a candidate solution\n            candidate = np.concatenate([\n                new_solution[:start],\n                new_solution[start+segment_length:],\n                segment\n            ])\n\n            if pos < start:\n                candidate = np.concatenate([\n                    candidate[:pos],\n                    segment,\n                    candidate[pos:]\n                ])\n            else:\n                candidate = np.concatenate([\n                    candidate[:pos-segment_length],\n                    segment,\n                    candidate[pos-segment_length:]\n                ])\n\n            # Calculate new distances\n            new_dist = calculate_total_distance(candidate)\n\n            # Calculate improvement (sum of normalized improvements)\n            improvement = sum([\n                (current_dist[0] - new_dist[0]) / (current_dist[0] + 1e-10),\n                (current_dist[1] - new_dist[1]) / (current_dist[1] + 1e-10),\n                (current_dist[2] - new_dist[2]) / (current_dist[2] + 1e-10)\n            ])\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_insert_pos = pos\n\n        # Apply the best move\n        if best_insert_pos != start:\n            segment = new_solution[start:start+segment_length]\n            new_solution = np.concatenate([\n                new_solution[:start],\n                new_solution[start+segment_length:],\n                segment\n            ])\n\n            if best_insert_pos < start:\n                new_solution = np.concatenate([\n                    new_solution[:best_insert_pos],\n                    segment,\n                    new_solution[best_insert_pos:]\n                ])\n            else:\n                new_solution = np.concatenate([\n                    new_solution[:best_insert_pos-segment_length],\n                    segment,\n                    new_solution[best_insert_pos-segment_length:]\n                ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 186,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    potentials = []\n    for sol, obj in archive:\n        # Calculate potential as the sum of normalized improvements across objectives\n        # Here, we assume smaller objectives are better\n        potential = sum(obj)  # Simplified potential calculation\n        potentials.append(potential)\n\n    # Normalize potentials to create a probability distribution\n    min_pot = min(potentials)\n    max_pot = max(potentials)\n    if min_pot == max_pot:\n        probs = [1.0 / len(potentials)] * len(potentials)\n    else:\n        normalized = [(max_pot - p) / (max_pot - min_pot) for p in potentials]\n        probs = [p / sum(normalized) for p in normalized]\n\n    # Select a solution based on the probability distribution\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(base_solution)\n    for _ in range(10):  # Perform a fixed number of local search steps\n        # Randomly select two distinct edges to swap (2-opt)\n        i, j = sorted(random.sample(range(n), 2))\n        if i == j or j == (i + 1) % n:\n            continue  # Skip if edges are consecutive\n\n        # Perform 2-opt swap\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Check if the swap improves any objective\n        # Calculate the change in objectives\n        obj1_change = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[j]] -\n                        distance_matrix_1[new_solution[i], new_solution[(j+1)%n]])\n\n        obj2_change = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[j]] -\n                        distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n        obj3_change = (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_3[new_solution[j], new_solution[(j+1)%n]] -\n                        distance_matrix_3[new_solution[i-1], new_solution[j]] -\n                        distance_matrix_3[new_solution[i], new_solution[(j+1)%n]])\n\n        # If the swap doesn't improve any objective, revert it\n        if obj1_change >= 0 and obj2_change >= 0 and obj3_change >= 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # With some probability, perform an objective-aware swap\n        if random.random() < 0.3:\n            # Select a node to swap with its neighbor based on the worst objective\n            worst_obj = np.argmax([obj1_change, obj2_change, obj3_change])\n            if worst_obj == 0:\n                # Find the node that would most improve the first objective\n                for k in range(n):\n                    temp_sol = new_solution.copy()\n                    temp_sol[k], temp_sol[(k+1)%n] = temp_sol[(k+1)%n], temp_sol[k]\n                    temp_change = (distance_matrix_1[temp_sol[k-1], temp_sol[k]] +\n                                  distance_matrix_1[temp_sol[(k+1)%n], temp_sol[(k+2)%n]] -\n                                  distance_matrix_1[temp_sol[k-1], temp_sol[(k+1)%n]] -\n                                  distance_matrix_1[temp_sol[k], temp_sol[(k+2)%n]])\n                    if temp_change < 0:\n                        new_solution = temp_sol\n                        break\n            elif worst_obj == 1:\n                # Similar for second objective\n                for k in range(n):\n                    temp_sol = new_solution.copy()\n                    temp_sol[k], temp_sol[(k+1)%n] = temp_sol[(k+1)%n], temp_sol[k]\n                    temp_change = (distance_matrix_2[temp_sol[k-1], temp_sol[k]] +\n                                  distance_matrix_2[temp_sol[(k+1)%n], temp_sol[(k+2)%n]] -\n                                  distance_matrix_2[temp_sol[k-1], temp_sol[(k+1)%n]] -\n                                  distance_matrix_2[temp_sol[k], temp_sol[(k+2)%n]])\n                    if temp_change < 0:\n                        new_solution = temp_sol\n                        break\n            else:\n                # Similar for third objective\n                for k in range(n):\n                    temp_sol = new_solution.copy()\n                    temp_sol[k], temp_sol[(k+1)%n] = temp_sol[(k+1)%n], temp_sol[k]\n                    temp_change = (distance_matrix_3[temp_sol[k-1], temp_sol[k]] +\n                                  distance_matrix_3[temp_sol[(k+1)%n], temp_sol[(k+2)%n]] -\n                                  distance_matrix_3[temp_sol[k-1], temp_sol[(k+1)%n]] -\n                                  distance_matrix_3[temp_sol[k], temp_sol[(k+2)%n]])\n                    if temp_change < 0:\n                        new_solution = temp_sol\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.8198468348300866,
            2.294589471817017
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    potentials = []\n    for sol, obj in archive:\n        # Calculate potential as the sum of normalized improvements across objectives\n        # Here, we assume smaller objectives are better\n        potential = sum(obj)  # Simplified potential calculation\n        potentials.append(potential)\n\n    # Normalize potentials to create a probability distribution\n    min_pot = min(potentials)\n    max_pot = max(potentials)\n    if min_pot == max_pot:\n        probs = [1.0 / len(potentials)] * len(potentials)\n    else:\n        normalized = [(max_pot - p) / (max_pot - min_pot) for p in potentials]\n        probs = [p / sum(normalized) for p in normalized]\n\n    # Select a solution based on the probability distribution\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(base_solution)\n    for _ in range(10):  # Perform a fixed number of local search steps\n        # Randomly select two distinct edges to swap (2-opt)\n        i, j = sorted(random.sample(range(n), 2))\n        if i == j or j == (i + 1) % n:\n            continue  # Skip if edges are consecutive\n\n        # Perform 2-opt swap\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Check if the swap improves any objective\n        # Calculate the change in objectives\n        obj1_change = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[j]] -\n                        distance_matrix_1[new_solution[i], new_solution[(j+1)%n]])\n\n        obj2_change = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[j]] -\n                        distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n        obj3_change = (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_3[new_solution[j], new_solution[(j+1)%n]] -\n                        distance_matrix_3[new_solution[i-1], new_solution[j]] -\n                        distance_matrix_3[new_solution[i], new_solution[(j+1)%n]])\n\n        # If the swap doesn't improve any objective, revert it\n        if obj1_change >= 0 and obj2_change >= 0 and obj3_change >= 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # With some probability, perform an objective-aware swap\n        if random.random() < 0.3:\n            # Select a node to swap with its neighbor based on the worst objective\n            worst_obj = np.argmax([obj1_change, obj2_change, obj3_change])\n            if worst_obj == 0:\n                # Find the node that would most improve the first objective\n                for k in range(n):\n                    temp_sol = new_solution.copy()\n                    temp_sol[k], temp_sol[(k+1)%n] = temp_sol[(k+1)%n], temp_sol[k]\n                    temp_change = (distance_matrix_1[temp_sol[k-1], temp_sol[k]] +\n                                  distance_matrix_1[temp_sol[(k+1)%n], temp_sol[(k+2)%n]] -\n                                  distance_matrix_1[temp_sol[k-1], temp_sol[(k+1)%n]] -\n                                  distance_matrix_1[temp_sol[k], temp_sol[(k+2)%n]])\n                    if temp_change < 0:\n                        new_solution = temp_sol\n                        break\n            elif worst_obj == 1:\n                # Similar for second objective\n                for k in range(n):\n                    temp_sol = new_solution.copy()\n                    temp_sol[k], temp_sol[(k+1)%n] = temp_sol[(k+1)%n], temp_sol[k]\n                    temp_change = (distance_matrix_2[temp_sol[k-1], temp_sol[k]] +\n                                  distance_matrix_2[temp_sol[(k+1)%n], temp_sol[(k+2)%n]] -\n                                  distance_matrix_2[temp_sol[k-1], temp_sol[(k+1)%n]] -\n                                  distance_matrix_2[temp_sol[k], temp_sol[(k+2)%n]])\n                    if temp_change < 0:\n                        new_solution = temp_sol\n                        break\n            else:\n                # Similar for third objective\n                for k in range(n):\n                    temp_sol = new_solution.copy()\n                    temp_sol[k], temp_sol[(k+1)%n] = temp_sol[(k+1)%n], temp_sol[k]\n                    temp_change = (distance_matrix_3[temp_sol[k-1], temp_sol[k]] +\n                                  distance_matrix_3[temp_sol[(k+1)%n], temp_sol[(k+2)%n]] -\n                                  distance_matrix_3[temp_sol[k-1], temp_sol[(k+1)%n]] -\n                                  distance_matrix_3[temp_sol[k], temp_sol[(k+2)%n]])\n                    if temp_change < 0:\n                        new_solution = temp_sol\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 187,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    obj_vars = np.var(objectives, axis=0)\n    weighted_scores = np.sum(objectives * obj_vars, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply hybrid local search\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # 2-opt local search\n        improved = False\n        for i in range(n - 1):\n            for j in range(i + 2, n):\n                # Check if reversing the segment improves at least one objective\n                delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                          distance_matrix_1[new_solution[i], new_solution[j+1]] -\n                          distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                          distance_matrix_1[new_solution[j], new_solution[j+1]])\n\n                delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                          distance_matrix_2[new_solution[i], new_solution[j+1]] -\n                          distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                          distance_matrix_2[new_solution[j], new_solution[j+1]])\n\n                delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                          distance_matrix_3[new_solution[i], new_solution[j+1]] -\n                          distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                          distance_matrix_3[new_solution[j], new_solution[j+1]])\n\n                if (delta1 < 0) or (delta2 < 0) or (delta3 < 0):\n                    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n                    improved = True\n                    break\n            if improved:\n                break\n\n        if not improved:\n            # Try 3-way edge swap if 2-opt doesn't improve\n            i, j, k = sorted(np.random.choice(range(n), size=3, replace=False))\n            # Check if swapping edges (i,j), (j,k) with (i,k), (j,j) improves at least one objective\n            delta1 = (distance_matrix_1[new_solution[i-1], new_solution[k]] +\n                      distance_matrix_1[new_solution[j], new_solution[k]] +\n                      distance_matrix_1[new_solution[i], new_solution[j]] -\n                      distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                      distance_matrix_1[new_solution[j], new_solution[k]] -\n                      distance_matrix_1[new_solution[i], new_solution[k]])\n\n            delta2 = (distance_matrix_2[new_solution[i-1], new_solution[k]] +\n                      distance_matrix_2[new_solution[j], new_solution[k]] +\n                      distance_matrix_2[new_solution[i], new_solution[j]] -\n                      distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                      distance_matrix_2[new_solution[j], new_solution[k]] -\n                      distance_matrix_2[new_solution[i], new_solution[k]])\n\n            delta3 = (distance_matrix_3[new_solution[i-1], new_solution[k]] +\n                      distance_matrix_3[new_solution[j], new_solution[k]] +\n                      distance_matrix_3[new_solution[i], new_solution[j]] -\n                      distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                      distance_matrix_3[new_solution[j], new_solution[k]] -\n                      distance_matrix_3[new_solution[i], new_solution[k]])\n\n            if (delta1 < 0) or (delta2 < 0) or (delta3 < 0):\n                new_solution[[i, j, k]] = new_solution[[i, k, j]]\n\n    return new_solution\n\n",
        "score": [
            -0.741299987882482,
            1.6292469143867492
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    obj_vars = np.var(objectives, axis=0)\n    weighted_scores = np.sum(objectives * obj_vars, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply hybrid local search\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # 2-opt local search\n        improved = False\n        for i in range(n - 1):\n            for j in range(i + 2, n):\n                # Check if reversing the segment improves at least one objective\n                delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                          distance_matrix_1[new_solution[i], new_solution[j+1]] -\n                          distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                          distance_matrix_1[new_solution[j], new_solution[j+1]])\n\n                delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                          distance_matrix_2[new_solution[i], new_solution[j+1]] -\n                          distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                          distance_matrix_2[new_solution[j], new_solution[j+1]])\n\n                delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                          distance_matrix_3[new_solution[i], new_solution[j+1]] -\n                          distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                          distance_matrix_3[new_solution[j], new_solution[j+1]])\n\n                if (delta1 < 0) or (delta2 < 0) or (delta3 < 0):\n                    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n                    improved = True\n                    break\n            if improved:\n                break\n\n        if not improved:\n            # Try 3-way edge swap if 2-opt doesn't improve\n            i, j, k = sorted(np.random.choice(range(n), size=3, replace=False))\n            # Check if swapping edges (i,j), (j,k) with (i,k), (j,j) improves at least one objective\n            delta1 = (distance_matrix_1[new_solution[i-1], new_solution[k]] +\n                      distance_matrix_1[new_solution[j], new_solution[k]] +\n                      distance_matrix_1[new_solution[i], new_solution[j]] -\n                      distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                      distance_matrix_1[new_solution[j], new_solution[k]] -\n                      distance_matrix_1[new_solution[i], new_solution[k]])\n\n            delta2 = (distance_matrix_2[new_solution[i-1], new_solution[k]] +\n                      distance_matrix_2[new_solution[j], new_solution[k]] +\n                      distance_matrix_2[new_solution[i], new_solution[j]] -\n                      distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                      distance_matrix_2[new_solution[j], new_solution[k]] -\n                      distance_matrix_2[new_solution[i], new_solution[k]])\n\n            delta3 = (distance_matrix_3[new_solution[i-1], new_solution[k]] +\n                      distance_matrix_3[new_solution[j], new_solution[k]] +\n                      distance_matrix_3[new_solution[i], new_solution[j]] -\n                      distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                      distance_matrix_3[new_solution[j], new_solution[k]] -\n                      distance_matrix_3[new_solution[i], new_solution[k]])\n\n            if (delta1 < 0) or (delta2 < 0) or (delta3 < 0):\n                new_solution[[i, j, k]] = new_solution[[i, k, j]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 188,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending) to prioritize less optimal solutions\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the middle of the sorted list to balance exploration and exploitation\n        selected_idx = min(len(sorted_archive) // 2, len(sorted_archive) - 1)\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of 2-opt and node insertion\n    n = len(new_solution)\n    # Randomly select two distinct edges to perform 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n    # Reverse the segment between i and j to create a new tour\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select a node to reinsert (node insertion move)\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    # Remove the node from its current position\n    new_solution = np.delete(new_solution, k)\n    # Insert the node at a random position\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7739067269926456,
            1.376542603969574
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending) to prioritize less optimal solutions\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the middle of the sorted list to balance exploration and exploitation\n        selected_idx = min(len(sorted_archive) // 2, len(sorted_archive) - 1)\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of 2-opt and node insertion\n    n = len(new_solution)\n    # Randomly select two distinct edges to perform 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n    # Reverse the segment between i and j to create a new tour\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select a node to reinsert (node insertion move)\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    # Remove the node from its current position\n    new_solution = np.delete(new_solution, k)\n    # Insert the node at a random position\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 189,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy combining 2-opt and insertion moves\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, just perform a 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # With probability 0.7, perform 2-opt; otherwise, perform insertion\n        if np.random.rand() < 0.7:\n            # 2-opt move\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Insertion move\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            while j == i or j == (i + 1) % n or j == (i - 1) % n:\n                j = np.random.randint(0, n)\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains feasible (visits all nodes exactly once)\n    assert len(np.unique(new_solution)) == len(base_solution), \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            -0.81132873420928,
            1.3622259259223939
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy combining 2-opt and insertion moves\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, just perform a 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # With probability 0.7, perform 2-opt; otherwise, perform insertion\n        if np.random.rand() < 0.7:\n            # 2-opt move\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Insertion move\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            while j == i or j == (i + 1) % n or j == (i - 1) % n:\n                j = np.random.randint(0, n)\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains feasible (visits all nodes exactly once)\n    assert len(np.unique(new_solution)) == len(base_solution), \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 190,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate the crowding distance for each solution in the archive\n    crowding_distances = []\n    objectives = [obj for _, obj in archive]\n\n    for i in range(3):  # For each objective\n        sorted_indices = np.argsort([obj[i] for obj in objectives])\n        min_obj = objectives[sorted_indices[0]][i]\n        max_obj = objectives[sorted_indices[-1]][i]\n\n        # Handle edge cases where all solutions have the same objective value\n        if min_obj == max_obj:\n            crowding_dist = [0.0 for _ in objectives]\n        else:\n            crowding_dist = [0.0] * len(objectives)\n            crowding_dist[sorted_indices[0]] = float('inf')\n            crowding_dist[sorted_indices[-1]] = float('inf')\n\n            for j in range(1, len(objectives) - 1):\n                crowding_dist[sorted_indices[j]] = (objectives[sorted_indices[j+1]][i] - objectives[sorted_indices[j-1]][i]) / (max_obj - min_obj)\n\n        crowding_distances.append(crowding_dist)\n\n    # Combine crowding distances across objectives\n    combined_crowding = [sum(cd) for cd in zip(*crowding_distances)]\n\n    # Select solutions with above-average crowding distance\n    avg_crowding = np.mean(combined_crowding)\n    candidates = [i for i, cd in enumerate(combined_crowding) if cd > avg_crowding]\n\n    if not candidates:\n        # If no candidates found, select a random solution\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        # Select a candidate with probability proportional to its crowding distance\n        probabilities = [combined_crowding[i] for i in candidates]\n        probabilities = [p / sum(probabilities) for p in probabilities]\n        selected_idx = random.choices(candidates, weights=probabilities, k=1)[0]\n\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, perform an objective-aware swap\n    # Calculate the cost of the current solution\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Try to improve by swapping nodes that are \"dominated\" in one objective but better in others\n    for _ in range(min(10, n)):  # Limit the number of attempts\n        a, b = random.sample(range(n), 2)\n        if a > b:\n            a, b = b, a\n\n        # Create a candidate solution with the swap\n        candidate = new_solution.copy()\n        candidate[a], candidate[b] = candidate[b], candidate[a]\n\n        candidate_cost = calculate_cost(candidate)\n\n        # Check if the candidate is better in at least one objective without being worse in all others\n        improved = False\n        for i in range(3):\n            if candidate_cost[i] < current_cost[i]:\n                if all(candidate_cost[j] <= current_cost[j] for j in range(3)):\n                    improved = True\n                    break\n\n        if improved:\n            new_solution = candidate\n            current_cost = candidate_cost\n            break  # Accept the first improvement\n\n    return new_solution\n\n",
        "score": [
            -0.7349835088661905,
            3.804696023464203
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate the crowding distance for each solution in the archive\n    crowding_distances = []\n    objectives = [obj for _, obj in archive]\n\n    for i in range(3):  # For each objective\n        sorted_indices = np.argsort([obj[i] for obj in objectives])\n        min_obj = objectives[sorted_indices[0]][i]\n        max_obj = objectives[sorted_indices[-1]][i]\n\n        # Handle edge cases where all solutions have the same objective value\n        if min_obj == max_obj:\n            crowding_dist = [0.0 for _ in objectives]\n        else:\n            crowding_dist = [0.0] * len(objectives)\n            crowding_dist[sorted_indices[0]] = float('inf')\n            crowding_dist[sorted_indices[-1]] = float('inf')\n\n            for j in range(1, len(objectives) - 1):\n                crowding_dist[sorted_indices[j]] = (objectives[sorted_indices[j+1]][i] - objectives[sorted_indices[j-1]][i]) / (max_obj - min_obj)\n\n        crowding_distances.append(crowding_dist)\n\n    # Combine crowding distances across objectives\n    combined_crowding = [sum(cd) for cd in zip(*crowding_distances)]\n\n    # Select solutions with above-average crowding distance\n    avg_crowding = np.mean(combined_crowding)\n    candidates = [i for i, cd in enumerate(combined_crowding) if cd > avg_crowding]\n\n    if not candidates:\n        # If no candidates found, select a random solution\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        # Select a candidate with probability proportional to its crowding distance\n        probabilities = [combined_crowding[i] for i in candidates]\n        probabilities = [p / sum(probabilities) for p in probabilities]\n        selected_idx = random.choices(candidates, weights=probabilities, k=1)[0]\n\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, perform an objective-aware swap\n    # Calculate the cost of the current solution\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n\n    # Try to improve by swapping nodes that are \"dominated\" in one objective but better in others\n    for _ in range(min(10, n)):  # Limit the number of attempts\n        a, b = random.sample(range(n), 2)\n        if a > b:\n            a, b = b, a\n\n        # Create a candidate solution with the swap\n        candidate = new_solution.copy()\n        candidate[a], candidate[b] = candidate[b], candidate[a]\n\n        candidate_cost = calculate_cost(candidate)\n\n        # Check if the candidate is better in at least one objective without being worse in all others\n        improved = False\n        for i in range(3):\n            if candidate_cost[i] < current_cost[i]:\n                if all(candidate_cost[j] <= current_cost[j] for j in range(3)):\n                    improved = True\n                    break\n\n        if improved:\n            new_solution = candidate\n            current_cost = candidate_cost\n            break  # Accept the first improvement\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 191,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective diversity)\n    weights = [1.0 / (1.0 + obj[0] + obj[1] + obj[2]) for (sol, obj) in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt and 3-opt with multi-objective aware selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt or 3-opt with probability based on objective diversity\n    obj_diversity = archive[selected_idx][1][0] + archive[selected_idx][1][1] + archive[selected_idx][1][2]\n    use_3_opt = obj_diversity > np.mean([sum(obj) for (sol, obj) in archive]) if len(archive) > 1 else False\n\n    if use_3_opt and n >= 4:\n        # Multi-objective aware 3-opt\n        i, j, k = sorted(random.sample(range(1, n-1), 3))\n        candidates = [\n            new_solution.copy(),\n            np.concatenate([new_solution[:i], new_solution[i:j][::-1], new_solution[j:]]),\n            np.concatenate([new_solution[:i], new_solution[j:k][::-1], new_solution[i:j], new_solution[k:]]),\n            np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j][::-1], new_solution[k:]])\n        ]\n\n        # Evaluate all candidates across all objectives\n        def evaluate(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n            return (cost1, cost2, cost3)\n\n        costs = [evaluate(c) for c in candidates]\n        dominated_counts = [sum(1 for c in costs if all(c[j] <= costs[i][j] for j in range(3)) and any(c[j] < costs[i][j] for j in range(3))) for i in range(len(costs))]\n\n        # Select the candidate that dominates the most other candidates\n        best_idx = np.argmin(dominated_counts)\n        new_solution = candidates[best_idx]\n    else:\n        # Multi-objective aware 2-opt\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        candidate1 = new_solution.copy()\n        candidate1[i:j] = candidate1[i:j][::-1]\n\n        # Evaluate candidates\n        def evaluate(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n            return (cost1, cost2, cost3)\n\n        cost_original = evaluate(new_solution)\n        cost_candidate = evaluate(candidate1)\n\n        # Accept if candidate dominates in at least one objective\n        if any(cost_candidate[i] < cost_original[i] for i in range(3)):\n            new_solution = candidate1\n\n    return new_solution\n\n",
        "score": [
            -0.6874501650736877,
            3.7071847558021545
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective diversity)\n    weights = [1.0 / (1.0 + obj[0] + obj[1] + obj[2]) for (sol, obj) in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt and 3-opt with multi-objective aware selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt or 3-opt with probability based on objective diversity\n    obj_diversity = archive[selected_idx][1][0] + archive[selected_idx][1][1] + archive[selected_idx][1][2]\n    use_3_opt = obj_diversity > np.mean([sum(obj) for (sol, obj) in archive]) if len(archive) > 1 else False\n\n    if use_3_opt and n >= 4:\n        # Multi-objective aware 3-opt\n        i, j, k = sorted(random.sample(range(1, n-1), 3))\n        candidates = [\n            new_solution.copy(),\n            np.concatenate([new_solution[:i], new_solution[i:j][::-1], new_solution[j:]]),\n            np.concatenate([new_solution[:i], new_solution[j:k][::-1], new_solution[i:j], new_solution[k:]]),\n            np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j][::-1], new_solution[k:]])\n        ]\n\n        # Evaluate all candidates across all objectives\n        def evaluate(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n            return (cost1, cost2, cost3)\n\n        costs = [evaluate(c) for c in candidates]\n        dominated_counts = [sum(1 for c in costs if all(c[j] <= costs[i][j] for j in range(3)) and any(c[j] < costs[i][j] for j in range(3))) for i in range(len(costs))]\n\n        # Select the candidate that dominates the most other candidates\n        best_idx = np.argmin(dominated_counts)\n        new_solution = candidates[best_idx]\n    else:\n        # Multi-objective aware 2-opt\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        candidate1 = new_solution.copy()\n        candidate1[i:j] = candidate1[i:j][::-1]\n\n        # Evaluate candidates\n        def evaluate(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n            return (cost1, cost2, cost3)\n\n        cost_original = evaluate(new_solution)\n        cost_candidate = evaluate(candidate1)\n\n        # Accept if candidate dominates in at least one objective\n        if any(cost_candidate[i] < cost_original[i] for i in range(3)):\n            new_solution = candidate1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 192,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate a score for each solution based on its objective values (lower is better)\n    scores = []\n    for sol, obj in archive:\n        # Normalize the objectives to make them comparable\n        norm_obj = np.array(obj) / np.sum(np.array(obj))\n        score = np.sum(norm_obj)  # Lower score is better\n        scores.append(score)\n\n    # Select the solution with the lowest score (best objective values)\n    best_idx = np.argmin(scores)\n    base_solution = archive[best_idx][0].copy()\n\n    # Apply a hybrid local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose a random segment to perturb (2-opt or swap)\n    if random.random() < 0.5:\n        # 2-opt move (swap two edges)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Swap two nodes (swap move)\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    assert len(set(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.6703817216046798,
            4.485583233833313
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate a score for each solution based on its objective values (lower is better)\n    scores = []\n    for sol, obj in archive:\n        # Normalize the objectives to make them comparable\n        norm_obj = np.array(obj) / np.sum(np.array(obj))\n        score = np.sum(norm_obj)  # Lower score is better\n        scores.append(score)\n\n    # Select the solution with the lowest score (best objective values)\n    best_idx = np.argmin(scores)\n    base_solution = archive[best_idx][0].copy()\n\n    # Apply a hybrid local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose a random segment to perturb (2-opt or swap)\n    if random.random() < 0.5:\n        # 2-opt move (swap two edges)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Swap two nodes (swap move)\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    assert len(set(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 193,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with relatively high objective values)\n    objectives = [obj for _, obj in archive]\n    max_objectives = np.max(objectives, axis=0)\n    min_objectives = np.min(objectives, axis=0)\n    normalized_objectives = [(obj - min_objectives) / (max_objectives - min_objectives + 1e-10) for obj in objectives]\n    avg_normalized = np.mean(normalized_objectives, axis=1)\n    selected_idx = np.argmax(avg_normalized)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and objective-aware edge swap\n    n = len(new_solution)\n    for _ in range(10):  # Number of perturbation attempts\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate potential improvement across all objectives\n        current_edges = [\n            (new_solution[i-1], new_solution[i]),\n            (new_solution[j], new_solution[(j+1)%n]),\n            (new_solution[i], new_solution[(i+1)%n]),\n            (new_solution[j-1], new_solution[j])\n        ]\n\n        new_edges = [\n            (new_solution[i-1], new_solution[j]),\n            (new_solution[i], new_solution[(j+1)%n]),\n            (new_solution[j-1], new_solution[i]),\n            (new_solution[(i+1)%n], new_solution[j])\n        ]\n\n        # Calculate objective improvements\n        delta_obj1 = sum(distance_matrix_1[a][b] for a, b in new_edges) - sum(distance_matrix_1[a][b] for a, b in current_edges)\n        delta_obj2 = sum(distance_matrix_2[a][b] for a, b in new_edges) - sum(distance_matrix_2[a][b] for a, b in current_edges)\n        delta_obj3 = sum(distance_matrix_3[a][b] for a, b in new_edges) - sum(distance_matrix_3[a][b] for a, b in current_edges)\n\n        # Accept if at least one objective improves\n        if delta_obj1 < 0 or delta_obj2 < 0 or delta_obj3 < 0:\n            # Reverse the segment between i and j\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6431393912013808,
            3.7390615344047546
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with relatively high objective values)\n    objectives = [obj for _, obj in archive]\n    max_objectives = np.max(objectives, axis=0)\n    min_objectives = np.min(objectives, axis=0)\n    normalized_objectives = [(obj - min_objectives) / (max_objectives - min_objectives + 1e-10) for obj in objectives]\n    avg_normalized = np.mean(normalized_objectives, axis=1)\n    selected_idx = np.argmax(avg_normalized)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and objective-aware edge swap\n    n = len(new_solution)\n    for _ in range(10):  # Number of perturbation attempts\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate potential improvement across all objectives\n        current_edges = [\n            (new_solution[i-1], new_solution[i]),\n            (new_solution[j], new_solution[(j+1)%n]),\n            (new_solution[i], new_solution[(i+1)%n]),\n            (new_solution[j-1], new_solution[j])\n        ]\n\n        new_edges = [\n            (new_solution[i-1], new_solution[j]),\n            (new_solution[i], new_solution[(j+1)%n]),\n            (new_solution[j-1], new_solution[i]),\n            (new_solution[(i+1)%n], new_solution[j])\n        ]\n\n        # Calculate objective improvements\n        delta_obj1 = sum(distance_matrix_1[a][b] for a, b in new_edges) - sum(distance_matrix_1[a][b] for a, b in current_edges)\n        delta_obj2 = sum(distance_matrix_2[a][b] for a, b in new_edges) - sum(distance_matrix_2[a][b] for a, b in current_edges)\n        delta_obj3 = sum(distance_matrix_3[a][b] for a, b in new_edges) - sum(distance_matrix_3[a][b] for a, b in current_edges)\n\n        # Accept if at least one objective improves\n        if delta_obj1 < 0 or delta_obj2 < 0 or delta_obj3 < 0:\n            # Reverse the segment between i and j\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 194,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    combined_scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First perform a standard 2-opt move\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform an objective-aware swap\n    # Calculate the current total distance for each objective\n    def compute_total_distance(sol, dist_matrix):\n        total = 0\n        for k in range(n):\n            total += dist_matrix[sol[k], sol[(k+1)%n]]\n        return total\n\n    current_dist1 = compute_total_distance(new_solution, distance_matrix_1)\n    current_dist2 = compute_total_distance(new_solution, distance_matrix_2)\n    current_dist3 = compute_total_distance(new_solution, distance_matrix_3)\n\n    # Try swapping nodes that are most \"out of place\" in any objective\n    for _ in range(10):  # Limit attempts to prevent excessive computation\n        a, b = np.random.choice(n, 2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Create a temporary solution with the swap\n        temp_solution = new_solution.copy()\n        temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n        # Calculate new distances\n        new_dist1 = compute_total_distance(temp_solution, distance_matrix_1)\n        new_dist2 = compute_total_distance(temp_solution, distance_matrix_2)\n        new_dist3 = compute_total_distance(temp_solution, distance_matrix_3)\n\n        # Accept if at least one objective improves\n        if (new_dist1 < current_dist1) or (new_dist2 < current_dist2) or (new_dist3 < current_dist3):\n            new_solution = temp_solution\n            current_dist1, current_dist2, current_dist3 = new_dist1, new_dist2, new_dist3\n            break  # Only accept one improvement per iteration\n\n    return new_solution\n\n",
        "score": [
            -0.7236710188225679,
            2.445747172832489
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    combined_scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First perform a standard 2-opt move\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform an objective-aware swap\n    # Calculate the current total distance for each objective\n    def compute_total_distance(sol, dist_matrix):\n        total = 0\n        for k in range(n):\n            total += dist_matrix[sol[k], sol[(k+1)%n]]\n        return total\n\n    current_dist1 = compute_total_distance(new_solution, distance_matrix_1)\n    current_dist2 = compute_total_distance(new_solution, distance_matrix_2)\n    current_dist3 = compute_total_distance(new_solution, distance_matrix_3)\n\n    # Try swapping nodes that are most \"out of place\" in any objective\n    for _ in range(10):  # Limit attempts to prevent excessive computation\n        a, b = np.random.choice(n, 2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Create a temporary solution with the swap\n        temp_solution = new_solution.copy()\n        temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n        # Calculate new distances\n        new_dist1 = compute_total_distance(temp_solution, distance_matrix_1)\n        new_dist2 = compute_total_distance(temp_solution, distance_matrix_2)\n        new_dist3 = compute_total_distance(temp_solution, distance_matrix_3)\n\n        # Accept if at least one objective improves\n        if (new_dist1 < current_dist1) or (new_dist2 < current_dist2) or (new_dist3 < current_dist3):\n            new_solution = temp_solution\n            current_dist1, current_dist2, current_dist3 = new_dist1, new_dist2, new_dist3\n            break  # Only accept one improvement per iteration\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 195,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    objective_variance = np.var(objectives, axis=0)\n    normalized_variance = objective_variance / np.sum(objective_variance)\n    weights = normalized_variance / np.sum(normalized_variance)\n\n    # Calculate a score for each solution based on its potential for improvement\n    scores = np.zeros(len(archive))\n    for i, (sol, obj) in enumerate(archive):\n        # Combine objectives with weights to identify solutions with high potential\n        scores[i] = np.sum(np.array(obj) * weights)\n\n    # Select the solution with the highest score (most promising for improvement)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt and 3-opt with weighted edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and 3-opt based on objective weights\n    if np.random.rand() < 0.7:  # 70% chance for 2-opt\n        # Weighted 2-opt: select edges with higher potential for improvement\n        edge_scores = np.zeros(n)\n        for i in range(n):\n            u, v = new_solution[i], new_solution[(i+1)%n]\n            # Score based on combined distance improvement potential\n            edge_scores[i] = (distance_matrix_1[u, v] * weights[0] +\n                             distance_matrix_2[u, v] * weights[1] +\n                             distance_matrix_3[u, v] * weights[2])\n\n        # Select the worst edge to flip (highest score)\n        worst_edge = np.argmax(edge_scores)\n        i, j = worst_edge, (worst_edge + 1) % n\n\n        # Perform 2-opt swap\n        if i < j:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        else:\n            new_solution[i+1:] = new_solution[i+1:][::-1]\n            new_solution[:j+1] = new_solution[:j+1][::-1]\n    else:  # 3-opt for more complex moves\n        # Select three random positions\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        # Perform 3-opt move (all possible permutations)\n        candidates = [\n            new_solution.copy(),\n            np.concatenate([new_solution[:i+1], new_solution[j+1:k+1], new_solution[i+1:j+1], new_solution[k+1:]]),\n            np.concatenate([new_solution[:i+1], new_solution[k:j:-1], new_solution[i+1:k+1][::-1], new_solution[j+1:]]),\n            np.concatenate([new_solution[:i+1], new_solution[k:j:-1], new_solution[i+1:j+1], new_solution[k+1:]]),\n            np.concatenate([new_solution[:i+1], new_solution[j+1:k+1][::-1], new_solution[i+1:k+1], new_solution[j+1:]]),\n            np.concatenate([new_solution[:i+1], new_solution[j+1:k+1][::-1], new_solution[i+1:j+1][::-1], new_solution[k+1:]]),\n            np.concatenate([new_solution[:i+1], new_solution[k:j:-1], new_solution[i+1:j+1][::-1], new_solution[k+1:]]),\n        ]\n\n        # Evaluate all candidates based on weighted objectives\n        best_candidate = new_solution.copy()\n        best_score = float('inf')\n\n        for candidate in candidates:\n            total_score = 0\n            for m in range(n):\n                u, v = candidate[m], candidate[(m+1)%n]\n                total_score += (distance_matrix_1[u, v] * weights[0] +\n                               distance_matrix_2[u, v] * weights[1] +\n                               distance_matrix_3[u, v] * weights[2])\n\n            if total_score < best_score:\n                best_score = total_score\n                best_candidate = candidate.copy()\n\n        new_solution = best_candidate\n\n    return new_solution\n\n",
        "score": [
            -0.6998125130426801,
            3.9501523852348326
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    objective_variance = np.var(objectives, axis=0)\n    normalized_variance = objective_variance / np.sum(objective_variance)\n    weights = normalized_variance / np.sum(normalized_variance)\n\n    # Calculate a score for each solution based on its potential for improvement\n    scores = np.zeros(len(archive))\n    for i, (sol, obj) in enumerate(archive):\n        # Combine objectives with weights to identify solutions with high potential\n        scores[i] = np.sum(np.array(obj) * weights)\n\n    # Select the solution with the highest score (most promising for improvement)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt and 3-opt with weighted edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and 3-opt based on objective weights\n    if np.random.rand() < 0.7:  # 70% chance for 2-opt\n        # Weighted 2-opt: select edges with higher potential for improvement\n        edge_scores = np.zeros(n)\n        for i in range(n):\n            u, v = new_solution[i], new_solution[(i+1)%n]\n            # Score based on combined distance improvement potential\n            edge_scores[i] = (distance_matrix_1[u, v] * weights[0] +\n                             distance_matrix_2[u, v] * weights[1] +\n                             distance_matrix_3[u, v] * weights[2])\n\n        # Select the worst edge to flip (highest score)\n        worst_edge = np.argmax(edge_scores)\n        i, j = worst_edge, (worst_edge + 1) % n\n\n        # Perform 2-opt swap\n        if i < j:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        else:\n            new_solution[i+1:] = new_solution[i+1:][::-1]\n            new_solution[:j+1] = new_solution[:j+1][::-1]\n    else:  # 3-opt for more complex moves\n        # Select three random positions\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        # Perform 3-opt move (all possible permutations)\n        candidates = [\n            new_solution.copy(),\n            np.concatenate([new_solution[:i+1], new_solution[j+1:k+1], new_solution[i+1:j+1], new_solution[k+1:]]),\n            np.concatenate([new_solution[:i+1], new_solution[k:j:-1], new_solution[i+1:k+1][::-1], new_solution[j+1:]]),\n            np.concatenate([new_solution[:i+1], new_solution[k:j:-1], new_solution[i+1:j+1], new_solution[k+1:]]),\n            np.concatenate([new_solution[:i+1], new_solution[j+1:k+1][::-1], new_solution[i+1:k+1], new_solution[j+1:]]),\n            np.concatenate([new_solution[:i+1], new_solution[j+1:k+1][::-1], new_solution[i+1:j+1][::-1], new_solution[k+1:]]),\n            np.concatenate([new_solution[:i+1], new_solution[k:j:-1], new_solution[i+1:j+1][::-1], new_solution[k+1:]]),\n        ]\n\n        # Evaluate all candidates based on weighted objectives\n        best_candidate = new_solution.copy()\n        best_score = float('inf')\n\n        for candidate in candidates:\n            total_score = 0\n            for m in range(n):\n                u, v = candidate[m], candidate[(m+1)%n]\n                total_score += (distance_matrix_1[u, v] * weights[0] +\n                               distance_matrix_2[u, v] * weights[1] +\n                               distance_matrix_3[u, v] * weights[2])\n\n            if total_score < best_score:\n                best_score = total_score\n                best_candidate = candidate.copy()\n\n        new_solution = best_candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 196,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best trade-off across objectives (using a simple weighted sum)\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    scores = [sum(w * obj for w, obj in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search: 2-opt + edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose a segment to modify\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Apply 2-opt on the selected segment\n    if j - i > 1:\n        segment = new_solution[i:j+1]\n        reversed_segment = segment[::-1]\n        new_solution[i:j+1] = reversed_segment\n\n    # Apply edge insertion: move a random node to a random position\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback: swap two random nodes if invalid\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7629110395895501,
            2.459303319454193
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best trade-off across objectives (using a simple weighted sum)\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    scores = [sum(w * obj for w, obj in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search: 2-opt + edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose a segment to modify\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Apply 2-opt on the selected segment\n    if j - i > 1:\n        segment = new_solution[i:j+1]\n        reversed_segment = segment[::-1]\n        new_solution[i:j+1] = reversed_segment\n\n    # Apply edge insertion: move a random node to a random position\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback: swap two random nodes if invalid\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 197,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution, _ = archive[selected_idx]\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # No possible improvement\n\n    # Perform a 2-opt move based on the objective with the highest improvement potential\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Evaluate the impact on all three objectives\n    def evaluate_swap(sol, a, b):\n        cost1 = distance_matrix_1[sol[a-1], sol[a]] + distance_matrix_1[sol[b-1], sol[b]]\n        cost2 = distance_matrix_2[sol[a-1], sol[a]] + distance_matrix_2[sol[b-1], sol[b]]\n        cost3 = distance_matrix_3[sol[a-1], sol[a]] + distance_matrix_3[sol[b-1], sol[b]]\n\n        new_cost1 = distance_matrix_1[sol[a-1], sol[b]] + distance_matrix_1[sol[b-1], sol[a]]\n        new_cost2 = distance_matrix_2[sol[a-1], sol[b]] + distance_matrix_2[sol[b-1], sol[a]]\n        new_cost3 = distance_matrix_3[sol[a-1], sol[b]] + distance_matrix_3[sol[b-1], sol[a]]\n\n        return (new_cost1 - cost1, new_cost2 - cost2, new_cost3 - cost3)\n\n    # Perform the swap that improves at least one objective\n    delta1, delta2, delta3 = evaluate_swap(new_solution, i, j)\n    if delta1 < 0 or delta2 < 0 or delta3 < 0:\n        new_solution[i:j] = np.flip(new_solution[i:j])\n    else:\n        # If no improvement, try another 2-opt\n        delta1, delta2, delta3 = evaluate_swap(new_solution, k, l)\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[k:l] = np.flip(new_solution[k:l])\n\n    # Additional perturbation to escape local optima\n    if random.random() < 0.3:  # 30% chance of perturbation\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8203226226525118,
            1.5790029406547545
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution, _ = archive[selected_idx]\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # No possible improvement\n\n    # Perform a 2-opt move based on the objective with the highest improvement potential\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Evaluate the impact on all three objectives\n    def evaluate_swap(sol, a, b):\n        cost1 = distance_matrix_1[sol[a-1], sol[a]] + distance_matrix_1[sol[b-1], sol[b]]\n        cost2 = distance_matrix_2[sol[a-1], sol[a]] + distance_matrix_2[sol[b-1], sol[b]]\n        cost3 = distance_matrix_3[sol[a-1], sol[a]] + distance_matrix_3[sol[b-1], sol[b]]\n\n        new_cost1 = distance_matrix_1[sol[a-1], sol[b]] + distance_matrix_1[sol[b-1], sol[a]]\n        new_cost2 = distance_matrix_2[sol[a-1], sol[b]] + distance_matrix_2[sol[b-1], sol[a]]\n        new_cost3 = distance_matrix_3[sol[a-1], sol[b]] + distance_matrix_3[sol[b-1], sol[a]]\n\n        return (new_cost1 - cost1, new_cost2 - cost2, new_cost3 - cost3)\n\n    # Perform the swap that improves at least one objective\n    delta1, delta2, delta3 = evaluate_swap(new_solution, i, j)\n    if delta1 < 0 or delta2 < 0 or delta3 < 0:\n        new_solution[i:j] = np.flip(new_solution[i:j])\n    else:\n        # If no improvement, try another 2-opt\n        delta1, delta2, delta3 = evaluate_swap(new_solution, k, l)\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[k:l] = np.flip(new_solution[k:l])\n\n    # Additional perturbation to escape local optima\n    if random.random() < 0.3:  # 30% chance of perturbation\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 198,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    worst_solution_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[worst_solution_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with random segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Decide between 2-opt or segment reversal based on random choice\n    if random.random() < 0.5:\n        # 2-opt move: randomly select two edges and reverse the segment between them\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Random segment reversal: reverse a random segment of the tour\n        seg_length = random.randint(2, min(10, n // 2))\n        start = random.randint(0, n - seg_length)\n        new_solution[start:start+seg_length] = new_solution[start:start+seg_length][::-1]\n\n    # Ensure the solution remains a valid tour (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple 2-opt move\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6577216153753608,
            1.4112089276313782
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    worst_solution_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[worst_solution_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with random segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Decide between 2-opt or segment reversal based on random choice\n    if random.random() < 0.5:\n        # 2-opt move: randomly select two edges and reverse the segment between them\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Random segment reversal: reverse a random segment of the tour\n        seg_length = random.randint(2, min(10, n // 2))\n        start = random.randint(0, n - seg_length)\n        new_solution[start:start+seg_length] = new_solution[start:start+seg_length][::-1]\n\n    # Ensure the solution remains a valid tour (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple 2-opt move\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 199,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a probability proportional to its potential for improvement\n    # Here, we use the sum of normalized objectives to estimate potential\n    objectives = [obj for _, obj in archive]\n    normalized_objectives = np.array(objectives) / (np.max(np.array(objectives), axis=0) + 1e-10)\n    potential_scores = np.sum(normalized_objectives, axis=1)\n    probabilities = potential_scores / np.sum(potential_scores)\n\n    base_solution = random.choices(archive, weights=probabilities, k=1)[0][0].copy()\n\n    # Apply a hybrid local search operator: combination of 2-opt and edge exchange\n    new_solution = base_solution.copy()\n\n    # Determine the number of operations to perform (adaptive based on problem size)\n    n = len(new_solution)\n    num_operations = max(2, n // 10)\n\n    for _ in range(num_operations):\n        # Randomly choose between 2-opt and edge exchange\n        if random.random() < 0.5:\n            # 2-opt operation\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Edge exchange operation\n            i, j = sorted(random.sample(range(n), 2))\n            a, b = random.sample(range(n), 2)\n            if i != a and j != b:\n                # Ensure we don't create duplicates or invalid tours\n                temp = new_solution[i]\n                new_solution[i] = new_solution[a]\n                new_solution[a] = temp\n                temp = new_solution[j]\n                new_solution[j] = new_solution[b]\n                new_solution[b] = temp\n\n    # Ensure the solution is valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7966584175732134,
            1.699573278427124
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a probability proportional to its potential for improvement\n    # Here, we use the sum of normalized objectives to estimate potential\n    objectives = [obj for _, obj in archive]\n    normalized_objectives = np.array(objectives) / (np.max(np.array(objectives), axis=0) + 1e-10)\n    potential_scores = np.sum(normalized_objectives, axis=1)\n    probabilities = potential_scores / np.sum(potential_scores)\n\n    base_solution = random.choices(archive, weights=probabilities, k=1)[0][0].copy()\n\n    # Apply a hybrid local search operator: combination of 2-opt and edge exchange\n    new_solution = base_solution.copy()\n\n    # Determine the number of operations to perform (adaptive based on problem size)\n    n = len(new_solution)\n    num_operations = max(2, n // 10)\n\n    for _ in range(num_operations):\n        # Randomly choose between 2-opt and edge exchange\n        if random.random() < 0.5:\n            # 2-opt operation\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Edge exchange operation\n            i, j = sorted(random.sample(range(n), 2))\n            a, b = random.sample(range(n), 2)\n            if i != a and j != b:\n                # Ensure we don't create duplicates or invalid tours\n                temp = new_solution[i]\n                new_solution[i] = new_solution[a]\n                new_solution[a] = temp\n                temp = new_solution[j]\n                new_solution[j] = new_solution[b]\n                new_solution[b] = temp\n\n    # Ensure the solution is valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 200,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    if not objectives:\n        return archive[0][0].copy() if archive else None\n\n    # Normalize objectives to compare across different scales\n    objectives = np.array(objectives)\n    objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n\n    # Calculate a score for each solution based on its normalized objectives\n    scores = np.sum(objectives, axis=1)\n    probabilities = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with a multi-objective aware swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move to improve tour structure\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform a multi-objective aware swap to improve objective values\n    if n > 2:\n        # Select nodes to swap based on their potential to improve multiple objectives\n        k, l = random.sample(range(n), 2)\n        node_k = new_solution[k]\n        node_l = new_solution[l]\n\n        # Calculate potential improvement in all three objectives\n        current_cost = (\n            distance_matrix_1[node_k, new_solution[(k-1)%n]] + distance_matrix_1[new_solution[(k+1)%n], node_k],\n            distance_matrix_2[node_k, new_solution[(k-1)%n]] + distance_matrix_2[new_solution[(k+1)%n], node_k],\n            distance_matrix_3[node_k, new_solution[(k-1)%n]] + distance_matrix_3[new_solution[(k+1)%n], node_k]\n        )\n\n        new_cost = (\n            distance_matrix_1[node_l, new_solution[(k-1)%n]] + distance_matrix_1[new_solution[(k+1)%n], node_l],\n            distance_matrix_2[node_l, new_solution[(k-1)%n]] + distance_matrix_2[new_solution[(k+1)%n], node_l],\n            distance_matrix_3[node_l, new_solution[(k-1)%n]] + distance_matrix_3[new_solution[(k+1)%n], node_l]\n        )\n\n        # If the swap improves at least one objective, perform it\n        if any(nc < cc for nc, cc in zip(new_cost, current_cost)):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7561862418186912,
            1.5440441131591798
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    if not objectives:\n        return archive[0][0].copy() if archive else None\n\n    # Normalize objectives to compare across different scales\n    objectives = np.array(objectives)\n    objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n\n    # Calculate a score for each solution based on its normalized objectives\n    scores = np.sum(objectives, axis=1)\n    probabilities = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with a multi-objective aware swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move to improve tour structure\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform a multi-objective aware swap to improve objective values\n    if n > 2:\n        # Select nodes to swap based on their potential to improve multiple objectives\n        k, l = random.sample(range(n), 2)\n        node_k = new_solution[k]\n        node_l = new_solution[l]\n\n        # Calculate potential improvement in all three objectives\n        current_cost = (\n            distance_matrix_1[node_k, new_solution[(k-1)%n]] + distance_matrix_1[new_solution[(k+1)%n], node_k],\n            distance_matrix_2[node_k, new_solution[(k-1)%n]] + distance_matrix_2[new_solution[(k+1)%n], node_k],\n            distance_matrix_3[node_k, new_solution[(k-1)%n]] + distance_matrix_3[new_solution[(k+1)%n], node_k]\n        )\n\n        new_cost = (\n            distance_matrix_1[node_l, new_solution[(k-1)%n]] + distance_matrix_1[new_solution[(k+1)%n], node_l],\n            distance_matrix_2[node_l, new_solution[(k-1)%n]] + distance_matrix_2[new_solution[(k+1)%n], node_l],\n            distance_matrix_3[node_l, new_solution[(k-1)%n]] + distance_matrix_3[new_solution[(k+1)%n], node_l]\n        )\n\n        # If the swap improves at least one objective, perform it\n        if any(nc < cc for nc, cc in zip(new_cost, current_cost)):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 201,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best trade-off between objectives using Pareto dominance\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Make a copy of the selected solution\n    new_solution = selected_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Randomly select two distinct edges to swap (2-opt)\n    i, j = sorted(random.sample(range(n), 2))\n    if i == j:\n        j = (j + 1) % n\n\n    # Perform 2-opt move\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly decide whether to apply a random swap for diversification\n    if random.random() < 0.3:\n        k, l = random.sample(range(n), 2)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Verify the solution remains valid (no duplicates and all nodes visited)\n    if len(set(new_solution)) != n or len(new_solution) != n:\n        # If invalid, revert to original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6080023826944218,
            1.1727225184440613
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best trade-off between objectives using Pareto dominance\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Make a copy of the selected solution\n    new_solution = selected_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt + random swap for multi-objective optimization\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Randomly select two distinct edges to swap (2-opt)\n    i, j = sorted(random.sample(range(n), 2))\n    if i == j:\n        j = (j + 1) % n\n\n    # Perform 2-opt move\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly decide whether to apply a random swap for diversification\n    if random.random() < 0.3:\n        k, l = random.sample(range(n), 2)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Verify the solution remains valid (no duplicates and all nodes visited)\n    if len(set(new_solution)) != n or len(new_solution) != n:\n        # If invalid, revert to original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 202,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: choose solutions with the best trade-off across objectives\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Normalize objectives to avoid bias towards larger scales\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n\n    # Calculate crowding distance (promising solutions are those with good diversity)\n    crowding_dist = np.zeros(len(solutions))\n    for m in range(3):\n        sorted_idx = np.argsort(normalized_obj[:, m])\n        crowding_dist[sorted_idx[0]] = np.inf\n        crowding_dist[sorted_idx[-1]] = np.inf\n        for i in range(1, len(solutions)-1):\n            crowding_dist[sorted_idx[i]] += normalized_obj[sorted_idx[i+1], m] - normalized_obj[sorted_idx[i-1], m]\n\n    # Select solutions with high crowding distance (promising for improvement)\n    promising_idx = np.argsort(crowding_dist)[-max(2, len(solutions)//2):]\n    selected_solution = solutions[np.random.choice(promising_idx)]\n\n    # Hybrid local search: combine 2-opt with objective-aware edge swapping\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform objective-aware edge swapping\n    for _ in range(3):  # Number of swaps to attempt\n        # Calculate current objectives\n        current_obj = (\n            sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        )\n\n        # Find edges to swap\n        a, b = np.random.choice(n, 2, replace=False)\n        c, d = np.random.choice(n, 2, replace=False)\n\n        # Create candidate solution\n        candidate = new_solution.copy()\n        candidate[a], candidate[b] = candidate[b], candidate[a]\n        candidate[c], candidate[d] = candidate[d], candidate[c]\n\n        # Calculate candidate objectives\n        candidate_obj = (\n            sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_3[candidate[k], candidate[(k+1)%n]] for k in range(n))\n        )\n\n        # Accept if at least one objective improves\n        if any(c < o for c, o in zip(candidate_obj, current_obj)):\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7387426753145754,
            2.6840741634368896
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: choose solutions with the best trade-off across objectives\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Normalize objectives to avoid bias towards larger scales\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n\n    # Calculate crowding distance (promising solutions are those with good diversity)\n    crowding_dist = np.zeros(len(solutions))\n    for m in range(3):\n        sorted_idx = np.argsort(normalized_obj[:, m])\n        crowding_dist[sorted_idx[0]] = np.inf\n        crowding_dist[sorted_idx[-1]] = np.inf\n        for i in range(1, len(solutions)-1):\n            crowding_dist[sorted_idx[i]] += normalized_obj[sorted_idx[i+1], m] - normalized_obj[sorted_idx[i-1], m]\n\n    # Select solutions with high crowding distance (promising for improvement)\n    promising_idx = np.argsort(crowding_dist)[-max(2, len(solutions)//2):]\n    selected_solution = solutions[np.random.choice(promising_idx)]\n\n    # Hybrid local search: combine 2-opt with objective-aware edge swapping\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform objective-aware edge swapping\n    for _ in range(3):  # Number of swaps to attempt\n        # Calculate current objectives\n        current_obj = (\n            sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        )\n\n        # Find edges to swap\n        a, b = np.random.choice(n, 2, replace=False)\n        c, d = np.random.choice(n, 2, replace=False)\n\n        # Create candidate solution\n        candidate = new_solution.copy()\n        candidate[a], candidate[b] = candidate[b], candidate[a]\n        candidate[c], candidate[d] = candidate[d], candidate[c]\n\n        # Calculate candidate objectives\n        candidate_obj = (\n            sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_3[candidate[k], candidate[(k+1)%n]] for k in range(n))\n        )\n\n        # Accept if at least one objective improves\n        if any(c < o for c, o in zip(candidate_obj, current_obj)):\n            new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 203,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or marginal improvement potential\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator combining 2-opt and 3-opt with objective-aware selection\n    n = len(base_solution)\n    if n < 4:\n        # For small instances, just swap two nodes\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Apply a combination of 2-opt and 3-opt with objective-aware selection\n        # First, identify the most critical edge in each objective space\n        critical_edges = []\n        for dm in [distance_matrix_1, distance_matrix_2, distance_matrix_3]:\n            # Find the edge with the highest cost in this objective space\n            max_cost = -1\n            max_edge = (0, 0)\n            for i in range(n):\n                u = base_solution[i]\n                v = base_solution[(i + 1) % n]\n                cost = dm[u, v]\n                if cost > max_cost:\n                    max_cost = cost\n                    max_edge = (i, (i + 1) % n)\n            critical_edges.append(max_edge)\n\n        # Select the edge that appears most frequently in critical edges\n        edge_counts = {}\n        for edge in critical_edges:\n            edge_counts[edge] = edge_counts.get(edge, 0) + 1\n        most_critical_edge = max(edge_counts.items(), key=lambda x: x[1])[0]\n\n        # Apply 2-opt on the most critical edge\n        i, j = most_critical_edge\n        if i > j:\n            i, j = j, i\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n        # Additionally apply a random 3-opt move to further explore the neighborhood\n        if n >= 4:\n            a, b, c = np.random.choice(n, 3, replace=False)\n            a, b, c = sorted([a, b, c])\n            # Perform the 3-opt move\n            new_solution[b:c+1] = new_solution[b:c+1][::-1]\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7532088411458615,
            1.7738270998001098
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or marginal improvement potential\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator combining 2-opt and 3-opt with objective-aware selection\n    n = len(base_solution)\n    if n < 4:\n        # For small instances, just swap two nodes\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Apply a combination of 2-opt and 3-opt with objective-aware selection\n        # First, identify the most critical edge in each objective space\n        critical_edges = []\n        for dm in [distance_matrix_1, distance_matrix_2, distance_matrix_3]:\n            # Find the edge with the highest cost in this objective space\n            max_cost = -1\n            max_edge = (0, 0)\n            for i in range(n):\n                u = base_solution[i]\n                v = base_solution[(i + 1) % n]\n                cost = dm[u, v]\n                if cost > max_cost:\n                    max_cost = cost\n                    max_edge = (i, (i + 1) % n)\n            critical_edges.append(max_edge)\n\n        # Select the edge that appears most frequently in critical edges\n        edge_counts = {}\n        for edge in critical_edges:\n            edge_counts[edge] = edge_counts.get(edge, 0) + 1\n        most_critical_edge = max(edge_counts.items(), key=lambda x: x[1])[0]\n\n        # Apply 2-opt on the most critical edge\n        i, j = most_critical_edge\n        if i > j:\n            i, j = j, i\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n        # Additionally apply a random 3-opt move to further explore the neighborhood\n        if n >= 4:\n            a, b, c = np.random.choice(n, 3, replace=False)\n            a, b, c = sorted([a, b, c])\n            # Perform the 3-opt move\n            new_solution[b:c+1] = new_solution[b:c+1][::-1]\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 204,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate the crowding distance for each solution (simplified for multi-objective)\n    crowding_distances = np.zeros(len(archive_objectives))\n    for i in range(3):  # For each objective\n        sorted_indices = np.argsort([obj[i] for obj in archive_objectives])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(sorted_indices)-1):\n            crowding_distances[sorted_indices[j]] += (archive_objectives[sorted_indices[j+1]][i] -\n                                                    archive_objectives[sorted_indices[j-1]][i])\n\n    # Select a solution with moderate crowding distance (not too crowded)\n    selected_idx = np.argmin(np.abs(crowding_distances - np.median(crowding_distances)))\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment and reverse it (2-opt)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly swap two non-adjacent edges (3-opt)\n    if n >= 4:\n        i, j, k = sorted(np.random.choice(range(1, n-1), 3, replace=False))\n        # Perform a 3-opt move (simplified)\n        new_solution[i:j] = new_solution[j-1:i-1:-1]\n        new_solution[j:k] = new_solution[k-1:j-1:-1]\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        return base_solution  # Fallback to original if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.6985135458342949,
            2.5052210211753847
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate the crowding distance for each solution (simplified for multi-objective)\n    crowding_distances = np.zeros(len(archive_objectives))\n    for i in range(3):  # For each objective\n        sorted_indices = np.argsort([obj[i] for obj in archive_objectives])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(sorted_indices)-1):\n            crowding_distances[sorted_indices[j]] += (archive_objectives[sorted_indices[j+1]][i] -\n                                                    archive_objectives[sorted_indices[j-1]][i])\n\n    # Select a solution with moderate crowding distance (not too crowded)\n    selected_idx = np.argmin(np.abs(crowding_distances - np.median(crowding_distances)))\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment and reverse it (2-opt)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly swap two non-adjacent edges (3-opt)\n    if n >= 4:\n        i, j, k = sorted(np.random.choice(range(1, n-1), 3, replace=False))\n        # Perform a 3-opt move (simplified)\n        new_solution[i:j] = new_solution[j-1:i-1:-1]\n        new_solution[j:k] = new_solution[k-1:j-1:-1]\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        return base_solution  # Fallback to original if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 205,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best average objective value for diversity\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj) / 3 for obj in objectives]\n    selected_index = np.argmin(avg_objectives)\n    base_solution = archive[selected_index][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n\n    # Perform a 2-opt move (reverses a segment of the tour)\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware swap: swap nodes that are distant in at least one objective space\n    for _ in range(3):  # Try multiple swaps\n        k, l = sorted(np.random.choice(range(n), size=2, replace=False))\n        node_k, node_l = new_solution[k], new_solution[l]\n\n        # Check if swap improves at least one objective\n        current_cost = (distance_matrix_1[node_k, new_solution[(k-1)%n]] + distance_matrix_1[new_solution[(k+1)%n], node_l] +\n                        distance_matrix_2[node_k, new_solution[(k-1)%n]] + distance_matrix_2[new_solution[(k+1)%n], node_l] +\n                        distance_matrix_3[node_k, new_solution[(k-1)%n]] + distance_matrix_3[new_solution[(k+1)%n], node_l])\n\n        new_cost = (distance_matrix_1[node_l, new_solution[(k-1)%n]] + distance_matrix_1[new_solution[(k+1)%n], node_k] +\n                    distance_matrix_2[node_l, new_solution[(k-1)%n]] + distance_matrix_2[new_solution[(k+1)%n], node_k] +\n                    distance_matrix_3[node_l, new_solution[(k-1)%n]] + distance_matrix_3[new_solution[(k+1)%n], node_k])\n\n        if new_cost < current_cost:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7079420660357081,
            1.4854304552078248
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best average objective value for diversity\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj) / 3 for obj in objectives]\n    selected_index = np.argmin(avg_objectives)\n    base_solution = archive[selected_index][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n\n    # Perform a 2-opt move (reverses a segment of the tour)\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware swap: swap nodes that are distant in at least one objective space\n    for _ in range(3):  # Try multiple swaps\n        k, l = sorted(np.random.choice(range(n), size=2, replace=False))\n        node_k, node_l = new_solution[k], new_solution[l]\n\n        # Check if swap improves at least one objective\n        current_cost = (distance_matrix_1[node_k, new_solution[(k-1)%n]] + distance_matrix_1[new_solution[(k+1)%n], node_l] +\n                        distance_matrix_2[node_k, new_solution[(k-1)%n]] + distance_matrix_2[new_solution[(k+1)%n], node_l] +\n                        distance_matrix_3[node_k, new_solution[(k-1)%n]] + distance_matrix_3[new_solution[(k+1)%n], node_l])\n\n        new_cost = (distance_matrix_1[node_l, new_solution[(k-1)%n]] + distance_matrix_1[new_solution[(k+1)%n], node_k] +\n                    distance_matrix_2[node_l, new_solution[(k-1)%n]] + distance_matrix_2[new_solution[(k+1)%n], node_k] +\n                    distance_matrix_3[node_l, new_solution[(k-1)%n]] + distance_matrix_3[new_solution[(k+1)%n], node_k])\n\n        if new_cost < current_cost:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 206,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already locally optimal)\n    # Here we select the solution with the highest sum of objectives (worst solution)\n    # Alternatively, you could use other criteria like diversity or entropy\n    objectives = np.array([obj for _, obj in archive])\n    worst_idx = np.argmax(np.sum(objectives, axis=1))\n    base_solution = archive[worst_idx][0].copy()\n\n    # Hybrid local search operator: combination of 2-opt and edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n\n    # Apply 2-opt on the selected segment\n    if b - a > 1:\n        # Reverse the segment\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply edge insertion for further improvement\n    # Select a random node and insert it in a different position\n    if n > 2:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.671729436305905,
            1.7423197269439696
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already locally optimal)\n    # Here we select the solution with the highest sum of objectives (worst solution)\n    # Alternatively, you could use other criteria like diversity or entropy\n    objectives = np.array([obj for _, obj in archive])\n    worst_idx = np.argmax(np.sum(objectives, axis=1))\n    base_solution = archive[worst_idx][0].copy()\n\n    # Hybrid local search operator: combination of 2-opt and edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n\n    # Apply 2-opt on the selected segment\n    if b - a > 1:\n        # Reverse the segment\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply edge insertion for further improvement\n    # Select a random node and insert it in a different position\n    if n > 2:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 207,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    archive.sort(key=lambda x: sum(x[1]))  # Sort by sum of objectives (can be replaced with more sophisticated criteria)\n    selected_idx = min(2, len(archive) - 1)  # Select from top 3 candidates\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt with a bias towards edges that improve at least one objective\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == j:\n            continue\n\n        # Evaluate original and reversed segment in all three objectives\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        reversed_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        reversed_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        original_cost3 = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        reversed_cost3 = distance_matrix_3[new_solution[i-1], new_solution[j-1]] + distance_matrix_3[new_solution[i], new_solution[j]]\n\n        # Count how many objectives would improve\n        improvements = sum([reversed_cost1 < original_cost1, reversed_cost2 < original_cost2, reversed_cost3 < original_cost3])\n\n        # Accept the move if it improves at least one objective or with some probability\n        if improvements > 0 or np.random.random() < 0.2:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7105697527178579,
            2.0224873065948485
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    archive.sort(key=lambda x: sum(x[1]))  # Sort by sum of objectives (can be replaced with more sophisticated criteria)\n    selected_idx = min(2, len(archive) - 1)  # Select from top 3 candidates\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt with a bias towards edges that improve at least one objective\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == j:\n            continue\n\n        # Evaluate original and reversed segment in all three objectives\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        reversed_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        reversed_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        original_cost3 = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        reversed_cost3 = distance_matrix_3[new_solution[i-1], new_solution[j-1]] + distance_matrix_3[new_solution[i], new_solution[j]]\n\n        # Count how many objectives would improve\n        improvements = sum([reversed_cost1 < original_cost1, reversed_cost2 < original_cost2, reversed_cost3 < original_cost3])\n\n        # Accept the move if it improves at least one objective or with some probability\n        if improvements > 0 or np.random.random() < 0.2:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 208,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (higher sum = more potential for improvement)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Randomly select among top 30% solutions\n        top_percent = max(1, int(0.3 * len(archive_sorted)))\n        selected_idx = random.randint(0, top_percent - 1)\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel multi-objective operator\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, apply a novel multi-objective operator inspired by Pareto dominance\n    # This operator tries to improve one objective while minimally affecting the others\n    for _ in range(2):  # Repeat a few times\n        # Randomly select two edges to modify\n        a, b, c = sorted(random.sample(range(n), 3))\n\n        # Calculate current and potential costs for all three objectives\n        current_cost1 = distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[c], new_solution[(a+1)%n]]\n        potential_cost1 = distance_matrix_1[new_solution[a], new_solution[c]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]]\n\n        current_cost2 = distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[c], new_solution[(a+1)%n]]\n        potential_cost2 = distance_matrix_2[new_solution[a], new_solution[c]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]]\n\n        current_cost3 = distance_matrix_3[new_solution[a], new_solution[b]] + distance_matrix_3[new_solution[c], new_solution[(a+1)%n]]\n        potential_cost3 = distance_matrix_3[new_solution[a], new_solution[c]] + distance_matrix_3[new_solution[b], new_solution[(a+1)%n]]\n\n        # Check if the move improves at least one objective while not worsening others by more than a threshold\n        if ((potential_cost1 < current_cost1 and (potential_cost2 <= current_cost2 * 1.05) and (potential_cost3 <= current_cost3 * 1.05)) or\n            (potential_cost2 < current_cost2 and (potential_cost1 <= current_cost1 * 1.05) and (potential_cost3 <= current_cost3 * 1.05)) or\n            (potential_cost3 < current_cost3 and (potential_cost1 <= current_cost1 * 1.05) and (potential_cost2 <= current_cost2 * 1.05))):\n            # Perform the move\n            new_solution[a+1:b+1] = new_solution[a+1:b+1][::-1]\n            new_solution[b+1:c+1] = new_solution[b+1:c+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.574998220798915,
            1.4995527625083924
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (higher sum = more potential for improvement)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Randomly select among top 30% solutions\n        top_percent = max(1, int(0.3 * len(archive_sorted)))\n        selected_idx = random.randint(0, top_percent - 1)\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel multi-objective operator\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, apply a novel multi-objective operator inspired by Pareto dominance\n    # This operator tries to improve one objective while minimally affecting the others\n    for _ in range(2):  # Repeat a few times\n        # Randomly select two edges to modify\n        a, b, c = sorted(random.sample(range(n), 3))\n\n        # Calculate current and potential costs for all three objectives\n        current_cost1 = distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[c], new_solution[(a+1)%n]]\n        potential_cost1 = distance_matrix_1[new_solution[a], new_solution[c]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]]\n\n        current_cost2 = distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[c], new_solution[(a+1)%n]]\n        potential_cost2 = distance_matrix_2[new_solution[a], new_solution[c]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]]\n\n        current_cost3 = distance_matrix_3[new_solution[a], new_solution[b]] + distance_matrix_3[new_solution[c], new_solution[(a+1)%n]]\n        potential_cost3 = distance_matrix_3[new_solution[a], new_solution[c]] + distance_matrix_3[new_solution[b], new_solution[(a+1)%n]]\n\n        # Check if the move improves at least one objective while not worsening others by more than a threshold\n        if ((potential_cost1 < current_cost1 and (potential_cost2 <= current_cost2 * 1.05) and (potential_cost3 <= current_cost3 * 1.05)) or\n            (potential_cost2 < current_cost2 and (potential_cost1 <= current_cost1 * 1.05) and (potential_cost3 <= current_cost3 * 1.05)) or\n            (potential_cost3 < current_cost3 and (potential_cost1 <= current_cost1 * 1.05) and (potential_cost2 <= current_cost2 * 1.05))):\n            # Perform the move\n            new_solution[a+1:b+1] = new_solution[a+1:b+1][::-1]\n            new_solution[b+1:c+1] = new_solution[b+1:c+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 209,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: choose a solution with the best trade-off across objectives\n    # Here, we select a solution that has at least one objective better than the median\n    objectives = np.array([obj for _, obj in archive])\n    median_objectives = np.median(objectives, axis=0)\n\n    candidates = []\n    for sol, obj in archive:\n        if any(o < m for o, m in zip(obj, median_objectives)):\n            candidates.append(sol)\n\n    if not candidates:\n        # If no such solution exists, select a random one\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware swap to improve multiple objectives\n    # Select two nodes that are adjacent in the tour but have high distance in at least one objective\n    for _ in range(10):  # Try multiple times to find a good swap\n        a, b = random.sample(range(n), 2)\n        a, b = min(a, b), max(a, b)\n\n        # Calculate current distances in all three objectives\n        current_dist1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n        current_dist2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n        current_dist3 = distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]]\n\n        # Calculate potential new distances after swap\n        new_dist1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]]\n        new_dist2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]]\n        new_dist3 = distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[a], new_solution[(b+1)%n]]\n\n        # Count how many objectives would be improved\n        improvements = sum(1 for curr, new in [(current_dist1, new_dist1), (current_dist2, new_dist2), (current_dist3, new_dist3)] if new < curr)\n\n        # If at least two objectives would be improved, accept the swap\n        if improvements >= 2:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n            break\n\n    # Ensure the solution remains feasible (no duplicates, all nodes included)\n    assert len(new_solution) == len(base_solution)\n    assert len(set(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.8149477328753795,
            2.011430335044861
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: choose a solution with the best trade-off across objectives\n    # Here, we select a solution that has at least one objective better than the median\n    objectives = np.array([obj for _, obj in archive])\n    median_objectives = np.median(objectives, axis=0)\n\n    candidates = []\n    for sol, obj in archive:\n        if any(o < m for o, m in zip(obj, median_objectives)):\n            candidates.append(sol)\n\n    if not candidates:\n        # If no such solution exists, select a random one\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware swap to improve multiple objectives\n    # Select two nodes that are adjacent in the tour but have high distance in at least one objective\n    for _ in range(10):  # Try multiple times to find a good swap\n        a, b = random.sample(range(n), 2)\n        a, b = min(a, b), max(a, b)\n\n        # Calculate current distances in all three objectives\n        current_dist1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n        current_dist2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n        current_dist3 = distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]]\n\n        # Calculate potential new distances after swap\n        new_dist1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]]\n        new_dist2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]]\n        new_dist3 = distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[a], new_solution[(b+1)%n]]\n\n        # Count how many objectives would be improved\n        improvements = sum(1 for curr, new in [(current_dist1, new_dist1), (current_dist2, new_dist2), (current_dist3, new_dist3)] if new < curr)\n\n        # If at least two objectives would be improved, accept the swap\n        if improvements >= 2:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n            break\n\n    # Ensure the solution remains feasible (no duplicates, all nodes included)\n    assert len(new_solution) == len(base_solution)\n    assert len(set(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 210,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with high diversity or low crowding distance)\n    # Here, we select the solution with the highest sum of objectives (worst solution in the archive)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy:\n    # 1. Apply a 2-opt move (for one objective)\n    # 2. Apply a node insertion (for another objective)\n    # 3. Apply a 3-opt move (for the third objective)\n    new_solution = base_solution.copy()\n\n    # 1. 2-opt move on the first objective\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # 2. Node insertion on the second objective\n    if n > 3:\n        k = np.random.randint(1, n-1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = np.random.randint(1, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # 3. 3-opt move on the third objective\n    if n > 5:\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution[a:c] = np.concatenate([segment2, segment1])\n\n    return new_solution\n\n",
        "score": [
            -0.5346336563051587,
            1.7696284532546998
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with high diversity or low crowding distance)\n    # Here, we select the solution with the highest sum of objectives (worst solution in the archive)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy:\n    # 1. Apply a 2-opt move (for one objective)\n    # 2. Apply a node insertion (for another objective)\n    # 3. Apply a 3-opt move (for the third objective)\n    new_solution = base_solution.copy()\n\n    # 1. 2-opt move on the first objective\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # 2. Node insertion on the second objective\n    if n > 3:\n        k = np.random.randint(1, n-1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = np.random.randint(1, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # 3. 3-opt move on the third objective\n    if n > 5:\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution[a:c] = np.concatenate([segment2, segment1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 211,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective values)\n    weights = [1 / (1 + obj[0] + obj[1] + obj[2]) for (sol, obj) in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on the most improving objective\n    obj_values = archive[selected_idx][1]\n    best_obj_idx = np.argmin(obj_values)\n\n    if best_obj_idx == 0:\n        dist_matrix = distance_matrix_1\n    elif best_obj_idx == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the best 2-opt move for the selected objective\n    best_delta = 0\n    best_i, best_j = -1, -1\n\n    for i in range(n - 1):\n        for j in range(i + 2, n):\n            a, b = new_solution[i], new_solution[i+1]\n            c, d = new_solution[j], new_solution[(j+1)%n]\n\n            delta = (dist_matrix[b, c] + dist_matrix[a, d]) - (dist_matrix[a, b] + dist_matrix[c, d])\n            if delta < best_delta:\n                best_delta = delta\n                best_i, best_j = i, j\n\n    if best_i != -1:\n        # Apply the best 2-opt move\n        new_solution[best_i+1:best_j+1] = np.flip(new_solution[best_i+1:best_j+1])\n\n    # Perform objective-aware swaps to improve other objectives\n    for _ in range(2):  # Limit the number of swaps for efficiency\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n\n        # Evaluate the swap for all objectives\n        a, b = new_solution[i], new_solution[(i+1)%n]\n        c, d = new_solution[j], new_solution[(j+1)%n]\n\n        delta1 = (distance_matrix_1[b, d] + distance_matrix_1[a, c]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n        delta2 = (distance_matrix_2[b, d] + distance_matrix_2[a, c]) - (distance_matrix_2[a, b] + distance_matrix_2[c, d])\n        delta3 = (distance_matrix_3[b, d] + distance_matrix_3[a, c]) - (distance_matrix_3[a, b] + distance_matrix_3[c, d])\n\n        # Accept if it improves at least one objective\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7516832226712633,
            2.8607845664024354
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective values)\n    weights = [1 / (1 + obj[0] + obj[1] + obj[2]) for (sol, obj) in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on the most improving objective\n    obj_values = archive[selected_idx][1]\n    best_obj_idx = np.argmin(obj_values)\n\n    if best_obj_idx == 0:\n        dist_matrix = distance_matrix_1\n    elif best_obj_idx == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the best 2-opt move for the selected objective\n    best_delta = 0\n    best_i, best_j = -1, -1\n\n    for i in range(n - 1):\n        for j in range(i + 2, n):\n            a, b = new_solution[i], new_solution[i+1]\n            c, d = new_solution[j], new_solution[(j+1)%n]\n\n            delta = (dist_matrix[b, c] + dist_matrix[a, d]) - (dist_matrix[a, b] + dist_matrix[c, d])\n            if delta < best_delta:\n                best_delta = delta\n                best_i, best_j = i, j\n\n    if best_i != -1:\n        # Apply the best 2-opt move\n        new_solution[best_i+1:best_j+1] = np.flip(new_solution[best_i+1:best_j+1])\n\n    # Perform objective-aware swaps to improve other objectives\n    for _ in range(2):  # Limit the number of swaps for efficiency\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n\n        # Evaluate the swap for all objectives\n        a, b = new_solution[i], new_solution[(i+1)%n]\n        c, d = new_solution[j], new_solution[(j+1)%n]\n\n        delta1 = (distance_matrix_1[b, d] + distance_matrix_1[a, c]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n        delta2 = (distance_matrix_2[b, d] + distance_matrix_2[a, c]) - (distance_matrix_2[a, b] + distance_matrix_2[c, d])\n        delta3 = (distance_matrix_3[b, d] + distance_matrix_3[a, c]) - (distance_matrix_3[a, b] + distance_matrix_3[c, d])\n\n        # Accept if it improves at least one objective\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 212,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a random solution from the archive with higher probability for solutions with higher potential\n    # Potential is defined as the sum of the inverse of the objectives (lower is better)\n    objectives = np.array([obj for (sol, obj) in archive])\n    potential = 1.0 / (objectives + 1e-10)  # Avoid division by zero\n    potential = potential.sum(axis=1)\n    probabilities = potential / potential.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with a multi-objective aware swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # First, perform a standard 2-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform a multi-objective aware swap to further improve the solution\n    # Select two nodes that are close in at least one objective space but far in others\n    for _ in range(10):  # Try a few times to find a beneficial swap\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        node_k, node_l = new_solution[k], new_solution[l]\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[node_k, new_solution[k-1]] + distance_matrix_1[new_solution[(k+1)%n], node_l] +\n                  distance_matrix_1[node_l, new_solution[l-1]] + distance_matrix_1[new_solution[(l+1)%n], node_k] -\n                  distance_matrix_1[new_solution[k-1], node_k] - distance_matrix_1[node_k, new_solution[(k+1)%n]] -\n                  distance_matrix_1[new_solution[l-1], node_l] - distance_matrix_1[node_l, new_solution[(l+1)%n]])\n\n        delta2 = (distance_matrix_2[node_k, new_solution[k-1]] + distance_matrix_2[new_solution[(k+1)%n], node_l] +\n                  distance_matrix_2[node_l, new_solution[l-1]] + distance_matrix_2[new_solution[(l+1)%n], node_k] -\n                  distance_matrix_2[new_solution[k-1], node_k] - distance_matrix_2[node_k, new_solution[(k+1)%n]] -\n                  distance_matrix_2[new_solution[l-1], node_l] - distance_matrix_2[node_l, new_solution[(l+1)%n]])\n\n        delta3 = (distance_matrix_3[node_k, new_solution[k-1]] + distance_matrix_3[new_solution[(k+1)%n], node_l] +\n                  distance_matrix_3[node_l, new_solution[l-1]] + distance_matrix_3[new_solution[(l+1)%n], node_k] -\n                  distance_matrix_3[new_solution[k-1], node_k] - distance_matrix_3[node_k, new_solution[(k+1)%n]] -\n                  distance_matrix_3[new_solution[l-1], node_l] - distance_matrix_3[node_l, new_solution[(l+1)%n]])\n\n        # Accept the swap if it improves at least one objective\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7987976538057373,
            1.8938696265220643
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a random solution from the archive with higher probability for solutions with higher potential\n    # Potential is defined as the sum of the inverse of the objectives (lower is better)\n    objectives = np.array([obj for (sol, obj) in archive])\n    potential = 1.0 / (objectives + 1e-10)  # Avoid division by zero\n    potential = potential.sum(axis=1)\n    probabilities = potential / potential.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with a multi-objective aware swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # First, perform a standard 2-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform a multi-objective aware swap to further improve the solution\n    # Select two nodes that are close in at least one objective space but far in others\n    for _ in range(10):  # Try a few times to find a beneficial swap\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        node_k, node_l = new_solution[k], new_solution[l]\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[node_k, new_solution[k-1]] + distance_matrix_1[new_solution[(k+1)%n], node_l] +\n                  distance_matrix_1[node_l, new_solution[l-1]] + distance_matrix_1[new_solution[(l+1)%n], node_k] -\n                  distance_matrix_1[new_solution[k-1], node_k] - distance_matrix_1[node_k, new_solution[(k+1)%n]] -\n                  distance_matrix_1[new_solution[l-1], node_l] - distance_matrix_1[node_l, new_solution[(l+1)%n]])\n\n        delta2 = (distance_matrix_2[node_k, new_solution[k-1]] + distance_matrix_2[new_solution[(k+1)%n], node_l] +\n                  distance_matrix_2[node_l, new_solution[l-1]] + distance_matrix_2[new_solution[(l+1)%n], node_k] -\n                  distance_matrix_2[new_solution[k-1], node_k] - distance_matrix_2[node_k, new_solution[(k+1)%n]] -\n                  distance_matrix_2[new_solution[l-1], node_l] - distance_matrix_2[node_l, new_solution[(l+1)%n]])\n\n        delta3 = (distance_matrix_3[node_k, new_solution[k-1]] + distance_matrix_3[new_solution[(k+1)%n], node_l] +\n                  distance_matrix_3[node_l, new_solution[l-1]] + distance_matrix_3[new_solution[(l+1)%n], node_k] -\n                  distance_matrix_3[new_solution[k-1], node_k] - distance_matrix_3[node_k, new_solution[(k+1)%n]] -\n                  distance_matrix_3[new_solution[l-1], node_l] - distance_matrix_3[node_l, new_solution[(l+1)%n]])\n\n        # Accept the swap if it improves at least one objective\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 213,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt and 3-opt with objective-aware selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Objective-aware edge selection: prioritize edges with high potential for improvement\n    def edge_score(i, j):\n        # Calculate the improvement potential in all three objectives\n        current_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                    distance_matrix_2[new_solution[i], new_solution[j]] +\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n        return current_cost - new_cost\n\n    # Perform a combination of 2-opt and 3-opt moves\n    for _ in range(5):  # Number of iterations can be adjusted\n        # Select two random edges with high potential\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) < 2 or (i == j):\n            j = np.random.randint(0, n)\n\n        # Ensure we have valid indices\n        i, j = min(i, j), max(i, j)\n\n        # Apply 2-opt if it improves the solution\n        if edge_score(i, j) > 0:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n        # Apply 3-opt with objective-aware selection\n        k = np.random.randint(0, n)\n        while k in [i, j, (i+1)%n, (j+1)%n]:\n            k = np.random.randint(0, n)\n\n        # Calculate the potential improvement for 3-opt\n        def three_opt_score(a, b, c):\n            current = (distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                      distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                      distance_matrix_3[new_solution[a], new_solution[(a+1)%n]])\n            new1 = (distance_matrix_1[new_solution[a], new_solution[b]] +\n                   distance_matrix_2[new_solution[a], new_solution[b]] +\n                   distance_matrix_3[new_solution[a], new_solution[b]])\n            new2 = (distance_matrix_1[new_solution[b], new_solution[c]] +\n                   distance_matrix_2[new_solution[b], new_solution[c]] +\n                   distance_matrix_3[new_solution[b], new_solution[c]])\n            new3 = (distance_matrix_1[new_solution[c], new_solution[(a+1)%n]] +\n                   distance_matrix_2[new_solution[c], new_solution[(a+1)%n]] +\n                   distance_matrix_3[new_solution[c], new_solution[(a+1)%n]])\n            return current - (new1 + new2 + new3)\n\n        if three_opt_score(i, j, k) > 0:\n            # Apply the 3-opt move\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n            new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6615933883489292,
            1.832748246192932
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt and 3-opt with objective-aware selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Objective-aware edge selection: prioritize edges with high potential for improvement\n    def edge_score(i, j):\n        # Calculate the improvement potential in all three objectives\n        current_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                    distance_matrix_2[new_solution[i], new_solution[j]] +\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n        return current_cost - new_cost\n\n    # Perform a combination of 2-opt and 3-opt moves\n    for _ in range(5):  # Number of iterations can be adjusted\n        # Select two random edges with high potential\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) < 2 or (i == j):\n            j = np.random.randint(0, n)\n\n        # Ensure we have valid indices\n        i, j = min(i, j), max(i, j)\n\n        # Apply 2-opt if it improves the solution\n        if edge_score(i, j) > 0:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n        # Apply 3-opt with objective-aware selection\n        k = np.random.randint(0, n)\n        while k in [i, j, (i+1)%n, (j+1)%n]:\n            k = np.random.randint(0, n)\n\n        # Calculate the potential improvement for 3-opt\n        def three_opt_score(a, b, c):\n            current = (distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                      distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                      distance_matrix_3[new_solution[a], new_solution[(a+1)%n]])\n            new1 = (distance_matrix_1[new_solution[a], new_solution[b]] +\n                   distance_matrix_2[new_solution[a], new_solution[b]] +\n                   distance_matrix_3[new_solution[a], new_solution[b]])\n            new2 = (distance_matrix_1[new_solution[b], new_solution[c]] +\n                   distance_matrix_2[new_solution[b], new_solution[c]] +\n                   distance_matrix_3[new_solution[b], new_solution[c]])\n            new3 = (distance_matrix_1[new_solution[c], new_solution[(a+1)%n]] +\n                   distance_matrix_2[new_solution[c], new_solution[(a+1)%n]] +\n                   distance_matrix_3[new_solution[c], new_solution[(a+1)%n]])\n            return current - (new1 + new2 + new3)\n\n        if three_opt_score(i, j, k) > 0:\n            # Apply the 3-opt move\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n            new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 214,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too diverse)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Perform 2-opt swap\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Objective-aware swap: if the swap improves at least one objective\n        if (distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]] >\n            distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[k], new_solution[l-1]]) or \\\n           (distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]] >\n            distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[k], new_solution[l-1]]) or \\\n           (distance_matrix_3[new_solution[k-1], new_solution[k]] + distance_matrix_3[new_solution[l-1], new_solution[l]] >\n            distance_matrix_3[new_solution[k-1], new_solution[l]] + distance_matrix_3[new_solution[k], new_solution[l-1]]):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7673840497422805,
            2.4570792078971864
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too diverse)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Perform 2-opt swap\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Objective-aware swap: if the swap improves at least one objective\n        if (distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]] >\n            distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[k], new_solution[l-1]]) or \\\n           (distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]] >\n            distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[k], new_solution[l-1]]) or \\\n           (distance_matrix_3[new_solution[k-1], new_solution[k]] + distance_matrix_3[new_solution[l-1], new_solution[l]] >\n            distance_matrix_3[new_solution[k-1], new_solution[l]] + distance_matrix_3[new_solution[k], new_solution[l-1]]):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 215,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective values)\n    weights = np.array([sum(obj) for _, obj in archive])\n    if np.sum(weights) == 0:\n        weights = np.ones(len(archive))\n    selected_idx = np.random.choice(len(archive), p=weights/np.sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware swap based on the most critical objective\n    obj = archive[selected_idx][1]\n    critical_obj = np.argmax(obj)  # Identify the most critical objective\n\n    # Choose a pair of nodes to swap based on the critical objective\n    if critical_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif critical_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the worst edge in the current solution for the critical objective\n    worst_edge = -1\n    max_dist = -1\n    for k in range(n):\n        u, v = new_solution[k], new_solution[(k+1)%n]\n        if dist_matrix[u, v] > max_dist:\n            max_dist = dist_matrix[u, v]\n            worst_edge = k\n\n    # Perform a swap to improve the worst edge\n    if worst_edge != -1:\n        u, v = new_solution[worst_edge], new_solution[(worst_edge+1)%n]\n        # Find the best possible replacement for this edge\n        best_replacement = -1\n        min_dist = float('inf')\n        for k in range(n):\n            if k == worst_edge or k == (worst_edge+1)%n:\n                continue\n            w = new_solution[k]\n            if dist_matrix[u, w] + dist_matrix[w, v] < min_dist:\n                min_dist = dist_matrix[u, w] + dist_matrix[w, v]\n                best_replacement = k\n\n        if best_replacement != -1:\n            # Perform the swap\n            if worst_edge < best_replacement:\n                new_solution[worst_edge+1:best_replacement+1] = new_solution[worst_edge+1:best_replacement+1][::-1]\n            else:\n                new_solution[best_replacement:worst_edge+1] = new_solution[best_replacement:worst_edge+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7538083982242163,
            1.926514446735382
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective values)\n    weights = np.array([sum(obj) for _, obj in archive])\n    if np.sum(weights) == 0:\n        weights = np.ones(len(archive))\n    selected_idx = np.random.choice(len(archive), p=weights/np.sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware swap based on the most critical objective\n    obj = archive[selected_idx][1]\n    critical_obj = np.argmax(obj)  # Identify the most critical objective\n\n    # Choose a pair of nodes to swap based on the critical objective\n    if critical_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif critical_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the worst edge in the current solution for the critical objective\n    worst_edge = -1\n    max_dist = -1\n    for k in range(n):\n        u, v = new_solution[k], new_solution[(k+1)%n]\n        if dist_matrix[u, v] > max_dist:\n            max_dist = dist_matrix[u, v]\n            worst_edge = k\n\n    # Perform a swap to improve the worst edge\n    if worst_edge != -1:\n        u, v = new_solution[worst_edge], new_solution[(worst_edge+1)%n]\n        # Find the best possible replacement for this edge\n        best_replacement = -1\n        min_dist = float('inf')\n        for k in range(n):\n            if k == worst_edge or k == (worst_edge+1)%n:\n                continue\n            w = new_solution[k]\n            if dist_matrix[u, w] + dist_matrix[w, v] < min_dist:\n                min_dist = dist_matrix[u, w] + dist_matrix[w, v]\n                best_replacement = k\n\n        if best_replacement != -1:\n            # Perform the swap\n            if worst_edge < best_replacement:\n                new_solution[worst_edge+1:best_replacement+1] = new_solution[worst_edge+1:best_replacement+1][::-1]\n            else:\n                new_solution[best_replacement:worst_edge+1] = new_solution[best_replacement:worst_edge+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 216,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate objective differences to identify promising solutions\n    objectives = np.array([obj for _, obj in archive])\n    obj_diffs = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    promising_indices = np.where(obj_diffs > np.median(obj_diffs))[0]\n\n    if len(promising_indices) == 0:\n        promising_indices = np.arange(len(archive))\n\n    selected_idx = np.random.choice(promising_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply hybrid local search: combination of 2-opt and node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose a local search operator\n    operator = np.random.choice(['2opt', 'insertion'])\n\n    if operator == '2opt':\n        # Perform 2-opt with the objective that has the highest variance\n        obj_variance = np.var(objectives, axis=0)\n        selected_obj = np.argmax(obj_variance)\n\n        if selected_obj == 0:\n            dist_matrix = distance_matrix_1\n        elif selected_obj == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Ensure feasibility\n        if not np.all(np.unique(new_solution) == np.arange(n)):\n            new_solution = base_solution.copy()\n\n    else:  # insertion\n        # Perform node insertion with the objective that has the lowest variance (more stable)\n        obj_variance = np.var(objectives, axis=0)\n        selected_obj = np.argmin(obj_variance)\n\n        if selected_obj == 0:\n            dist_matrix = distance_matrix_1\n        elif selected_obj == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Randomly select a node to remove and reinsert\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n\n        # Remove the node\n        new_solution = np.delete(new_solution, node_idx)\n\n        # Find the best insertion position\n        best_pos = 0\n        best_cost = float('inf')\n\n        for pos in range(n - 1):\n            # Calculate cost of inserting node between pos and pos+1\n            cost = (dist_matrix[new_solution[pos], node] +\n                    dist_matrix[node, new_solution[(pos + 1) % (n - 1)]] -\n                    dist_matrix[new_solution[pos], new_solution[(pos + 1) % (n - 1)]])\n\n            if cost < best_cost:\n                best_cost = cost\n                best_pos = pos\n\n        # Insert the node at the best position\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6170505693709751,
            1.6436824440956115
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate objective differences to identify promising solutions\n    objectives = np.array([obj for _, obj in archive])\n    obj_diffs = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    promising_indices = np.where(obj_diffs > np.median(obj_diffs))[0]\n\n    if len(promising_indices) == 0:\n        promising_indices = np.arange(len(archive))\n\n    selected_idx = np.random.choice(promising_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply hybrid local search: combination of 2-opt and node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose a local search operator\n    operator = np.random.choice(['2opt', 'insertion'])\n\n    if operator == '2opt':\n        # Perform 2-opt with the objective that has the highest variance\n        obj_variance = np.var(objectives, axis=0)\n        selected_obj = np.argmax(obj_variance)\n\n        if selected_obj == 0:\n            dist_matrix = distance_matrix_1\n        elif selected_obj == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Ensure feasibility\n        if not np.all(np.unique(new_solution) == np.arange(n)):\n            new_solution = base_solution.copy()\n\n    else:  # insertion\n        # Perform node insertion with the objective that has the lowest variance (more stable)\n        obj_variance = np.var(objectives, axis=0)\n        selected_obj = np.argmin(obj_variance)\n\n        if selected_obj == 0:\n            dist_matrix = distance_matrix_1\n        elif selected_obj == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Randomly select a node to remove and reinsert\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n\n        # Remove the node\n        new_solution = np.delete(new_solution, node_idx)\n\n        # Find the best insertion position\n        best_pos = 0\n        best_cost = float('inf')\n\n        for pos in range(n - 1):\n            # Calculate cost of inserting node between pos and pos+1\n            cost = (dist_matrix[new_solution[pos], node] +\n                    dist_matrix[node, new_solution[(pos + 1) % (n - 1)]] -\n                    dist_matrix[new_solution[pos], new_solution[(pos + 1) % (n - 1)]])\n\n            if cost < best_cost:\n                best_cost = cost\n                best_pos = pos\n\n        # Insert the node at the best position\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 217,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort archive by a combined objective score (sum of normalized objectives)\n        objectives = np.array([obj for _, obj in archive])\n        normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n        combined_scores = normalized_obj.sum(axis=1)\n        # Select solutions with top 30% combined scores\n        top_indices = np.argsort(combined_scores)[-max(1, len(archive)//3):]\n        selected_idx = np.random.choice(top_indices)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator combining 2-opt with objective-aware edge swaps\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # First perform 2-opt to improve the primary objective (sum of all objectives)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform objective-aware edge swaps based on the worst-performing objective\n    objectives = archive[selected_idx][1] if len(archive) > 1 else (0, 0, 0)\n    worst_obj_idx = np.argmax(objectives)\n\n    # Select edges based on the worst objective\n    if worst_obj_idx == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj_idx == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the worst edge in the current solution for the selected objective\n    worst_edge = None\n    max_edge_cost = -1\n    for k in range(n):\n        u, v = new_solution[k], new_solution[(k+1)%n]\n        edge_cost = dist_matrix[u, v]\n        if edge_cost > max_edge_cost:\n            max_edge_cost = edge_cost\n            worst_edge = (k, (k+1)%n)\n\n    if worst_edge is not None:\n        i, j = worst_edge\n        # Try to replace this edge with a shorter one in the distance matrix\n        u, v = new_solution[i], new_solution[j]\n        # Find the best replacement edge\n        best_replacement = None\n        min_replacement_cost = float('inf')\n        for k in range(n):\n            if k == i or k == j or k == (i-1)%n or k == (j+1)%n:\n                continue\n            x = new_solution[k]\n            y = new_solution[(k+1)%n]\n            replacement_cost = dist_matrix[x, y] + dist_matrix[u, x] + dist_matrix[y, v] - dist_matrix[u, v]\n            if replacement_cost < min_replacement_cost:\n                min_replacement_cost = replacement_cost\n                best_replacement = (k, (k+1)%n)\n\n        if best_replacement is not None and min_replacement_cost < 0:\n            k, l = best_replacement\n            # Perform the edge replacement (2-opt variant)\n            if i < j:\n                new_solution[i+1:j+1] = new_solution[j:i:-1]\n            else:\n                new_solution[i+1:] = new_solution[j::-1]\n                new_solution[:j+1] = new_solution[j::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.5285514020243351,
            1.2116109371185302
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort archive by a combined objective score (sum of normalized objectives)\n        objectives = np.array([obj for _, obj in archive])\n        normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n        combined_scores = normalized_obj.sum(axis=1)\n        # Select solutions with top 30% combined scores\n        top_indices = np.argsort(combined_scores)[-max(1, len(archive)//3):]\n        selected_idx = np.random.choice(top_indices)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator combining 2-opt with objective-aware edge swaps\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # First perform 2-opt to improve the primary objective (sum of all objectives)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform objective-aware edge swaps based on the worst-performing objective\n    objectives = archive[selected_idx][1] if len(archive) > 1 else (0, 0, 0)\n    worst_obj_idx = np.argmax(objectives)\n\n    # Select edges based on the worst objective\n    if worst_obj_idx == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj_idx == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the worst edge in the current solution for the selected objective\n    worst_edge = None\n    max_edge_cost = -1\n    for k in range(n):\n        u, v = new_solution[k], new_solution[(k+1)%n]\n        edge_cost = dist_matrix[u, v]\n        if edge_cost > max_edge_cost:\n            max_edge_cost = edge_cost\n            worst_edge = (k, (k+1)%n)\n\n    if worst_edge is not None:\n        i, j = worst_edge\n        # Try to replace this edge with a shorter one in the distance matrix\n        u, v = new_solution[i], new_solution[j]\n        # Find the best replacement edge\n        best_replacement = None\n        min_replacement_cost = float('inf')\n        for k in range(n):\n            if k == i or k == j or k == (i-1)%n or k == (j+1)%n:\n                continue\n            x = new_solution[k]\n            y = new_solution[(k+1)%n]\n            replacement_cost = dist_matrix[x, y] + dist_matrix[u, x] + dist_matrix[y, v] - dist_matrix[u, v]\n            if replacement_cost < min_replacement_cost:\n                min_replacement_cost = replacement_cost\n                best_replacement = (k, (k+1)%n)\n\n        if best_replacement is not None and min_replacement_cost < 0:\n            k, l = best_replacement\n            # Perform the edge replacement (2-opt variant)\n            if i < j:\n                new_solution[i+1:j+1] = new_solution[j:i:-1]\n            else:\n                new_solution[i+1:] = new_solution[j::-1]\n                new_solution[:j+1] = new_solution[j::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 218,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high objective values)\n    # Here we select the solution with the highest sum of objectives\n    selected_index = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_index][0].copy()\n\n    # Apply a hybrid local search operator combining 2-opt and 3-opt moves\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and 3-opt\n    if np.random.rand() < 0.7:  # Higher probability for 2-opt\n        # 2-opt local search\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # 3-opt local search\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        # Apply 3-opt move (cycle reversal between i, j, k)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Ensure the solution is valid (no duplicates and all nodes are visited)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.6205347098167513,
            1.345438826084137
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high objective values)\n    # Here we select the solution with the highest sum of objectives\n    selected_index = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_index][0].copy()\n\n    # Apply a hybrid local search operator combining 2-opt and 3-opt moves\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and 3-opt\n    if np.random.rand() < 0.7:  # Higher probability for 2-opt\n        # 2-opt local search\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # 3-opt local search\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        # Apply 3-opt move (cycle reversal between i, j, k)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Ensure the solution is valid (no duplicates and all nodes are visited)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 219,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    objective_sums = np.sum(objectives, axis=1)\n    sorted_indices = np.argsort(objective_sums)\n    selected_index = random.choice(sorted_indices[:max(1, len(sorted_indices)//4)])\n    base_solution = archive[selected_index][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between 2-opt, 3-opt, or a custom multi-objective operator\n    operator = random.choice(['2-opt', '3-opt', 'multi-objective'])\n\n    if operator == '2-opt':\n        # Standard 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == '3-opt':\n        # Standard 3-opt local search\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    else:  # Multi-objective operator\n        # Custom operator that considers all three objectives\n        # Select two random nodes and swap them if it improves at least one objective\n        i, j = random.sample(range(n), 2)\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        original_cost3 = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        new_cost3 = distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j-1], new_solution[i]]\n\n        # If swap improves at least one objective, perform it\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2) or (new_cost3 < original_cost3):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7404849755617091,
            1.491249966621399
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    objective_sums = np.sum(objectives, axis=1)\n    sorted_indices = np.argsort(objective_sums)\n    selected_index = random.choice(sorted_indices[:max(1, len(sorted_indices)//4)])\n    base_solution = archive[selected_index][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between 2-opt, 3-opt, or a custom multi-objective operator\n    operator = random.choice(['2-opt', '3-opt', 'multi-objective'])\n\n    if operator == '2-opt':\n        # Standard 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == '3-opt':\n        # Standard 3-opt local search\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    else:  # Multi-objective operator\n        # Custom operator that considers all three objectives\n        # Select two random nodes and swap them if it improves at least one objective\n        i, j = random.sample(range(n), 2)\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        original_cost3 = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        new_cost3 = distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j-1], new_solution[i]]\n\n        # If swap improves at least one objective, perform it\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2) or (new_cost3 < original_cost3):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 220,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective diversity)\n    weights = [1 / (1 + obj[0] + obj[1] + obj[2]) for sol, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then perform an objective-aware swap to balance objectives\n    if random.random() < 0.5:  # 50% chance to perform objective-aware swap\n        # Calculate current and potential costs\n        current_costs = [\n            sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n            sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n            sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n        ]\n\n        # Identify the worst objective\n        worst_obj = np.argmax(current_costs)\n\n        # Find the best possible swap to improve the worst objective\n        best_improvement = 0\n        best_swap = None\n\n        # Try swapping nodes that are far in the worst objective space\n        for a in range(n):\n            for b in range(a+1, n):\n                if worst_obj == 0:\n                    delta = (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[a+1]] +\n                            distance_matrix_1[new_solution[b-1], new_solution[a]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]]) - \\\n                           (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[a], new_solution[a+1]] +\n                            distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n                elif worst_obj == 1:\n                    delta = (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[a+1]] +\n                            distance_matrix_2[new_solution[b-1], new_solution[a]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]]) - \\\n                           (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a], new_solution[a+1]] +\n                            distance_matrix_2[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n                else:\n                    delta = (distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b], new_solution[a+1]] +\n                            distance_matrix_3[new_solution[b-1], new_solution[a]] + distance_matrix_3[new_solution[a], new_solution[(b+1)%n]]) - \\\n                           (distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[a], new_solution[a+1]] +\n                            distance_matrix_3[new_solution[b-1], new_solution[b]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n                if delta < best_improvement:\n                    best_improvement = delta\n                    best_swap = (a, b)\n\n        if best_swap is not None:\n            a, b = best_swap\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8169466835880662,
            3.1921799898147585
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective diversity)\n    weights = [1 / (1 + obj[0] + obj[1] + obj[2]) for sol, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then perform an objective-aware swap to balance objectives\n    if random.random() < 0.5:  # 50% chance to perform objective-aware swap\n        # Calculate current and potential costs\n        current_costs = [\n            sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n            sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n            sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n        ]\n\n        # Identify the worst objective\n        worst_obj = np.argmax(current_costs)\n\n        # Find the best possible swap to improve the worst objective\n        best_improvement = 0\n        best_swap = None\n\n        # Try swapping nodes that are far in the worst objective space\n        for a in range(n):\n            for b in range(a+1, n):\n                if worst_obj == 0:\n                    delta = (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[a+1]] +\n                            distance_matrix_1[new_solution[b-1], new_solution[a]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]]) - \\\n                           (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[a], new_solution[a+1]] +\n                            distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n                elif worst_obj == 1:\n                    delta = (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[a+1]] +\n                            distance_matrix_2[new_solution[b-1], new_solution[a]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]]) - \\\n                           (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a], new_solution[a+1]] +\n                            distance_matrix_2[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n                else:\n                    delta = (distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b], new_solution[a+1]] +\n                            distance_matrix_3[new_solution[b-1], new_solution[a]] + distance_matrix_3[new_solution[a], new_solution[(b+1)%n]]) - \\\n                           (distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[a], new_solution[a+1]] +\n                            distance_matrix_3[new_solution[b-1], new_solution[b]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n                if delta < best_improvement:\n                    best_improvement = delta\n                    best_swap = (a, b)\n\n        if best_swap is not None:\n            a, b = best_swap\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 221,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (lowest objective values)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = sorted_archive[0][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform a random 2-opt move (local search component)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap (hybrid component)\n    # Identify nodes with the highest contribution to each objective\n    objectives = archive[0][1]\n    obj_weights = np.array([1/objectives[0], 1/objectives[1], 1/objectives[2]])\n    obj_weights /= obj_weights.sum()\n\n    # Calculate node contributions\n    node_contributions = np.zeros(n)\n    for k in range(n):\n        prev = new_solution[k-1]\n        curr = new_solution[k]\n        next_ = new_solution[(k+1)%n]\n\n        # Contribution to each objective\n        contrib1 = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_]\n        contrib2 = distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_]\n        contrib3 = distance_matrix_3[prev, curr] + distance_matrix_3[curr, next_]\n\n        # Weighted contribution\n        node_contributions[k] = obj_weights[0]*contrib1 + obj_weights[1]*contrib2 + obj_weights[2]*contrib3\n\n    # Find nodes to swap (highest contribution)\n    swap_candidates = np.argsort(node_contributions)[-2:]\n\n    # Perform the swap if it improves the weighted objective\n    if len(swap_candidates) == 2:\n        a, b = swap_candidates[0], swap_candidates[1]\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.6301432039980852,
            2.0085921049118043
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (lowest objective values)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = sorted_archive[0][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform a random 2-opt move (local search component)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap (hybrid component)\n    # Identify nodes with the highest contribution to each objective\n    objectives = archive[0][1]\n    obj_weights = np.array([1/objectives[0], 1/objectives[1], 1/objectives[2]])\n    obj_weights /= obj_weights.sum()\n\n    # Calculate node contributions\n    node_contributions = np.zeros(n)\n    for k in range(n):\n        prev = new_solution[k-1]\n        curr = new_solution[k]\n        next_ = new_solution[(k+1)%n]\n\n        # Contribution to each objective\n        contrib1 = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_]\n        contrib2 = distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_]\n        contrib3 = distance_matrix_3[prev, curr] + distance_matrix_3[curr, next_]\n\n        # Weighted contribution\n        node_contributions[k] = obj_weights[0]*contrib1 + obj_weights[1]*contrib2 + obj_weights[2]*contrib3\n\n    # Find nodes to swap (highest contribution)\n    swap_candidates = np.argsort(node_contributions)[-2:]\n\n    # Perform the swap if it improves the weighted objective\n    if len(swap_candidates) == 2:\n        a, b = swap_candidates[0], swap_candidates[1]\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 222,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Perform 2-opt swap (standard local search)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: identify the worst edge in any objective space\n    worst_edge = -1\n    worst_obj = -1\n    for obj_idx, dist_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        for k in range(n):\n            a, b = base_solution[k], base_solution[(k+1)%n]\n            current_cost = dist_matrix[a, b]\n            new_cost = dist_matrix[base_solution[(k-1)%n], base_solution[k]] + dist_matrix[base_solution[(k+1)%n], base_solution[(k+2)%n]]\n            if new_cost < current_cost and new_cost > worst_obj:\n                worst_obj = new_cost\n                worst_edge = k\n\n    if worst_edge != -1:\n        # Perform a swap that improves the worst objective\n        k = worst_edge\n        new_solution[k], new_solution[(k+1)%n] = new_solution[(k+1)%n], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.8044904981090107,
            1.0908861756324768
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Perform 2-opt swap (standard local search)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: identify the worst edge in any objective space\n    worst_edge = -1\n    worst_obj = -1\n    for obj_idx, dist_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        for k in range(n):\n            a, b = base_solution[k], base_solution[(k+1)%n]\n            current_cost = dist_matrix[a, b]\n            new_cost = dist_matrix[base_solution[(k-1)%n], base_solution[k]] + dist_matrix[base_solution[(k+1)%n], base_solution[(k+2)%n]]\n            if new_cost < current_cost and new_cost > worst_obj:\n                worst_obj = new_cost\n                worst_edge = k\n\n    if worst_edge != -1:\n        # Perform a swap that improves the worst objective\n        k = worst_edge\n        new_solution[k], new_solution[(k+1)%n] = new_solution[(k+1)%n], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 223,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.array([1.0 / (1.0 + obj[0] + obj[1] + obj[2]) for _, obj in archive])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt and edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on the first objective space\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform edge insertion on the second objective space\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k != l:\n        new_solution = np.roll(new_solution, -k)\n        new_solution[1] = new_solution[l]\n        new_solution = np.roll(new_solution, k)\n\n    # Perform 2-opt on the third objective space\n    m, n_ = np.random.choice(n, 2, replace=False)\n    if m > n_:\n        m, n_ = n_, m\n    new_solution[m:n_+1] = new_solution[m:n_+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.674261778257111,
            0.5068677663803101
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.array([1.0 / (1.0 + obj[0] + obj[1] + obj[2]) for _, obj in archive])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt and edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on the first objective space\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform edge insertion on the second objective space\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k != l:\n        new_solution = np.roll(new_solution, -k)\n        new_solution[1] = new_solution[l]\n        new_solution = np.roll(new_solution, k)\n\n    # Perform 2-opt on the third objective space\n    m, n_ = np.random.choice(n, 2, replace=False)\n    if m > n_:\n        m, n_ = n_, m\n    new_solution[m:n_+1] = new_solution[m:n_+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 224,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by the sum of objectives to prioritize solutions with better overall performance\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select from top 50% of solutions to encourage exploration\n        selected_idx = random.randint(0, max(1, len(archive_sorted) // 2 - 1))\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and edge exchange\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Choose between 2-opt or edge exchange based on random selection\n        if random.random() < 0.5:\n            # 2-opt local search\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Edge exchange: select two non-consecutive edges and swap them\n            while True:\n                a, b, c, d = sorted(random.sample(range(n), 4))\n                if b != a + 1 and c != b + 1 and d != c + 1:\n                    break\n            # Create new edges: (a,b) -> (a,d), (b,c) -> (b,c), (c,d) -> (c,d), (d,a) -> (d,a)\n            # Reconstruct the tour\n            part1 = new_solution[:a+1]\n            part2 = new_solution[a+1:b+1]\n            part3 = new_solution[b+1:c+1]\n            part4 = new_solution[c+1:d+1]\n            part5 = new_solution[d+1:]\n\n            # New tour order: part1 -> part4 -> part2 -> part3 -> part5\n            new_solution = np.concatenate([part1, part4, part2, part3, part5])\n\n    # Verify the solution remains valid (no duplicates and all nodes present)\n    assert len(new_solution) == len(set(new_solution)) == len(instance), \"Invalid solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.7271350928470167,
            1.4611714124679565
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by the sum of objectives to prioritize solutions with better overall performance\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select from top 50% of solutions to encourage exploration\n        selected_idx = random.randint(0, max(1, len(archive_sorted) // 2 - 1))\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and edge exchange\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Choose between 2-opt or edge exchange based on random selection\n        if random.random() < 0.5:\n            # 2-opt local search\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Edge exchange: select two non-consecutive edges and swap them\n            while True:\n                a, b, c, d = sorted(random.sample(range(n), 4))\n                if b != a + 1 and c != b + 1 and d != c + 1:\n                    break\n            # Create new edges: (a,b) -> (a,d), (b,c) -> (b,c), (c,d) -> (c,d), (d,a) -> (d,a)\n            # Reconstruct the tour\n            part1 = new_solution[:a+1]\n            part2 = new_solution[a+1:b+1]\n            part3 = new_solution[b+1:c+1]\n            part4 = new_solution[c+1:d+1]\n            part5 = new_solution[d+1:]\n\n            # New tour order: part1 -> part4 -> part2 -> part3 -> part5\n            new_solution = np.concatenate([part1, part4, part2, part3, part5])\n\n    # Verify the solution remains valid (no duplicates and all nodes present)\n    assert len(new_solution) == len(set(new_solution)) == len(instance), \"Invalid solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 225,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with higher objective values)\n    objectives = [obj for _, obj in archive]\n    max_obj = max(objectives, key=lambda x: sum(x))\n    base_solution = archive[objectives.index(max_obj)][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Number of attempts to find an improving move\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Calculate current and new objective values for all three objectives\n        def get_objective(solution):\n            cost1 = sum(distance_matrix_1[solution[k], solution[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[solution[k], solution[(k+1)%n]] for k in range(n))\n            cost3 = sum(distance_matrix_3[solution[k], solution[(k+1)%n]] for k in range(n))\n            return (cost1, cost2, cost3)\n\n        current_obj = get_objective(new_solution)\n        temp_solution = new_solution.copy()\n        temp_solution[i:j+1] = temp_solution[i:j+1][::-1]  # 2-opt swap\n        new_obj = get_objective(temp_solution)\n\n        # Accept if at least one objective improves\n        if any(new_o < current_o for new_o, current_o in zip(new_obj, current_obj)):\n            new_solution = temp_solution\n            break\n\n        # Try objective-aware swaps if 2-opt doesn't help\n        if random.random() < 0.3:  # 30% chance to try objective-aware swap\n            worst_obj = max(range(3), key=lambda k: new_obj[k])\n            # Find the edge with highest contribution to the worst objective\n            worst_edge = max(range(n), key=lambda k: distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] if worst_obj == 0 else\n                            distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] if worst_obj == 1 else\n                            distance_matrix_3[new_solution[k], new_solution[(k+1)%n]])\n            # Swap nodes to potentially improve the worst objective\n            temp_solution = new_solution.copy()\n            temp_solution[worst_edge], temp_solution[(worst_edge+1)%n] = temp_solution[(worst_edge+1)%n], temp_solution[worst_edge]\n            new_obj = get_objective(temp_solution)\n            if any(new_o < current_o for new_o, current_o in zip(new_obj, current_obj)):\n                new_solution = temp_solution\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.617663145763721,
            1.4476324319839478
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with higher objective values)\n    objectives = [obj for _, obj in archive]\n    max_obj = max(objectives, key=lambda x: sum(x))\n    base_solution = archive[objectives.index(max_obj)][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Number of attempts to find an improving move\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Calculate current and new objective values for all three objectives\n        def get_objective(solution):\n            cost1 = sum(distance_matrix_1[solution[k], solution[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[solution[k], solution[(k+1)%n]] for k in range(n))\n            cost3 = sum(distance_matrix_3[solution[k], solution[(k+1)%n]] for k in range(n))\n            return (cost1, cost2, cost3)\n\n        current_obj = get_objective(new_solution)\n        temp_solution = new_solution.copy()\n        temp_solution[i:j+1] = temp_solution[i:j+1][::-1]  # 2-opt swap\n        new_obj = get_objective(temp_solution)\n\n        # Accept if at least one objective improves\n        if any(new_o < current_o for new_o, current_o in zip(new_obj, current_obj)):\n            new_solution = temp_solution\n            break\n\n        # Try objective-aware swaps if 2-opt doesn't help\n        if random.random() < 0.3:  # 30% chance to try objective-aware swap\n            worst_obj = max(range(3), key=lambda k: new_obj[k])\n            # Find the edge with highest contribution to the worst objective\n            worst_edge = max(range(n), key=lambda k: distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] if worst_obj == 0 else\n                            distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] if worst_obj == 1 else\n                            distance_matrix_3[new_solution[k], new_solution[(k+1)%n]])\n            # Swap nodes to potentially improve the worst objective\n            temp_solution = new_solution.copy()\n            temp_solution[worst_edge], temp_solution[(worst_edge+1)%n] = temp_solution[(worst_edge+1)%n], temp_solution[worst_edge]\n            new_obj = get_objective(temp_solution)\n            if any(new_o < current_o for new_o, current_o in zip(new_obj, current_obj)):\n                new_solution = temp_solution\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 226,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Select solutions with the highest diversity (far from the centroid)\n        objectives = np.array([obj for _, obj in archive])\n        centroid = np.mean(objectives, axis=0)\n        distances = np.linalg.norm(objectives - centroid, axis=1)\n        selected_idx = np.argmax(distances)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Hybrid local search operator\n    # Apply a combination of 2-opt and edge insertion for each objective space\n    n = len(new_solution)\n\n    # Randomly choose one of the three objectives to focus on for this move\n    obj_to_optimize = random.randint(0, 2)\n\n    # Apply 2-opt on the chosen objective's distance matrix\n    i, j = sorted(random.sample(range(n), 2))\n    if obj_to_optimize == 0:\n        # Check if reversing this segment improves the first objective\n        current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[j]])\n        new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                    distance_matrix_1[new_solution[i], new_solution[j]])\n        if new_cost < current_cost:\n            new_solution[i:j] = new_solution[i:j][::-1]\n    elif obj_to_optimize == 1:\n        # Check if reversing this segment improves the second objective\n        current_cost = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[j]])\n        new_cost = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                    distance_matrix_2[new_solution[i], new_solution[j]])\n        if new_cost < current_cost:\n            new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Check if reversing this segment improves the third objective\n        current_cost = (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_3[new_solution[j-1], new_solution[j]])\n        new_cost = (distance_matrix_3[new_solution[i-1], new_solution[j-1]] +\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n        if new_cost < current_cost:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 3: Apply edge insertion to further optimize\n    # Randomly select a node and insert it in a different position\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n\n    # Find the best insertion position for this node across all objectives\n    best_pos = k\n    best_improvement = 0\n\n    for pos in range(n):\n        if pos == k or pos == (k-1)%n:\n            continue\n\n        # Calculate the change in all three objectives\n        delta_obj1 = (distance_matrix_1[new_solution[pos-1], node] +\n                      distance_matrix_1[node, new_solution[(pos)%n]] -\n                      distance_matrix_1[new_solution[pos-1], new_solution[pos]])\n\n        delta_obj2 = (distance_matrix_2[new_solution[pos-1], node] +\n                      distance_matrix_2[node, new_solution[(pos)%n]] -\n                      distance_matrix_2[new_solution[pos-1], new_solution[pos]])\n\n        delta_obj3 = (distance_matrix_3[new_solution[pos-1], node] +\n                      distance_matrix_3[node, new_solution[(pos)%n]] -\n                      distance_matrix_3[new_solution[pos-1], new_solution[pos]])\n\n        # Weighted improvement (can be adjusted)\n        improvement = -0.5*delta_obj1 - 0.3*delta_obj2 - 0.2*delta_obj3\n\n        if improvement < best_improvement:\n            best_improvement = improvement\n            best_pos = pos\n\n    if best_pos != k:\n        # Remove the node and insert it at the best position\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.5388490200512808,
            1.8083049654960632
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Select solutions with the highest diversity (far from the centroid)\n        objectives = np.array([obj for _, obj in archive])\n        centroid = np.mean(objectives, axis=0)\n        distances = np.linalg.norm(objectives - centroid, axis=1)\n        selected_idx = np.argmax(distances)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Hybrid local search operator\n    # Apply a combination of 2-opt and edge insertion for each objective space\n    n = len(new_solution)\n\n    # Randomly choose one of the three objectives to focus on for this move\n    obj_to_optimize = random.randint(0, 2)\n\n    # Apply 2-opt on the chosen objective's distance matrix\n    i, j = sorted(random.sample(range(n), 2))\n    if obj_to_optimize == 0:\n        # Check if reversing this segment improves the first objective\n        current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[j]])\n        new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                    distance_matrix_1[new_solution[i], new_solution[j]])\n        if new_cost < current_cost:\n            new_solution[i:j] = new_solution[i:j][::-1]\n    elif obj_to_optimize == 1:\n        # Check if reversing this segment improves the second objective\n        current_cost = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[j]])\n        new_cost = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                    distance_matrix_2[new_solution[i], new_solution[j]])\n        if new_cost < current_cost:\n            new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Check if reversing this segment improves the third objective\n        current_cost = (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_3[new_solution[j-1], new_solution[j]])\n        new_cost = (distance_matrix_3[new_solution[i-1], new_solution[j-1]] +\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n        if new_cost < current_cost:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 3: Apply edge insertion to further optimize\n    # Randomly select a node and insert it in a different position\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n\n    # Find the best insertion position for this node across all objectives\n    best_pos = k\n    best_improvement = 0\n\n    for pos in range(n):\n        if pos == k or pos == (k-1)%n:\n            continue\n\n        # Calculate the change in all three objectives\n        delta_obj1 = (distance_matrix_1[new_solution[pos-1], node] +\n                      distance_matrix_1[node, new_solution[(pos)%n]] -\n                      distance_matrix_1[new_solution[pos-1], new_solution[pos]])\n\n        delta_obj2 = (distance_matrix_2[new_solution[pos-1], node] +\n                      distance_matrix_2[node, new_solution[(pos)%n]] -\n                      distance_matrix_2[new_solution[pos-1], new_solution[pos]])\n\n        delta_obj3 = (distance_matrix_3[new_solution[pos-1], node] +\n                      distance_matrix_3[node, new_solution[(pos)%n]] -\n                      distance_matrix_3[new_solution[pos-1], new_solution[pos]])\n\n        # Weighted improvement (can be adjusted)\n        improvement = -0.5*delta_obj1 - 0.3*delta_obj2 - 0.2*delta_obj3\n\n        if improvement < best_improvement:\n            best_improvement = improvement\n            best_pos = pos\n\n    if best_pos != k:\n        # Remove the node and insert it at the best position\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 227,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (higher sum indicates more potential)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select top 30% or at least 1 solution\n        top_n = max(1, int(0.3 * len(sorted_archive)))\n        selected_solutions = sorted_archive[:top_n]\n        # Randomly select one from the top candidates\n        base_solution, _ = random.choice(selected_solutions)\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # 1. Perform 2-opt swap (standard local search)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # 2. Objective-aware swap: swap nodes that are far apart in at least one objective space\n    for _ in range(2):  # Try a few times\n        a, b = random.sample(range(n), 2)\n        node_a, node_b = new_solution[a], new_solution[b]\n\n        # Calculate distances in all three spaces\n        dist1 = distance_matrix_1[node_a, node_b]\n        dist2 = distance_matrix_2[node_a, node_b]\n        dist3 = distance_matrix_3[node_a, node_b]\n\n        # If the nodes are far apart in at least one space, swap them\n        if any(d > threshold for d, threshold in zip([dist1, dist2, dist3], [np.mean(distance_matrix_1), np.mean(distance_matrix_2), np.mean(distance_matrix_3)])):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n            break\n\n    # 3. Optional: Perform a small 3-opt to further improve the solution\n    if n >= 4:\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment = new_solution[i:j+1]\n        # Reverse the middle segment\n        new_solution[i:j+1] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7149928800875808,
            1.2549440741539002
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (higher sum indicates more potential)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select top 30% or at least 1 solution\n        top_n = max(1, int(0.3 * len(sorted_archive)))\n        selected_solutions = sorted_archive[:top_n]\n        # Randomly select one from the top candidates\n        base_solution, _ = random.choice(selected_solutions)\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # 1. Perform 2-opt swap (standard local search)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # 2. Objective-aware swap: swap nodes that are far apart in at least one objective space\n    for _ in range(2):  # Try a few times\n        a, b = random.sample(range(n), 2)\n        node_a, node_b = new_solution[a], new_solution[b]\n\n        # Calculate distances in all three spaces\n        dist1 = distance_matrix_1[node_a, node_b]\n        dist2 = distance_matrix_2[node_a, node_b]\n        dist3 = distance_matrix_3[node_a, node_b]\n\n        # If the nodes are far apart in at least one space, swap them\n        if any(d > threshold for d, threshold in zip([dist1, dist2, dist3], [np.mean(distance_matrix_1), np.mean(distance_matrix_2), np.mean(distance_matrix_3)])):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n            break\n\n    # 3. Optional: Perform a small 3-opt to further improve the solution\n    if n >= 4:\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment = new_solution[i:j+1]\n        # Reverse the middle segment\n        new_solution[i:j+1] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 228,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too crowded in the archive)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Perform 2-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: find the best swap within a small neighborhood\n    window_size = min(5, n // 2)\n    for _ in range(3):  # Perform a few objective-aware swaps\n        # Select a random segment to consider for swaps\n        start = np.random.randint(0, n - window_size + 1)\n        segment = new_solution[start:start+window_size]\n\n        # Evaluate all possible swaps in this segment\n        best_swap = None\n        best_improvement = 0\n\n        for k in range(len(segment)):\n            for l in range(k + 1, len(segment)):\n                # Create a temporary swap\n                temp_solution = new_solution.copy()\n                temp_solution[start+k], temp_solution[start+l] = temp_solution[start+l], temp_solution[start+k]\n\n                # Calculate the change in all three objectives\n                delta1 = (distance_matrix_1[temp_solution[start+k-1], temp_solution[start+k]] +\n                          distance_matrix_1[temp_solution[start+k], temp_solution[start+l]] +\n                          distance_matrix_1[temp_solution[start+l], temp_solution[start+k+1 if k+1 < len(segment) else start]]) - \\\n                         (distance_matrix_1[temp_solution[start+k-1], temp_solution[start+l]] +\n                          distance_matrix_1[temp_solution[start+l], temp_solution[start+k]] +\n                          distance_matrix_1[temp_solution[start+k], temp_solution[start+k+1 if k+1 < len(segment) else start]])\n\n                delta2 = (distance_matrix_2[temp_solution[start+k-1], temp_solution[start+k]] +\n                          distance_matrix_2[temp_solution[start+k], temp_solution[start+l]] +\n                          distance_matrix_2[temp_solution[start+l], temp_solution[start+k+1 if k+1 < len(segment) else start]]) - \\\n                         (distance_matrix_2[temp_solution[start+k-1], temp_solution[start+l]] +\n                          distance_matrix_2[temp_solution[start+l], temp_solution[start+k]] +\n                          distance_matrix_2[temp_solution[start+k], temp_solution[start+k+1 if k+1 < len(segment) else start]])\n\n                delta3 = (distance_matrix_3[temp_solution[start+k-1], temp_solution[start+k]] +\n                          distance_matrix_3[temp_solution[start+k], temp_solution[start+l]] +\n                          distance_matrix_3[temp_solution[start+l], temp_solution[start+k+1 if k+1 < len(segment) else start]]) - \\\n                         (distance_matrix_3[temp_solution[start+k-1], temp_solution[start+l]] +\n                          distance_matrix_3[temp_solution[start+l], temp_solution[start+k]] +\n                          distance_matrix_3[temp_solution[start+k], temp_solution[start+k+1 if k+1 < len(segment) else start]])\n\n                # Simple improvement metric (could be replaced with more sophisticated multi-objective metric)\n                improvement = - (delta1 + delta2 + delta3)\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_swap = (start+k, start+l)\n\n        # Apply the best swap found\n        if best_swap is not None:\n            k, l = best_swap\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7664529227650093,
            2.3855351209640503
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too crowded in the archive)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Perform 2-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: find the best swap within a small neighborhood\n    window_size = min(5, n // 2)\n    for _ in range(3):  # Perform a few objective-aware swaps\n        # Select a random segment to consider for swaps\n        start = np.random.randint(0, n - window_size + 1)\n        segment = new_solution[start:start+window_size]\n\n        # Evaluate all possible swaps in this segment\n        best_swap = None\n        best_improvement = 0\n\n        for k in range(len(segment)):\n            for l in range(k + 1, len(segment)):\n                # Create a temporary swap\n                temp_solution = new_solution.copy()\n                temp_solution[start+k], temp_solution[start+l] = temp_solution[start+l], temp_solution[start+k]\n\n                # Calculate the change in all three objectives\n                delta1 = (distance_matrix_1[temp_solution[start+k-1], temp_solution[start+k]] +\n                          distance_matrix_1[temp_solution[start+k], temp_solution[start+l]] +\n                          distance_matrix_1[temp_solution[start+l], temp_solution[start+k+1 if k+1 < len(segment) else start]]) - \\\n                         (distance_matrix_1[temp_solution[start+k-1], temp_solution[start+l]] +\n                          distance_matrix_1[temp_solution[start+l], temp_solution[start+k]] +\n                          distance_matrix_1[temp_solution[start+k], temp_solution[start+k+1 if k+1 < len(segment) else start]])\n\n                delta2 = (distance_matrix_2[temp_solution[start+k-1], temp_solution[start+k]] +\n                          distance_matrix_2[temp_solution[start+k], temp_solution[start+l]] +\n                          distance_matrix_2[temp_solution[start+l], temp_solution[start+k+1 if k+1 < len(segment) else start]]) - \\\n                         (distance_matrix_2[temp_solution[start+k-1], temp_solution[start+l]] +\n                          distance_matrix_2[temp_solution[start+l], temp_solution[start+k]] +\n                          distance_matrix_2[temp_solution[start+k], temp_solution[start+k+1 if k+1 < len(segment) else start]])\n\n                delta3 = (distance_matrix_3[temp_solution[start+k-1], temp_solution[start+k]] +\n                          distance_matrix_3[temp_solution[start+k], temp_solution[start+l]] +\n                          distance_matrix_3[temp_solution[start+l], temp_solution[start+k+1 if k+1 < len(segment) else start]]) - \\\n                         (distance_matrix_3[temp_solution[start+k-1], temp_solution[start+l]] +\n                          distance_matrix_3[temp_solution[start+l], temp_solution[start+k]] +\n                          distance_matrix_3[temp_solution[start+k], temp_solution[start+k+1 if k+1 < len(segment) else start]])\n\n                # Simple improvement metric (could be replaced with more sophisticated multi-objective metric)\n                improvement = - (delta1 + delta2 + delta3)\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_swap = (start+k, start+l)\n\n        # Apply the best swap found\n        if best_swap is not None:\n            k, l = best_swap\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 229,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high objective values)\n    # Here we select a solution with the highest sum of objectives (can be replaced with other criteria)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search strategy\n    new_solution = selected_solution.copy()\n\n    # Strategy 1: Randomly select a segment and reverse it (2-opt move)\n    if len(new_solution) > 3:\n        a, b = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Strategy 2: Apply a 3-opt move if the tour is long enough\n    if len(new_solution) > 4:\n        i, j, k = sorted(random.sample(range(len(new_solution)), 3))\n        new_segment = np.concatenate([\n            new_solution[i:j],\n            new_solution[k:],\n            new_solution[j:k]\n        ])\n        new_solution[i:] = new_segment\n\n    # Strategy 3: Randomly swap two nodes to introduce diversity\n    if len(new_solution) > 1:\n        a, b = random.sample(range(len(new_solution)), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    # This is already guaranteed by the operations above\n\n    return new_solution\n\n",
        "score": [
            -0.6215123837064886,
            1.083422601222992
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high objective values)\n    # Here we select a solution with the highest sum of objectives (can be replaced with other criteria)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search strategy\n    new_solution = selected_solution.copy()\n\n    # Strategy 1: Randomly select a segment and reverse it (2-opt move)\n    if len(new_solution) > 3:\n        a, b = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Strategy 2: Apply a 3-opt move if the tour is long enough\n    if len(new_solution) > 4:\n        i, j, k = sorted(random.sample(range(len(new_solution)), 3))\n        new_segment = np.concatenate([\n            new_solution[i:j],\n            new_solution[k:],\n            new_solution[j:k]\n        ])\n        new_solution[i:] = new_segment\n\n    # Strategy 3: Randomly swap two nodes to introduce diversity\n    if len(new_solution) > 1:\n        a, b = random.sample(range(len(new_solution)), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    # This is already guaranteed by the operations above\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 230,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (not just the first one)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Number of attempts\n        # Randomly select two distinct positions\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if any objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            # Perform 2-opt swap\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Try objective-aware swap (swap nodes that improve multiple objectives)\n            k, l = random.sample(range(n), 2)\n            if k > l:\n                k, l = l, k\n\n            delta1_swap = (distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                          distance_matrix_1[new_solution[l], new_solution[(k+1)%n]] -\n                          distance_matrix_1[new_solution[k-1], new_solution[k]] -\n                          distance_matrix_1[new_solution[l], new_solution[(l+1)%n]])\n\n            delta2_swap = (distance_matrix_2[new_solution[k-1], new_solution[l]] +\n                          distance_matrix_2[new_solution[l], new_solution[(k+1)%n]] -\n                          distance_matrix_2[new_solution[k-1], new_solution[k]] -\n                          distance_matrix_2[new_solution[l], new_solution[(l+1)%n]])\n\n            delta3_swap = (distance_matrix_3[new_solution[k-1], new_solution[l]] +\n                          distance_matrix_3[new_solution[l], new_solution[(k+1)%n]] -\n                          distance_matrix_3[new_solution[k-1], new_solution[k]] -\n                          distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n            # Count how many objectives would improve\n            improvements = sum(1 for d in [delta1_swap, delta2_swap, delta3_swap] if d < 0)\n\n            if improvements >= 2:  # Require at least two objectives to improve\n                new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.8397817057398365,
            1.6692597270011902
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (not just the first one)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Number of attempts\n        # Randomly select two distinct positions\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if any objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            # Perform 2-opt swap\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Try objective-aware swap (swap nodes that improve multiple objectives)\n            k, l = random.sample(range(n), 2)\n            if k > l:\n                k, l = l, k\n\n            delta1_swap = (distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                          distance_matrix_1[new_solution[l], new_solution[(k+1)%n]] -\n                          distance_matrix_1[new_solution[k-1], new_solution[k]] -\n                          distance_matrix_1[new_solution[l], new_solution[(l+1)%n]])\n\n            delta2_swap = (distance_matrix_2[new_solution[k-1], new_solution[l]] +\n                          distance_matrix_2[new_solution[l], new_solution[(k+1)%n]] -\n                          distance_matrix_2[new_solution[k-1], new_solution[k]] -\n                          distance_matrix_2[new_solution[l], new_solution[(l+1)%n]])\n\n            delta3_swap = (distance_matrix_3[new_solution[k-1], new_solution[l]] +\n                          distance_matrix_3[new_solution[l], new_solution[(k+1)%n]] -\n                          distance_matrix_3[new_solution[k-1], new_solution[k]] -\n                          distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n            # Count how many objectives would improve\n            improvements = sum(1 for d in [delta1_swap, delta2_swap, delta3_swap] if d < 0)\n\n            if improvements >= 2:  # Require at least two objectives to improve\n                new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 231,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a bias towards those with higher potential for improvement\n    # Here, we consider solutions with the highest variance in their objectives as more promising\n    objectives = np.array([obj for (sol, obj) in archive])\n    variances = np.var(objectives, axis=1)\n    probabilities = variances / np.sum(variances)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator combining 2-opt and random segment inversion\n    # with objective-aware selection\n    if random.random() < 0.7:  # 70% chance for 2-opt\n        i, j = sorted(random.sample(range(n), 2))\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:  # 30% chance for random segment inversion\n        # Select a segment and invert it, but ensure it doesn't worsen all objectives\n        for _ in range(10):  # Try up to 10 times to find an improving move\n            i, j = sorted(random.sample(range(n), 2))\n            candidate = new_solution.copy()\n            candidate[i:j+1] = candidate[i:j+1][::-1]\n\n            # Calculate the change in all three objectives\n            old_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))\n            old_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n            old_cost3 = sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n\n            new_cost1 = sum(distance_matrix_1[candidate[k-1], candidate[k]] for k in range(n))\n            new_cost2 = sum(distance_matrix_2[candidate[k-1], candidate[k]] for k in range(n))\n            new_cost3 = sum(distance_matrix_3[candidate[k-1], candidate[k]] for k in range(n))\n\n            # Accept if at least one objective improves\n            if (new_cost1 < old_cost1) or (new_cost2 < old_cost2) or (new_cost3 < old_cost3):\n                new_solution = candidate\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.669759801113605,
            1.5825451731681823
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a bias towards those with higher potential for improvement\n    # Here, we consider solutions with the highest variance in their objectives as more promising\n    objectives = np.array([obj for (sol, obj) in archive])\n    variances = np.var(objectives, axis=1)\n    probabilities = variances / np.sum(variances)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator combining 2-opt and random segment inversion\n    # with objective-aware selection\n    if random.random() < 0.7:  # 70% chance for 2-opt\n        i, j = sorted(random.sample(range(n), 2))\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:  # 30% chance for random segment inversion\n        # Select a segment and invert it, but ensure it doesn't worsen all objectives\n        for _ in range(10):  # Try up to 10 times to find an improving move\n            i, j = sorted(random.sample(range(n), 2))\n            candidate = new_solution.copy()\n            candidate[i:j+1] = candidate[i:j+1][::-1]\n\n            # Calculate the change in all three objectives\n            old_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))\n            old_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n            old_cost3 = sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n\n            new_cost1 = sum(distance_matrix_1[candidate[k-1], candidate[k]] for k in range(n))\n            new_cost2 = sum(distance_matrix_2[candidate[k-1], candidate[k]] for k in range(n))\n            new_cost3 = sum(distance_matrix_3[candidate[k-1], candidate[k]] for k in range(n))\n\n            # Accept if at least one objective improves\n            if (new_cost1 < old_cost1) or (new_cost2 < old_cost2) or (new_cost3 < old_cost3):\n                new_solution = candidate\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 232,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the current Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a multi-objective aware swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt with multi-objective consideration\n    if i != j:\n        # Calculate the impact on all three objectives\n        obj1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        obj2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        obj3_before = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n\n        obj1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]]\n        obj2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]]\n        obj3_after = distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j-1]]\n\n        # If the move improves at least one objective, apply it\n        if (obj1_after < obj1_before) or (obj2_after < obj2_before) or (obj3_after < obj3_before):\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Additional multi-objective aware swap\n    if np.random.random() < 0.3:  # 30% chance to apply this\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        if k != l:\n            # Calculate the impact on all three objectives\n            obj1_before = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n            obj2_before = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n            obj3_before = distance_matrix_3[new_solution[k-1], new_solution[k]] + distance_matrix_3[new_solution[l-1], new_solution[l]]\n\n            obj1_after = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[k], new_solution[l-1]]\n            obj2_after = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[k], new_solution[l-1]]\n            obj3_after = distance_matrix_3[new_solution[k-1], new_solution[l]] + distance_matrix_3[new_solution[k], new_solution[l-1]]\n\n            # If the move improves at least one objective, apply it\n            if (obj1_after < obj1_before) or (obj2_after < obj2_before) or (obj3_after < obj3_before):\n                new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.797243623474787,
            1.8068086862564088
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the current Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a multi-objective aware swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt with multi-objective consideration\n    if i != j:\n        # Calculate the impact on all three objectives\n        obj1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        obj2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        obj3_before = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n\n        obj1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]]\n        obj2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]]\n        obj3_after = distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j-1]]\n\n        # If the move improves at least one objective, apply it\n        if (obj1_after < obj1_before) or (obj2_after < obj2_before) or (obj3_after < obj3_before):\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Additional multi-objective aware swap\n    if np.random.random() < 0.3:  # 30% chance to apply this\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        if k != l:\n            # Calculate the impact on all three objectives\n            obj1_before = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n            obj2_before = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n            obj3_before = distance_matrix_3[new_solution[k-1], new_solution[k]] + distance_matrix_3[new_solution[l-1], new_solution[l]]\n\n            obj1_after = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[k], new_solution[l-1]]\n            obj2_after = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[k], new_solution[l-1]]\n            obj3_after = distance_matrix_3[new_solution[k-1], new_solution[l]] + distance_matrix_3[new_solution[k], new_solution[l-1]]\n\n            # If the move improves at least one objective, apply it\n            if (obj1_after < obj1_before) or (obj2_after < obj2_before) or (obj3_after < obj3_before):\n                new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 233,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., highest crowding distance or least dominated)\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    current_solution = selected_solution.copy()\n    n = len(current_solution)\n\n    # Hybrid local search strategy:\n    # 1. Apply 2-opt with objective-aware edge selection\n    # 2. Apply insertion heuristic considering all three objectives\n\n    # Step 1: 2-opt with objective-aware edge selection\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        # Select edges to swap based on their contribution to all three objectives\n        i, j = np.random.randint(0, n, size=2)\n        if i == j:\n            continue\n\n        # Calculate the change in all three objectives\n        a, b = current_solution[i], current_solution[(i+1)%n]\n        c, d = current_solution[j], current_solution[(j+1)%n]\n\n        delta1 = (distance_matrix_1[a, c] + distance_matrix_1[b, d]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n        delta2 = (distance_matrix_2[a, c] + distance_matrix_2[b, d]) - (distance_matrix_2[a, b] + distance_matrix_2[c, d])\n        delta3 = (distance_matrix_3[a, c] + distance_matrix_3[b, d]) - (distance_matrix_3[a, b] + distance_matrix_3[c, d])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            current_solution[i+1:j+1] = current_solution[i+1:j+1][::-1]\n\n    # Step 2: Insertion heuristic considering all three objectives\n    for _ in range(5):\n        # Select a node to move\n        k = np.random.randint(0, n)\n        node = current_solution[k]\n\n        # Find the best insertion position considering all three objectives\n        best_pos = -1\n        best_score = float('inf')\n\n        for i in range(n):\n            if i == k or i == (k-1)%n:\n                continue\n\n            # Calculate the change in all three objectives\n            a, b = current_solution[i], current_solution[(i+1)%n]\n            c, d = current_solution[k], current_solution[(k+1)%n]\n\n            delta1 = (distance_matrix_1[a, node] + distance_matrix_1[node, b] + distance_matrix_1[c, d]) - (distance_matrix_1[a, c] + distance_matrix_1[d, b])\n            delta2 = (distance_matrix_2[a, node] + distance_matrix_2[node, b] + distance_matrix_2[c, d]) - (distance_matrix_2[a, c] + distance_matrix_2[d, b])\n            delta3 = (distance_matrix_3[a, node] + distance_matrix_3[node, b] + distance_matrix_3[c, d]) - (distance_matrix_3[a, c] + distance_matrix_3[d, b])\n\n            # Use a weighted sum of improvements as the score\n            score = (delta1 + delta2 + delta3) / 3  # Simple average could be replaced with more sophisticated weighting\n\n            if score < best_score:\n                best_score = score\n                best_pos = i\n\n        if best_pos != -1:\n            # Remove the node from its current position\n            current_solution = np.delete(current_solution, k)\n            # Insert it at the best position\n            current_solution = np.insert(current_solution, best_pos, node)\n\n    return current_solution\n\n",
        "score": [
            -0.6276115522220082,
            3.743527185916901
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., highest crowding distance or least dominated)\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    current_solution = selected_solution.copy()\n    n = len(current_solution)\n\n    # Hybrid local search strategy:\n    # 1. Apply 2-opt with objective-aware edge selection\n    # 2. Apply insertion heuristic considering all three objectives\n\n    # Step 1: 2-opt with objective-aware edge selection\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        # Select edges to swap based on their contribution to all three objectives\n        i, j = np.random.randint(0, n, size=2)\n        if i == j:\n            continue\n\n        # Calculate the change in all three objectives\n        a, b = current_solution[i], current_solution[(i+1)%n]\n        c, d = current_solution[j], current_solution[(j+1)%n]\n\n        delta1 = (distance_matrix_1[a, c] + distance_matrix_1[b, d]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n        delta2 = (distance_matrix_2[a, c] + distance_matrix_2[b, d]) - (distance_matrix_2[a, b] + distance_matrix_2[c, d])\n        delta3 = (distance_matrix_3[a, c] + distance_matrix_3[b, d]) - (distance_matrix_3[a, b] + distance_matrix_3[c, d])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            current_solution[i+1:j+1] = current_solution[i+1:j+1][::-1]\n\n    # Step 2: Insertion heuristic considering all three objectives\n    for _ in range(5):\n        # Select a node to move\n        k = np.random.randint(0, n)\n        node = current_solution[k]\n\n        # Find the best insertion position considering all three objectives\n        best_pos = -1\n        best_score = float('inf')\n\n        for i in range(n):\n            if i == k or i == (k-1)%n:\n                continue\n\n            # Calculate the change in all three objectives\n            a, b = current_solution[i], current_solution[(i+1)%n]\n            c, d = current_solution[k], current_solution[(k+1)%n]\n\n            delta1 = (distance_matrix_1[a, node] + distance_matrix_1[node, b] + distance_matrix_1[c, d]) - (distance_matrix_1[a, c] + distance_matrix_1[d, b])\n            delta2 = (distance_matrix_2[a, node] + distance_matrix_2[node, b] + distance_matrix_2[c, d]) - (distance_matrix_2[a, c] + distance_matrix_2[d, b])\n            delta3 = (distance_matrix_3[a, node] + distance_matrix_3[node, b] + distance_matrix_3[c, d]) - (distance_matrix_3[a, c] + distance_matrix_3[d, b])\n\n            # Use a weighted sum of improvements as the score\n            score = (delta1 + delta2 + delta3) / 3  # Simple average could be replaced with more sophisticated weighting\n\n            if score < best_score:\n                best_score = score\n                best_pos = i\n\n        if best_pos != -1:\n            # Remove the node from its current position\n            current_solution = np.delete(current_solution, k)\n            # Insert it at the best position\n            current_solution = np.insert(current_solution, best_pos, node)\n\n    return current_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 234,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution with high potential for improvement\n    # We prioritize solutions that have at least one objective worse than the average\n    objectives = np.array([obj for _, obj in archive])\n    avg_objectives = np.mean(objectives, axis=0)\n    promising_indices = [i for i, obj in enumerate(objectives) if any(o > avg for o, avg in zip(obj, avg_objectives))]\n\n    if not promising_indices:\n        promising_indices = list(range(len(archive)))\n\n    selected_idx = np.random.choice(promising_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    # We combine 2-opt with a multi-objective aware edge swap\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Randomly select two distinct segments\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform 2-opt on the first segment\n    if i + 1 < j:\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform 2-opt on the second segment\n    if k + 1 < l:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Multi-objective aware edge swap\n    for _ in range(3):  # Limit the number of swaps to prevent excessive computation\n        # Select two random edges\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n\n        # Get the current edges\n        current_edges = [\n            (new_solution[a], new_solution[(a+1)%n]),\n            (new_solution[b], new_solution[(b+1)%n]),\n            (new_solution[c], new_solution[(c+1)%n]),\n            (new_solution[d], new_solution[(d+1)%n])\n        ]\n\n        # Calculate current cost\n        current_cost = sum([\n            distance_matrix_1[e1, e2] + distance_matrix_2[e1, e2] + distance_matrix_3[e1, e2]\n            for e1, e2 in current_edges\n        ])\n\n        # Try swapping the edges\n        temp_solution = new_solution.copy()\n        temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n        temp_solution[c], temp_solution[d] = temp_solution[d], temp_solution[c]\n\n        # Calculate new edges\n        new_edges = [\n            (temp_solution[a], temp_solution[(a+1)%n]),\n            (temp_solution[b], temp_solution[(b+1)%n]),\n            (temp_solution[c], temp_solution[(c+1)%n]),\n            (temp_solution[d], temp_solution[(d+1)%n])\n        ]\n\n        # Calculate new cost\n        new_cost = sum([\n            distance_matrix_1[e1, e2] + distance_matrix_2[e1, e2] + distance_matrix_3[e1, e2]\n            for e1, e2 in new_edges\n        ])\n\n        # Accept if improvement is found\n        if new_cost < current_cost:\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7759836277265901,
            2.767072308063507
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution with high potential for improvement\n    # We prioritize solutions that have at least one objective worse than the average\n    objectives = np.array([obj for _, obj in archive])\n    avg_objectives = np.mean(objectives, axis=0)\n    promising_indices = [i for i, obj in enumerate(objectives) if any(o > avg for o, avg in zip(obj, avg_objectives))]\n\n    if not promising_indices:\n        promising_indices = list(range(len(archive)))\n\n    selected_idx = np.random.choice(promising_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    # We combine 2-opt with a multi-objective aware edge swap\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Randomly select two distinct segments\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform 2-opt on the first segment\n    if i + 1 < j:\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform 2-opt on the second segment\n    if k + 1 < l:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Multi-objective aware edge swap\n    for _ in range(3):  # Limit the number of swaps to prevent excessive computation\n        # Select two random edges\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n\n        # Get the current edges\n        current_edges = [\n            (new_solution[a], new_solution[(a+1)%n]),\n            (new_solution[b], new_solution[(b+1)%n]),\n            (new_solution[c], new_solution[(c+1)%n]),\n            (new_solution[d], new_solution[(d+1)%n])\n        ]\n\n        # Calculate current cost\n        current_cost = sum([\n            distance_matrix_1[e1, e2] + distance_matrix_2[e1, e2] + distance_matrix_3[e1, e2]\n            for e1, e2 in current_edges\n        ])\n\n        # Try swapping the edges\n        temp_solution = new_solution.copy()\n        temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n        temp_solution[c], temp_solution[d] = temp_solution[d], temp_solution[c]\n\n        # Calculate new edges\n        new_edges = [\n            (temp_solution[a], temp_solution[(a+1)%n]),\n            (temp_solution[b], temp_solution[(b+1)%n]),\n            (temp_solution[c], temp_solution[(c+1)%n]),\n            (temp_solution[d], temp_solution[(d+1)%n])\n        ]\n\n        # Calculate new cost\n        new_cost = sum([\n            distance_matrix_1[e1, e2] + distance_matrix_2[e1, e2] + distance_matrix_3[e1, e2]\n            for e1, e2 in new_edges\n        ])\n\n        # Accept if improvement is found\n        if new_cost < current_cost:\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 235,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimized in all objectives)\n    # Here, we select a solution that is not dominated by others in all objectives\n    selected_solution = None\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and other_obj[2] <= obj[2] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1] or other_obj[2] < obj[2])):\n                dominated = True\n                break\n        if not dominated:\n            selected_solution = sol.copy()\n            break\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine 2-opt and 3-opt with objective-aware moves\n    # First, perform a random 2-opt move\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform a 3-opt move targeting the worst objective\n    obj = archive[0][1]  # Using the first solution's objective as reference\n    worst_obj = np.argmax(obj)\n\n    if worst_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the worst edge in the worst objective\n    worst_edge = -1\n    max_dist = -1\n    for k in range(n):\n        dist = dist_matrix[new_solution[k], new_solution[(k+1)%n]]\n        if dist > max_dist:\n            max_dist = dist\n            worst_edge = k\n\n    # Perform 3-opt on the worst edge\n    if worst_edge != -1:\n        a, b, c = worst_edge, (worst_edge + 1) % n, (worst_edge + 2) % n\n        # Try different 3-opt configurations\n        configs = [\n            (a, b, c),\n            (a, c, b),\n            (b, a, c),\n            (b, c, a),\n            (c, a, b),\n            (c, b, a)\n        ]\n        best_config = None\n        min_total_dist = float('inf')\n\n        for config in configs:\n            temp_solution = new_solution.copy()\n            i, j, k = config\n            temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n            temp_solution[j:k+1] = temp_solution[j:k+1][::-1]\n\n            total_dist = 0\n            for m in range(n):\n                total_dist += dist_matrix[temp_solution[m], temp_solution[(m+1)%n]]\n\n            if total_dist < min_total_dist:\n                min_total_dist = total_dist\n                best_config = config\n\n        if best_config is not None:\n            i, j, k = best_config\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7176948297020427,
            1.8322860479354859
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimized in all objectives)\n    # Here, we select a solution that is not dominated by others in all objectives\n    selected_solution = None\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and other_obj[2] <= obj[2] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1] or other_obj[2] < obj[2])):\n                dominated = True\n                break\n        if not dominated:\n            selected_solution = sol.copy()\n            break\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine 2-opt and 3-opt with objective-aware moves\n    # First, perform a random 2-opt move\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform a 3-opt move targeting the worst objective\n    obj = archive[0][1]  # Using the first solution's objective as reference\n    worst_obj = np.argmax(obj)\n\n    if worst_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the worst edge in the worst objective\n    worst_edge = -1\n    max_dist = -1\n    for k in range(n):\n        dist = dist_matrix[new_solution[k], new_solution[(k+1)%n]]\n        if dist > max_dist:\n            max_dist = dist\n            worst_edge = k\n\n    # Perform 3-opt on the worst edge\n    if worst_edge != -1:\n        a, b, c = worst_edge, (worst_edge + 1) % n, (worst_edge + 2) % n\n        # Try different 3-opt configurations\n        configs = [\n            (a, b, c),\n            (a, c, b),\n            (b, a, c),\n            (b, c, a),\n            (c, a, b),\n            (c, b, a)\n        ]\n        best_config = None\n        min_total_dist = float('inf')\n\n        for config in configs:\n            temp_solution = new_solution.copy()\n            i, j, k = config\n            temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n            temp_solution[j:k+1] = temp_solution[j:k+1][::-1]\n\n            total_dist = 0\n            for m in range(n):\n                total_dist += dist_matrix[temp_solution[m], temp_solution[(m+1)%n]]\n\n            if total_dist < min_total_dist:\n                min_total_dist = total_dist\n                best_config = config\n\n        if best_config is not None:\n            i, j, k = best_config\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 236,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest combined objective value)\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search strategy combining 2-opt and node insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and node insertion\n    if np.random.rand() < 0.5:\n        # 2-opt local search\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Node insertion\n        if n > 2:\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            while j == i or j == (i + 1) % n:\n                j = np.random.randint(0, n)\n            # Remove node at i and insert before j\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.623760666773201,
            1.5664645910263062
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest combined objective value)\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search strategy combining 2-opt and node insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and node insertion\n    if np.random.rand() < 0.5:\n        # 2-opt local search\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Node insertion\n        if n > 2:\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            while j == i or j == (i + 1) % n:\n                j = np.random.randint(0, n)\n            # Remove node at i and insert before j\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 237,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (higher sum indicates more room for improvement)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select top 50% of solutions with the highest potential\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 2)]\n        # Randomly select one from the top solutions\n        selected_idx = random.randint(0, len(top_solutions) - 1)\n        base_solution = top_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy:\n    # 1. Randomly select a segment of the tour (2-4 nodes)\n    n = len(new_solution)\n    segment_length = random.randint(2, min(4, n // 2))\n    start_idx = random.randint(0, n - segment_length)\n\n    # 2. Reverse the selected segment (2-opt move)\n    segment = new_solution[start_idx:start_idx + segment_length]\n    new_solution[start_idx:start_idx + segment_length] = segment[::-1]\n\n    # 3. If the segment is small (2 nodes), consider a swap (3-opt move)\n    if segment_length == 2:\n        if random.random() < 0.5:\n            new_solution[start_idx], new_solution[start_idx + 1] = new_solution[start_idx + 1], new_solution[start_idx]\n\n    # 4. If the segment is large (3-4 nodes), consider a shift (insertion move)\n    elif segment_length > 2 and random.random() < 0.3:\n        # Remove the segment and insert it at a different position\n        removed = np.delete(new_solution, slice(start_idx, start_idx + segment_length))\n        insert_pos = random.randint(0, len(removed))\n        new_solution = np.insert(removed, insert_pos, segment)\n\n    # 5. Evaluate the new solution and ensure feasibility\n    # (This step is implicit as we're working with valid TSP tours)\n\n    return new_solution\n\n",
        "score": [
            -0.6791552162911182,
            1.384457492828369
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (higher sum indicates more room for improvement)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select top 50% of solutions with the highest potential\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 2)]\n        # Randomly select one from the top solutions\n        selected_idx = random.randint(0, len(top_solutions) - 1)\n        base_solution = top_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy:\n    # 1. Randomly select a segment of the tour (2-4 nodes)\n    n = len(new_solution)\n    segment_length = random.randint(2, min(4, n // 2))\n    start_idx = random.randint(0, n - segment_length)\n\n    # 2. Reverse the selected segment (2-opt move)\n    segment = new_solution[start_idx:start_idx + segment_length]\n    new_solution[start_idx:start_idx + segment_length] = segment[::-1]\n\n    # 3. If the segment is small (2 nodes), consider a swap (3-opt move)\n    if segment_length == 2:\n        if random.random() < 0.5:\n            new_solution[start_idx], new_solution[start_idx + 1] = new_solution[start_idx + 1], new_solution[start_idx]\n\n    # 4. If the segment is large (3-4 nodes), consider a shift (insertion move)\n    elif segment_length > 2 and random.random() < 0.3:\n        # Remove the segment and insert it at a different position\n        removed = np.delete(new_solution, slice(start_idx, start_idx + segment_length))\n        insert_pos = random.randint(0, len(removed))\n        new_solution = np.insert(removed, insert_pos, segment)\n\n    # 5. Evaluate the new solution and ensure feasibility\n    # (This step is implicit as we're working with valid TSP tours)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 238,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = random.choice(sorted_archive[:max(1, len(archive) // 4)])[0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel multi-objective edge swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt for the first objective\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Multi-objective edge swap for the other objectives\n    if n > 3:\n        k = random.randint(0, n-1)\n        l = (k + random.randint(2, n-1)) % n\n\n        # Calculate current and potential costs for all three objectives\n        current_cost = (\n            distance_matrix_1[new_solution[k-1], new_solution[k]] +\n            distance_matrix_1[new_solution[l-1], new_solution[l]],\n            distance_matrix_2[new_solution[k-1], new_solution[k]] +\n            distance_matrix_2[new_solution[l-1], new_solution[l]],\n            distance_matrix_3[new_solution[k-1], new_solution[k]] +\n            distance_matrix_3[new_solution[l-1], new_solution[l]]\n        )\n\n        swapped_cost = (\n            distance_matrix_1[new_solution[k-1], new_solution[l]] +\n            distance_matrix_1[new_solution[l-1], new_solution[k]],\n            distance_matrix_2[new_solution[k-1], new_solution[l]] +\n            distance_matrix_2[new_solution[l-1], new_solution[k]],\n            distance_matrix_3[new_solution[k-1], new_solution[l]] +\n            distance_matrix_3[new_solution[l-1], new_solution[k]]\n        )\n\n        # Accept the swap if it improves at least one objective without worsening others\n        if any(s < c for s, c in zip(swapped_cost, current_cost)) and \\\n           all(s <= c for s, c in zip(swapped_cost, current_cost)):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.6114843219385646,
            1.5792515397071838
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = random.choice(sorted_archive[:max(1, len(archive) // 4)])[0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel multi-objective edge swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt for the first objective\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Multi-objective edge swap for the other objectives\n    if n > 3:\n        k = random.randint(0, n-1)\n        l = (k + random.randint(2, n-1)) % n\n\n        # Calculate current and potential costs for all three objectives\n        current_cost = (\n            distance_matrix_1[new_solution[k-1], new_solution[k]] +\n            distance_matrix_1[new_solution[l-1], new_solution[l]],\n            distance_matrix_2[new_solution[k-1], new_solution[k]] +\n            distance_matrix_2[new_solution[l-1], new_solution[l]],\n            distance_matrix_3[new_solution[k-1], new_solution[k]] +\n            distance_matrix_3[new_solution[l-1], new_solution[l]]\n        )\n\n        swapped_cost = (\n            distance_matrix_1[new_solution[k-1], new_solution[l]] +\n            distance_matrix_1[new_solution[l-1], new_solution[k]],\n            distance_matrix_2[new_solution[k-1], new_solution[l]] +\n            distance_matrix_2[new_solution[l-1], new_solution[k]],\n            distance_matrix_3[new_solution[k-1], new_solution[l]] +\n            distance_matrix_3[new_solution[l-1], new_solution[k]]\n        )\n\n        # Accept the swap if it improves at least one objective without worsening others\n        if any(s < c for s, c in zip(swapped_cost, current_cost)) and \\\n           all(s <= c for s, c in zip(swapped_cost, current_cost)):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 239,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    # Normalize objectives to avoid division by zero\n    normalized = objectives / (objectives.sum(axis=0) + 1e-10)\n    # Calculate weights based on normalized objectives (smaller values are better)\n    weights = 1 / (normalized + 1e-10)\n    weights = weights / weights.sum(axis=0)\n    # Calculate selection probabilities (higher for solutions with better trade-offs)\n    probs = np.prod(weights, axis=1)\n    probs = probs / probs.sum()\n\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Hybrid operator: combine 2-opt with a multi-objective aware swap\n    if np.random.rand() < 0.5:\n        # 2-opt move (standard TSP operator)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Multi-objective aware swap\n        # Find the worst edge in terms of at least one objective\n        worst_edge = -1\n        worst_value = -1\n        for k in range(n-1):\n            node1, node2 = new_solution[k], new_solution[k+1]\n            # Calculate the sum of normalized distances across all objectives\n            dist = (distance_matrix_1[node1, node2] / distance_matrix_1.max() +\n                    distance_matrix_2[node1, node2] / distance_matrix_2.max() +\n                    distance_matrix_3[node1, node2] / distance_matrix_3.max())\n            if dist > worst_value:\n                worst_value = dist\n                worst_edge = k\n\n        if worst_edge != -1:\n            # Swap nodes to improve the worst edge\n            k = worst_edge\n            node1, node2 = new_solution[k], new_solution[k+1]\n            # Find a better pair to swap with\n            candidates = []\n            for l in range(n-1):\n                if l != k and l != k+1:\n                    candidates.append((l, new_solution[l], new_solution[l+1]))\n\n            if candidates:\n                # Evaluate all candidates based on the sum of normalized distances\n                candidate_scores = []\n                for l, node3, node4 in candidates:\n                    # Original distance\n                    orig_dist = (distance_matrix_1[node1, node2] / distance_matrix_1.max() +\n                                distance_matrix_2[node1, node2] / distance_matrix_2.max() +\n                                distance_matrix_3[node1, node2] / distance_matrix_3.max())\n                    # New distance if we swap\n                    new_dist = (distance_matrix_1[node3, node4] / distance_matrix_1.max() +\n                               distance_matrix_2[node3, node4] / distance_matrix_2.max() +\n                               distance_matrix_3[node3, node4] / distance_matrix_3.max())\n                    candidate_scores.append((l, orig_dist - new_dist))\n\n                # Select the candidate that provides the most improvement\n                best_candidate = max(candidate_scores, key=lambda x: x[1])\n                l = best_candidate[0]\n                # Perform the swap\n                new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.6807803753300881,
            2.8147658109664917
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    # Normalize objectives to avoid division by zero\n    normalized = objectives / (objectives.sum(axis=0) + 1e-10)\n    # Calculate weights based on normalized objectives (smaller values are better)\n    weights = 1 / (normalized + 1e-10)\n    weights = weights / weights.sum(axis=0)\n    # Calculate selection probabilities (higher for solutions with better trade-offs)\n    probs = np.prod(weights, axis=1)\n    probs = probs / probs.sum()\n\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Hybrid operator: combine 2-opt with a multi-objective aware swap\n    if np.random.rand() < 0.5:\n        # 2-opt move (standard TSP operator)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Multi-objective aware swap\n        # Find the worst edge in terms of at least one objective\n        worst_edge = -1\n        worst_value = -1\n        for k in range(n-1):\n            node1, node2 = new_solution[k], new_solution[k+1]\n            # Calculate the sum of normalized distances across all objectives\n            dist = (distance_matrix_1[node1, node2] / distance_matrix_1.max() +\n                    distance_matrix_2[node1, node2] / distance_matrix_2.max() +\n                    distance_matrix_3[node1, node2] / distance_matrix_3.max())\n            if dist > worst_value:\n                worst_value = dist\n                worst_edge = k\n\n        if worst_edge != -1:\n            # Swap nodes to improve the worst edge\n            k = worst_edge\n            node1, node2 = new_solution[k], new_solution[k+1]\n            # Find a better pair to swap with\n            candidates = []\n            for l in range(n-1):\n                if l != k and l != k+1:\n                    candidates.append((l, new_solution[l], new_solution[l+1]))\n\n            if candidates:\n                # Evaluate all candidates based on the sum of normalized distances\n                candidate_scores = []\n                for l, node3, node4 in candidates:\n                    # Original distance\n                    orig_dist = (distance_matrix_1[node1, node2] / distance_matrix_1.max() +\n                                distance_matrix_2[node1, node2] / distance_matrix_2.max() +\n                                distance_matrix_3[node1, node2] / distance_matrix_3.max())\n                    # New distance if we swap\n                    new_dist = (distance_matrix_1[node3, node4] / distance_matrix_1.max() +\n                               distance_matrix_2[node3, node4] / distance_matrix_2.max() +\n                               distance_matrix_3[node3, node4] / distance_matrix_3.max())\n                    candidate_scores.append((l, orig_dist - new_dist))\n\n                # Select the candidate that provides the most improvement\n                best_candidate = max(candidate_scores, key=lambda x: x[1])\n                l = best_candidate[0]\n                # Perform the swap\n                new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 240,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solutions with the best trade-off between objectives (using Pareto front approximation)\n    candidates = [sol for sol, _ in archive]\n    if len(candidates) > 1:\n        # Randomly select among top 30% of solutions (sorted by sum of objectives)\n        sorted_solutions = sorted(archive, key=lambda x: sum(x[1]))\n        top_candidates = sorted_solutions[:max(1, len(sorted_solutions) // 3)]\n        selected_solution = random.choice(top_candidates)[0].copy()\n    else:\n        selected_solution = candidates[0].copy()\n\n    # Hybrid local search operator: combines 2-opt, 3-opt, and a novel multi-objective edge swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with probability 0.4\n    if random.random() < 0.4:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply 3-opt with probability 0.3\n    elif random.random() < 0.3:\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n        new_solution[i:k+1] = np.concatenate([segment2, segment1])\n\n    # Apply multi-objective edge swap with remaining probability\n    else:\n        # Select two random edges from different objective spaces\n        obj1_edges = [(i, (i+1)%n) for i in range(n)]\n        obj2_edges = [(i, (i+1)%n) for i in range(n)]\n        obj3_edges = [(i, (i+1)%n) for i in range(n)]\n\n        # Sort edges by their contribution to each objective\n        obj1_edges.sort(key=lambda x: distance_matrix_1[x[0], x[1]])\n        obj2_edges.sort(key=lambda x: distance_matrix_2[x[0], x[1]])\n        obj3_edges.sort(key=lambda x: distance_matrix_3[x[0], x[1]])\n\n        # Select edges with high potential for improvement\n        candidate_edges = obj1_edges[:n//3] + obj2_edges[:n//3] + obj3_edges[:n//3]\n        if candidate_edges:\n            i, j = random.choice(candidate_edges)\n            k = random.randint(0, n-1)\n            while k == i or k == j or k == (i+1)%n or k == (j+1)%n:\n                k = random.randint(0, n-1)\n\n            # Perform edge swap\n            new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6785898677460028,
            1.6099785089492797
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solutions with the best trade-off between objectives (using Pareto front approximation)\n    candidates = [sol for sol, _ in archive]\n    if len(candidates) > 1:\n        # Randomly select among top 30% of solutions (sorted by sum of objectives)\n        sorted_solutions = sorted(archive, key=lambda x: sum(x[1]))\n        top_candidates = sorted_solutions[:max(1, len(sorted_solutions) // 3)]\n        selected_solution = random.choice(top_candidates)[0].copy()\n    else:\n        selected_solution = candidates[0].copy()\n\n    # Hybrid local search operator: combines 2-opt, 3-opt, and a novel multi-objective edge swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with probability 0.4\n    if random.random() < 0.4:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply 3-opt with probability 0.3\n    elif random.random() < 0.3:\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n        new_solution[i:k+1] = np.concatenate([segment2, segment1])\n\n    # Apply multi-objective edge swap with remaining probability\n    else:\n        # Select two random edges from different objective spaces\n        obj1_edges = [(i, (i+1)%n) for i in range(n)]\n        obj2_edges = [(i, (i+1)%n) for i in range(n)]\n        obj3_edges = [(i, (i+1)%n) for i in range(n)]\n\n        # Sort edges by their contribution to each objective\n        obj1_edges.sort(key=lambda x: distance_matrix_1[x[0], x[1]])\n        obj2_edges.sort(key=lambda x: distance_matrix_2[x[0], x[1]])\n        obj3_edges.sort(key=lambda x: distance_matrix_3[x[0], x[1]])\n\n        # Select edges with high potential for improvement\n        candidate_edges = obj1_edges[:n//3] + obj2_edges[:n//3] + obj3_edges[:n//3]\n        if candidate_edges:\n            i, j = random.choice(candidate_edges)\n            k = random.randint(0, n-1)\n            while k == i or k == j or k == (i+1)%n or k == (j+1)%n:\n                k = random.randint(0, n-1)\n\n            # Perform edge swap\n            new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 241,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or promising potential\n    selected_idx = np.random.choice(len(archive), p=[1.0 / len(archive) for _ in range(len(archive))])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt with objective-aware edge selection\n    for _ in range(10):  # Limit iterations to balance exploration/exploitation\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate potential improvement across all three objectives\n        obj1_improvement = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n                          (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        obj2_improvement = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n                          (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        obj3_improvement = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]) - \\\n                          (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Apply the move if it improves at least one objective\n        if obj1_improvement < 0 or obj2_improvement < 0 or obj3_improvement < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additional diversification: random swap if no improvement found\n    if np.array_equal(new_solution, base_solution):\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8007869111604256,
            2.2527604579925535
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or promising potential\n    selected_idx = np.random.choice(len(archive), p=[1.0 / len(archive) for _ in range(len(archive))])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt with objective-aware edge selection\n    for _ in range(10):  # Limit iterations to balance exploration/exploitation\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate potential improvement across all three objectives\n        obj1_improvement = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n                          (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        obj2_improvement = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n                          (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        obj3_improvement = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]) - \\\n                          (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Apply the move if it improves at least one objective\n        if obj1_improvement < 0 or obj2_improvement < 0 or obj3_improvement < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additional diversification: random swap if no improvement found\n    if np.array_equal(new_solution, base_solution):\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 242,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    objectives = archive[selected_idx][1]\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # Perform 2-opt move for the first objective\n    i, j = sorted(np.random.choice(n_nodes, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: identify the worst objective and improve it\n    costs = [objectives[0], objectives[1], objectives[2]]\n    worst_obj = np.argmax(costs)\n\n    if worst_obj == 0:\n        # Improve first objective by swapping nodes with high distance in space 1\n        for _ in range(3):  # Try a few swaps\n            a, b = sorted(np.random.choice(n_nodes, 2, replace=False))\n            if distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]] > \\\n               distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    elif worst_obj == 1:\n        # Improve second objective by swapping nodes with high distance in space 2\n        for _ in range(3):\n            a, b = sorted(np.random.choice(n_nodes, 2, replace=False))\n            if distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]] > \\\n               distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    else:\n        # Improve third objective by swapping nodes with high distance in space 3\n        for _ in range(3):\n            a, b = sorted(np.random.choice(n_nodes, 2, replace=False))\n            if distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]] > \\\n               distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(set(new_solution)) != n_nodes:\n        # If invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6092456057293884,
            1.6690871834754943
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    objectives = archive[selected_idx][1]\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # Perform 2-opt move for the first objective\n    i, j = sorted(np.random.choice(n_nodes, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: identify the worst objective and improve it\n    costs = [objectives[0], objectives[1], objectives[2]]\n    worst_obj = np.argmax(costs)\n\n    if worst_obj == 0:\n        # Improve first objective by swapping nodes with high distance in space 1\n        for _ in range(3):  # Try a few swaps\n            a, b = sorted(np.random.choice(n_nodes, 2, replace=False))\n            if distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]] > \\\n               distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    elif worst_obj == 1:\n        # Improve second objective by swapping nodes with high distance in space 2\n        for _ in range(3):\n            a, b = sorted(np.random.choice(n_nodes, 2, replace=False))\n            if distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]] > \\\n               distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    else:\n        # Improve third objective by swapping nodes with high distance in space 3\n        for _ in range(3):\n            a, b = sorted(np.random.choice(n_nodes, 2, replace=False))\n            if distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]] > \\\n               distance_matrix_3[new_solution[a-1], new_solution[b]] + distance_matrix_3[new_solution[b-1], new_solution[a]]:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(set(new_solution)) != n_nodes:\n        # If invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 243,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    mean_objectives = np.mean(objectives, axis=0)\n    std_objectives = np.std(objectives, axis=0)\n    normalized_objectives = (objectives - mean_objectives) / (std_objectives + 1e-10)\n\n    # Calculate a score for each solution based on how \"spread out\" its objectives are\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt and edge insertion with objective-aware selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose a segment to perturb (2-opt or edge insertion)\n    if random.random() < 0.5:\n        # 2-opt: select two edges and reverse the segment between them\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Edge insertion: remove a node and reinsert it elsewhere\n        if n > 3:\n            k = random.randint(0, n-1)\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Fallback to a simple swap if the above operations cause issues\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6966862239036216,
            1.9626832485198975
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    mean_objectives = np.mean(objectives, axis=0)\n    std_objectives = np.std(objectives, axis=0)\n    normalized_objectives = (objectives - mean_objectives) / (std_objectives + 1e-10)\n\n    # Calculate a score for each solution based on how \"spread out\" its objectives are\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt and edge insertion with objective-aware selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose a segment to perturb (2-opt or edge insertion)\n    if random.random() < 0.5:\n        # 2-opt: select two edges and reverse the segment between them\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Edge insertion: remove a node and reinsert it elsewhere\n        if n > 3:\n            k = random.randint(0, n-1)\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Fallback to a simple swap if the above operations cause issues\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 244,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (prioritize those with higher costs)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select a random solution from the top 20% or top 5, whichever is larger\n        selection_pool = archive_sorted[:max(5, len(archive_sorted) // 5)]\n        selected_solution, _ = random.choice(selection_pool)\n    else:\n        selected_solution = archive[0][0]\n\n    new_solution = selected_solution.copy()\n\n    # Apply hybrid local search: 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Calculate current and potential costs for all three objectives\n        current_cost_1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        current_cost_2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        current_cost_3 = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n\n        potential_cost_1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n        potential_cost_2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n        potential_cost_3 = distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]\n\n        # Accept if at least one objective improves, or if no objective worsens significantly\n        if (potential_cost_1 < current_cost_1 or potential_cost_2 < current_cost_2 or potential_cost_3 < current_cost_3) or \\\n           (potential_cost_1 <= current_cost_1 * 1.05 and potential_cost_2 <= current_cost_2 * 1.05 and potential_cost_3 <= current_cost_3 * 1.05):\n            # Perform the swap\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6786068816082514,
            1.4041507244110107
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (prioritize those with higher costs)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select a random solution from the top 20% or top 5, whichever is larger\n        selection_pool = archive_sorted[:max(5, len(archive_sorted) // 5)]\n        selected_solution, _ = random.choice(selection_pool)\n    else:\n        selected_solution = archive[0][0]\n\n    new_solution = selected_solution.copy()\n\n    # Apply hybrid local search: 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Number of perturbation attempts\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Calculate current and potential costs for all three objectives\n        current_cost_1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        current_cost_2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        current_cost_3 = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n\n        potential_cost_1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n        potential_cost_2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n        potential_cost_3 = distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]\n\n        # Accept if at least one objective improves, or if no objective worsens significantly\n        if (potential_cost_1 < current_cost_1 or potential_cost_2 < current_cost_2 or potential_cost_3 < current_cost_3) or \\\n           (potential_cost_1 <= current_cost_1 * 1.05 and potential_cost_2 <= current_cost_2 * 1.05 and potential_cost_3 <= current_cost_3 * 1.05):\n            # Perform the swap\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 245,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (promising for improvement)\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: 3-opt with objective-aware edge selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct positions\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Calculate the cost change for each objective\n    def calculate_cost_change(sol, a, b, c):\n        # Original edges: (a-1, a), (b-1, b), (c-1, c)\n        # New edges: (a-1, b), (b-1, c), (c-1, a)\n        original_edges = [\n            (sol[a-1], sol[a]),\n            (sol[b-1], sol[b]),\n            (sol[c-1], sol[c])\n        ]\n        new_edges = [\n            (sol[a-1], sol[b]),\n            (sol[b-1], sol[c]),\n            (sol[c-1], sol[a])\n        ]\n\n        # Calculate cost change for each objective\n        cost_change = [0.0, 0.0, 0.0]\n        for (u, v), (x, y) in zip(original_edges, new_edges):\n            cost_change[0] += distance_matrix_1[x, y] - distance_matrix_1[u, v]\n            cost_change[1] += distance_matrix_2[x, y] - distance_matrix_2[u, v]\n            cost_change[2] += distance_matrix_3[x, y] - distance_matrix_3[u, v]\n\n        return cost_change\n\n    cost_change = calculate_cost_change(new_solution, i, j, k)\n\n    # Apply 3-opt if it improves at least one objective\n    if any(change < 0 for change in cost_change):\n        # Perform the 3-opt move\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Additional edge swap for multi-objective improvement\n    # Select two random edges and swap them if it improves the solution\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Verify the solution is still a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8112199921730981,
            1.3106088876724242
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (promising for improvement)\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: 3-opt with objective-aware edge selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct positions\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Calculate the cost change for each objective\n    def calculate_cost_change(sol, a, b, c):\n        # Original edges: (a-1, a), (b-1, b), (c-1, c)\n        # New edges: (a-1, b), (b-1, c), (c-1, a)\n        original_edges = [\n            (sol[a-1], sol[a]),\n            (sol[b-1], sol[b]),\n            (sol[c-1], sol[c])\n        ]\n        new_edges = [\n            (sol[a-1], sol[b]),\n            (sol[b-1], sol[c]),\n            (sol[c-1], sol[a])\n        ]\n\n        # Calculate cost change for each objective\n        cost_change = [0.0, 0.0, 0.0]\n        for (u, v), (x, y) in zip(original_edges, new_edges):\n            cost_change[0] += distance_matrix_1[x, y] - distance_matrix_1[u, v]\n            cost_change[1] += distance_matrix_2[x, y] - distance_matrix_2[u, v]\n            cost_change[2] += distance_matrix_3[x, y] - distance_matrix_3[u, v]\n\n        return cost_change\n\n    cost_change = calculate_cost_change(new_solution, i, j, k)\n\n    # Apply 3-opt if it improves at least one objective\n    if any(change < 0 for change in cost_change):\n        # Perform the 3-opt move\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Additional edge swap for multi-objective improvement\n    # Select two random edges and swap them if it improves the solution\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Verify the solution is still a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 246,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on a combination of objectives\n    def selection_criterion(solution_obj):\n        # Normalize objectives to avoid bias towards larger scales\n        obj1, obj2, obj3 = solution_obj\n        norm_obj1 = obj1 / (distance_matrix_1.sum() / len(distance_matrix_1))\n        norm_obj2 = obj2 / (distance_matrix_2.sum() / len(distance_matrix_2))\n        norm_obj3 = obj3 / (distance_matrix_3.sum() / len(distance_matrix_3))\n        # Combine objectives with weights to prioritize diversity\n        return 0.4 * norm_obj1 + 0.3 * norm_obj2 + 0.3 * norm_obj3\n\n    # Sort solutions by the selection criterion\n    archive.sort(key=lambda x: selection_criterion(x[1]))\n    # Select top 20% of solutions for further consideration\n    top_solutions = archive[:max(1, len(archive) // 5)]\n    # Randomly select one from top solutions\n    selected = random.choice(top_solutions)\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: combination of 2-opt and swap operations\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and swap\n    if random.random() < 0.7:  # Higher probability for 2-opt\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Swap operation\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility by checking for duplicates (shouldn't happen with proper implementation)\n    if len(set(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.5734666194975355,
            4.0468982577323915
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on a combination of objectives\n    def selection_criterion(solution_obj):\n        # Normalize objectives to avoid bias towards larger scales\n        obj1, obj2, obj3 = solution_obj\n        norm_obj1 = obj1 / (distance_matrix_1.sum() / len(distance_matrix_1))\n        norm_obj2 = obj2 / (distance_matrix_2.sum() / len(distance_matrix_2))\n        norm_obj3 = obj3 / (distance_matrix_3.sum() / len(distance_matrix_3))\n        # Combine objectives with weights to prioritize diversity\n        return 0.4 * norm_obj1 + 0.3 * norm_obj2 + 0.3 * norm_obj3\n\n    # Sort solutions by the selection criterion\n    archive.sort(key=lambda x: selection_criterion(x[1]))\n    # Select top 20% of solutions for further consideration\n    top_solutions = archive[:max(1, len(archive) // 5)]\n    # Randomly select one from top solutions\n    selected = random.choice(top_solutions)\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: combination of 2-opt and swap operations\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and swap\n    if random.random() < 0.7:  # Higher probability for 2-opt\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Swap operation\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility by checking for duplicates (shouldn't happen with proper implementation)\n    if len(set(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 247,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most promising solution based on a combination of objectives\n    # Here, we use a simple approach: select the solution with the lowest sum of objectives\n    # You can replace this with a more sophisticated selection criterion\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel 3-way exchange\n    n = len(new_solution)\n    if n < 4:\n        # If the tour is too small, perform a simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # With 70% probability, perform 2-opt\n        if np.random.rand() < 0.7:\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # With 30% probability, perform a novel 3-way exchange\n            # This operator selects three positions and performs a cyclic permutation\n            i, j, k = sorted(np.random.choice(n, 3, replace=False))\n            new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n    # Ensure the solution remains a valid tour\n    assert len(np.unique(new_solution)) == len(base_solution), \"Invalid tour generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.6390261451499919,
            1.658967876434326
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most promising solution based on a combination of objectives\n    # Here, we use a simple approach: select the solution with the lowest sum of objectives\n    # You can replace this with a more sophisticated selection criterion\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel 3-way exchange\n    n = len(new_solution)\n    if n < 4:\n        # If the tour is too small, perform a simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # With 70% probability, perform 2-opt\n        if np.random.rand() < 0.7:\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # With 30% probability, perform a novel 3-way exchange\n            # This operator selects three positions and performs a cyclic permutation\n            i, j, k = sorted(np.random.choice(n, 3, replace=False))\n            new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n    # Ensure the solution remains a valid tour\n    assert len(np.unique(new_solution)) == len(base_solution), \"Invalid tour generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 248,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        # Calculate the variance of each objective across the archive\n        variances = np.var(objectives, axis=0)\n        # Select solutions with high variance (potentially closer to the Pareto front)\n        high_variance_indices = np.where(variances > np.percentile(variances, 75))[0]\n        if len(high_variance_indices) > 0:\n            selected_idx = random.choice(high_variance_indices)\n            base_solution = archive[selected_idx][0].copy()\n        else:\n            base_solution = archive[random.randint(0, len(archive)-1)][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move to improve one objective\n    for _ in range(10):  # Limit the number of attempts to avoid excessive computation\n        i, j = sorted(random.sample(range(n), 2))\n        # Select the objective with the highest improvement potential\n        obj1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        obj2 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        if obj2 < obj1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, perform objective-aware swaps to balance the three objectives\n    for _ in range(10):\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta_obj1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                      distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                      distance_matrix_1[new_solution[j], new_solution[j]])\n\n        delta_obj2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                      distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                      distance_matrix_2[new_solution[j], new_solution[j]])\n\n        delta_obj3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] -\n                      distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                      distance_matrix_3[new_solution[j], new_solution[j]])\n\n        # If the swap improves at least one objective, accept it\n        if delta_obj1 < 0 or delta_obj2 < 0 or delta_obj3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7867858977480846,
            2.884713625907898
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        # Calculate the variance of each objective across the archive\n        variances = np.var(objectives, axis=0)\n        # Select solutions with high variance (potentially closer to the Pareto front)\n        high_variance_indices = np.where(variances > np.percentile(variances, 75))[0]\n        if len(high_variance_indices) > 0:\n            selected_idx = random.choice(high_variance_indices)\n            base_solution = archive[selected_idx][0].copy()\n        else:\n            base_solution = archive[random.randint(0, len(archive)-1)][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move to improve one objective\n    for _ in range(10):  # Limit the number of attempts to avoid excessive computation\n        i, j = sorted(random.sample(range(n), 2))\n        # Select the objective with the highest improvement potential\n        obj1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        obj2 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        if obj2 < obj1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, perform objective-aware swaps to balance the three objectives\n    for _ in range(10):\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta_obj1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                      distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                      distance_matrix_1[new_solution[j], new_solution[j]])\n\n        delta_obj2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                      distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                      distance_matrix_2[new_solution[j], new_solution[j]])\n\n        delta_obj3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] -\n                      distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                      distance_matrix_3[new_solution[j], new_solution[j]])\n\n        # If the swap improves at least one objective, accept it\n        if delta_obj1 < 0 or delta_obj2 < 0 or delta_obj3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 249,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution from the archive with a probability proportional to its potential for improvement\n    # Here, we use a simple roulette wheel selection based on the sum of the objectives\n    objectives = np.array([obj for _, obj in archive])\n    objective_sums = np.sum(objectives, axis=1)\n    min_sum = np.min(objective_sums)\n    max_sum = np.max(objective_sums)\n\n    # Normalize to avoid division by zero and give preference to solutions with lower sums\n    normalized = (max_sum - objective_sums) / (max_sum - min_sum + 1e-10)\n    probabilities = normalized / np.sum(normalized)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: a combination of 2-opt and edge exchange\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # Perform 2-opt on the objective with the highest current cost\n    current_objectives = archive[selected_idx][1]\n    obj_idx = np.argmax(current_objectives)\n\n    if obj_idx == 0:\n        distance_matrix = distance_matrix_1\n    elif obj_idx == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Find the best 2-opt move for the selected objective\n    best_improvement = 0\n    best_i, best_j = -1, -1\n\n    for i in range(n_nodes - 1):\n        for j in range(i + 2, n_nodes):\n            a, b = new_solution[i], new_solution[i + 1]\n            c, d = new_solution[j], new_solution[(j + 1) % n_nodes]\n\n            # Calculate the change in distance for the selected objective\n            delta = (distance_matrix[b, c] + distance_matrix[a, d]) - (distance_matrix[a, b] + distance_matrix[c, d])\n\n            if delta < best_improvement:\n                best_improvement = delta\n                best_i, best_j = i, j\n\n    if best_i != -1:\n        # Apply the 2-opt move\n        new_solution[best_i + 1:best_j + 1] = new_solution[best_i + 1:best_j + 1][::-1]\n\n    # Perform edge exchange to improve other objectives\n    # Select a random segment to exchange\n    segment_length = np.random.randint(2, min(5, n_nodes // 2))\n    start = np.random.randint(0, n_nodes - segment_length)\n\n    # Find the best exchange for the other two objectives\n    for obj_idx in range(3):\n        if obj_idx == np.argmax(current_objectives):\n            continue\n\n        if obj_idx == 0:\n            distance_matrix = distance_matrix_1\n        elif obj_idx == 1:\n            distance_matrix = distance_matrix_2\n        else:\n            distance_matrix = distance_matrix_3\n\n        best_improvement = 0\n        best_pos = -1\n\n        # Try inserting the segment at different positions\n        for pos in range(n_nodes):\n            if pos >= start and pos < start + segment_length:\n                continue\n\n            # Calculate the change in distance for this objective\n            a = new_solution[(start - 1) % n_nodes]\n            b = new_solution[start]\n            c = new_solution[(start + segment_length - 1) % n_nodes]\n            d = new_solution[(start + segment_length) % n_nodes]\n\n            if pos == 0:\n                x = new_solution[-1]\n                y = new_solution[0]\n            else:\n                x = new_solution[pos - 1]\n                y = new_solution[pos]\n\n            delta = (distance_matrix[a, c] + distance_matrix[b, d] +\n                     distance_matrix[x, b] + distance_matrix[c, y]) - \\\n                    (distance_matrix[a, b] + distance_matrix[c, d] +\n                     distance_matrix[x, c] + distance_matrix[b, y])\n\n            if delta < best_improvement:\n                best_improvement = delta\n                best_pos = pos\n\n        if best_pos != -1:\n            # Apply the edge exchange\n            segment = new_solution[start:start + segment_length]\n            new_solution = np.concatenate([\n                new_solution[:start],\n                new_solution[start + segment_length:]\n            ])\n            if best_pos == 0:\n                new_solution = np.concatenate([segment, new_solution])\n            else:\n                new_solution = np.concatenate([\n                    new_solution[:best_pos],\n                    segment,\n                    new_solution[best_pos:]\n                ])\n\n    return new_solution\n\n",
        "score": [
            -0.7613412002192737,
            3.8199782848358153
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution from the archive with a probability proportional to its potential for improvement\n    # Here, we use a simple roulette wheel selection based on the sum of the objectives\n    objectives = np.array([obj for _, obj in archive])\n    objective_sums = np.sum(objectives, axis=1)\n    min_sum = np.min(objective_sums)\n    max_sum = np.max(objective_sums)\n\n    # Normalize to avoid division by zero and give preference to solutions with lower sums\n    normalized = (max_sum - objective_sums) / (max_sum - min_sum + 1e-10)\n    probabilities = normalized / np.sum(normalized)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: a combination of 2-opt and edge exchange\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # Perform 2-opt on the objective with the highest current cost\n    current_objectives = archive[selected_idx][1]\n    obj_idx = np.argmax(current_objectives)\n\n    if obj_idx == 0:\n        distance_matrix = distance_matrix_1\n    elif obj_idx == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Find the best 2-opt move for the selected objective\n    best_improvement = 0\n    best_i, best_j = -1, -1\n\n    for i in range(n_nodes - 1):\n        for j in range(i + 2, n_nodes):\n            a, b = new_solution[i], new_solution[i + 1]\n            c, d = new_solution[j], new_solution[(j + 1) % n_nodes]\n\n            # Calculate the change in distance for the selected objective\n            delta = (distance_matrix[b, c] + distance_matrix[a, d]) - (distance_matrix[a, b] + distance_matrix[c, d])\n\n            if delta < best_improvement:\n                best_improvement = delta\n                best_i, best_j = i, j\n\n    if best_i != -1:\n        # Apply the 2-opt move\n        new_solution[best_i + 1:best_j + 1] = new_solution[best_i + 1:best_j + 1][::-1]\n\n    # Perform edge exchange to improve other objectives\n    # Select a random segment to exchange\n    segment_length = np.random.randint(2, min(5, n_nodes // 2))\n    start = np.random.randint(0, n_nodes - segment_length)\n\n    # Find the best exchange for the other two objectives\n    for obj_idx in range(3):\n        if obj_idx == np.argmax(current_objectives):\n            continue\n\n        if obj_idx == 0:\n            distance_matrix = distance_matrix_1\n        elif obj_idx == 1:\n            distance_matrix = distance_matrix_2\n        else:\n            distance_matrix = distance_matrix_3\n\n        best_improvement = 0\n        best_pos = -1\n\n        # Try inserting the segment at different positions\n        for pos in range(n_nodes):\n            if pos >= start and pos < start + segment_length:\n                continue\n\n            # Calculate the change in distance for this objective\n            a = new_solution[(start - 1) % n_nodes]\n            b = new_solution[start]\n            c = new_solution[(start + segment_length - 1) % n_nodes]\n            d = new_solution[(start + segment_length) % n_nodes]\n\n            if pos == 0:\n                x = new_solution[-1]\n                y = new_solution[0]\n            else:\n                x = new_solution[pos - 1]\n                y = new_solution[pos]\n\n            delta = (distance_matrix[a, c] + distance_matrix[b, d] +\n                     distance_matrix[x, b] + distance_matrix[c, y]) - \\\n                    (distance_matrix[a, b] + distance_matrix[c, d] +\n                     distance_matrix[x, c] + distance_matrix[b, y])\n\n            if delta < best_improvement:\n                best_improvement = delta\n                best_pos = pos\n\n        if best_pos != -1:\n            # Apply the edge exchange\n            segment = new_solution[start:start + segment_length]\n            new_solution = np.concatenate([\n                new_solution[:start],\n                new_solution[start + segment_length:]\n            ])\n            if best_pos == 0:\n                new_solution = np.concatenate([segment, new_solution])\n            else:\n                new_solution = np.concatenate([\n                    new_solution[:best_pos],\n                    segment,\n                    new_solution[best_pos:]\n                ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 250,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Make a copy of the selected solution\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a multi-objective aware move\n    n_nodes = len(new_solution)\n    i, j = np.random.choice(n_nodes, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Perform 2-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective aware move: select the best among several possible moves\n    candidates = []\n    for _ in range(3):  # Generate 3 candidate moves\n        candidate = new_solution.copy()\n        k, l = np.random.choice(n_nodes, size=2, replace=False)\n        k, l = min(k, l), max(k, l)\n        candidate[k:l+1] = candidate[k:l+1][::-1]\n        candidates.append(candidate)\n\n    # Evaluate candidates based on all three objectives\n    best_candidate = new_solution\n    best_score = float('inf')\n\n    for candidate in candidates:\n        # Calculate total distance for all three objectives\n        total_dist_1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n_nodes]] for i in range(n_nodes))\n        total_dist_2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n_nodes]] for i in range(n_nodes))\n        total_dist_3 = sum(distance_matrix_3[candidate[i], candidate[(i+1)%n_nodes]] for i in range(n_nodes))\n\n        # Combined score (simple sum of normalized distances)\n        # In a real implementation, you might use a more sophisticated approach like Pareto dominance\n        score = total_dist_1 + total_dist_2 + total_dist_3\n\n        if score < best_score:\n            best_score = score\n            best_candidate = candidate\n\n    return best_candidate\n\n",
        "score": [
            -0.6213431105679631,
            2.2222100138664245
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Make a copy of the selected solution\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a multi-objective aware move\n    n_nodes = len(new_solution)\n    i, j = np.random.choice(n_nodes, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Perform 2-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective aware move: select the best among several possible moves\n    candidates = []\n    for _ in range(3):  # Generate 3 candidate moves\n        candidate = new_solution.copy()\n        k, l = np.random.choice(n_nodes, size=2, replace=False)\n        k, l = min(k, l), max(k, l)\n        candidate[k:l+1] = candidate[k:l+1][::-1]\n        candidates.append(candidate)\n\n    # Evaluate candidates based on all three objectives\n    best_candidate = new_solution\n    best_score = float('inf')\n\n    for candidate in candidates:\n        # Calculate total distance for all three objectives\n        total_dist_1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n_nodes]] for i in range(n_nodes))\n        total_dist_2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n_nodes]] for i in range(n_nodes))\n        total_dist_3 = sum(distance_matrix_3[candidate[i], candidate[(i+1)%n_nodes]] for i in range(n_nodes))\n\n        # Combined score (simple sum of normalized distances)\n        # In a real implementation, you might use a more sophisticated approach like Pareto dominance\n        score = total_dist_1 + total_dist_2 + total_dist_3\n\n        if score < best_score:\n            best_score = score\n            best_candidate = candidate\n\n    return best_candidate\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 251,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel multi-objective edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt for the first objective\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == j:\n            continue\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Novel multi-objective edge swap\n    for _ in range(10):  # Limit iterations\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == j:\n            continue\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                 distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                 distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] -\n                 distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # If the swap improves at least one objective without worsening others significantly\n        if (delta1 <= 0 or delta2 <= 0 or delta3 <= 0) and not (delta1 > 0 and delta2 > 0 and delta3 > 0):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6968384608871804,
            2.8561434864997866
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel multi-objective edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt for the first objective\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == j:\n            continue\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Novel multi-objective edge swap\n    for _ in range(10):  # Limit iterations\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == j:\n            continue\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                 distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                 distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] -\n                 distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # If the swap improves at least one objective without worsening others significantly\n        if (delta1 <= 0 or delta2 <= 0 or delta3 <= 0) and not (delta1 > 0 and delta2 > 0 and delta3 > 0):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 252,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (ascending)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the middle 60% to avoid extreme solutions\n        selection_index = random.randint(len(archive_sorted) // 5, len(archive_sorted) * 4 // 5)\n        base_solution = archive_sorted[selection_index][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and node insertion\n    n = len(new_solution)\n    if n < 4:\n        # For very small tours, just swap two nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # With 70% probability, apply 2-opt\n        if random.random() < 0.7:\n            i, j = sorted(random.sample(range(n), 2))\n            # Reverse the segment between i and j\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # With 30% probability, apply node insertion\n            i = random.randint(0, n-1)\n            node = new_solution[i]\n            # Remove the node and insert it at a random position\n            new_solution = np.delete(new_solution, i)\n            insert_pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains feasible\n    assert len(new_solution) == len(base_solution) and len(set(new_solution)) == len(base_solution), \"Generated solution is not feasible\"\n\n    return new_solution\n\n",
        "score": [
            -0.7233846935110406,
            1.522333574295044
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (ascending)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the middle 60% to avoid extreme solutions\n        selection_index = random.randint(len(archive_sorted) // 5, len(archive_sorted) * 4 // 5)\n        base_solution = archive_sorted[selection_index][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and node insertion\n    n = len(new_solution)\n    if n < 4:\n        # For very small tours, just swap two nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # With 70% probability, apply 2-opt\n        if random.random() < 0.7:\n            i, j = sorted(random.sample(range(n), 2))\n            # Reverse the segment between i and j\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # With 30% probability, apply node insertion\n            i = random.randint(0, n-1)\n            node = new_solution[i]\n            # Remove the node and insert it at a random position\n            new_solution = np.delete(new_solution, i)\n            insert_pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains feasible\n    assert len(new_solution) == len(base_solution) and len(set(new_solution)) == len(base_solution), \"Generated solution is not feasible\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 253,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest sum of objectives)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt and objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a random 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform objective-aware swaps based on the most critical objective\n    objectives = archive_sorted[0][1]\n    critical_obj = objectives.index(max(objectives))  # Identify the most critical objective\n\n    # Find the worst edge in the critical objective space\n    worst_edge = None\n    max_distance = -1\n    for k in range(n):\n        u, v = new_solution[k], new_solution[(k+1)%n]\n        if critical_obj == 0:\n            dist = distance_matrix_1[u, v]\n        elif critical_obj == 1:\n            dist = distance_matrix_2[u, v]\n        else:\n            dist = distance_matrix_3[u, v]\n\n        if dist > max_distance:\n            max_distance = dist\n            worst_edge = k\n\n    # Perform a swap that improves the worst edge in the critical objective space\n    if worst_edge is not None:\n        u, v = new_solution[worst_edge], new_solution[(worst_edge+1)%n]\n        # Find the best possible replacement for this edge\n        best_replacement = None\n        min_dist = float('inf')\n        for a in range(n):\n            for b in range(a+1, n):\n                if a == worst_edge or b == worst_edge or a == (worst_edge+1)%n or b == (worst_edge+1)%n:\n                    continue\n                if critical_obj == 0:\n                    dist = distance_matrix_1[new_solution[a], new_solution[b]]\n                elif critical_obj == 1:\n                    dist = distance_matrix_2[new_solution[a], new_solution[b]]\n                else:\n                    dist = distance_matrix_3[new_solution[a], new_solution[b]]\n                if dist < min_dist:\n                    min_dist = dist\n                    best_replacement = (a, b)\n\n        if best_replacement is not None:\n            a, b = best_replacement\n            # Perform the swap\n            new_solution[worst_edge] = new_solution[a]\n            new_solution[(worst_edge+1)%n] = new_solution[b]\n\n    return new_solution\n\n",
        "score": [
            -0.66877449039212,
            0.7469487428665161
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest sum of objectives)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt and objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a random 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform objective-aware swaps based on the most critical objective\n    objectives = archive_sorted[0][1]\n    critical_obj = objectives.index(max(objectives))  # Identify the most critical objective\n\n    # Find the worst edge in the critical objective space\n    worst_edge = None\n    max_distance = -1\n    for k in range(n):\n        u, v = new_solution[k], new_solution[(k+1)%n]\n        if critical_obj == 0:\n            dist = distance_matrix_1[u, v]\n        elif critical_obj == 1:\n            dist = distance_matrix_2[u, v]\n        else:\n            dist = distance_matrix_3[u, v]\n\n        if dist > max_distance:\n            max_distance = dist\n            worst_edge = k\n\n    # Perform a swap that improves the worst edge in the critical objective space\n    if worst_edge is not None:\n        u, v = new_solution[worst_edge], new_solution[(worst_edge+1)%n]\n        # Find the best possible replacement for this edge\n        best_replacement = None\n        min_dist = float('inf')\n        for a in range(n):\n            for b in range(a+1, n):\n                if a == worst_edge or b == worst_edge or a == (worst_edge+1)%n or b == (worst_edge+1)%n:\n                    continue\n                if critical_obj == 0:\n                    dist = distance_matrix_1[new_solution[a], new_solution[b]]\n                elif critical_obj == 1:\n                    dist = distance_matrix_2[new_solution[a], new_solution[b]]\n                else:\n                    dist = distance_matrix_3[new_solution[a], new_solution[b]]\n                if dist < min_dist:\n                    min_dist = dist\n                    best_replacement = (a, b)\n\n        if best_replacement is not None:\n            a, b = best_replacement\n            # Perform the swap\n            new_solution[worst_edge] = new_solution[a]\n            new_solution[(worst_edge+1)%n] = new_solution[b]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 254,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with the highest diversity or worst objectives)\n    # Here we select the solution with the worst combined objective value\n    def combined_objective(obj):\n        return sum(obj)\n\n    worst_solution = max(archive, key=lambda x: combined_objective(x[1]))\n    base_solution = worst_solution[0].copy()\n\n    # Hybrid local search: combine 2-opt with a multi-objective aware swap\n    new_solution = base_solution.copy()\n\n    # First, perform a 2-opt move to improve the worst objective\n    worst_obj_idx = np.argmax(worst_solution[1])\n    if worst_obj_idx == 0:\n        distance_matrix = distance_matrix_1\n    elif worst_obj_idx == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    n = len(new_solution)\n    best_improvement = 0\n    best_i, best_j, best_k, best_l = 0, 0, 0, 0\n\n    # Find the best 2-opt move for the worst objective\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            # Current edges: (i, i+1) and (j, j+1)\n            a, b = new_solution[i], new_solution[(i + 1) % n]\n            c, d = new_solution[j], new_solution[(j + 1) % n]\n\n            # Possible new edges: (i, j) and (i+1, j+1)\n            new_edges = [\n                (a, c), (b, d),  # Original: (a,b) and (c,d)\n                (a, d), (b, c)    # Reversed: (a,d) and (b,c)\n            ]\n\n            # Calculate improvement for the worst objective\n            original_cost = distance_matrix[a, b] + distance_matrix[c, d]\n            reversed_cost = distance_matrix[a, d] + distance_matrix[b, c]\n            improvement = original_cost - reversed_cost\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_i, best_j = i, j\n\n    if best_improvement > 0:\n        # Perform the 2-opt move\n        i, j = best_i, best_j\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Then perform a multi-objective aware swap to balance the objectives\n    # Select two random positions to swap\n    i, j = np.random.choice(len(new_solution), 2, replace=False)\n\n    # Calculate the change in objectives\n    a, b = new_solution[i], new_solution[j]\n\n    # Original edges: (i-1, i), (i, i+1), (j-1, j), (j, j+1)\n    # After swap: (i-1, j), (j, i+1), (j-1, i), (i, j+1)\n\n    # Calculate the change in each objective\n    def calculate_change(matrix):\n        original = (\n            matrix[new_solution[i-1], a] + matrix[a, new_solution[(i+1)%n]] +\n            matrix[new_solution[j-1], b] + matrix[b, new_solution[(j+1)%n]]\n        )\n        swapped = (\n            matrix[new_solution[i-1], b] + matrix[b, new_solution[(i+1)%n]] +\n            matrix[new_solution[j-1], a] + matrix[a, new_solution[(j+1)%n]]\n        )\n        return original - swapped\n\n    change_1 = calculate_change(distance_matrix_1)\n    change_2 = calculate_change(distance_matrix_2)\n    change_3 = calculate_change(distance_matrix_3)\n\n    # Only perform the swap if it improves at least one objective\n    if change_1 > 0 or change_2 > 0 or change_3 > 0:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6823241024484498,
            2.6100924253463744
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with the highest diversity or worst objectives)\n    # Here we select the solution with the worst combined objective value\n    def combined_objective(obj):\n        return sum(obj)\n\n    worst_solution = max(archive, key=lambda x: combined_objective(x[1]))\n    base_solution = worst_solution[0].copy()\n\n    # Hybrid local search: combine 2-opt with a multi-objective aware swap\n    new_solution = base_solution.copy()\n\n    # First, perform a 2-opt move to improve the worst objective\n    worst_obj_idx = np.argmax(worst_solution[1])\n    if worst_obj_idx == 0:\n        distance_matrix = distance_matrix_1\n    elif worst_obj_idx == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    n = len(new_solution)\n    best_improvement = 0\n    best_i, best_j, best_k, best_l = 0, 0, 0, 0\n\n    # Find the best 2-opt move for the worst objective\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            # Current edges: (i, i+1) and (j, j+1)\n            a, b = new_solution[i], new_solution[(i + 1) % n]\n            c, d = new_solution[j], new_solution[(j + 1) % n]\n\n            # Possible new edges: (i, j) and (i+1, j+1)\n            new_edges = [\n                (a, c), (b, d),  # Original: (a,b) and (c,d)\n                (a, d), (b, c)    # Reversed: (a,d) and (b,c)\n            ]\n\n            # Calculate improvement for the worst objective\n            original_cost = distance_matrix[a, b] + distance_matrix[c, d]\n            reversed_cost = distance_matrix[a, d] + distance_matrix[b, c]\n            improvement = original_cost - reversed_cost\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_i, best_j = i, j\n\n    if best_improvement > 0:\n        # Perform the 2-opt move\n        i, j = best_i, best_j\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Then perform a multi-objective aware swap to balance the objectives\n    # Select two random positions to swap\n    i, j = np.random.choice(len(new_solution), 2, replace=False)\n\n    # Calculate the change in objectives\n    a, b = new_solution[i], new_solution[j]\n\n    # Original edges: (i-1, i), (i, i+1), (j-1, j), (j, j+1)\n    # After swap: (i-1, j), (j, i+1), (j-1, i), (i, j+1)\n\n    # Calculate the change in each objective\n    def calculate_change(matrix):\n        original = (\n            matrix[new_solution[i-1], a] + matrix[a, new_solution[(i+1)%n]] +\n            matrix[new_solution[j-1], b] + matrix[b, new_solution[(j+1)%n]]\n        )\n        swapped = (\n            matrix[new_solution[i-1], b] + matrix[b, new_solution[(i+1)%n]] +\n            matrix[new_solution[j-1], a] + matrix[a, new_solution[(j+1)%n]]\n        )\n        return original - swapped\n\n    change_1 = calculate_change(distance_matrix_1)\n    change_2 = calculate_change(distance_matrix_2)\n    change_3 = calculate_change(distance_matrix_3)\n\n    # Only perform the swap if it improves at least one objective\n    if change_1 > 0 or change_2 > 0 or change_3 > 0:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 255,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with high diversity or near Pareto front)\n    selected_idx = random.choices(range(len(archive)), weights=[1/len(archive) for _ in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and node swapping\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No meaningful improvement possible\n\n    # 2-opt move (for improving all three objectives)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Node swapping (for fine-tuning)\n    if random.random() < 0.5:  # 50% chance to perform node swap\n        k, l = sorted(random.sample(range(n), 2))\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8179654778166929,
            1.4325498461723327
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with high diversity or near Pareto front)\n    selected_idx = random.choices(range(len(archive)), weights=[1/len(archive) for _ in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and node swapping\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No meaningful improvement possible\n\n    # 2-opt move (for improving all three objectives)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Node swapping (for fine-tuning)\n    if random.random() < 0.5:  # 50% chance to perform node swap\n        k, l = sorted(random.sample(range(n), 2))\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 256,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by the sum of objectives (worst first)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select from top 30% to promote diversity\n        top_k = max(1, int(len(archive_sorted) * 0.3))\n        selected_idx = random.randint(0, top_k - 1)\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations for better exploration\n        # Randomly select two distinct edges to swap (2-opt)\n        i, j = sorted(random.sample(range(1, n), 2))\n        if i != j:\n            # Apply 2-opt move\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Objective-aware swap: identify and swap nodes that improve at least one objective\n        for _ in range(3):  # Try multiple swaps\n            a, b = random.sample(range(n), 2)\n            if a == b:\n                continue\n\n            # Calculate current and potential new costs\n            current_costs = [\n                distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                distance_matrix_1[new_solution[b-1], new_solution[b]],\n                distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                distance_matrix_2[new_solution[b-1], new_solution[b]],\n                distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                distance_matrix_3[new_solution[b-1], new_solution[b]]\n            ]\n\n            potential_costs = [\n                distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                distance_matrix_1[new_solution[b-1], new_solution[a]],\n                distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                distance_matrix_2[new_solution[b-1], new_solution[a]],\n                distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                distance_matrix_3[new_solution[b-1], new_solution[a]]\n            ]\n\n            # Count how many objectives would improve\n            improvements = sum(1 for c, p in zip(current_costs, potential_costs) if p < c)\n\n            # Accept the swap if it improves at least one objective\n            if improvements > 0:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.6920566365263169,
            2.231120538711548
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by the sum of objectives (worst first)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select from top 30% to promote diversity\n        top_k = max(1, int(len(archive_sorted) * 0.3))\n        selected_idx = random.randint(0, top_k - 1)\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations for better exploration\n        # Randomly select two distinct edges to swap (2-opt)\n        i, j = sorted(random.sample(range(1, n), 2))\n        if i != j:\n            # Apply 2-opt move\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Objective-aware swap: identify and swap nodes that improve at least one objective\n        for _ in range(3):  # Try multiple swaps\n            a, b = random.sample(range(n), 2)\n            if a == b:\n                continue\n\n            # Calculate current and potential new costs\n            current_costs = [\n                distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                distance_matrix_1[new_solution[b-1], new_solution[b]],\n                distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                distance_matrix_2[new_solution[b-1], new_solution[b]],\n                distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                distance_matrix_3[new_solution[b-1], new_solution[b]]\n            ]\n\n            potential_costs = [\n                distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                distance_matrix_1[new_solution[b-1], new_solution[a]],\n                distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                distance_matrix_2[new_solution[b-1], new_solution[a]],\n                distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                distance_matrix_3[new_solution[b-1], new_solution[a]]\n            ]\n\n            # Count how many objectives would improve\n            improvements = sum(1 for c, p in zip(current_costs, potential_costs) if p < c)\n\n            # Accept the swap if it improves at least one objective\n            if improvements > 0:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 257,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distances for all solutions in the archive\n        objectives = np.array([obj for _, obj in archive])\n        crowding_distances = np.zeros(len(archive))\n\n        for m in range(3):  # For each objective\n            sorted_indices = np.argsort(objectives[:, m])\n            crowding_distances[sorted_indices[0]] = np.inf\n            crowding_distances[sorted_indices[-1]] = np.inf\n            for i in range(1, len(archive) - 1):\n                if objectives[sorted_indices[-1], m] == objectives[sorted_indices[0], m]:\n                    continue\n                crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m])\n\n        # Select the solution with the highest crowding distance\n        selected_idx = np.argmax(crowding_distances)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    # 1. Randomly select a segment of the tour\n    n = len(new_solution)\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, min(start + n // 3, n - 1))\n\n    # 2. Reverse the selected segment (2-opt)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # 3. Apply a 3-opt move to further improve the solution\n    if n >= 6:\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Perform 3-opt move\n        new_segment = np.concatenate([new_solution[i:j], new_solution[j:k], new_solution[k:i]])\n        new_solution[i:k] = new_segment\n\n    # 4. Randomly swap two nodes to introduce diversity\n    if n >= 2:\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.6452673055582323,
            3.280551815032959
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distances for all solutions in the archive\n        objectives = np.array([obj for _, obj in archive])\n        crowding_distances = np.zeros(len(archive))\n\n        for m in range(3):  # For each objective\n            sorted_indices = np.argsort(objectives[:, m])\n            crowding_distances[sorted_indices[0]] = np.inf\n            crowding_distances[sorted_indices[-1]] = np.inf\n            for i in range(1, len(archive) - 1):\n                if objectives[sorted_indices[-1], m] == objectives[sorted_indices[0], m]:\n                    continue\n                crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m])\n\n        # Select the solution with the highest crowding distance\n        selected_idx = np.argmax(crowding_distances)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    # 1. Randomly select a segment of the tour\n    n = len(new_solution)\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, min(start + n // 3, n - 1))\n\n    # 2. Reverse the selected segment (2-opt)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # 3. Apply a 3-opt move to further improve the solution\n    if n >= 6:\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Perform 3-opt move\n        new_segment = np.concatenate([new_solution[i:j], new_solution[j:k], new_solution[k:i]])\n        new_solution[i:k] = new_segment\n\n    # 4. Randomly swap two nodes to introduce diversity\n    if n >= 2:\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 258,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    from math import sqrt\n\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest objective values)\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_idx = min(3, len(archive) - 1)  # Select among top 3 or all if less than 3\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator combining 2-opt and edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt or edge insertion\n    if random.random() < 0.5:\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Edge insertion with objective-aware selection\n        # Calculate edge costs across all objectives\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        # Find edges with high potential for improvement\n        edges = []\n        for i in range(n):\n            a, b = new_solution[i], new_solution[(i+1)%n]\n            cost = edge_cost(a, b)\n            edges.append((cost, i))\n\n        # Sort edges by their potential improvement (sum of costs)\n        edges.sort(key=lambda x: sum(x[0]))\n        worst_edge_idx = edges[-1][1] if len(edges) > 1 else 0\n\n        # Remove the worst edge and insert it elsewhere\n        a, b = new_solution[worst_edge_idx], new_solution[(worst_edge_idx+1)%n]\n        new_solution = np.delete(new_solution, worst_edge_idx)\n        insert_pos = random.randint(0, len(new_solution))\n\n        # Ensure the solution remains valid\n        if insert_pos == 0:\n            new_solution = np.concatenate([[a], new_solution])\n        else:\n            new_solution = np.insert(new_solution, insert_pos, a)\n\n    return new_solution\n\n",
        "score": [
            -0.6489381044296058,
            1.851432490348816
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    from math import sqrt\n\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest objective values)\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_idx = min(3, len(archive) - 1)  # Select among top 3 or all if less than 3\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator combining 2-opt and edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt or edge insertion\n    if random.random() < 0.5:\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Edge insertion with objective-aware selection\n        # Calculate edge costs across all objectives\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        # Find edges with high potential for improvement\n        edges = []\n        for i in range(n):\n            a, b = new_solution[i], new_solution[(i+1)%n]\n            cost = edge_cost(a, b)\n            edges.append((cost, i))\n\n        # Sort edges by their potential improvement (sum of costs)\n        edges.sort(key=lambda x: sum(x[0]))\n        worst_edge_idx = edges[-1][1] if len(edges) > 1 else 0\n\n        # Remove the worst edge and insert it elsewhere\n        a, b = new_solution[worst_edge_idx], new_solution[(worst_edge_idx+1)%n]\n        new_solution = np.delete(new_solution, worst_edge_idx)\n        insert_pos = random.randint(0, len(new_solution))\n\n        # Ensure the solution remains valid\n        if insert_pos == 0:\n            new_solution = np.concatenate([[a], new_solution])\n        else:\n            new_solution = np.insert(new_solution, insert_pos, a)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 259,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    selected_idx = np.argmax(diversity)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # 1. Random 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # 2. Inversion with multi-objective evaluation\n    for _ in range(2):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[a:b]\n\n        # Evaluate original and inverted segment\n        original_cost = (\n            sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1)),\n            sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1)),\n            sum(distance_matrix_3[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        )\n\n        inverted_cost = (\n            sum(distance_matrix_1[segment[i+1], segment[i]] for i in range(len(segment)-1)),\n            sum(distance_matrix_2[segment[i+1], segment[i]] for i in range(len(segment)-1)),\n            sum(distance_matrix_3[segment[i+1], segment[i]] for i in range(len(segment)-1))\n        )\n\n        # Accept if any objective improves\n        if any(o_inv < o_orig for o_inv, o_orig in zip(inverted_cost, original_cost)):\n            new_solution[a:b] = segment[::-1]\n\n    # 3. Multi-objective edge swap\n    for _ in range(3):\n        i = np.random.randint(n)\n        j = np.random.randint(n)\n        if i == j:\n            continue\n\n        # Evaluate original and swapped edges\n        original_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j-1], new_solution[j]]\n        )\n\n        swapped_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_1[new_solution[j-1], new_solution[i]],\n            distance_matrix_2[new_solution[i-1], new_solution[j]] +\n            distance_matrix_2[new_solution[j-1], new_solution[i]],\n            distance_matrix_3[new_solution[i-1], new_solution[j]] +\n            distance_matrix_3[new_solution[j-1], new_solution[i]]\n        )\n\n        # Accept if any objective improves\n        if any(s_inv < s_orig for s_inv, s_orig in zip(swapped_cost, original_cost)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7022278269615775,
            2.1670850038528444
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    selected_idx = np.argmax(diversity)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # 1. Random 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # 2. Inversion with multi-objective evaluation\n    for _ in range(2):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[a:b]\n\n        # Evaluate original and inverted segment\n        original_cost = (\n            sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1)),\n            sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1)),\n            sum(distance_matrix_3[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        )\n\n        inverted_cost = (\n            sum(distance_matrix_1[segment[i+1], segment[i]] for i in range(len(segment)-1)),\n            sum(distance_matrix_2[segment[i+1], segment[i]] for i in range(len(segment)-1)),\n            sum(distance_matrix_3[segment[i+1], segment[i]] for i in range(len(segment)-1))\n        )\n\n        # Accept if any objective improves\n        if any(o_inv < o_orig for o_inv, o_orig in zip(inverted_cost, original_cost)):\n            new_solution[a:b] = segment[::-1]\n\n    # 3. Multi-objective edge swap\n    for _ in range(3):\n        i = np.random.randint(n)\n        j = np.random.randint(n)\n        if i == j:\n            continue\n\n        # Evaluate original and swapped edges\n        original_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j-1], new_solution[j]]\n        )\n\n        swapped_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_1[new_solution[j-1], new_solution[i]],\n            distance_matrix_2[new_solution[i-1], new_solution[j]] +\n            distance_matrix_2[new_solution[j-1], new_solution[i]],\n            distance_matrix_3[new_solution[i-1], new_solution[j]] +\n            distance_matrix_3[new_solution[j-1], new_solution[i]]\n        )\n\n        # Accept if any objective improves\n        if any(s_inv < s_orig for s_inv, s_orig in zip(swapped_cost, original_cost)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 260,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement by choosing the one with the highest variance in objectives\n    objectives = np.array([obj for (sol, obj) in archive])\n    variances = np.var(objectives, axis=0)\n    weighted_scores = variances * np.random.rand(3)  # Random weights to add stochasticity\n    selected_idx = np.argmax(np.sum(weighted_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine 2-opt with a multi-objective aware swap\n    for _ in range(2):  # Perform multiple iterations for better exploration\n        # Randomly select two distinct edges to break\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # 2-opt move (swap edges)\n        if i != j and k != l:\n            # Create new solution by reversing the segment between i and j\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = np.flip(temp_solution[i:j+1])\n\n            # Evaluate the new solution's objectives\n            temp_obj = (\n                sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n)),\n                sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n)),\n                sum(distance_matrix_3[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n            )\n\n            # Multi-objective aware swap: if the new solution is better in at least one objective, accept it\n            current_obj = (\n                sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n                sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n                sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n            )\n\n            if any(temp_obj[obj_idx] < current_obj[obj_idx] for obj_idx in range(3)):\n                new_solution = temp_solution\n\n        # Multi-objective swap: swap nodes based on the objective with highest variance\n        obj_idx_to_optimize = np.argmax(np.var(objectives, axis=0))\n        m, p = sorted(np.random.choice(n, 2, replace=False))\n        temp_solution = new_solution.copy()\n        temp_solution[m], temp_solution[p] = temp_solution[p], temp_solution[m]\n\n        # Evaluate the new solution's objectives\n        temp_obj = (\n            sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_3[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        )\n\n        # Accept if better in the selected objective\n        if temp_obj[obj_idx_to_optimize] < current_obj[obj_idx_to_optimize]:\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7236395981892292,
            3.427205538749695
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement by choosing the one with the highest variance in objectives\n    objectives = np.array([obj for (sol, obj) in archive])\n    variances = np.var(objectives, axis=0)\n    weighted_scores = variances * np.random.rand(3)  # Random weights to add stochasticity\n    selected_idx = np.argmax(np.sum(weighted_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine 2-opt with a multi-objective aware swap\n    for _ in range(2):  # Perform multiple iterations for better exploration\n        # Randomly select two distinct edges to break\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # 2-opt move (swap edges)\n        if i != j and k != l:\n            # Create new solution by reversing the segment between i and j\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = np.flip(temp_solution[i:j+1])\n\n            # Evaluate the new solution's objectives\n            temp_obj = (\n                sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n)),\n                sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n)),\n                sum(distance_matrix_3[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n            )\n\n            # Multi-objective aware swap: if the new solution is better in at least one objective, accept it\n            current_obj = (\n                sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n                sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n                sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n            )\n\n            if any(temp_obj[obj_idx] < current_obj[obj_idx] for obj_idx in range(3)):\n                new_solution = temp_solution\n\n        # Multi-objective swap: swap nodes based on the objective with highest variance\n        obj_idx_to_optimize = np.argmax(np.var(objectives, axis=0))\n        m, p = sorted(np.random.choice(n, 2, replace=False))\n        temp_solution = new_solution.copy()\n        temp_solution[m], temp_solution[p] = temp_solution[p], temp_solution[m]\n\n        # Evaluate the new solution's objectives\n        temp_obj = (\n            sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_3[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        )\n\n        # Accept if better in the selected objective\n        if temp_obj[obj_idx_to_optimize] < current_obj[obj_idx_to_optimize]:\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 261,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already locally optimal)\n    # Here, we select the solution with the highest combined objective value (for diversification)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy:\n    # 1. Apply a 2-opt move (for standard TSP improvement)\n    # 2. Apply a multi-objective edge swap (considering all three objectives)\n\n    # Step 1: 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Multi-objective edge swap\n    # Select two random edges and swap them if it improves at least one objective\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n    if k != l:\n        # Calculate current and potential costs for all three objectives\n        current_costs = [\n            sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        ]\n\n        # Create potential solution with edge swap\n        temp_solution = new_solution.copy()\n        temp_solution[k], temp_solution[l] = temp_solution[l], temp_solution[k]\n\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_3[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        ]\n\n        # Accept if at least one objective improves\n        if any(new < current for new, current in zip(new_costs, current_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.6567011502840694,
            1.8426436543464662
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already locally optimal)\n    # Here, we select the solution with the highest combined objective value (for diversification)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy:\n    # 1. Apply a 2-opt move (for standard TSP improvement)\n    # 2. Apply a multi-objective edge swap (considering all three objectives)\n\n    # Step 1: 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Multi-objective edge swap\n    # Select two random edges and swap them if it improves at least one objective\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n    if k != l:\n        # Calculate current and potential costs for all three objectives\n        current_costs = [\n            sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        ]\n\n        # Create potential solution with edge swap\n        temp_solution = new_solution.copy()\n        temp_solution[k], temp_solution[l] = temp_solution[l], temp_solution[k]\n\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_3[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        ]\n\n        # Accept if at least one objective improves\n        if any(new < current for new, current in zip(new_costs, current_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 262,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_solution = archive[0][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with multi-objective consideration\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to perturb\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j+1]\n\n    # Reverse the segment to create a 2-opt move\n    new_segment = segment[::-1]\n\n    # Calculate the change in objectives\n    def calculate_objective_change(solution):\n        cost1 = sum(distance_matrix_1[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n        cost2 = sum(distance_matrix_2[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n        cost3 = sum(distance_matrix_3[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_3[solution[-1], solution[0]]\n        return (cost1, cost2, cost3)\n\n    current_obj = calculate_objective_change(new_solution)\n    temp_solution = new_solution.copy()\n    temp_solution[i:j+1] = new_segment\n    new_obj = calculate_objective_change(temp_solution)\n\n    # Accept the move if it doesn't dominate the current solution in any objective\n    if not any(new_obj[k] > current_obj[k] for k in range(3)):\n        new_solution = temp_solution\n\n    # Apply a second move: swap two random nodes\n    k, l = random.sample(range(n), 2)\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7084205161560692,
            1.9144734025001526
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_solution = archive[0][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with multi-objective consideration\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to perturb\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j+1]\n\n    # Reverse the segment to create a 2-opt move\n    new_segment = segment[::-1]\n\n    # Calculate the change in objectives\n    def calculate_objective_change(solution):\n        cost1 = sum(distance_matrix_1[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n        cost2 = sum(distance_matrix_2[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n        cost3 = sum(distance_matrix_3[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_3[solution[-1], solution[0]]\n        return (cost1, cost2, cost3)\n\n    current_obj = calculate_objective_change(new_solution)\n    temp_solution = new_solution.copy()\n    temp_solution[i:j+1] = new_segment\n    new_obj = calculate_objective_change(temp_solution)\n\n    # Accept the move if it doesn't dominate the current solution in any objective\n    if not any(new_obj[k] > current_obj[k] for k in range(3)):\n        new_solution = temp_solution\n\n    # Apply a second move: swap two random nodes\n    k, l = random.sample(range(n), 2)\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 263,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a combination of objectives and diversity\n    def selection_criteria(sol_obj_pair):\n        sol, obj = sol_obj_pair\n        # Combine objectives with weights to balance the selection\n        weighted_score = 0.4 * obj[0] + 0.3 * obj[1] + 0.3 * obj[2]\n        # Add a small random factor to encourage exploration\n        weighted_score += 0.01 * random.random()\n        return weighted_score\n\n    # Select the solution with the best combined score\n    selected = min(archive, key=selection_criteria)\n    base_solution = selected[0].copy()\n\n    # Hybrid local search operator: combine 2-opt and 3-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Determine the type of local search to apply\n    search_type = random.choice(['2opt', '3opt', 'objective_swap'])\n\n    if search_type == '2opt':\n        # Standard 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif search_type == '3opt':\n        # Standard 3-opt local search\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n        new_solution[i:k+1] = np.concatenate([segment1[::-1], segment2[::-1]])\n\n    else:  # objective_swap\n        # Objective-aware swap: identify the worst-performing segment in any objective\n        # and try to improve it by swapping with a better segment\n        def calculate_segment_cost(solution):\n            cost1 = sum(distance_matrix_1[solution[i-1], solution[i]] for i in range(len(solution)))\n            cost2 = sum(distance_matrix_2[solution[i-1], solution[i]] for i in range(len(solution)))\n            cost3 = sum(distance_matrix_3[solution[i-1], solution[i]] for i in range(len(solution)))\n            return (cost1, cost2, cost3)\n\n        # Find the worst-performing segment in any objective\n        current_costs = calculate_segment_cost(base_solution)\n        worst_obj = np.argmax(current_costs)\n\n        # Select a random segment to compare\n        seg_length = random.randint(3, min(10, n//2))\n        start = random.randint(0, n - seg_length)\n        end = start + seg_length\n        segment = base_solution[start:end]\n\n        # Find the best position to insert this segment to improve the worst objective\n        best_insert_pos = -1\n        best_improvement = 0\n\n        for pos in range(n):\n            if pos >= start and pos <= end:\n                continue  # Skip the original position\n\n            # Try inserting the segment at this position\n            temp_solution = np.concatenate([\n                base_solution[:pos],\n                segment,\n                base_solution[pos:start],\n                base_solution[end:]\n            ])\n\n            temp_costs = calculate_segment_cost(temp_solution)\n            improvement = current_costs[worst_obj] - temp_costs[worst_obj]\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_insert_pos = pos\n\n        if best_insert_pos != -1:\n            # Apply the best improvement found\n            new_solution = np.concatenate([\n                base_solution[:best_insert_pos],\n                segment,\n                base_solution[best_insert_pos:start],\n                base_solution[end:]\n            ])\n\n    return new_solution\n\n",
        "score": [
            -0.6005271613311575,
            3.2305857658386232
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a combination of objectives and diversity\n    def selection_criteria(sol_obj_pair):\n        sol, obj = sol_obj_pair\n        # Combine objectives with weights to balance the selection\n        weighted_score = 0.4 * obj[0] + 0.3 * obj[1] + 0.3 * obj[2]\n        # Add a small random factor to encourage exploration\n        weighted_score += 0.01 * random.random()\n        return weighted_score\n\n    # Select the solution with the best combined score\n    selected = min(archive, key=selection_criteria)\n    base_solution = selected[0].copy()\n\n    # Hybrid local search operator: combine 2-opt and 3-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Determine the type of local search to apply\n    search_type = random.choice(['2opt', '3opt', 'objective_swap'])\n\n    if search_type == '2opt':\n        # Standard 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif search_type == '3opt':\n        # Standard 3-opt local search\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n        new_solution[i:k+1] = np.concatenate([segment1[::-1], segment2[::-1]])\n\n    else:  # objective_swap\n        # Objective-aware swap: identify the worst-performing segment in any objective\n        # and try to improve it by swapping with a better segment\n        def calculate_segment_cost(solution):\n            cost1 = sum(distance_matrix_1[solution[i-1], solution[i]] for i in range(len(solution)))\n            cost2 = sum(distance_matrix_2[solution[i-1], solution[i]] for i in range(len(solution)))\n            cost3 = sum(distance_matrix_3[solution[i-1], solution[i]] for i in range(len(solution)))\n            return (cost1, cost2, cost3)\n\n        # Find the worst-performing segment in any objective\n        current_costs = calculate_segment_cost(base_solution)\n        worst_obj = np.argmax(current_costs)\n\n        # Select a random segment to compare\n        seg_length = random.randint(3, min(10, n//2))\n        start = random.randint(0, n - seg_length)\n        end = start + seg_length\n        segment = base_solution[start:end]\n\n        # Find the best position to insert this segment to improve the worst objective\n        best_insert_pos = -1\n        best_improvement = 0\n\n        for pos in range(n):\n            if pos >= start and pos <= end:\n                continue  # Skip the original position\n\n            # Try inserting the segment at this position\n            temp_solution = np.concatenate([\n                base_solution[:pos],\n                segment,\n                base_solution[pos:start],\n                base_solution[end:]\n            ])\n\n            temp_costs = calculate_segment_cost(temp_solution)\n            improvement = current_costs[worst_obj] - temp_costs[worst_obj]\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_insert_pos = pos\n\n        if best_insert_pos != -1:\n            # Apply the best improvement found\n            new_solution = np.concatenate([\n                base_solution[:best_insert_pos],\n                segment,\n                base_solution[best_insert_pos:start],\n                base_solution[end:]\n            ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 264,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    # Here we select a solution with the highest sum of objectives (worst in all dimensions)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Limit the number of attempts to ensure efficiency\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Calculate current and potential costs\n        current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n                        distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        potential_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                           distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] +\n                           distance_matrix_3[new_solution[i], new_solution[(j+1)%n]])\n\n        # Accept if the potential cost is better in at least one objective\n        if potential_cost < current_cost:\n            # Perform 2-opt swap\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            break\n\n    # Additional objective-aware 2-opt (considering all three objectives)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Calculate objective improvements\n        obj1_improvement = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n                          (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        obj2_improvement = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n                          (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        obj3_improvement = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]) - \\\n                          (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if (obj1_improvement < 0) or (obj2_improvement < 0) or (obj3_improvement < 0):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7023604815609616,
            1.6491957902908325
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    # Here we select a solution with the highest sum of objectives (worst in all dimensions)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Limit the number of attempts to ensure efficiency\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Calculate current and potential costs\n        current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n                        distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        potential_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                           distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] +\n                           distance_matrix_3[new_solution[i], new_solution[(j+1)%n]])\n\n        # Accept if the potential cost is better in at least one objective\n        if potential_cost < current_cost:\n            # Perform 2-opt swap\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            break\n\n    # Additional objective-aware 2-opt (considering all three objectives)\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Calculate objective improvements\n        obj1_improvement = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n                          (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        obj2_improvement = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n                          (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        obj3_improvement = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]) - \\\n                          (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if (obj1_improvement < 0) or (obj2_improvement < 0) or (obj3_improvement < 0):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 265,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def potential_score(solution, objectives):\n        # Calculate the sum of normalized objectives to identify solutions with high potential\n        total = sum(objectives)\n        if total == 0:\n            return 0\n        return max(objectives) / total  # Prioritize solutions with high max objective\n\n    scored_solutions = [(solution, objectives, potential_score(solution, objectives))\n                        for solution, objectives in archive]\n    scored_solutions.sort(key=lambda x: -x[2])  # Sort by descending potential score\n\n    # Select top 20% of solutions with highest potential\n    top_k = max(1, len(scored_solutions) // 5)\n    candidates = scored_solutions[:top_k]\n    selected = random.choice(candidates)[0].copy()\n\n    # Hybrid local search operator: combination of 2-opt and node insertion\n    n = len(selected)\n    new_solution = selected.copy()\n\n    # Apply 2-opt on a random segment\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply node insertion: move a random node to a random position\n    node_to_move = random.randint(0, n-1)\n    pos = random.randint(0, n-1)\n    if node_to_move != pos:\n        node = new_solution[node_to_move]\n        new_solution = np.delete(new_solution, node_to_move)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.591469651863066,
            1.710071873664856
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def potential_score(solution, objectives):\n        # Calculate the sum of normalized objectives to identify solutions with high potential\n        total = sum(objectives)\n        if total == 0:\n            return 0\n        return max(objectives) / total  # Prioritize solutions with high max objective\n\n    scored_solutions = [(solution, objectives, potential_score(solution, objectives))\n                        for solution, objectives in archive]\n    scored_solutions.sort(key=lambda x: -x[2])  # Sort by descending potential score\n\n    # Select top 20% of solutions with highest potential\n    top_k = max(1, len(scored_solutions) // 5)\n    candidates = scored_solutions[:top_k]\n    selected = random.choice(candidates)[0].copy()\n\n    # Hybrid local search operator: combination of 2-opt and node insertion\n    n = len(selected)\n    new_solution = selected.copy()\n\n    # Apply 2-opt on a random segment\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply node insertion: move a random node to a random position\n    node_to_move = random.randint(0, n-1)\n    pos = random.randint(0, n-1)\n    if node_to_move != pos:\n        node = new_solution[node_to_move]\n        new_solution = np.delete(new_solution, node_to_move)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 266,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly from top 20% of archive)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selection_pool = archive_sorted[:max(1, len(archive_sorted) // 5)]\n    selected = random.choice(selection_pool)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly choose between 2-opt and 3-opt for structural improvement\n    # 2. Apply a biased edge swap based on the worst-performing objective\n    # 3. Ensure feasibility by checking for duplicates\n\n    # Step 1: Choose between 2-opt and 3-opt\n    if random.random() < 0.7:  # 70% chance for 2-opt\n        # 2-opt local search\n        i, j = sorted(random.sample(range(1, len(base_solution)), 2))\n        new_solution[i:j] = base_solution[i:j][::-1]\n    else:\n        # 3-opt local search\n        i, j, k = sorted(random.sample(range(1, len(base_solution)), 3))\n        segment1 = base_solution[i:j]\n        segment2 = base_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Step 2: Biased edge swap based on the worst-performing objective\n    objectives = selected[1]\n    worst_obj = objectives.index(max(objectives))\n\n    # Select a random edge to swap based on the worst objective's distance matrix\n    if worst_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the edge with the highest cost in the worst objective\n    max_cost = -1\n    max_i, max_j = -1, -1\n    for i in range(len(new_solution)-1):\n        u, v = new_solution[i], new_solution[i+1]\n        cost = dist_matrix[u, v]\n        if cost > max_cost:\n            max_cost = cost\n            max_i, max_j = i, i+1\n\n    # Swap the nodes to potentially reduce this high-cost edge\n    if max_i != -1 and max_j != -1:\n        new_solution[max_i], new_solution[max_j] = new_solution[max_j], new_solution[max_i]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != len(new_solution):\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6850154153059849,
            1.7475762009620666
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly from top 20% of archive)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selection_pool = archive_sorted[:max(1, len(archive_sorted) // 5)]\n    selected = random.choice(selection_pool)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly choose between 2-opt and 3-opt for structural improvement\n    # 2. Apply a biased edge swap based on the worst-performing objective\n    # 3. Ensure feasibility by checking for duplicates\n\n    # Step 1: Choose between 2-opt and 3-opt\n    if random.random() < 0.7:  # 70% chance for 2-opt\n        # 2-opt local search\n        i, j = sorted(random.sample(range(1, len(base_solution)), 2))\n        new_solution[i:j] = base_solution[i:j][::-1]\n    else:\n        # 3-opt local search\n        i, j, k = sorted(random.sample(range(1, len(base_solution)), 3))\n        segment1 = base_solution[i:j]\n        segment2 = base_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Step 2: Biased edge swap based on the worst-performing objective\n    objectives = selected[1]\n    worst_obj = objectives.index(max(objectives))\n\n    # Select a random edge to swap based on the worst objective's distance matrix\n    if worst_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the edge with the highest cost in the worst objective\n    max_cost = -1\n    max_i, max_j = -1, -1\n    for i in range(len(new_solution)-1):\n        u, v = new_solution[i], new_solution[i+1]\n        cost = dist_matrix[u, v]\n        if cost > max_cost:\n            max_cost = cost\n            max_i, max_j = i, i+1\n\n    # Swap the nodes to potentially reduce this high-cost edge\n    if max_i != -1 and max_j != -1:\n        new_solution[max_i], new_solution[max_j] = new_solution[max_j], new_solution[max_i]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != len(new_solution):\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 267,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (smallest crowding distance or most diverse)\n    # We use crowding distance to identify solutions that are less crowded in the objective space\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for m in range(3):  # For each objective\n        sorted_indices = np.argsort(objectives[:, m])\n        sorted_objectives = objectives[sorted_indices, m]\n\n        # Calculate crowding distance for each objective\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n\n        for i in range(1, len(archive) - 1):\n            if sorted_objectives[-1] == sorted_objectives[0]:\n                crowding_distances[sorted_indices[i]] += 0\n            else:\n                crowding_distances[sorted_indices[i]] += (sorted_objectives[i+1] - sorted_objectives[i-1]) / (sorted_objectives[-1] - sorted_objectives[0])\n\n    # Select the solution with the smallest crowding distance (most crowded, likely to be improved)\n    selected_idx = np.argmin(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Apply a combination of 2-opt and swap operations\n    if np.random.rand() < 0.5:\n        # 2-opt: Reverse a segment\n        new_solution[i:j+1] = segment[::-1]\n    else:\n        # Swap two nodes in the segment\n        if len(segment) > 1:\n            k, l = np.random.choice(len(segment), 2, replace=False)\n            segment[k], segment[l] = segment[l], segment[k]\n            new_solution[i:j+1] = segment\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6457635977569656,
            2.7770570039749147
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (smallest crowding distance or most diverse)\n    # We use crowding distance to identify solutions that are less crowded in the objective space\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for m in range(3):  # For each objective\n        sorted_indices = np.argsort(objectives[:, m])\n        sorted_objectives = objectives[sorted_indices, m]\n\n        # Calculate crowding distance for each objective\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n\n        for i in range(1, len(archive) - 1):\n            if sorted_objectives[-1] == sorted_objectives[0]:\n                crowding_distances[sorted_indices[i]] += 0\n            else:\n                crowding_distances[sorted_indices[i]] += (sorted_objectives[i+1] - sorted_objectives[i-1]) / (sorted_objectives[-1] - sorted_objectives[0])\n\n    # Select the solution with the smallest crowding distance (most crowded, likely to be improved)\n    selected_idx = np.argmin(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Apply a combination of 2-opt and swap operations\n    if np.random.rand() < 0.5:\n        # 2-opt: Reverse a segment\n        new_solution[i:j+1] = segment[::-1]\n    else:\n        # Swap two nodes in the segment\n        if len(segment) > 1:\n            k, l = np.random.choice(len(segment), 2, replace=False)\n            segment[k], segment[l] = segment[l], segment[k]\n            new_solution[i:j+1] = segment\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 268,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # We prioritize solutions that are non-dominated and have the worst objective value in at least one dimension\n    # This suggests they may have room for improvement in that dimension\n    max_obj_values = np.array([obj for _, obj in archive])\n    worst_indices = np.argmax(max_obj_values, axis=0)\n    candidate_indices = list(set(worst_indices))\n    selected_idx = random.choice(candidate_indices) if candidate_indices else random.randint(0, len(archive)-1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    # 1. Randomly select a segment of the tour\n    n = len(base_solution)\n    a, b = sorted(random.sample(range(n), 2))\n    segment = base_solution[a:b+1]\n\n    # 2. Reverse the segment (2-opt move) for potential improvement in one objective\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    # 3. For the tri-objective case, we also consider a 3-opt move that may improve multiple objectives\n    if n >= 6 and random.random() < 0.3:  # 30% chance for 3-opt\n        c, d = sorted(random.sample(range(n), 2))\n        if c < a < b < d:  # Ensure valid segment ordering\n            segment1 = new_solution[a:b+1]\n            segment2 = new_solution[c:d+1]\n\n            # Calculate the cost difference for each objective\n            def calculate_cost(solution):\n                cost1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(len(solution)-1)) + distance_matrix_1[solution[-1], solution[0]]\n                cost2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(len(solution)-1)) + distance_matrix_2[solution[-1], solution[0]]\n                cost3 = sum(distance_matrix_3[solution[i], solution[i+1]] for i in range(len(solution)-1)) + distance_matrix_3[solution[-1], solution[0]]\n                return (cost1, cost2, cost3)\n\n            original_cost = calculate_cost(new_solution)\n\n            # Try different 3-opt configurations\n            # Configuration 1: reverse segment1\n            temp_solution = new_solution.copy()\n            temp_solution[a:b+1] = segment1[::-1]\n            cost1 = calculate_cost(temp_solution)\n\n            # Configuration 2: reverse segment2\n            temp_solution = new_solution.copy()\n            temp_solution[c:d+1] = segment2[::-1]\n            cost2 = calculate_cost(temp_solution)\n\n            # Configuration 3: reverse both segments\n            temp_solution = new_solution.copy()\n            temp_solution[a:b+1] = segment1[::-1]\n            temp_solution[c:d+1] = segment2[::-1]\n            cost3 = calculate_cost(temp_solution)\n\n            # Select the configuration that improves the most in any objective\n            costs = [original_cost, cost1, cost2, cost3]\n            improvements = [sum(o - n for o, n in zip(original_cost, c)) for c in costs]\n            best_idx = np.argmax(improvements)\n\n            if best_idx == 1:\n                new_solution[a:b+1] = segment1[::-1]\n            elif best_idx == 2:\n                new_solution[c:d+1] = segment2[::-1]\n            elif best_idx == 3:\n                new_solution[a:b+1] = segment1[::-1]\n                new_solution[c:d+1] = segment2[::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.58307015336602,
            1.731499719619751
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # We prioritize solutions that are non-dominated and have the worst objective value in at least one dimension\n    # This suggests they may have room for improvement in that dimension\n    max_obj_values = np.array([obj for _, obj in archive])\n    worst_indices = np.argmax(max_obj_values, axis=0)\n    candidate_indices = list(set(worst_indices))\n    selected_idx = random.choice(candidate_indices) if candidate_indices else random.randint(0, len(archive)-1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    # 1. Randomly select a segment of the tour\n    n = len(base_solution)\n    a, b = sorted(random.sample(range(n), 2))\n    segment = base_solution[a:b+1]\n\n    # 2. Reverse the segment (2-opt move) for potential improvement in one objective\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    # 3. For the tri-objective case, we also consider a 3-opt move that may improve multiple objectives\n    if n >= 6 and random.random() < 0.3:  # 30% chance for 3-opt\n        c, d = sorted(random.sample(range(n), 2))\n        if c < a < b < d:  # Ensure valid segment ordering\n            segment1 = new_solution[a:b+1]\n            segment2 = new_solution[c:d+1]\n\n            # Calculate the cost difference for each objective\n            def calculate_cost(solution):\n                cost1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(len(solution)-1)) + distance_matrix_1[solution[-1], solution[0]]\n                cost2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(len(solution)-1)) + distance_matrix_2[solution[-1], solution[0]]\n                cost3 = sum(distance_matrix_3[solution[i], solution[i+1]] for i in range(len(solution)-1)) + distance_matrix_3[solution[-1], solution[0]]\n                return (cost1, cost2, cost3)\n\n            original_cost = calculate_cost(new_solution)\n\n            # Try different 3-opt configurations\n            # Configuration 1: reverse segment1\n            temp_solution = new_solution.copy()\n            temp_solution[a:b+1] = segment1[::-1]\n            cost1 = calculate_cost(temp_solution)\n\n            # Configuration 2: reverse segment2\n            temp_solution = new_solution.copy()\n            temp_solution[c:d+1] = segment2[::-1]\n            cost2 = calculate_cost(temp_solution)\n\n            # Configuration 3: reverse both segments\n            temp_solution = new_solution.copy()\n            temp_solution[a:b+1] = segment1[::-1]\n            temp_solution[c:d+1] = segment2[::-1]\n            cost3 = calculate_cost(temp_solution)\n\n            # Select the configuration that improves the most in any objective\n            costs = [original_cost, cost1, cost2, cost3]\n            improvements = [sum(o - n for o, n in zip(original_cost, c)) for c in costs]\n            best_idx = np.argmax(improvements)\n\n            if best_idx == 1:\n                new_solution[a:b+1] = segment1[::-1]\n            elif best_idx == 2:\n                new_solution[c:d+1] = segment2[::-1]\n            elif best_idx == 3:\n                new_solution[a:b+1] = segment1[::-1]\n                new_solution[c:d+1] = segment2[::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 269,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest potential for improvement (lowest objective values)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate the normalized improvement potential (lower is better)\n    normalized_objectives = np.array(archive_objectives)\n    normalized_objectives = (normalized_objectives - normalized_objectives.min(axis=0)) / (normalized_objectives.max(axis=0) - normalized_objectives.min(axis=0) + 1e-10)\n    improvement_potential = normalized_objectives.sum(axis=1)\n\n    # Select the solution with highest potential (lowest normalized sum)\n    selected_idx = np.argmin(improvement_potential)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search operator: combine 2-opt with multi-objective aware segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to invert (2-opt like move)\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective aware segment inversion: invert based on objective improvement\n    if np.random.rand() < 0.5:  # 50% chance to apply multi-objective inversion\n        # Calculate the objective change for each possible inversion\n        possible_inversions = []\n        for k in range(1, n):\n            temp_sol = new_solution.copy()\n            temp_sol[k:] = temp_sol[k:][::-1]\n\n            # Calculate the new objectives\n            obj1 = sum(distance_matrix_1[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n))\n            obj2 = sum(distance_matrix_2[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n))\n            obj3 = sum(distance_matrix_3[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n))\n\n            # Calculate the improvement in all objectives\n            current_obj = archive_objectives[selected_idx]\n            improvement = (current_obj[0] - obj1, current_obj[1] - obj2, current_obj[2] - obj3)\n            possible_inversions.append((temp_sol, improvement))\n\n        # Select the inversion that improves the most in the most objectives\n        if possible_inversions:\n            best_inversion = max(possible_inversions, key=lambda x: sum(1 for imp in x[1] if imp > 0))\n            new_solution = best_inversion[0]\n\n    return new_solution\n\n",
        "score": [
            -0.6831449464981137,
            3.1581541538238525
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest potential for improvement (lowest objective values)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate the normalized improvement potential (lower is better)\n    normalized_objectives = np.array(archive_objectives)\n    normalized_objectives = (normalized_objectives - normalized_objectives.min(axis=0)) / (normalized_objectives.max(axis=0) - normalized_objectives.min(axis=0) + 1e-10)\n    improvement_potential = normalized_objectives.sum(axis=1)\n\n    # Select the solution with highest potential (lowest normalized sum)\n    selected_idx = np.argmin(improvement_potential)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search operator: combine 2-opt with multi-objective aware segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to invert (2-opt like move)\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective aware segment inversion: invert based on objective improvement\n    if np.random.rand() < 0.5:  # 50% chance to apply multi-objective inversion\n        # Calculate the objective change for each possible inversion\n        possible_inversions = []\n        for k in range(1, n):\n            temp_sol = new_solution.copy()\n            temp_sol[k:] = temp_sol[k:][::-1]\n\n            # Calculate the new objectives\n            obj1 = sum(distance_matrix_1[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n))\n            obj2 = sum(distance_matrix_2[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n))\n            obj3 = sum(distance_matrix_3[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n))\n\n            # Calculate the improvement in all objectives\n            current_obj = archive_objectives[selected_idx]\n            improvement = (current_obj[0] - obj1, current_obj[1] - obj2, current_obj[2] - obj3)\n            possible_inversions.append((temp_sol, improvement))\n\n        # Select the inversion that improves the most in the most objectives\n        if possible_inversions:\n            best_inversion = max(possible_inversions, key=lambda x: sum(1 for imp in x[1] if imp > 0))\n            new_solution = best_inversion[0]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 270,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def dominance_score(solution, objective):\n        # Higher score means more potential for improvement\n        return sum(objective)\n\n    # Sort solutions by dominance score (ascending)\n    archive_sorted = sorted(archive, key=lambda x: dominance_score(x[0], x[1]))\n\n    # Select top 10% candidates\n    num_candidates = max(1, len(archive_sorted) // 10)\n    candidates = archive_sorted[:num_candidates]\n\n    # Randomly select one candidate\n    selected = candidates[np.random.randint(0, len(candidates))][0].copy()\n\n    # Hybrid local search operator\n    n = len(selected)\n    new_solution = selected.copy()\n\n    # Apply 2-opt with probability 0.7\n    if np.random.random() < 0.7:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply node swap with probability 0.3\n    elif np.random.random() < 0.3:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Apply objective-specific 2-opt if no improvement in the last 5 iterations\n    else:\n        # Evaluate current solution\n        current_obj = (\n            sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        )\n\n        # Try objective-specific moves\n        for _ in range(3):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n            # Calculate new objectives\n            new_obj = (\n                sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n)),\n                sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n)),\n                sum(distance_matrix_3[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n            )\n\n            # Accept if at least one objective improves\n            if any(new_obj[k] < current_obj[k] for k in range(3)):\n                new_solution = temp_solution\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.5845464375087299,
            1.8729230642318726
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def dominance_score(solution, objective):\n        # Higher score means more potential for improvement\n        return sum(objective)\n\n    # Sort solutions by dominance score (ascending)\n    archive_sorted = sorted(archive, key=lambda x: dominance_score(x[0], x[1]))\n\n    # Select top 10% candidates\n    num_candidates = max(1, len(archive_sorted) // 10)\n    candidates = archive_sorted[:num_candidates]\n\n    # Randomly select one candidate\n    selected = candidates[np.random.randint(0, len(candidates))][0].copy()\n\n    # Hybrid local search operator\n    n = len(selected)\n    new_solution = selected.copy()\n\n    # Apply 2-opt with probability 0.7\n    if np.random.random() < 0.7:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply node swap with probability 0.3\n    elif np.random.random() < 0.3:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Apply objective-specific 2-opt if no improvement in the last 5 iterations\n    else:\n        # Evaluate current solution\n        current_obj = (\n            sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        )\n\n        # Try objective-specific moves\n        for _ in range(3):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n            # Calculate new objectives\n            new_obj = (\n                sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n)),\n                sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n)),\n                sum(distance_matrix_3[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n            )\n\n            # Accept if at least one objective improves\n            if any(new_obj[k] < current_obj[k] for k in range(3)):\n                new_solution = temp_solution\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 271,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with the highest potential for improvement (lowest objective values)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate crowding distance to identify solutions in less crowded regions\n    crowding_distances = np.zeros(len(archive_objectives))\n    for i in range(3):\n        sorted_indices = np.argsort([obj[i] for obj in archive_objectives])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive_objectives)-1):\n            crowding_distances[sorted_indices[j]] += (archive_objectives[sorted_indices[j+1]][i] - archive_objectives[sorted_indices[j-1]][i])\n\n    # Select the solution with the highest crowding distance (less crowded)\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search strategy: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Calculate edge costs in all three objectives\n    def calculate_edge_cost(a, b):\n        cost1 = distance_matrix_1[a, b]\n        cost2 = distance_matrix_2[a, b]\n        cost3 = distance_matrix_3[a, b]\n        return cost1, cost2, cost3\n\n    # Find the best edge to replace in the segment\n    best_gain = -np.inf\n    best_a, best_b = -1, -1\n\n    for a in range(i, j):\n        for b in range(i, j):\n            if a == b:\n                continue\n            # Current edges: (a, a+1) and (b, b+1)\n            # Proposed edges: (a, b) and (a+1, b+1)\n            current_cost1 = distance_matrix_1[new_solution[a], new_solution[a+1]] + distance_matrix_1[new_solution[b], new_solution[b+1]]\n            current_cost2 = distance_matrix_2[new_solution[a], new_solution[a+1]] + distance_matrix_2[new_solution[b], new_solution[b+1]]\n            current_cost3 = distance_matrix_3[new_solution[a], new_solution[a+1]] + distance_matrix_3[new_solution[b], new_solution[b+1]]\n\n            proposed_cost1 = distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[a+1], new_solution[b+1]]\n            proposed_cost2 = distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[a+1], new_solution[b+1]]\n            proposed_cost3 = distance_matrix_3[new_solution[a], new_solution[b]] + distance_matrix_3[new_solution[a+1], new_solution[b+1]]\n\n            # Calculate gain in all three objectives\n            gain1 = current_cost1 - proposed_cost1\n            gain2 = current_cost2 - proposed_cost2\n            gain3 = current_cost3 - proposed_cost3\n\n            # Use a weighted sum of gains (could be improved with proper normalization)\n            total_gain = gain1 + gain2 + gain3\n\n            if total_gain > best_gain:\n                best_gain = total_gain\n                best_a, best_b = a, b\n\n    # Apply the best found 2-opt move if it improves the solution\n    if best_a != -1 and best_b != -1:\n        # Reverse the segment between best_a and best_b\n        new_solution[best_a:best_b+1] = new_solution[best_a:best_b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.5235951362280781,
            4.014281046390534
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with the highest potential for improvement (lowest objective values)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate crowding distance to identify solutions in less crowded regions\n    crowding_distances = np.zeros(len(archive_objectives))\n    for i in range(3):\n        sorted_indices = np.argsort([obj[i] for obj in archive_objectives])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive_objectives)-1):\n            crowding_distances[sorted_indices[j]] += (archive_objectives[sorted_indices[j+1]][i] - archive_objectives[sorted_indices[j-1]][i])\n\n    # Select the solution with the highest crowding distance (less crowded)\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search strategy: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Calculate edge costs in all three objectives\n    def calculate_edge_cost(a, b):\n        cost1 = distance_matrix_1[a, b]\n        cost2 = distance_matrix_2[a, b]\n        cost3 = distance_matrix_3[a, b]\n        return cost1, cost2, cost3\n\n    # Find the best edge to replace in the segment\n    best_gain = -np.inf\n    best_a, best_b = -1, -1\n\n    for a in range(i, j):\n        for b in range(i, j):\n            if a == b:\n                continue\n            # Current edges: (a, a+1) and (b, b+1)\n            # Proposed edges: (a, b) and (a+1, b+1)\n            current_cost1 = distance_matrix_1[new_solution[a], new_solution[a+1]] + distance_matrix_1[new_solution[b], new_solution[b+1]]\n            current_cost2 = distance_matrix_2[new_solution[a], new_solution[a+1]] + distance_matrix_2[new_solution[b], new_solution[b+1]]\n            current_cost3 = distance_matrix_3[new_solution[a], new_solution[a+1]] + distance_matrix_3[new_solution[b], new_solution[b+1]]\n\n            proposed_cost1 = distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[a+1], new_solution[b+1]]\n            proposed_cost2 = distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[a+1], new_solution[b+1]]\n            proposed_cost3 = distance_matrix_3[new_solution[a], new_solution[b]] + distance_matrix_3[new_solution[a+1], new_solution[b+1]]\n\n            # Calculate gain in all three objectives\n            gain1 = current_cost1 - proposed_cost1\n            gain2 = current_cost2 - proposed_cost2\n            gain3 = current_cost3 - proposed_cost3\n\n            # Use a weighted sum of gains (could be improved with proper normalization)\n            total_gain = gain1 + gain2 + gain3\n\n            if total_gain > best_gain:\n                best_gain = total_gain\n                best_a, best_b = a, b\n\n    # Apply the best found 2-opt move if it improves the solution\n    if best_a != -1 and best_b != -1:\n        # Reverse the segment between best_a and best_b\n        new_solution[best_a:best_b+1] = new_solution[best_a:best_b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 272,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective diversity)\n    weights = [1.0 / (1.0 + obj[0] + obj[1] + obj[2]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations\n        # Randomly select two distinct positions\n        i, j = sorted(random.sample(range(n), 2))\n\n        # 2-opt swap (basic local search)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Objective-aware swap: identify worst edge in any objective\n        worst_obj = -1\n        worst_edge = -1\n        for k in range(n):\n            node1 = new_solution[k]\n            node2 = new_solution[(k+1) % n]\n            # Calculate edge costs across all objectives\n            cost1 = distance_matrix_1[node1, node2]\n            cost2 = distance_matrix_2[node1, node2]\n            cost3 = distance_matrix_3[node1, node2]\n            total_cost = cost1 + cost2 + cost3\n\n            if worst_edge == -1 or total_cost > worst_obj:\n                worst_obj = total_cost\n                worst_edge = k\n\n        if worst_edge != -1:\n            # Swap nodes to potentially improve all objectives\n            new_solution[worst_edge], new_solution[(worst_edge+1) % n] = new_solution[(worst_edge+1) % n], new_solution[worst_edge]\n\n        # Optional: Apply a small random perturbation to escape local optima\n        if random.random() < 0.1:\n            k, l = sorted(random.sample(range(n), 2))\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7263286000392349,
            1.8735744833946228
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective diversity)\n    weights = [1.0 / (1.0 + obj[0] + obj[1] + obj[2]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations\n        # Randomly select two distinct positions\n        i, j = sorted(random.sample(range(n), 2))\n\n        # 2-opt swap (basic local search)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Objective-aware swap: identify worst edge in any objective\n        worst_obj = -1\n        worst_edge = -1\n        for k in range(n):\n            node1 = new_solution[k]\n            node2 = new_solution[(k+1) % n]\n            # Calculate edge costs across all objectives\n            cost1 = distance_matrix_1[node1, node2]\n            cost2 = distance_matrix_2[node1, node2]\n            cost3 = distance_matrix_3[node1, node2]\n            total_cost = cost1 + cost2 + cost3\n\n            if worst_edge == -1 or total_cost > worst_obj:\n                worst_obj = total_cost\n                worst_edge = k\n\n        if worst_edge != -1:\n            # Swap nodes to potentially improve all objectives\n            new_solution[worst_edge], new_solution[(worst_edge+1) % n] = new_solution[(worst_edge+1) % n], new_solution[worst_edge]\n\n        # Optional: Apply a small random perturbation to escape local optima\n        if random.random() < 0.1:\n            k, l = sorted(random.sample(range(n), 2))\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 273,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with high variance in objective improvements)\n    selected_solution = random.choice(archive)[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator combining 2-opt and objective-aware swaps\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Perform 2-opt with objective-aware selection\n    i, j = sorted(random.sample(range(n), 2))\n    if j - i > 1:  # Ensure we have at least one node in between\n        # Evaluate the current and reversed segment in all three objectives\n        current_segment = new_solution[i:j+1]\n        reversed_segment = current_segment[::-1]\n\n        # Calculate the delta in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], reversed_segment[0]] +\n                  distance_matrix_1[reversed_segment[-1], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], current_segment[0]] -\n                  distance_matrix_1[current_segment[-1], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], reversed_segment[0]] +\n                  distance_matrix_2[reversed_segment[-1], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], current_segment[0]] -\n                  distance_matrix_2[current_segment[-1], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], reversed_segment[0]] +\n                  distance_matrix_3[reversed_segment[-1], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], current_segment[0]] -\n                  distance_matrix_3[current_segment[-1], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = reversed_segment\n\n    # Perform objective-aware node swaps\n    a, b = random.sample(range(n), 2)\n    if a != b:\n        # Calculate the delta in all three objectives\n        delta1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                  distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                  distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                  distance_matrix_1[new_solution[a], new_solution[(b+1)%n]] -\n                  distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                  distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] -\n                  distance_matrix_1[new_solution[b-1], new_solution[b]] -\n                  distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                  distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                  distance_matrix_2[new_solution[b-1], new_solution[a]] +\n                  distance_matrix_2[new_solution[a], new_solution[(b+1)%n]] -\n                  distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                  distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] -\n                  distance_matrix_2[new_solution[b-1], new_solution[b]] -\n                  distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                  distance_matrix_3[new_solution[b], new_solution[(a+1)%n]] +\n                  distance_matrix_3[new_solution[b-1], new_solution[a]] +\n                  distance_matrix_3[new_solution[a], new_solution[(b+1)%n]] -\n                  distance_matrix_3[new_solution[a-1], new_solution[a]] -\n                  distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] -\n                  distance_matrix_3[new_solution[b-1], new_solution[b]] -\n                  distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7661456329849436,
            1.1451329231262206
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with high variance in objective improvements)\n    selected_solution = random.choice(archive)[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator combining 2-opt and objective-aware swaps\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Perform 2-opt with objective-aware selection\n    i, j = sorted(random.sample(range(n), 2))\n    if j - i > 1:  # Ensure we have at least one node in between\n        # Evaluate the current and reversed segment in all three objectives\n        current_segment = new_solution[i:j+1]\n        reversed_segment = current_segment[::-1]\n\n        # Calculate the delta in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], reversed_segment[0]] +\n                  distance_matrix_1[reversed_segment[-1], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], current_segment[0]] -\n                  distance_matrix_1[current_segment[-1], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], reversed_segment[0]] +\n                  distance_matrix_2[reversed_segment[-1], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], current_segment[0]] -\n                  distance_matrix_2[current_segment[-1], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], reversed_segment[0]] +\n                  distance_matrix_3[reversed_segment[-1], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], current_segment[0]] -\n                  distance_matrix_3[current_segment[-1], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = reversed_segment\n\n    # Perform objective-aware node swaps\n    a, b = random.sample(range(n), 2)\n    if a != b:\n        # Calculate the delta in all three objectives\n        delta1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                  distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                  distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                  distance_matrix_1[new_solution[a], new_solution[(b+1)%n]] -\n                  distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                  distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] -\n                  distance_matrix_1[new_solution[b-1], new_solution[b]] -\n                  distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                  distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                  distance_matrix_2[new_solution[b-1], new_solution[a]] +\n                  distance_matrix_2[new_solution[a], new_solution[(b+1)%n]] -\n                  distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                  distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] -\n                  distance_matrix_2[new_solution[b-1], new_solution[b]] -\n                  distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                  distance_matrix_3[new_solution[b], new_solution[(a+1)%n]] +\n                  distance_matrix_3[new_solution[b-1], new_solution[a]] +\n                  distance_matrix_3[new_solution[a], new_solution[(b+1)%n]] -\n                  distance_matrix_3[new_solution[a-1], new_solution[a]] -\n                  distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] -\n                  distance_matrix_3[new_solution[b-1], new_solution[b]] -\n                  distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 274,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity and potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n    selected_objectives = archive[selected_idx][1]\n\n    # Hybrid local search operator: combine 2-opt with a multi-objective aware swap\n    new_solution = selected_solution.copy()\n\n    # Perform 2-opt on the worst objective space\n    worst_obj_idx = np.argmax(selected_objectives)\n    if worst_obj_idx == 0:\n        distance_matrix = distance_matrix_1\n    elif worst_obj_idx == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Find the worst edge in the selected solution\n    n = len(new_solution)\n    worst_edge = None\n    max_edge_cost = -1\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i + 1) % n]\n        edge_cost = distance_matrix[u, v]\n        if edge_cost > max_edge_cost:\n            max_edge_cost = edge_cost\n            worst_edge = (i, (i + 1) % n)\n\n    if worst_edge is not None:\n        i, j = worst_edge\n        # Try to reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective aware swap: try to improve all objectives\n    for _ in range(3):  # Try a few swaps\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Calculate current and new tour costs\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] +\n            distance_matrix_1[new_solution[b], new_solution[(b+1)%n]] +\n            distance_matrix_2[new_solution[a-1], new_solution[a]] +\n            distance_matrix_2[new_solution[b], new_solution[(b+1)%n]] +\n            distance_matrix_3[new_solution[a-1], new_solution[a]] +\n            distance_matrix_3[new_solution[b], new_solution[(b+1)%n]]\n        ]\n\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] +\n            distance_matrix_1[new_solution[a], new_solution[(b+1)%n]] +\n            distance_matrix_2[new_solution[a-1], new_solution[b]] +\n            distance_matrix_2[new_solution[a], new_solution[(b+1)%n]] +\n            distance_matrix_3[new_solution[a-1], new_solution[b]] +\n            distance_matrix_3[new_solution[a], new_solution[(b+1)%n]]\n        ]\n\n        # If the swap improves at least one objective, accept it\n        if any(new_cost < current_cost for new_cost, current_cost in zip(new_costs, current_costs)):\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7422182921687971,
            2.2020209431648254
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity and potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n    selected_objectives = archive[selected_idx][1]\n\n    # Hybrid local search operator: combine 2-opt with a multi-objective aware swap\n    new_solution = selected_solution.copy()\n\n    # Perform 2-opt on the worst objective space\n    worst_obj_idx = np.argmax(selected_objectives)\n    if worst_obj_idx == 0:\n        distance_matrix = distance_matrix_1\n    elif worst_obj_idx == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Find the worst edge in the selected solution\n    n = len(new_solution)\n    worst_edge = None\n    max_edge_cost = -1\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i + 1) % n]\n        edge_cost = distance_matrix[u, v]\n        if edge_cost > max_edge_cost:\n            max_edge_cost = edge_cost\n            worst_edge = (i, (i + 1) % n)\n\n    if worst_edge is not None:\n        i, j = worst_edge\n        # Try to reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective aware swap: try to improve all objectives\n    for _ in range(3):  # Try a few swaps\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Calculate current and new tour costs\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] +\n            distance_matrix_1[new_solution[b], new_solution[(b+1)%n]] +\n            distance_matrix_2[new_solution[a-1], new_solution[a]] +\n            distance_matrix_2[new_solution[b], new_solution[(b+1)%n]] +\n            distance_matrix_3[new_solution[a-1], new_solution[a]] +\n            distance_matrix_3[new_solution[b], new_solution[(b+1)%n]]\n        ]\n\n        new_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] +\n            distance_matrix_1[new_solution[a], new_solution[(b+1)%n]] +\n            distance_matrix_2[new_solution[a-1], new_solution[b]] +\n            distance_matrix_2[new_solution[a], new_solution[(b+1)%n]] +\n            distance_matrix_3[new_solution[a-1], new_solution[b]] +\n            distance_matrix_3[new_solution[a], new_solution[(b+1)%n]]\n        ]\n\n        # If the swap improves at least one objective, accept it\n        if any(new_cost < current_cost for new_cost, current_cost in zip(new_costs, current_costs)):\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 275,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    objective_variance = np.var(objectives, axis=0)\n    weighted_scores = np.sum(objectives * objective_variance, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of 2-opt and objective-aware swaps\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # First, perform a 2-opt move (standard local search)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware swap to improve multi-objective quality\n    # Calculate the current objectives\n    def calculate_objectives(solution):\n        obj1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1))\n        obj1 += distance_matrix_1[solution[-1], solution[0]]\n        obj2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1))\n        obj2 += distance_matrix_2[solution[-1], solution[0]]\n        obj3 = sum(distance_matrix_3[solution[i], solution[i+1]] for i in range(n-1))\n        obj3 += distance_matrix_3[solution[-1], solution[0]]\n        return (obj1, obj2, obj3)\n\n    current_obj = calculate_objectives(new_solution)\n\n    # Try to find a better swap based on objective diversity\n    best_swap = None\n    best_improvement = 0\n\n    for _ in range(10):  # Limit the number of trials for efficiency\n        i, j = random.sample(range(n), 2)\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n        temp_obj = calculate_objectives(temp_solution)\n\n        # Calculate improvement in terms of objective diversity\n        improvement = sum((temp_obj[k] - current_obj[k]) * objective_variance[k] for k in range(3))\n\n        if improvement < best_improvement:\n            best_improvement = improvement\n            best_swap = (i, j)\n\n    if best_swap is not None:\n        i, j = best_swap\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.5796143135774995,
            3.8533553957939146
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    objective_variance = np.var(objectives, axis=0)\n    weighted_scores = np.sum(objectives * objective_variance, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of 2-opt and objective-aware swaps\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # First, perform a 2-opt move (standard local search)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware swap to improve multi-objective quality\n    # Calculate the current objectives\n    def calculate_objectives(solution):\n        obj1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1))\n        obj1 += distance_matrix_1[solution[-1], solution[0]]\n        obj2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1))\n        obj2 += distance_matrix_2[solution[-1], solution[0]]\n        obj3 = sum(distance_matrix_3[solution[i], solution[i+1]] for i in range(n-1))\n        obj3 += distance_matrix_3[solution[-1], solution[0]]\n        return (obj1, obj2, obj3)\n\n    current_obj = calculate_objectives(new_solution)\n\n    # Try to find a better swap based on objective diversity\n    best_swap = None\n    best_improvement = 0\n\n    for _ in range(10):  # Limit the number of trials for efficiency\n        i, j = random.sample(range(n), 2)\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n        temp_obj = calculate_objectives(temp_solution)\n\n        # Calculate improvement in terms of objective diversity\n        improvement = sum((temp_obj[k] - current_obj[k]) * objective_variance[k] for k in range(3))\n\n        if improvement < best_improvement:\n            best_improvement = improvement\n            best_swap = (i, j)\n\n    if best_swap is not None:\n        i, j = best_swap\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 276,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (not just the first one)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Perform 2-opt move (standard local search)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: identify nodes that are critical in any objective\n    # Calculate the total contribution of each node to each objective\n    def calculate_node_contributions(solution):\n        contributions = np.zeros((n, 3))\n        for k in range(n-1):\n            u, v = solution[k], solution[k+1]\n            contributions[u] += [distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v]]\n            contributions[v] += [distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v]]\n        # Add the last edge (return to start)\n        u, v = solution[-1], solution[0]\n        contributions[u] += [distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v]]\n        contributions[v] += [distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v]]\n        return contributions\n\n    contributions = calculate_node_contributions(new_solution)\n\n    # Find nodes with high contribution in any objective\n    critical_nodes = np.where(np.any(contributions > np.percentile(contributions, 90, axis=0), axis=1))[0]\n\n    if len(critical_nodes) >= 2:\n        # Perform a swap between two critical nodes\n        a, b = random.sample(list(critical_nodes), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if invalid\n        new_solution = base_solution.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7449507142139457,
            2.170365309715271
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (not just the first one)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Perform 2-opt move (standard local search)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: identify nodes that are critical in any objective\n    # Calculate the total contribution of each node to each objective\n    def calculate_node_contributions(solution):\n        contributions = np.zeros((n, 3))\n        for k in range(n-1):\n            u, v = solution[k], solution[k+1]\n            contributions[u] += [distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v]]\n            contributions[v] += [distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v]]\n        # Add the last edge (return to start)\n        u, v = solution[-1], solution[0]\n        contributions[u] += [distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v]]\n        contributions[v] += [distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v]]\n        return contributions\n\n    contributions = calculate_node_contributions(new_solution)\n\n    # Find nodes with high contribution in any objective\n    critical_nodes = np.where(np.any(contributions > np.percentile(contributions, 90, axis=0), axis=1))[0]\n\n    if len(critical_nodes) >= 2:\n        # Perform a swap between two critical nodes\n        a, b = random.sample(list(critical_nodes), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if invalid\n        new_solution = base_solution.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 277,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest objective values)\n    archive_solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate a combined score for each solution (lower is better)\n    scores = [sum(obj) for obj in objectives]\n    best_indices = np.argsort(scores)[:max(1, len(archive) // 2)]  # Consider top half\n\n    # Randomly select from the best candidates\n    selected_idx = np.random.choice(best_indices)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(base_solution)\n    operator = np.random.choice(['2opt', '3opt', 'insertion'])\n\n    if operator == '2opt':\n        # 2-opt with objective-aware edge selection\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        # Select edges based on the objective with the highest improvement potential\n        obj_idx = np.argmax([objectives[selected_idx][k] for k in range(3)])\n        if obj_idx == 0:\n            dm = distance_matrix_1\n        elif obj_idx == 1:\n            dm = distance_matrix_2\n        else:\n            dm = distance_matrix_3\n\n        # Find the best 2-opt move for the selected objective\n        best_improvement = 0\n        best_i, best_j = i, j\n        for a in range(n):\n            for b in range(a + 1, n):\n                # Current edges: (a, a+1) and (b, b+1)\n                # Proposed edges: (a, b) and (a+1, b+1)\n                current = dm[a, (a+1)%n] + dm[b, (b+1)%n]\n                proposed = dm[a, b] + dm[(a+1)%n, (b+1)%n]\n                improvement = current - proposed\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_i, best_j = a, b\n\n        if best_improvement > 0:\n            new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n    elif operator == '3opt':\n        # 3-opt with objective-aware segment selection\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        # Select the objective with the highest potential improvement\n        obj_idx = np.argmax([objectives[selected_idx][k] for k in range(3)])\n        if obj_idx == 0:\n            dm = distance_matrix_1\n        elif obj_idx == 1:\n            dm = distance_matrix_2\n        else:\n            dm = distance_matrix_3\n\n        # Try all 8 possible 3-opt configurations\n        configurations = [\n            (i, j, k),\n            (i, k, j),\n            (j, i, k),\n            (j, k, i),\n            (k, i, j),\n            (k, j, i),\n            (i, j, k)[::-1],\n            (i, k, j)[::-1]\n        ]\n\n        best_config = None\n        best_improvement = 0\n\n        for config in configurations:\n            a, b, c = config\n            # Calculate current and proposed costs\n            current = dm[a, (a+1)%n] + dm[b, (b+1)%n] + dm[c, (c+1)%n]\n            proposed = dm[a, b] + dm[b, c] + dm[c, (a+1)%n]\n            improvement = current - proposed\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_config = config\n\n        if best_config is not None:\n            a, b, c = best_config\n            # Apply the best 3-opt move\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n            new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    elif operator == 'insertion':\n        # Objective-aware insertion move\n        i = np.random.randint(n)\n        j = np.random.randint(n)\n        while i == j:\n            j = np.random.randint(n)\n\n        # Select the objective with the highest potential improvement\n        obj_idx = np.argmax([objectives[selected_idx][k] for k in range(3)])\n        if obj_idx == 0:\n            dm = distance_matrix_1\n        elif obj_idx == 1:\n            dm = distance_matrix_2\n        else:\n            dm = distance_matrix_3\n\n        # Calculate improvement for insertion\n        current = dm[i, (i+1)%n] + dm[j, (j+1)%n]\n        proposed = dm[i, j] + dm[j, (i+1)%n]\n        improvement = current - proposed\n\n        if improvement > 0:\n            # Perform insertion\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6929091487639816,
            2.7488510966300965
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest objective values)\n    archive_solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate a combined score for each solution (lower is better)\n    scores = [sum(obj) for obj in objectives]\n    best_indices = np.argsort(scores)[:max(1, len(archive) // 2)]  # Consider top half\n\n    # Randomly select from the best candidates\n    selected_idx = np.random.choice(best_indices)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(base_solution)\n    operator = np.random.choice(['2opt', '3opt', 'insertion'])\n\n    if operator == '2opt':\n        # 2-opt with objective-aware edge selection\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        # Select edges based on the objective with the highest improvement potential\n        obj_idx = np.argmax([objectives[selected_idx][k] for k in range(3)])\n        if obj_idx == 0:\n            dm = distance_matrix_1\n        elif obj_idx == 1:\n            dm = distance_matrix_2\n        else:\n            dm = distance_matrix_3\n\n        # Find the best 2-opt move for the selected objective\n        best_improvement = 0\n        best_i, best_j = i, j\n        for a in range(n):\n            for b in range(a + 1, n):\n                # Current edges: (a, a+1) and (b, b+1)\n                # Proposed edges: (a, b) and (a+1, b+1)\n                current = dm[a, (a+1)%n] + dm[b, (b+1)%n]\n                proposed = dm[a, b] + dm[(a+1)%n, (b+1)%n]\n                improvement = current - proposed\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_i, best_j = a, b\n\n        if best_improvement > 0:\n            new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n    elif operator == '3opt':\n        # 3-opt with objective-aware segment selection\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        # Select the objective with the highest potential improvement\n        obj_idx = np.argmax([objectives[selected_idx][k] for k in range(3)])\n        if obj_idx == 0:\n            dm = distance_matrix_1\n        elif obj_idx == 1:\n            dm = distance_matrix_2\n        else:\n            dm = distance_matrix_3\n\n        # Try all 8 possible 3-opt configurations\n        configurations = [\n            (i, j, k),\n            (i, k, j),\n            (j, i, k),\n            (j, k, i),\n            (k, i, j),\n            (k, j, i),\n            (i, j, k)[::-1],\n            (i, k, j)[::-1]\n        ]\n\n        best_config = None\n        best_improvement = 0\n\n        for config in configurations:\n            a, b, c = config\n            # Calculate current and proposed costs\n            current = dm[a, (a+1)%n] + dm[b, (b+1)%n] + dm[c, (c+1)%n]\n            proposed = dm[a, b] + dm[b, c] + dm[c, (a+1)%n]\n            improvement = current - proposed\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_config = config\n\n        if best_config is not None:\n            a, b, c = best_config\n            # Apply the best 3-opt move\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n            new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    elif operator == 'insertion':\n        # Objective-aware insertion move\n        i = np.random.randint(n)\n        j = np.random.randint(n)\n        while i == j:\n            j = np.random.randint(n)\n\n        # Select the objective with the highest potential improvement\n        obj_idx = np.argmax([objectives[selected_idx][k] for k in range(3)])\n        if obj_idx == 0:\n            dm = distance_matrix_1\n        elif obj_idx == 1:\n            dm = distance_matrix_2\n        else:\n            dm = distance_matrix_3\n\n        # Calculate improvement for insertion\n        current = dm[i, (i+1)%n] + dm[j, (j+1)%n]\n        proposed = dm[i, j] + dm[j, (i+1)%n]\n        improvement = current - proposed\n\n        if improvement > 0:\n            # Perform insertion\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 278,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (higher sum indicates more room for improvement)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select the top 20% solutions with the highest objective sums\n        top_solutions = archive_sorted[:max(1, len(archive_sorted) // 5)]\n        selected = random.choice(top_solutions)\n        base_solution = selected[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and edge exchange\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful changes\n\n    # Randomly select two distinct segments for exchange\n    i1, i2 = sorted(random.sample(range(1, n-1), 2))\n    j1, j2 = sorted(random.sample(range(1, n-1), 2))\n\n    # Perform a partial 2-opt swap between two segments\n    if i1 < i2 and j1 < j2:\n        # Ensure the exchange maintains tour validity\n        if (i2 - i1) == (j2 - j1):\n            # Equal-length segments: direct swap\n            new_solution[i1:i2], new_solution[j1:j2] = new_solution[j1:j2], new_solution[i1:i2]\n        else:\n            # Unequal-length segments: more complex exchange\n            segment1 = new_solution[i1:i2]\n            segment2 = new_solution[j1:j2]\n            new_solution = np.concatenate([\n                new_solution[:i1],\n                segment2,\n                new_solution[i2:j1],\n                segment1,\n                new_solution[j2:]\n            ])\n\n    # Verify the solution remains valid\n    if len(np.unique(new_solution)) != len(new_solution):\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6976242902028351,
            0.4040583252906799
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (higher sum indicates more room for improvement)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select the top 20% solutions with the highest objective sums\n        top_solutions = archive_sorted[:max(1, len(archive_sorted) // 5)]\n        selected = random.choice(top_solutions)\n        base_solution = selected[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and edge exchange\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful changes\n\n    # Randomly select two distinct segments for exchange\n    i1, i2 = sorted(random.sample(range(1, n-1), 2))\n    j1, j2 = sorted(random.sample(range(1, n-1), 2))\n\n    # Perform a partial 2-opt swap between two segments\n    if i1 < i2 and j1 < j2:\n        # Ensure the exchange maintains tour validity\n        if (i2 - i1) == (j2 - j1):\n            # Equal-length segments: direct swap\n            new_solution[i1:i2], new_solution[j1:j2] = new_solution[j1:j2], new_solution[i1:i2]\n        else:\n            # Unequal-length segments: more complex exchange\n            segment1 = new_solution[i1:i2]\n            segment2 = new_solution[j1:j2]\n            new_solution = np.concatenate([\n                new_solution[:i1],\n                segment2,\n                new_solution[i2:j1],\n                segment1,\n                new_solution[j2:]\n            ])\n\n    # Verify the solution remains valid\n    if len(np.unique(new_solution)) != len(new_solution):\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 279,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine 2-opt and insertion move\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Not enough nodes for meaningful changes\n\n    # Randomly select two distinct segments and perform 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n    if j - i > 1:  # Ensure there are at least two nodes between i and j\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select a node and perform insertion move\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Verify the solution is still valid\n    if len(np.unique(new_solution)) != n:\n        raise ValueError(\"Generated solution is invalid\")\n\n    return new_solution\n\n",
        "score": [
            -0.708950099331483,
            1.5830953598022461
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine 2-opt and insertion move\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Not enough nodes for meaningful changes\n\n    # Randomly select two distinct segments and perform 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n    if j - i > 1:  # Ensure there are at least two nodes between i and j\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select a node and perform insertion move\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Verify the solution is still valid\n    if len(np.unique(new_solution)) != n:\n        raise ValueError(\"Generated solution is invalid\")\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 280,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest objective values)\n    archive_solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate a combined score for each solution (lower is better)\n    scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmin(scores)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb (2-opt or swap operation)\n    if np.random.rand() < 0.5:\n        # 2-opt operation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Swap operation with bias towards improving the worst objective\n        worst_obj_idx = np.argmax(objectives[selected_idx])\n        if worst_obj_idx == 0:\n            # Improve first objective\n            i, j = np.random.choice(n, 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        elif worst_obj_idx == 1:\n            # Improve second objective\n            # Find the two nodes with the highest distance in the second space\n            max_dist = -1\n            best_i, best_j = 0, 1\n            for i in range(n):\n                for j in range(i+1, n):\n                    dist = distance_matrix_2[new_solution[i], new_solution[j]]\n                    if dist > max_dist:\n                        max_dist = dist\n                        best_i, best_j = i, j\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n        else:\n            # Improve third objective\n            # Find the two nodes with the highest distance in the third space\n            max_dist = -1\n            best_i, best_j = 0, 1\n            for i in range(n):\n                for j in range(i+1, n):\n                    dist = distance_matrix_3[new_solution[i], new_solution[j]]\n                    if dist > max_dist:\n                        max_dist = dist\n                        best_i, best_j = i, j\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.743937705075794,
            1.950761353969574
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest objective values)\n    archive_solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate a combined score for each solution (lower is better)\n    scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmin(scores)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb (2-opt or swap operation)\n    if np.random.rand() < 0.5:\n        # 2-opt operation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Swap operation with bias towards improving the worst objective\n        worst_obj_idx = np.argmax(objectives[selected_idx])\n        if worst_obj_idx == 0:\n            # Improve first objective\n            i, j = np.random.choice(n, 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        elif worst_obj_idx == 1:\n            # Improve second objective\n            # Find the two nodes with the highest distance in the second space\n            max_dist = -1\n            best_i, best_j = 0, 1\n            for i in range(n):\n                for j in range(i+1, n):\n                    dist = distance_matrix_2[new_solution[i], new_solution[j]]\n                    if dist > max_dist:\n                        max_dist = dist\n                        best_i, best_j = i, j\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n        else:\n            # Improve third objective\n            # Find the two nodes with the highest distance in the third space\n            max_dist = -1\n            best_i, best_j = 0, 1\n            for i in range(n):\n                for j in range(i+1, n):\n                    dist = distance_matrix_3[new_solution[i], new_solution[j]]\n                    if dist > max_dist:\n                        max_dist = dist\n                        best_i, best_j = i, j\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 281,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective values)\n    weights = [1 / (obj[0] + obj[1] + obj[2] + 1e-6) for (sol, obj) in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(base_solution)\n    move_type = random.choice(['2opt', 'swap', 'insert'])\n\n    if move_type == '2opt':\n        # 2-opt move: reverse a segment of the tour\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif move_type == 'swap':\n        # Swap two nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    else:  # insert\n        # Insertion move: move a node to a different position\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains valid (visits each node exactly once)\n    assert len(new_solution) == len(set(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.7850646491676371,
            1.7144270420074463
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective values)\n    weights = [1 / (obj[0] + obj[1] + obj[2] + 1e-6) for (sol, obj) in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(base_solution)\n    move_type = random.choice(['2opt', 'swap', 'insert'])\n\n    if move_type == '2opt':\n        # 2-opt move: reverse a segment of the tour\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif move_type == 'swap':\n        # Swap two nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    else:  # insert\n        # Insertion move: move a node to a different position\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains valid (visits each node exactly once)\n    assert len(new_solution) == len(set(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 282,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(int(0.3 * len(sorted_archive)), len(sorted_archive) - 1)\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of 2-opt and edge insertion\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    k, l = np.random.choice(n, 2, replace=False)\n\n    # Apply 2-opt swap\n    if i > j:\n        i, j = j, i\n    if k > l:\n        k, l = l, k\n\n    # Ensure valid 2-opt swap\n    if i < j and k < l:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Apply edge insertion\n    if np.random.rand() < 0.5:\n        node_to_insert = new_solution[np.random.randint(n)]\n        pos = np.random.randint(n)\n        new_solution = np.insert(new_solution, pos, node_to_insert)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_insert)[0][1])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = np.concatenate([np.unique(new_solution), base_solution[np.random.permutation(n)]])[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.7471220513100927,
            1.595390522480011
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(int(0.3 * len(sorted_archive)), len(sorted_archive) - 1)\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of 2-opt and edge insertion\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    k, l = np.random.choice(n, 2, replace=False)\n\n    # Apply 2-opt swap\n    if i > j:\n        i, j = j, i\n    if k > l:\n        k, l = l, k\n\n    # Ensure valid 2-opt swap\n    if i < j and k < l:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Apply edge insertion\n    if np.random.rand() < 0.5:\n        node_to_insert = new_solution[np.random.randint(n)]\n        pos = np.random.randint(n)\n        new_solution = np.insert(new_solution, pos, node_to_insert)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_insert)[0][1])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = np.concatenate([np.unique(new_solution), base_solution[np.random.permutation(n)]])[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 283,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with high objective values)\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Make a copy of the selected solution\n    new_solution = selected_solution.copy()\n\n    # Apply a hybrid local search operator: 3-opt with objective-aware edge selection\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful local search\n\n    # Select three distinct edges to modify\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Calculate the objective-aware edge weights\n    def edge_weight(a, b):\n        return (distance_matrix_1[a, b] + distance_matrix_2[a, b] + distance_matrix_3[a, b]) / 3\n\n    # Evaluate possible 3-opt moves\n    current_weight = (edge_weight(new_solution[i-1], new_solution[i]) +\n                      edge_weight(new_solution[j-1], new_solution[j]) +\n                      edge_weight(new_solution[k-1], new_solution[k]))\n\n    # Try all possible 3-opt configurations\n    best_weight = current_weight\n    best_config = None\n\n    # Configuration 1: Reverse segment between i and j\n    config1 = new_solution.copy()\n    config1[i:j] = config1[i:j][::-1]\n    weight1 = (edge_weight(config1[i-1], config1[i]) +\n               edge_weight(config1[j-1], config1[j]) +\n               edge_weight(config1[k-1], config1[k]))\n\n    # Configuration 2: Reverse segment between j and k\n    config2 = new_solution.copy()\n    config2[j:k] = config2[j:k][::-1]\n    weight2 = (edge_weight(config2[i-1], config2[i]) +\n               edge_weight(config2[j-1], config2[j]) +\n               edge_weight(config2[k-1], config2[k]))\n\n    # Configuration 3: Reverse all segments\n    config3 = new_solution.copy()\n    config3[i:j] = config3[i:j][::-1]\n    config3[j:k] = config3[j:k][::-1]\n    weight3 = (edge_weight(config3[i-1], config3[i]) +\n               edge_weight(config3[j-1], config3[j]) +\n               edge_weight(config3[k-1], config3[k]))\n\n    # Select the best configuration\n    if weight1 < best_weight:\n        best_weight = weight1\n        best_config = config1\n    if weight2 < best_weight:\n        best_weight = weight2\n        best_config = config2\n    if weight3 < best_weight:\n        best_weight = weight3\n        best_config = config3\n\n    if best_config is not None:\n        new_solution = best_config\n\n    return new_solution\n\n",
        "score": [
            -0.6672762139303552,
            1.628802764415741
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with high objective values)\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Make a copy of the selected solution\n    new_solution = selected_solution.copy()\n\n    # Apply a hybrid local search operator: 3-opt with objective-aware edge selection\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful local search\n\n    # Select three distinct edges to modify\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Calculate the objective-aware edge weights\n    def edge_weight(a, b):\n        return (distance_matrix_1[a, b] + distance_matrix_2[a, b] + distance_matrix_3[a, b]) / 3\n\n    # Evaluate possible 3-opt moves\n    current_weight = (edge_weight(new_solution[i-1], new_solution[i]) +\n                      edge_weight(new_solution[j-1], new_solution[j]) +\n                      edge_weight(new_solution[k-1], new_solution[k]))\n\n    # Try all possible 3-opt configurations\n    best_weight = current_weight\n    best_config = None\n\n    # Configuration 1: Reverse segment between i and j\n    config1 = new_solution.copy()\n    config1[i:j] = config1[i:j][::-1]\n    weight1 = (edge_weight(config1[i-1], config1[i]) +\n               edge_weight(config1[j-1], config1[j]) +\n               edge_weight(config1[k-1], config1[k]))\n\n    # Configuration 2: Reverse segment between j and k\n    config2 = new_solution.copy()\n    config2[j:k] = config2[j:k][::-1]\n    weight2 = (edge_weight(config2[i-1], config2[i]) +\n               edge_weight(config2[j-1], config2[j]) +\n               edge_weight(config2[k-1], config2[k]))\n\n    # Configuration 3: Reverse all segments\n    config3 = new_solution.copy()\n    config3[i:j] = config3[i:j][::-1]\n    config3[j:k] = config3[j:k][::-1]\n    weight3 = (edge_weight(config3[i-1], config3[i]) +\n               edge_weight(config3[j-1], config3[j]) +\n               edge_weight(config3[k-1], config3[k]))\n\n    # Select the best configuration\n    if weight1 < best_weight:\n        best_weight = weight1\n        best_config = config1\n    if weight2 < best_weight:\n        best_weight = weight2\n        best_config = config2\n    if weight3 < best_weight:\n        best_weight = weight3\n        best_config = config3\n\n    if best_config is not None:\n        new_solution = best_config\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 284,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., with high diversity or low crowding distance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n\n    # First, perform a random 2-opt move (standard local search)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware swap based on the worst objective\n    objectives = archive[selected_idx][1]\n    worst_obj_idx = np.argmax(objectives)\n\n    # Choose the worst objective's distance matrix\n    if worst_obj_idx == 0:\n        distance_matrix = distance_matrix_1\n    elif worst_obj_idx == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Find the pair of nodes that would most improve the worst objective\n    best_improvement = 0\n    best_pair = (0, 1)\n\n    for i in range(n):\n        for j in range(i+1, n):\n            # Calculate the change in total distance for the worst objective\n            a, b, c, d = new_solution[i-1], new_solution[i], new_solution[j-1], new_solution[j]\n            current_dist = distance_matrix[a, b] + distance_matrix[c, d]\n            new_dist = distance_matrix[a, d] + distance_matrix[b, c]\n            improvement = current_dist - new_dist\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pair = (i, j)\n\n    if best_improvement > 0:\n        i, j = best_pair\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7718926947458999,
            2.396815264225006
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., with high diversity or low crowding distance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n\n    # First, perform a random 2-opt move (standard local search)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware swap based on the worst objective\n    objectives = archive[selected_idx][1]\n    worst_obj_idx = np.argmax(objectives)\n\n    # Choose the worst objective's distance matrix\n    if worst_obj_idx == 0:\n        distance_matrix = distance_matrix_1\n    elif worst_obj_idx == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Find the pair of nodes that would most improve the worst objective\n    best_improvement = 0\n    best_pair = (0, 1)\n\n    for i in range(n):\n        for j in range(i+1, n):\n            # Calculate the change in total distance for the worst objective\n            a, b, c, d = new_solution[i-1], new_solution[i], new_solution[j-1], new_solution[j]\n            current_dist = distance_matrix[a, b] + distance_matrix[c, d]\n            new_dist = distance_matrix[a, d] + distance_matrix[b, c]\n            improvement = current_dist - new_dist\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pair = (i, j)\n\n    if best_improvement > 0:\n        i, j = best_pair\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 285,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too diverse)\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware swap to potentially improve all three objectives\n    # Select a node that is \"bad\" in at least one objective\n    bad_nodes = []\n    for k in range(n):\n        prev = selected_solution[k-1]\n        curr = selected_solution[k]\n        next_node = selected_solution[(k+1)%n]\n\n        # Check if this edge is bad in any objective\n        if (distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] >\n            distance_matrix_1[prev, next_node] + distance_matrix_1[next_node, curr]) or \\\n           (distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node] >\n            distance_matrix_2[prev, next_node] + distance_matrix_2[next_node, curr]) or \\\n           (distance_matrix_3[prev, curr] + distance_matrix_3[curr, next_node] >\n            distance_matrix_3[prev, next_node] + distance_matrix_3[next_node, curr]):\n            bad_nodes.append(k)\n\n    if bad_nodes:\n        k = random.choice(bad_nodes)\n        # Swap with a node that would improve at least one objective\n        for l in range(n):\n            if l != k and l != (k+1)%n and l != (k-1)%n:\n                # Check if swapping k and l improves any objective\n                prev_k = selected_solution[k-1]\n                next_k = selected_solution[(k+1)%n]\n                prev_l = selected_solution[l-1]\n                next_l = selected_solution[(l+1)%n]\n\n                # Calculate original and new distances for all three objectives\n                orig_dist1 = distance_matrix_1[prev_k, selected_solution[k]] + distance_matrix_1[selected_solution[k], next_k]\n                new_dist1 = distance_matrix_1[prev_k, selected_solution[l]] + distance_matrix_1[selected_solution[l], next_k]\n\n                orig_dist2 = distance_matrix_2[prev_k, selected_solution[k]] + distance_matrix_2[selected_solution[k], next_k]\n                new_dist2 = distance_matrix_2[prev_k, selected_solution[l]] + distance_matrix_2[selected_solution[l], next_k]\n\n                orig_dist3 = distance_matrix_3[prev_k, selected_solution[k]] + distance_matrix_3[selected_solution[k], next_k]\n                new_dist3 = distance_matrix_3[prev_k, selected_solution[l]] + distance_matrix_3[selected_solution[l], next_k]\n\n                if (new_dist1 < orig_dist1) or (new_dist2 < orig_dist2) or (new_dist3 < orig_dist3):\n                    # Perform the swap\n                    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7606073152955377,
            1.3953062653541566
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too diverse)\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware swap to potentially improve all three objectives\n    # Select a node that is \"bad\" in at least one objective\n    bad_nodes = []\n    for k in range(n):\n        prev = selected_solution[k-1]\n        curr = selected_solution[k]\n        next_node = selected_solution[(k+1)%n]\n\n        # Check if this edge is bad in any objective\n        if (distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] >\n            distance_matrix_1[prev, next_node] + distance_matrix_1[next_node, curr]) or \\\n           (distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node] >\n            distance_matrix_2[prev, next_node] + distance_matrix_2[next_node, curr]) or \\\n           (distance_matrix_3[prev, curr] + distance_matrix_3[curr, next_node] >\n            distance_matrix_3[prev, next_node] + distance_matrix_3[next_node, curr]):\n            bad_nodes.append(k)\n\n    if bad_nodes:\n        k = random.choice(bad_nodes)\n        # Swap with a node that would improve at least one objective\n        for l in range(n):\n            if l != k and l != (k+1)%n and l != (k-1)%n:\n                # Check if swapping k and l improves any objective\n                prev_k = selected_solution[k-1]\n                next_k = selected_solution[(k+1)%n]\n                prev_l = selected_solution[l-1]\n                next_l = selected_solution[(l+1)%n]\n\n                # Calculate original and new distances for all three objectives\n                orig_dist1 = distance_matrix_1[prev_k, selected_solution[k]] + distance_matrix_1[selected_solution[k], next_k]\n                new_dist1 = distance_matrix_1[prev_k, selected_solution[l]] + distance_matrix_1[selected_solution[l], next_k]\n\n                orig_dist2 = distance_matrix_2[prev_k, selected_solution[k]] + distance_matrix_2[selected_solution[k], next_k]\n                new_dist2 = distance_matrix_2[prev_k, selected_solution[l]] + distance_matrix_2[selected_solution[l], next_k]\n\n                orig_dist3 = distance_matrix_3[prev_k, selected_solution[k]] + distance_matrix_3[selected_solution[k], next_k]\n                new_dist3 = distance_matrix_3[prev_k, selected_solution[l]] + distance_matrix_3[selected_solution[l], next_k]\n\n                if (new_dist1 < orig_dist1) or (new_dist2 < orig_dist2) or (new_dist3 < orig_dist3):\n                    # Perform the swap\n                    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 286,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not already in the archive)\n    selected = random.choice(archive)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations for better exploration\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n        # 2-opt swap (standard local search)\n        if i != j and k != l:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Objective-aware swap: prioritize nodes that improve at least one objective\n        for _ in range(3):  # Try multiple swaps\n            a, b = random.sample(range(n), 2)\n            old_costs = [\n                distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                distance_matrix_1[new_solution[b-1], new_solution[b]],\n                distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                distance_matrix_2[new_solution[b-1], new_solution[b]],\n                distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                distance_matrix_3[new_solution[b-1], new_solution[b]]\n            ]\n\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n            new_costs = [\n                distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                distance_matrix_1[new_solution[b-1], new_solution[b]],\n                distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                distance_matrix_2[new_solution[b-1], new_solution[b]],\n                distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                distance_matrix_3[new_solution[b-1], new_solution[b]]\n            ]\n\n            # Revert if no improvement in any objective\n            if all(new_cost >= old_cost for new_cost, old_cost in zip(new_costs, old_costs)):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7612609175848377,
            2.473243010044098
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not already in the archive)\n    selected = random.choice(archive)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations for better exploration\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n        # 2-opt swap (standard local search)\n        if i != j and k != l:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Objective-aware swap: prioritize nodes that improve at least one objective\n        for _ in range(3):  # Try multiple swaps\n            a, b = random.sample(range(n), 2)\n            old_costs = [\n                distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                distance_matrix_1[new_solution[b-1], new_solution[b]],\n                distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                distance_matrix_2[new_solution[b-1], new_solution[b]],\n                distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                distance_matrix_3[new_solution[b-1], new_solution[b]]\n            ]\n\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n            new_costs = [\n                distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                distance_matrix_1[new_solution[b-1], new_solution[b]],\n                distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                distance_matrix_2[new_solution[b-1], new_solution[b]],\n                distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                distance_matrix_3[new_solution[b-1], new_solution[b]]\n            ]\n\n            # Revert if no improvement in any objective\n            if all(new_cost >= old_cost for new_cost, old_cost in zip(new_costs, old_costs)):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 287,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    # This encourages selecting solutions that have not been improved much\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / np.max(objectives, axis=0)\n    total_normalized = np.sum(normalized_objectives, axis=1)\n    probabilities = 1.0 / (total_normalized + 1e-10)  # Avoid division by zero\n    probabilities = probabilities / np.sum(probabilities)\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # For larger tours, apply a combination of 2-opt and node insertion\n        # First, perform a random 2-opt move\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Then, perform a random node insertion\n        if n > 4:\n            k = random.randint(0, n-1)\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == len(set(new_solution)) == len(base_solution)\n    return new_solution\n\n",
        "score": [
            -0.7323592999038828,
            2.0280190467834474
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    # This encourages selecting solutions that have not been improved much\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / np.max(objectives, axis=0)\n    total_normalized = np.sum(normalized_objectives, axis=1)\n    probabilities = 1.0 / (total_normalized + 1e-10)  # Avoid division by zero\n    probabilities = probabilities / np.sum(probabilities)\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # For larger tours, apply a combination of 2-opt and node insertion\n        # First, perform a random 2-opt move\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Then, perform a random node insertion\n        if n > 4:\n            k = random.randint(0, n-1)\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == len(set(new_solution)) == len(base_solution)\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 288,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(int(len(sorted_archive) * 0.3), len(sorted_archive) - 1)\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt, 3-opt, and objective-aware swaps\n    n = len(new_solution)\n    operation = random.choice(['2opt', '3opt', 'objective_swap'])\n\n    if operation == '2opt':\n        # 2-opt: reverse a random segment\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operation == '3opt':\n        # 3-opt: reverse three segments\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n    else:\n        # Objective-aware swap: swap nodes based on their contribution to each objective\n        i, j = random.sample(range(n), 2)\n\n        # Calculate current and potential contribution to each objective\n        def get_contribution(sol, a, b):\n            if a == 0 or b == 0:\n                return (0, 0, 0)\n            return (\n                distance_matrix_1[sol[a-1], sol[a]] + distance_matrix_1[sol[b-1], sol[b]],\n                distance_matrix_2[sol[a-1], sol[a]] + distance_matrix_2[sol[b-1], sol[b]],\n                distance_matrix_3[sol[a-1], sol[a]] + distance_matrix_3[sol[b-1], sol[b]]\n            )\n\n        current_contrib = get_contribution(new_solution, i, j)\n        swapped_solution = new_solution.copy()\n        swapped_solution[i], swapped_solution[j] = swapped_solution[j], swapped_solution[i]\n        swapped_contrib = get_contribution(swapped_solution, i, j)\n\n        # Accept swap if it improves at least one objective\n        if any(swapped_contrib[k] < current_contrib[k] for k in range(3)):\n            new_solution = swapped_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7347767722823039,
            1.466030192375183
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(int(len(sorted_archive) * 0.3), len(sorted_archive) - 1)\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt, 3-opt, and objective-aware swaps\n    n = len(new_solution)\n    operation = random.choice(['2opt', '3opt', 'objective_swap'])\n\n    if operation == '2opt':\n        # 2-opt: reverse a random segment\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operation == '3opt':\n        # 3-opt: reverse three segments\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n    else:\n        # Objective-aware swap: swap nodes based on their contribution to each objective\n        i, j = random.sample(range(n), 2)\n\n        # Calculate current and potential contribution to each objective\n        def get_contribution(sol, a, b):\n            if a == 0 or b == 0:\n                return (0, 0, 0)\n            return (\n                distance_matrix_1[sol[a-1], sol[a]] + distance_matrix_1[sol[b-1], sol[b]],\n                distance_matrix_2[sol[a-1], sol[a]] + distance_matrix_2[sol[b-1], sol[b]],\n                distance_matrix_3[sol[a-1], sol[a]] + distance_matrix_3[sol[b-1], sol[b]]\n            )\n\n        current_contrib = get_contribution(new_solution, i, j)\n        swapped_solution = new_solution.copy()\n        swapped_solution[i], swapped_solution[j] = swapped_solution[j], swapped_solution[i]\n        swapped_contrib = get_contribution(swapped_solution, i, j)\n\n        # Accept swap if it improves at least one objective\n        if any(swapped_contrib[k] < current_contrib[k] for k in range(3)):\n            new_solution = swapped_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 289,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    # Here, we select a solution that has at least one objective value in the top 30% of the archive\n    objectives = [obj for _, obj in archive]\n    obj1_values = [obj[0] for obj in objectives]\n    obj2_values = [obj[1] for obj in objectives]\n    obj3_values = [obj[2] for obj in objectives]\n\n    threshold1 = np.percentile(obj1_values, 70)\n    threshold2 = np.percentile(obj2_values, 70)\n    threshold3 = np.percentile(obj3_values, 70)\n\n    candidates = [sol for sol, obj in archive if obj[0] > threshold1 or obj[1] > threshold2 or obj[2] > threshold3]\n\n    if not candidates:\n        # If no candidates found, fall back to random selection\n        candidates = [sol for sol, _ in archive]\n\n    base_solution = random.choice(candidates).copy()\n\n    # Hybrid local search operator: combine 2-opt and edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt with a bias towards edges that improve multiple objectives\n    for _ in range(10):  # Limit number of attempts to avoid excessive computation\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i == 1:\n            continue  # Skip adjacent edges to avoid trivial swaps\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n                 (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n                 (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]) - \\\n                 (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if it improves at least one objective\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform edge exchange to further improve the solution\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i == 1:\n            continue\n\n        # Swap edges (i, i+1) and (j, j+1) with (i, j) and (i+1, j+1)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Verify the solution remains valid (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n        else:\n            # Revert if invalid\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6963370423231415,
            3.1593912959098818
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    # Here, we select a solution that has at least one objective value in the top 30% of the archive\n    objectives = [obj for _, obj in archive]\n    obj1_values = [obj[0] for obj in objectives]\n    obj2_values = [obj[1] for obj in objectives]\n    obj3_values = [obj[2] for obj in objectives]\n\n    threshold1 = np.percentile(obj1_values, 70)\n    threshold2 = np.percentile(obj2_values, 70)\n    threshold3 = np.percentile(obj3_values, 70)\n\n    candidates = [sol for sol, obj in archive if obj[0] > threshold1 or obj[1] > threshold2 or obj[2] > threshold3]\n\n    if not candidates:\n        # If no candidates found, fall back to random selection\n        candidates = [sol for sol, _ in archive]\n\n    base_solution = random.choice(candidates).copy()\n\n    # Hybrid local search operator: combine 2-opt and edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt with a bias towards edges that improve multiple objectives\n    for _ in range(10):  # Limit number of attempts to avoid excessive computation\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i == 1:\n            continue  # Skip adjacent edges to avoid trivial swaps\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n                 (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n                 (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]) - \\\n                 (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if it improves at least one objective\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform edge exchange to further improve the solution\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i == 1:\n            continue\n\n        # Swap edges (i, i+1) and (j, j+1) with (i, j) and (i+1, j+1)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Verify the solution remains valid (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n        else:\n            # Revert if invalid\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 290,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too similar to others)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    N = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations for better exploration\n        i, j = np.random.choice(N, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate current and potential costs for all three objectives\n        current_cost = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        potential_cost = [\n            distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_1[new_solution[j-1], new_solution[i]],\n            distance_matrix_2[new_solution[i-1], new_solution[j]] +\n            distance_matrix_2[new_solution[j-1], new_solution[i]],\n            distance_matrix_3[new_solution[i-1], new_solution[j]] +\n            distance_matrix_3[new_solution[j-1], new_solution[i]]\n        ]\n\n        # Accept the move if it improves at least one objective\n        if any(p < c for p, c in zip(potential_cost, current_cost)):\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Additional objective-aware 2-opt passes\n    for _ in range(5):\n        # Select a segment to reverse based on the most improved objective\n        i, j = np.random.choice(N, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate improvement potential for each objective\n        improvements = [\n            (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n             distance_matrix_1[new_solution[j-1], new_solution[i]]) -\n            (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n             distance_matrix_1[new_solution[j-1], new_solution[j]]),\n\n            (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n             distance_matrix_2[new_solution[j-1], new_solution[i]]) -\n            (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n             distance_matrix_2[new_solution[j-1], new_solution[j]]),\n\n            (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n             distance_matrix_3[new_solution[j-1], new_solution[i]]) -\n            (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n             distance_matrix_3[new_solution[j-1], new_solution[j]])\n        ]\n\n        # Accept if any objective improves\n        if any(imp < 0 for imp in improvements):\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.740031627558688,
            2.1918478846549987
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too similar to others)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    N = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations for better exploration\n        i, j = np.random.choice(N, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate current and potential costs for all three objectives\n        current_cost = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        potential_cost = [\n            distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_1[new_solution[j-1], new_solution[i]],\n            distance_matrix_2[new_solution[i-1], new_solution[j]] +\n            distance_matrix_2[new_solution[j-1], new_solution[i]],\n            distance_matrix_3[new_solution[i-1], new_solution[j]] +\n            distance_matrix_3[new_solution[j-1], new_solution[i]]\n        ]\n\n        # Accept the move if it improves at least one objective\n        if any(p < c for p, c in zip(potential_cost, current_cost)):\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Additional objective-aware 2-opt passes\n    for _ in range(5):\n        # Select a segment to reverse based on the most improved objective\n        i, j = np.random.choice(N, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate improvement potential for each objective\n        improvements = [\n            (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n             distance_matrix_1[new_solution[j-1], new_solution[i]]) -\n            (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n             distance_matrix_1[new_solution[j-1], new_solution[j]]),\n\n            (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n             distance_matrix_2[new_solution[j-1], new_solution[i]]) -\n            (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n             distance_matrix_2[new_solution[j-1], new_solution[j]]),\n\n            (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n             distance_matrix_3[new_solution[j-1], new_solution[i]]) -\n            (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n             distance_matrix_3[new_solution[j-1], new_solution[j]])\n        ]\n\n        # Accept if any objective improves\n        if any(imp < 0 for imp in improvements):\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 291,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    top_n = max(1, int(0.3 * len(archive)))\n    selected_solution = random.choice(archive[:top_n])[0].copy()\n\n    # Hybrid local search operator: combine 2-opt with a multi-objective aware swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt move (standard local search operator)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective aware swap: identify nodes with high improvement potential\n    if random.random() < 0.5:  # 50% chance to apply the multi-objective swap\n        # Calculate improvement potential for each node\n        improvements = []\n        for k in range(n):\n            # Calculate potential improvement if we swap node k with its neighbor\n            a, b = new_solution[k-1], new_solution[k]\n            c = new_solution[(k+1) % n]\n\n            # Calculate current and potential costs\n            current_costs = (\n                distance_matrix_1[a, b] + distance_matrix_1[b, c],\n                distance_matrix_2[a, b] + distance_matrix_2[b, c],\n                distance_matrix_3[a, b] + distance_matrix_3[b, c]\n            )\n\n            potential_costs = (\n                distance_matrix_1[a, c] + distance_matrix_1[c, b],\n                distance_matrix_2[a, c] + distance_matrix_2[c, b],\n                distance_matrix_3[a, c] + distance_matrix_3[c, b]\n            )\n\n            # Calculate improvement (negative values mean improvement)\n            improvement = sum(p - c for p, c in zip(potential_costs, current_costs))\n            improvements.append((improvement, k))\n\n        # Sort by improvement potential and select top candidates\n        improvements.sort()\n        top_candidates = [k for (imp, k) in improvements[:max(1, n//10)]]\n\n        if top_candidates:\n            k = random.choice(top_candidates)\n            # Perform the swap\n            new_solution[k-1], new_solution[k] = new_solution[k], new_solution[k-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7291817610917126,
            1.0965477108955384
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    top_n = max(1, int(0.3 * len(archive)))\n    selected_solution = random.choice(archive[:top_n])[0].copy()\n\n    # Hybrid local search operator: combine 2-opt with a multi-objective aware swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt move (standard local search operator)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective aware swap: identify nodes with high improvement potential\n    if random.random() < 0.5:  # 50% chance to apply the multi-objective swap\n        # Calculate improvement potential for each node\n        improvements = []\n        for k in range(n):\n            # Calculate potential improvement if we swap node k with its neighbor\n            a, b = new_solution[k-1], new_solution[k]\n            c = new_solution[(k+1) % n]\n\n            # Calculate current and potential costs\n            current_costs = (\n                distance_matrix_1[a, b] + distance_matrix_1[b, c],\n                distance_matrix_2[a, b] + distance_matrix_2[b, c],\n                distance_matrix_3[a, b] + distance_matrix_3[b, c]\n            )\n\n            potential_costs = (\n                distance_matrix_1[a, c] + distance_matrix_1[c, b],\n                distance_matrix_2[a, c] + distance_matrix_2[c, b],\n                distance_matrix_3[a, c] + distance_matrix_3[c, b]\n            )\n\n            # Calculate improvement (negative values mean improvement)\n            improvement = sum(p - c for p, c in zip(potential_costs, current_costs))\n            improvements.append((improvement, k))\n\n        # Sort by improvement potential and select top candidates\n        improvements.sort()\n        top_candidates = [k for (imp, k) in improvements[:max(1, n//10)]]\n\n        if top_candidates:\n            k = random.choice(top_candidates)\n            # Perform the swap\n            new_solution[k-1], new_solution[k] = new_solution[k], new_solution[k-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 292,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too similar to others)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and node insertion\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # With 70% probability, perform 2-opt\n        if random.random() < 0.7:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # With 30% probability, perform node insertion\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    assert len(np.unique(new_solution)) == len(base_solution), \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.7789020494024099,
            1.1916980624198914
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too similar to others)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and node insertion\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # With 70% probability, perform 2-opt\n        if random.random() < 0.7:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # With 30% probability, perform node insertion\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    assert len(np.unique(new_solution)) == len(base_solution), \"Generated solution is invalid\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 293,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high variance in objective values)\n    objectives = np.array([obj for _, obj in archive])\n    objective_variance = np.var(objectives, axis=0)\n    weighted_scores = np.sum(objectives * objective_variance, axis=1)\n    probabilities = weighted_scores / np.sum(weighted_scores)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations\n        # Randomly select two distinct positions\n        i, j = sorted(random.sample(range(n), 2))\n\n        # 2-opt move\n        if random.random() < 0.7:  # Higher probability for 2-opt\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Objective-aware swap: swap nodes that are far apart in at least one objective space\n            node_i, node_j = new_solution[i], new_solution[j]\n            dist1 = distance_matrix_1[node_i, node_j]\n            dist2 = distance_matrix_2[node_i, node_j]\n            dist3 = distance_matrix_3[node_i, node_j]\n\n            if max(dist1, dist2, dist3) > np.mean([np.mean(distance_matrix_1), np.mean(distance_matrix_2), np.mean(distance_matrix_3)]):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7704193302755868,
            2.2942917466163637
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high variance in objective values)\n    objectives = np.array([obj for _, obj in archive])\n    objective_variance = np.var(objectives, axis=0)\n    weighted_scores = np.sum(objectives * objective_variance, axis=1)\n    probabilities = weighted_scores / np.sum(weighted_scores)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations\n        # Randomly select two distinct positions\n        i, j = sorted(random.sample(range(n), 2))\n\n        # 2-opt move\n        if random.random() < 0.7:  # Higher probability for 2-opt\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Objective-aware swap: swap nodes that are far apart in at least one objective space\n            node_i, node_j = new_solution[i], new_solution[j]\n            dist1 = distance_matrix_1[node_i, node_j]\n            dist2 = distance_matrix_2[node_i, node_j]\n            dist3 = distance_matrix_3[node_i, node_j]\n\n            if max(dist1, dist2, dist3) > np.mean([np.mean(distance_matrix_1), np.mean(distance_matrix_2), np.mean(distance_matrix_3)]):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 294,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low cost in at least one objective\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware node swaps\n    n = len(new_solution)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform 2-opt on the selected edges\n    if (b - a) > 1 and (d - c) > 1:\n        # Check if the swap improves at least one objective\n        original_cost = (distance_matrix_1[base_solution[a], base_solution[b]] +\n                         distance_matrix_2[base_solution[a], base_solution[b]] +\n                         distance_matrix_3[base_solution[a], base_solution[b]] +\n                         distance_matrix_1[base_solution[c], base_solution[d]] +\n                         distance_matrix_2[base_solution[c], base_solution[d]] +\n                         distance_matrix_3[base_solution[c], base_solution[d]])\n\n        new_cost = (distance_matrix_1[base_solution[a], base_solution[c]] +\n                    distance_matrix_2[base_solution[a], base_solution[c]] +\n                    distance_matrix_3[base_solution[a], base_solution[c]] +\n                    distance_matrix_1[base_solution[b], base_solution[d]] +\n                    distance_matrix_2[base_solution[b], base_solution[d]] +\n                    distance_matrix_3[base_solution[b], base_solution[d]])\n\n        if new_cost < original_cost:\n            # Apply the swap if it improves at least one objective\n            new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n            new_solution[b], new_solution[d] = new_solution[d], new_solution[b]\n\n    # Objective-aware node insertion\n    if np.random.rand() < 0.3:  # 30% chance to perform insertion\n        i = np.random.randint(n)\n        j = np.random.randint(n)\n        if i != j:\n            # Evaluate insertion in all three objectives\n            original_costs = [\n                distance_matrix_1[base_solution[i-1], base_solution[i]] +\n                distance_matrix_1[base_solution[i], base_solution[i+1 if i+1 < n else 0]],\n                distance_matrix_2[base_solution[i-1], base_solution[i]] +\n                distance_matrix_2[base_solution[i], base_solution[i+1 if i+1 < n else 0]],\n                distance_matrix_3[base_solution[i-1], base_solution[i]] +\n                distance_matrix_3[base_solution[i], base_solution[i+1 if i+1 < n else 0]]\n            ]\n\n            new_costs = [\n                distance_matrix_1[base_solution[i-1], base_solution[j]] +\n                distance_matrix_1[base_solution[j], base_solution[i+1 if i+1 < n else 0]],\n                distance_matrix_2[base_solution[i-1], base_solution[j]] +\n                distance_matrix_2[base_solution[j], base_solution[i+1 if i+1 < n else 0]],\n                distance_matrix_3[base_solution[i-1], base_solution[j]] +\n                distance_matrix_3[base_solution[j], base_solution[i+1 if i+1 < n else 0]]\n            ]\n\n            if sum(new_costs) < sum(original_costs):\n                # Perform the insertion if it improves the overall cost\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7503081119917933,
            1.446879470348358
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low cost in at least one objective\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware node swaps\n    n = len(new_solution)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform 2-opt on the selected edges\n    if (b - a) > 1 and (d - c) > 1:\n        # Check if the swap improves at least one objective\n        original_cost = (distance_matrix_1[base_solution[a], base_solution[b]] +\n                         distance_matrix_2[base_solution[a], base_solution[b]] +\n                         distance_matrix_3[base_solution[a], base_solution[b]] +\n                         distance_matrix_1[base_solution[c], base_solution[d]] +\n                         distance_matrix_2[base_solution[c], base_solution[d]] +\n                         distance_matrix_3[base_solution[c], base_solution[d]])\n\n        new_cost = (distance_matrix_1[base_solution[a], base_solution[c]] +\n                    distance_matrix_2[base_solution[a], base_solution[c]] +\n                    distance_matrix_3[base_solution[a], base_solution[c]] +\n                    distance_matrix_1[base_solution[b], base_solution[d]] +\n                    distance_matrix_2[base_solution[b], base_solution[d]] +\n                    distance_matrix_3[base_solution[b], base_solution[d]])\n\n        if new_cost < original_cost:\n            # Apply the swap if it improves at least one objective\n            new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n            new_solution[b], new_solution[d] = new_solution[d], new_solution[b]\n\n    # Objective-aware node insertion\n    if np.random.rand() < 0.3:  # 30% chance to perform insertion\n        i = np.random.randint(n)\n        j = np.random.randint(n)\n        if i != j:\n            # Evaluate insertion in all three objectives\n            original_costs = [\n                distance_matrix_1[base_solution[i-1], base_solution[i]] +\n                distance_matrix_1[base_solution[i], base_solution[i+1 if i+1 < n else 0]],\n                distance_matrix_2[base_solution[i-1], base_solution[i]] +\n                distance_matrix_2[base_solution[i], base_solution[i+1 if i+1 < n else 0]],\n                distance_matrix_3[base_solution[i-1], base_solution[i]] +\n                distance_matrix_3[base_solution[i], base_solution[i+1 if i+1 < n else 0]]\n            ]\n\n            new_costs = [\n                distance_matrix_1[base_solution[i-1], base_solution[j]] +\n                distance_matrix_1[base_solution[j], base_solution[i+1 if i+1 < n else 0]],\n                distance_matrix_2[base_solution[i-1], base_solution[j]] +\n                distance_matrix_2[base_solution[j], base_solution[i+1 if i+1 < n else 0]],\n                distance_matrix_3[base_solution[i-1], base_solution[j]] +\n                distance_matrix_3[base_solution[j], base_solution[i+1 if i+1 < n else 0]]\n            ]\n\n            if sum(new_costs) < sum(original_costs):\n                # Perform the insertion if it improves the overall cost\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 295,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest objective values)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(len(archive_sorted) // 2, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    for _ in range(5):  # Perform multiple iterations for better exploration\n        # Select two distinct edges with high potential for improvement\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n        # Calculate improvement potential across all three objectives\n        def calculate_improvement(a, b, c, d):\n            old_cost = (distance_matrix_1[a][b] + distance_matrix_1[c][d] +\n                         distance_matrix_2[a][b] + distance_matrix_2[c][d] +\n                         distance_matrix_3[a][b] + distance_matrix_3[c][d])\n            new_cost = (distance_matrix_1[a][c] + distance_matrix_1[b][d] +\n                        distance_matrix_2[a][c] + distance_matrix_2[b][d] +\n                        distance_matrix_3[a][c] + distance_matrix_3[b][d])\n            return old_cost - new_cost\n\n        improvement = calculate_improvement(\n            new_solution[i], new_solution[(i+1)%n],\n            new_solution[j], new_solution[(j+1)%n]\n        )\n\n        if improvement > 0:\n            # Perform 2-opt move\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n        # Also consider edge swaps between different objectives\n        if random.random() < 0.3:  # 30% chance to perform edge swap\n            a, b = random.sample(range(n), 2)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7652777098469417,
            1.4140473127365112
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest objective values)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(len(archive_sorted) // 2, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    for _ in range(5):  # Perform multiple iterations for better exploration\n        # Select two distinct edges with high potential for improvement\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n        # Calculate improvement potential across all three objectives\n        def calculate_improvement(a, b, c, d):\n            old_cost = (distance_matrix_1[a][b] + distance_matrix_1[c][d] +\n                         distance_matrix_2[a][b] + distance_matrix_2[c][d] +\n                         distance_matrix_3[a][b] + distance_matrix_3[c][d])\n            new_cost = (distance_matrix_1[a][c] + distance_matrix_1[b][d] +\n                        distance_matrix_2[a][c] + distance_matrix_2[b][d] +\n                        distance_matrix_3[a][c] + distance_matrix_3[b][d])\n            return old_cost - new_cost\n\n        improvement = calculate_improvement(\n            new_solution[i], new_solution[(i+1)%n],\n            new_solution[j], new_solution[(j+1)%n]\n        )\n\n        if improvement > 0:\n            # Perform 2-opt move\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n        # Also consider edge swaps between different objectives\n        if random.random() < 0.3:  # 30% chance to perform edge swap\n            a, b = random.sample(range(n), 2)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 296,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest objective values)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate the \"potential\" as the sum of normalized objectives (lower is better)\n    min_obj = np.min(archive_objectives, axis=0)\n    max_obj = np.max(archive_objectives, axis=0)\n    normalized_obj = (archive_objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    potential = np.sum(normalized_obj, axis=1)\n\n    # Select the solution with the lowest potential (best current solution)\n    best_idx = np.argmin(potential)\n    base_solution = archive_solutions[best_idx].copy()\n\n    # Hybrid local search: apply 2-opt with a probability based on objective diversity\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate the diversity of the objectives for the selected solution\n    obj_diversity = np.std(archive_objectives[best_idx])\n\n    # Higher diversity suggests more room for improvement\n    if obj_diversity > 0.3:  # Threshold for applying more aggressive search\n        # Apply 2-opt with a higher probability\n        for _ in range(10):  # More iterations for diverse solutions\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Apply 2-opt with a lower probability\n        for _ in range(5):  # Fewer iterations for less diverse solutions\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution is valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a valid solution if invalid\n        new_solution = np.random.permutation(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.6683531007959178,
            2.362041985988617
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest objective values)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate the \"potential\" as the sum of normalized objectives (lower is better)\n    min_obj = np.min(archive_objectives, axis=0)\n    max_obj = np.max(archive_objectives, axis=0)\n    normalized_obj = (archive_objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    potential = np.sum(normalized_obj, axis=1)\n\n    # Select the solution with the lowest potential (best current solution)\n    best_idx = np.argmin(potential)\n    base_solution = archive_solutions[best_idx].copy()\n\n    # Hybrid local search: apply 2-opt with a probability based on objective diversity\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate the diversity of the objectives for the selected solution\n    obj_diversity = np.std(archive_objectives[best_idx])\n\n    # Higher diversity suggests more room for improvement\n    if obj_diversity > 0.3:  # Threshold for applying more aggressive search\n        # Apply 2-opt with a higher probability\n        for _ in range(10):  # More iterations for diverse solutions\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Apply 2-opt with a lower probability\n        for _ in range(5):  # Fewer iterations for less diverse solutions\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution is valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a valid solution if invalid\n        new_solution = np.random.permutation(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 297,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal in all objectives)\n    selected_idx = np.random.choice(len(archive))\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to balance exploration/exploitation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        # 2-opt move\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Objective-aware swap: select swap based on which objective is worse\n        if np.random.rand() < 0.5:  # 50% chance to apply objective-aware swap\n            obj1, obj2, obj3 = objectives\n            if obj1 > obj2 or obj3 > obj2:  # If second objective is worse\n                # Find the best swap in the second objective space\n                best_swap = None\n                best_improvement = 0\n                for k in range(i, j+1):\n                    for l in range(k+1, j+1):\n                        # Calculate improvement for this swap\n                        delta = (distance_matrix_2[new_solution[k-1], new_solution[l]] +\n                                distance_matrix_2[new_solution[l], new_solution[k]] -\n                                distance_matrix_2[new_solution[k-1], new_solution[k]] -\n                                distance_matrix_2[new_solution[l], new_solution[l+1] if l+1 < n else new_solution[0]])\n                        if delta < best_improvement:\n                            best_improvement = delta\n                            best_swap = (k, l)\n                if best_swap:\n                    k, l = best_swap\n                    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.8020578532398023,
            3.170363414287567
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal in all objectives)\n    selected_idx = np.random.choice(len(archive))\n    base_solution, objectives = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to balance exploration/exploitation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        # 2-opt move\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Objective-aware swap: select swap based on which objective is worse\n        if np.random.rand() < 0.5:  # 50% chance to apply objective-aware swap\n            obj1, obj2, obj3 = objectives\n            if obj1 > obj2 or obj3 > obj2:  # If second objective is worse\n                # Find the best swap in the second objective space\n                best_swap = None\n                best_improvement = 0\n                for k in range(i, j+1):\n                    for l in range(k+1, j+1):\n                        # Calculate improvement for this swap\n                        delta = (distance_matrix_2[new_solution[k-1], new_solution[l]] +\n                                distance_matrix_2[new_solution[l], new_solution[k]] -\n                                distance_matrix_2[new_solution[k-1], new_solution[k]] -\n                                distance_matrix_2[new_solution[l], new_solution[l+1] if l+1 < n else new_solution[0]])\n                        if delta < best_improvement:\n                            best_improvement = delta\n                            best_swap = (k, l)\n                if best_swap:\n                    k, l = best_swap\n                    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 298,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution based on diversity and potential for improvement\n    # We prioritize solutions that are non-dominated and have the highest diversity in their objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.std(normalized_objectives, axis=1)\n    scores = diversity_scores + 0.1 * np.random.rand(len(archive))  # Add small randomness to break ties\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between 2-opt and 3-opt with probability based on solution quality\n    if np.random.rand() < 0.7:  # Higher probability for 2-opt (faster but effective)\n        # 2-opt local search\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # 3-opt local search (more disruptive but can escape local optima)\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        # Apply 3-opt move (reverse segments and reorder)\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            -0.6152083404374231,
            2.062112641334534
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution based on diversity and potential for improvement\n    # We prioritize solutions that are non-dominated and have the highest diversity in their objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.std(normalized_objectives, axis=1)\n    scores = diversity_scores + 0.1 * np.random.rand(len(archive))  # Add small randomness to break ties\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between 2-opt and 3-opt with probability based on solution quality\n    if np.random.rand() < 0.7:  # Higher probability for 2-opt (faster but effective)\n        # 2-opt local search\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # 3-opt local search (more disruptive but can escape local optima)\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        # Apply 3-opt move (reverse segments and reorder)\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 299,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by many others)\n    selected = max(archive, key=lambda x: sum(x[1]))  # Select solution with highest total cost\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with objective-aware edge selection\n    n = len(base_solution)\n    if n < 3:\n        return new_solution  # No possible improvement\n\n    # Select three random edges to perform 3-opt\n    i, j, k = sorted(np.random.choice(range(n), size=3, replace=False))\n\n    # Perform 3-opt move with objective-aware edge selection\n    candidates = [\n        [i, j, k],\n        [i, k, j],\n        [j, i, k],\n        [j, k, i],\n        [k, i, j],\n        [k, j, i]\n    ]\n\n    # Evaluate all candidates based on all three objectives\n    best_candidate = None\n    best_score = float('inf')\n\n    for candidate in candidates:\n        a, b, c = candidate\n        # Calculate total cost for all three objectives\n        cost1 = (distance_matrix_1[base_solution[a-1], base_solution[b]] +\n                 distance_matrix_1[base_solution[b-1], base_solution[c]] +\n                 distance_matrix_1[base_solution[c-1], base_solution[a]])\n        cost2 = (distance_matrix_2[base_solution[a-1], base_solution[b]] +\n                 distance_matrix_2[base_solution[b-1], base_solution[c]] +\n                 distance_matrix_2[base_solution[c-1], base_solution[a]])\n        cost3 = (distance_matrix_3[base_solution[a-1], base_solution[b]] +\n                 distance_matrix_3[base_solution[b-1], base_solution[c]] +\n                 distance_matrix_3[base_solution[c-1], base_solution[a]])\n\n        # Use weighted sum of objectives for selection\n        total_cost = cost1 + cost2 + cost3\n        if total_cost < best_score:\n            best_score = total_cost\n            best_candidate = candidate\n\n    if best_candidate:\n        a, b, c = best_candidate\n        # Apply the best 3-opt move\n        new_solution[a:b] = np.flip(new_solution[a:b])\n        new_solution[b:c] = np.flip(new_solution[b:c])\n\n    return new_solution\n\n",
        "score": [
            -0.7266740260209668,
            1.396337866783142
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by many others)\n    selected = max(archive, key=lambda x: sum(x[1]))  # Select solution with highest total cost\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with objective-aware edge selection\n    n = len(base_solution)\n    if n < 3:\n        return new_solution  # No possible improvement\n\n    # Select three random edges to perform 3-opt\n    i, j, k = sorted(np.random.choice(range(n), size=3, replace=False))\n\n    # Perform 3-opt move with objective-aware edge selection\n    candidates = [\n        [i, j, k],\n        [i, k, j],\n        [j, i, k],\n        [j, k, i],\n        [k, i, j],\n        [k, j, i]\n    ]\n\n    # Evaluate all candidates based on all three objectives\n    best_candidate = None\n    best_score = float('inf')\n\n    for candidate in candidates:\n        a, b, c = candidate\n        # Calculate total cost for all three objectives\n        cost1 = (distance_matrix_1[base_solution[a-1], base_solution[b]] +\n                 distance_matrix_1[base_solution[b-1], base_solution[c]] +\n                 distance_matrix_1[base_solution[c-1], base_solution[a]])\n        cost2 = (distance_matrix_2[base_solution[a-1], base_solution[b]] +\n                 distance_matrix_2[base_solution[b-1], base_solution[c]] +\n                 distance_matrix_2[base_solution[c-1], base_solution[a]])\n        cost3 = (distance_matrix_3[base_solution[a-1], base_solution[b]] +\n                 distance_matrix_3[base_solution[b-1], base_solution[c]] +\n                 distance_matrix_3[base_solution[c-1], base_solution[a]])\n\n        # Use weighted sum of objectives for selection\n        total_cost = cost1 + cost2 + cost3\n        if total_cost < best_score:\n            best_score = total_cost\n            best_candidate = candidate\n\n    if best_candidate:\n        a, b, c = best_candidate\n        # Apply the best 3-opt move\n        new_solution[a:b] = np.flip(new_solution[a:b])\n        new_solution[b:c] = np.flip(new_solution[b:c])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 300,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate diversity scores for each solution\n        diversity_scores = []\n        for sol, obj in archive:\n            diversity = (obj[0] - obj[1])**2 + (obj[1] - obj[2])**2 + (obj[2] - obj[0])**2\n            diversity_scores.append(diversity)\n\n        # Select the solution with the highest diversity\n        selected_idx = np.argmax(diversity_scores)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    if random.random() < 0.7:  # 70% chance for 2-opt\n        # Select two distinct edges to swap\n        n = len(new_solution)\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure we don't create a sub-tour\n        if i != j and (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n    else:  # 30% chance for objective-aware swap\n        # Calculate edge costs for each objective\n        edge_costs = []\n        for k in range(len(new_solution)):\n            i = new_solution[k]\n            j = new_solution[(k+1) % len(new_solution)]\n            cost1 = distance_matrix_1[i, j]\n            cost2 = distance_matrix_2[i, j]\n            cost3 = distance_matrix_3[i, j]\n            edge_costs.append((cost1, cost2, cost3))\n\n        # Find the edge with the highest combined cost\n        combined_costs = [sum(costs) for costs in edge_costs]\n        worst_edge_idx = np.argmax(combined_costs)\n\n        # Swap the worst edge with another random edge\n        swap_candidate = random.randint(0, len(new_solution)-1)\n        while swap_candidate == worst_edge_idx or swap_candidate == (worst_edge_idx + 1) % len(new_solution):\n            swap_candidate = random.randint(0, len(new_solution)-1)\n\n        # Perform the swap\n        new_solution[worst_edge_idx], new_solution[swap_candidate] = new_solution[swap_candidate], new_solution[worst_edge_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.400375351358578,
            1.7175180435180664
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate diversity scores for each solution\n        diversity_scores = []\n        for sol, obj in archive:\n            diversity = (obj[0] - obj[1])**2 + (obj[1] - obj[2])**2 + (obj[2] - obj[0])**2\n            diversity_scores.append(diversity)\n\n        # Select the solution with the highest diversity\n        selected_idx = np.argmax(diversity_scores)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    if random.random() < 0.7:  # 70% chance for 2-opt\n        # Select two distinct edges to swap\n        n = len(new_solution)\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure we don't create a sub-tour\n        if i != j and (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n    else:  # 30% chance for objective-aware swap\n        # Calculate edge costs for each objective\n        edge_costs = []\n        for k in range(len(new_solution)):\n            i = new_solution[k]\n            j = new_solution[(k+1) % len(new_solution)]\n            cost1 = distance_matrix_1[i, j]\n            cost2 = distance_matrix_2[i, j]\n            cost3 = distance_matrix_3[i, j]\n            edge_costs.append((cost1, cost2, cost3))\n\n        # Find the edge with the highest combined cost\n        combined_costs = [sum(costs) for costs in edge_costs]\n        worst_edge_idx = np.argmax(combined_costs)\n\n        # Swap the worst edge with another random edge\n        swap_candidate = random.randint(0, len(new_solution)-1)\n        while swap_candidate == worst_edge_idx or swap_candidate == (worst_edge_idx + 1) % len(new_solution):\n            swap_candidate = random.randint(0, len(new_solution)-1)\n\n        # Perform the swap\n        new_solution[worst_edge_idx], new_solution[swap_candidate] = new_solution[swap_candidate], new_solution[worst_edge_idx]\n\n    return new_solution\n\n"
    }
]